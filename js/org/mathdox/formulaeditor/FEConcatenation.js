/**
 * Declare the global variables that will be exported by this script.
 */
var $package;
var $identify;
var $require;
var $contains;
var $main;
var $extend;
var $baseurl;
var $setOptions;

/**
 * Enter a private variable context, so that variables declared below are not
 * visible outside this script.
 */
(function(){

  /**
   * Contains a record of all $main arguments that have been executed. This is
   * used by the $main and $require functions to ensure that each $main argument
   * is executed only once.
   */
  var executed = {
    urls: {},
    nourl: {}
  };

  /**
   * This counter is used to keep track of how many urls were requested to be
   * loaded (using the $require function), but haven't finished loading yet.
   */
  var loading = 1;

  /**
   * A list of functions that wish to be called when the 'loading' counter
   * reaches 0.
   */
  var waiting = { 
    urls:{},
    nourl:[] 
  };

  /**
   * A list of scripts already added
   */
  var loadingurls = {};

  /**
   * Holds a reference to the script tag that was last added to the document by
   * the $require function. New scripts will be added below this script.
   */
  var lastadded;

  /**
   * Record the global variable scope in the 'global' object. This is used by
   * the $package function to create new package objects in the global scope.
   */
  var global = this;

  /**
   * Returns the package object for the specified package string. For instance,
   * the call $package("org.mathdox.javascript") will return the
   * org.mathdox.javascript object. If the package object doesn't exist, it is
   * created.
   */
  $package = function(string) {

    var parts = string.split(".");
    var parent = global;
    var i;

    for (i=0; i<parts.length; i++) {
      if (!parent[parts[i]]) {
        parent[parts[i]] = {};
      }
      parent = parent[parts[i]];
    }
    return parent;

  };

  /**
   * url of the currently procressed file 
   */
  var current={}; 

  /**
   * set the url of the currently processed file
   */
  $identify = function(name) {
    current.url = name;
  };

  var execute_with_requirements = function(url) {
    if (executed.urls[url]) {
      return;
    }

    if (!waiting.urls[url]) {
      return;
    }
	
    var requirements = waiting.urls[url].requirements;
    if (requirements && requirements.length) {
      var i;
      for (i=requirements.length-1; i>=0; i--) {
	execute_with_requirements(requirements[i].url);
      }
    }
    //alert("executing: "+url);
    waiting.urls[url].continuation();
    executed.urls[url] = true;
  };

  /**
   * When a script has been loaded, this function will check whether all
   * requirements have been loaded, and will then execute the main sections.
   */
  var onload = function() {

    loading = loading - 1;
    if (loading === 0) {
      while (waiting.nourl.length > 0) {
	var nourl = waiting.nourl.pop();
	var urlobj;
	for (urlobj in nourl.requirements) {
	  execute_with_requirements(nourl.requirements[urlobj].url);
	}
        var continuation = nourl.continuation;
        if (!executed.nourl[continuation]) {
          executed.nourl[continuation] = true;
          continuation();
        }
      }

      var url;
      for (url in waiting.urls) {
	execute_with_requirements(url);
      }
    }

  };

  /**
   * Ensures that the script at the specified url is loaded before the main
   * section is executed.
   * We cannot detect whether a script has finished loading when a third-party
   * script is loaded that doesn't contain a call to $main. In those cases a
   * 'ready' function to detect load completion must be specified. This function
   * should return 'true' when the script has loaded, and 'false' otherwise.
   * Typically, such a function would check for the presence of a variable that
   * is set by the third-party script.
   */

  /* delayed require */
  $require = function(url, ready) {
    if (!current.requirements) {
      current.requirements = new Array();
    }
    current.requirements.push( { url:url, ready:ready } );
  };

  var require_action = function(url, ready) {
    // already being loaded
    if (waiting.urls[url] || loadingurls[url]) {
      return;
    }

    // store that this url has been added
    loadingurls[url] = true;

    // add base url to url, unless it is an absolute url
    if (!url.match(/^\/|:/)) {
      url = $baseurl + url;
    }

    // increase the 'loading' counter
    loading = loading + 1;

    // add script tag to document
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = url;
    lastadded.parentNode.insertBefore(script, lastadded.nextSibling);
    lastadded = script;

    // use the 'ready' function to check for load complete, if it was specified
    if (ready instanceof Function) {
      var wait = function() {
        if (ready()) {
          onload();
        }
        else {
          setTimeout(wait, 100);
        }
      };
      wait();
    }

  };

  /**
   * Calls the continuation function that is specified as a parameter when all
   * previously specified requirements have been loaded. Each main section is
   * only executed once.
   */
  $main = function(continuation) {
    current.continuation = continuation;

    /* add current to waiting queue */
    if (current.url) {
      waiting.urls[current.url] = current;
    } else {
      waiting.nourl.push({
	continuation:continuation, 
	requirements:current.requirements
      });
    }

    /* store requirements and reset current */
    var requirements = current.requirements;

    current={};

    /* do delayed requires and create waiting queue */
    if (requirements) {
      var i;

      for (i = requirements.length - 1; i>=0; i--) {
	var req = requirements[i];

	require_action(req.url, req.ready);
      }
    }
    /* call onload function */
    onload();
  };

  /**
   * Returns a new class that adds the specified properties to the specified
   * parent class.
   */
  $extend = function(parent, properties) {

    // figure out what the prototype of the new class will be
    var prototype;
    if (parent instanceof Function) {
      prototype = new parent();
    }
    else {
      var parentConstructor = function(){};
      parentConstructor.prototype = parent;
      prototype = new parentConstructor();
    }

    // create the new class constructor
    var constructor = function(){
      if (this.initialize instanceof Function) {
        this.initialize.apply(this, arguments);
      }
    };

    // copy any static class properties of the parent to the new class
    if (parent instanceof Function) {
      for (x in parent) {
        constructor[x] = parent[x];
      }
    }

    // copy the additional properties to the prototype
    for (x in properties) {

      // add a 'parent' property to methods, to enable super calls
      if (properties[x] instanceof Function) {
        if (!("parent" in properties[x])) {
          if (parent instanceof Function) {
            properties[x].parent = parent.prototype;
          }
          else {
            properties[x].parent = parent;
          }
        }
      }

      prototype[x] = properties[x];

    }

    // combine constructor and prototype
    constructor.prototype = prototype;

    // return new class constructor
    return constructor;

  };

  /*
   * Help function to indicate that more files are concatenated and do not
   * needed to be loaded seperately.
   */
  $contains = function(url) {
    loadingurls[url] = true;
    loading += 1;
  };

  $setOptions = function(prefix, optionList) {
    var options = $package(prefix);
    var optionName;
    for (optionName in optionList) {
      options[optionName] = optionList[optionName];
    }
    return options;
  };

  /**
   * Find the script tag that was used to load this script, and use it to
   * calculate the value of 'lastadded' and '$baseurl'.
   */
  var scripts = document.getElementsByTagName("script");
  var scriptfinder1 = /(.*)org\/mathdox\/javascript\/core\.js$/;
  var scriptfinder2 = /(.*)org\/mathdox\/formulaeditor\/FEConcatenation\.js$/;
  for (var i=0; i<scripts.length; i++) {
    var match = scripts[i].src.match(scriptfinder1);
    if (match === null) {
      match = scripts[i].src.match(scriptfinder2);
    }
    if (match !== null) {
      lastadded = scripts[i];
      $baseurl = match[1];
    }
  }

})();
/*
 * This file has been generated automatically. 
 *
 * DO NOT EDIT
 *
 * Instead look for the $identify functions which are placed at the top 
 * of each file and indicate which file should be edited instead.
 */

  $contains("com/oreilly/javascript/tdg/XML.js");

  $contains("com/oreilly/javascript/tdg/XMLHttp.js");

  $contains("org/mathdox/debug/Debug.js");

  $contains("org/mathdox/formulaeditor/Canvas.js");

  $contains("org/mathdox/formulaeditor/Cursor.js");

  $contains("org/mathdox/formulaeditor/EventHandler.js");
 
  $contains("org/mathdox/formulaeditor/EventHandlerLocal.js");
 
  $contains("com/oreilly/javascript/tdg/XML.js");

  $contains("com/oreilly/javascript/tdg/XMLHttp.js");

  $contains("org/mathdox/debug/Debug.js");

  $contains("org/mathdox/formulaeditor/Canvas.js");

  $contains("org/mathdox/formulaeditor/Cursor.js");

  $contains("org/mathdox/formulaeditor/EventHandler.js");
 
  $contains("org/mathdox/formulaeditor/EventHandlerLocal.js");
 
  $contains("org/mathdox/formulaeditor/FormulaEditor.js");

  $contains("org/mathdox/formulaeditor/MathCanvas.js");

  $contains("org/mathdox/formulaeditor/MathCanvasFill.js");

  $contains("org/mathdox/formulaeditor/Options.js");

    $contains("org/mathdox/formulaeditor/OrbeonForms.js");

  $contains("org/mathdox/formulaeditor/Palettes.js");

  $contains("org/mathdox/formulaeditor/Services.js");

  $contains("org/mathdox/formulaeditor/modules/arith1/minus.js");

  $contains("org/mathdox/formulaeditor/modules/arith1/plus.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/abs.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/divide.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/power.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/product.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/root.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/sum.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/times.js");

    $contains("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");

  $contains("org/mathdox/formulaeditor/modules/calculus1/defint.js");

    $contains("org/mathdox/formulaeditor/modules/calculus1/diff.js");

  $contains("org/mathdox/formulaeditor/modules/calculus1/int.js");

    $contains("org/mathdox/formulaeditor/modules/complex1/complex_cartesian.js");

    $contains("org/mathdox/formulaeditor/modules/editor1/palette.js");

    $contains("org/mathdox/formulaeditor/modules/fns1/lambda.js");

  $contains("org/mathdox/formulaeditor/modules/integer1/factorial.js");

    $contains("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");

    $contains("org/mathdox/formulaeditor/modules/interval1/interval.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_cc.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_co.js");

    $contains("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_oc.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_oo.js");

  $contains("org/mathdox/formulaeditor/modules/keywords.js");

    $contains("org/mathdox/formulaeditor/modules/limit1/limit.js");

    $contains("org/mathdox/formulaeditor/modules/linalg/matrix.js");

    $contains("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");

    $contains("org/mathdox/formulaeditor/modules/list1/list.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/and.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/equivalent.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/implies.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/not.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/or.js");

    $contains("org/mathdox/formulaeditor/modules/nums1/rational.js");

  $contains("org/mathdox/formulaeditor/modules/permutation1/left_compose.js");

    $contains("org/mathdox/formulaeditor/modules/permutation1/permutation.js");

    $contains("org/mathdox/formulaeditor/modules/relation1/IntervalNotation.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/approx.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/eq.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/geq.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/gt.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/leq.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/lt.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/neq.js");

  $contains("org/mathdox/formulaeditor/modules/set1/in.js");

  $contains("org/mathdox/formulaeditor/modules/variables.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/VariableList.js");

  $contains("org/mathdox/formulaeditor/parsing/mathml/MathMLParser.js");

  $contains("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

  $contains("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

  $contains("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");

  $contains("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");

  $contains("org/mathdox/formulaeditor/presentation/BlockSymbol.js");

  $contains("org/mathdox/formulaeditor/presentation/Boxed.js");

  $contains("org/mathdox/formulaeditor/presentation/Bracket.js");

  $contains("org/mathdox/formulaeditor/presentation/Bracketed.js");

  $contains("org/mathdox/formulaeditor/presentation/Column.js");

  $contains("org/mathdox/formulaeditor/presentation/Editor.js");

  $contains("org/mathdox/formulaeditor/presentation/Fraction.js");

  $contains("org/mathdox/formulaeditor/presentation/Matrix.js");

  $contains("org/mathdox/formulaeditor/presentation/Node.js");

  $contains("org/mathdox/formulaeditor/presentation/PArray.js");

  $contains("org/mathdox/formulaeditor/presentation/PTabContainer.js");

  $contains("org/mathdox/formulaeditor/presentation/PseudoRow.js");

  $contains("org/mathdox/formulaeditor/presentation/Root.js");

  $contains("org/mathdox/formulaeditor/presentation/Row.js");

  $contains("org/mathdox/formulaeditor/presentation/Subscript.js");

  $contains("org/mathdox/formulaeditor/presentation/Superscript.js");

  $contains("org/mathdox/formulaeditor/presentation/SuperscriptSymbol.js");

  $contains("org/mathdox/formulaeditor/presentation/Symbol.js");

  $contains("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

  $contains("org/mathdox/formulaeditor/presentation/Vector.js");

  $contains("org/mathdox/formulaeditor/semantics/FunctionApplication.js");

  $contains("org/mathdox/formulaeditor/semantics/Integer.js");

  $contains("org/mathdox/formulaeditor/semantics/Keyword.js");

  $contains("org/mathdox/formulaeditor/semantics/Lambda.js");

  $contains("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

  $contains("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

  $contains("org/mathdox/formulaeditor/semantics/Node.js");

  $contains("org/mathdox/formulaeditor/semantics/SemanticFloat.js");

  $contains("org/mathdox/formulaeditor/semantics/String.js");

  $contains("org/mathdox/formulaeditor/semantics/Variable.js");

  $contains("org/mathdox/formulaeditor/version.js");

  $contains("org/mathdox/parsing/Parser.js");

  $contains("org/mathdox/parsing/ParserGenerator.js");

  $contains("org/mathdox/formulaeditor/FormulaEditor.js");

  $contains("org/mathdox/formulaeditor/MathCanvas.js");

  $contains("org/mathdox/formulaeditor/MathCanvasFill.js");

  $contains("org/mathdox/formulaeditor/Options.js");

  $contains("org/mathdox/formulaeditor/OrbeonForms.js");

  $contains("org/mathdox/formulaeditor/Palettes.js");

  $contains("org/mathdox/formulaeditor/Services.js");

  $contains("org/mathdox/formulaeditor/modules/arith1/minus.js");

  $contains("org/mathdox/formulaeditor/modules/arith1/plus.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/abs.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/divide.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/power.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/product.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/root.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/sum.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/times.js");

  $contains("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");

  $contains("org/mathdox/formulaeditor/modules/calculus1/defint.js");

  $contains("org/mathdox/formulaeditor/modules/calculus1/diff.js");

  $contains("org/mathdox/formulaeditor/modules/calculus1/int.js");

  $contains("org/mathdox/formulaeditor/modules/complex1/complex_cartesian.js");

  $contains("org/mathdox/formulaeditor/modules/editor1/palette.js");

  $contains("org/mathdox/formulaeditor/modules/fns1/lambda.js");

  $contains("org/mathdox/formulaeditor/modules/integer1/factorial.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_cc.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_co.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_oc.js");

  $contains("org/mathdox/formulaeditor/modules/interval1/interval_oo.js");

  $contains("org/mathdox/formulaeditor/modules/keywords.js");

  $contains("org/mathdox/formulaeditor/modules/limit1/limit.js");

  $contains("org/mathdox/formulaeditor/modules/linalg/matrix.js");

  $contains("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");

  $contains("org/mathdox/formulaeditor/modules/list1/list.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/and.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/equivalent.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/implies.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/not.js");

  $contains("org/mathdox/formulaeditor/modules/logic1/or.js");

  $contains("org/mathdox/formulaeditor/modules/nums1/rational.js");

  $contains("org/mathdox/formulaeditor/modules/permutation1/left_compose.js");

  $contains("org/mathdox/formulaeditor/modules/permutation1/permutation.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/IntervalNotation.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/approx.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/eq.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/geq.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/gt.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/leq.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/lt.js");

  $contains("org/mathdox/formulaeditor/modules/relation1/neq.js");

  $contains("org/mathdox/formulaeditor/modules/set1/in.js");

  $contains("org/mathdox/formulaeditor/modules/variables.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");

  $contains("org/mathdox/formulaeditor/parsing/expression/VariableList.js");

  $contains("org/mathdox/formulaeditor/parsing/mathml/MathMLParser.js");

  $contains("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

  $contains("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

  $contains("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");

  $contains("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");

  $contains("org/mathdox/formulaeditor/presentation/BlockSymbol.js");

  $contains("org/mathdox/formulaeditor/presentation/Boxed.js");

  $contains("org/mathdox/formulaeditor/presentation/Bracket.js");

  $contains("org/mathdox/formulaeditor/presentation/Bracketed.js");

  $contains("org/mathdox/formulaeditor/presentation/Column.js");

  $contains("org/mathdox/formulaeditor/presentation/Editor.js");

  $contains("org/mathdox/formulaeditor/presentation/Fraction.js");

  $contains("org/mathdox/formulaeditor/presentation/Matrix.js");

  $contains("org/mathdox/formulaeditor/presentation/Node.js");

  $contains("org/mathdox/formulaeditor/presentation/PArray.js");

  $contains("org/mathdox/formulaeditor/presentation/PTabContainer.js");

  $contains("org/mathdox/formulaeditor/presentation/PseudoRow.js");

  $contains("org/mathdox/formulaeditor/presentation/Root.js");

  $contains("org/mathdox/formulaeditor/presentation/Row.js");

  $contains("org/mathdox/formulaeditor/presentation/Subscript.js");

  $contains("org/mathdox/formulaeditor/presentation/Superscript.js");

  $contains("org/mathdox/formulaeditor/presentation/SuperscriptSymbol.js");

  $contains("org/mathdox/formulaeditor/presentation/Symbol.js");

  $contains("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

  $contains("org/mathdox/formulaeditor/presentation/Vector.js");

  $contains("org/mathdox/formulaeditor/semantics/FunctionApplication.js");

  $contains("org/mathdox/formulaeditor/semantics/Integer.js");

  $contains("org/mathdox/formulaeditor/semantics/Keyword.js");

  $contains("org/mathdox/formulaeditor/semantics/Lambda.js");

  $contains("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

  $contains("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

  $contains("org/mathdox/formulaeditor/semantics/Node.js");

  $contains("org/mathdox/formulaeditor/semantics/SemanticFloat.js");

  $contains("org/mathdox/formulaeditor/semantics/String.js");

  $contains("org/mathdox/formulaeditor/semantics/Variable.js");

  $contains("org/mathdox/formulaeditor/version.js");

  $contains("org/mathdox/parsing/Parser.js");

  $contains("org/mathdox/parsing/ParserGenerator.js");

$main( function() {} );

  $package("com.oreilly.javascript.tdg");

$identify("com/oreilly/javascript/tdg/XML.js");

$main(function(){
   /**
   * Class with static methods that facilitates usage of XML 
   * Note: modified to be initialized as an object and to use this
   * 
   * Several methods from JavaScript: The Definitive Guide, 5th edition
   * David Flanagan, 2006, O'Reilly, Sebastopol, ISBN-13: 978-0-596-10199-2
   * Chapter 21, starting at page 502, example 21-1, 21-4, 21-11
   */
  com.oreilly.javascript.tdg.XML = {

    /* example 21-1, page 503-504 */
    /** 
     * Create a new Document object. If no arguments are specified,
     * the document will be empty. If a root tag is specified, the document
     * will contain that single root tag. If the root tag has a namespace
     * prefix, the second argument must specify the URL that identifies the
     * namespace.
     */
    newDocument : function(rootTagName, namespaceURL) {
      if (!rootTagName) {
        rootTagName = "";
      }
      if (!namespaceURL) {
        namespaceURL = "";
      }
  
      if (document.implementation && document.implementation.createDocument) {
        // This is the W3C standard way to do it
        return document.implementation.createDocument(namespaceURL,
                rootTagName, null);
      } else { // This is the IE way to do it
        // Create an empty document as an ActiveX object
        // If there is no root element, this is all we have to do
        var doc = new ActiveXObject("MSXML2.DOMDocument");
  
        // If there is a root tag, initialize the document
        if (rootTagName) {
          // Look for a namespace prefix
          var prefix = "";
          var tagname = rootTagName;
          var p = rootTagName.indexOf(':');
          if ( p != -1) {
            prefix = rootTagName.substring(0, p);
            tagname = rootTagName.substring(p+1);
          }
  
          // If we have a namespace, we must have a namespace prefix
          // If we don't have a namespace, we discard any prefix
          if (namespaceURL) {
            if (!prefix) {
              prefix = "a0"; // What Firefox uses
            } 
  
          } else {
            prefix = "";
          }
          // Create the root element (with optional namespace) as a 
          // string of text
          var text = "<" + (prefix?(prefix+":"):"") + tagname +
            (namespaceURL
              ?(" xmlns:"+ prefix + '="' + namespaceURL +'"')
              :"") +
            "/>";
          // And parse that text into the empty document
          doc.loadXML(text);
        }
        return doc;
      }
    },
  
    /* example 21-4, page 505-506 */
  
    /**
     * Parse the XML document contained in the string argument and return
     * a Document object that represents it.
     */
    parse: function(text) {
      if (typeof DOMParser != "undefined" ) {
        // Mozilla, Firefox, and related browsers
        return (new DOMParser()).parseFromString(text, "application/xml");
      } else if (typeof ActiveXObject != "undefined") {
        // Internet Explorer.
        var doc = this.newDocument();        // Create an empty document
        doc.loadXML(text);                // Parse text into it
        return doc;                        // Return it
      } else {
        // As a last resort, try loading the document from a data: URL
        // This is suppossed to work in Safari. Thanks to Manos Batsis and
        // his Sariassa library (sarissa.sourceforge.net) for this technique.
        var url = "data:text/xml;charset=utf-8,"+encodeURIComponent(text);
        var request = new XMLHttpRequest();
        request.open("GET", url, false);
        request.send(null);
        return request.responseXML;
      }
    },
    /* Example 21-11, page 520 */
    /**
     * Serialize an XML Document or Eelement and return it as a string.
     */
    serialize : function(node) {
      if (typeof XMLSerializer != "undefined") {
        return (new XMLSerializer()).serializeToString(node);
      } else if (node.xml) {
        return node.xml;
      } else {
        throw "XML.serialize is not supported or can't serialize "+ node;
      }
    }
  };
});

  $package("com.oreilly.javascript.tdg");

$identify("com/oreilly/javascript/tdg/XMLHttp.js");

$main(function(){
  /**
   * Class with static methods that facilitates XML HTTP calls
   * Note: modified to be initialized as an object and to use this
   * 
   * Several methods from JavaScript: The Definitive Guide, 5th edition
   * David Flanagan, 2006, O'Reilly, Sebastopol, ISBN-13: 978-0-596-10199-2
   * Chapter 20, starting at page 478, example 20-1, 20-2, 20-3
   */
  com.oreilly.javascript.tdg.XMLHttp = {
    
    /* example 20-1, page 480-481 */
     
    // This is a list of XMLHttpRequest-creation factory functions to try
    _factories : [
      function() { return new XMLHttpRequest(); },
      function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
      function() { return new ActiveXObject("Microsoft.XMLHTTP"); }
    ],

    // When we find a factory that works, store it here.
    _factory : null,

    // Create and return a new XMLHttpRequest object.
    //
    // The first time we're called, try the list of factory functions until
    // we find one that returns a non-null value and does not throw an 
    // exception. Once we find a working factory, remember it for later use.
    //
    newRequest : function() {
      if (this._factory !== null) {
        return this._factory();
      }

      for (var i = 0; i < this._factories.length; i++) {
        try {
          var factory = this._factories[i];
          var request = factory();
          if (request !== null) {
            this._factory = factory;
            return request;
          }
        }
        catch (e) {
          continue;
        }
      }

      // If we ever get here, none of the factory candidates succeeded, 
      // so thown an exception now and for all future calls.
      this._factory = function() {
        throw new Error("XMLHttpRequest not supported");
      };
      this._factory(); // Throw an error
    },

    /* example 20-2, page 486 */
    getText : function(url, callback) {
      var request = this.newRequest();
      request.onreadystatechange = function() {
        if (request.readyState == 4 && request.status == 200) {
          callback(request.responseText);
        }
      };
      request.open("GET", url);
      request.send(null);
    },

    /* example 20-3, page 486 */
    getXML : function(url, callback) {
      var request = this.newRequest();
      request.onreadystatechange = function() {
        if (request.readyState == 4 && request.status == 200) {
          callback(request.responseXML);
        }
      };
      request.open("GET", url);
      request.send(null);
    },

    /* example 20-5, page 488 */
    /**
     * Send an HTTP POST request to the specified URL, using the names and
     * values of the properties of the values object as the body of the
     * request. Parse the server's response according to its content type and
     * pass the resulting value to the callback function. If an HTTP error
     * occurs, call the specified errorHandler function, or pass null to the
     * callback if no error handler is specified.
     **/
    post : function(url, values, callback, errorHandler) {
      var request = this.newRequest();
      request.onreadystatechange = function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            callback(request.responseText); // NOTE: example modified here
          } 
          else {
            if (errorHandler) {
              errorHandler(request.status, request.statusText);
            } else {
              callback(null);
            }
          }
        } 
      };

      request.open("POST", url);
      // This header tells the server how to interpret the body of the request.
      request.setRequestHeader("Content-Type", 
                               "application/x-www-form-urlencoded");
      // Encode the properties of the values object and send them as
      // the body of the request.
      request.send(this.encodeFormData(values));
    },

    /**
     * Encode the property name/value pairs of an object as if they were from
     * an HTML for, using application/x-www-urlencoded format
     */
    encodeFormData : function(data) {
      var pairs = [];
      var regexp = /%20/g; // A regular expression to match an encoded space

      for (var name in data) {
        var value = data[name].toString();
        // Create a name/value pair, but encode name and value first
        // The global function encodeURIComponent does almost what we want,
        // but it encodes spaces as %20 instead of as "+". We have to
        // fix that with String.replace()
        var pair = encodeURIComponent(name).replace(regexp,"+") + '=' +
          encodeURIComponent(value).replace(regexp,"+");
        pairs.push(pair);
      }

      // Concatenate all the name/value pairs, separating them with &
      return pairs.join('&');
    }
  };

});

  $package("org.mathdox.debug");

$identify("org/mathdox/debug/Debug.js");

$main(function() {
  org.mathdox.debug.Debug = $extend(Object, {

    //other variables
    debug             : true,
    debugBuffer       : "",
    debugDiv          : null,
    debugLevel        : 5,
    frameInitTimeStep : 10,
    idstr             : "MathDox Exercise System - PostDebug",
    
    initialize: function() {
      this.debugChildInit.idstr = this.idstr;
    },

    addDebug: function(text, level) {
      if (level === undefined || level === null) {
        level = 0;
      }

      if(this.debug && level <= this.debugLevel) {
        try {
          this.debugDiv.innerHTML+=text+'<br>';
        } catch(err) {
          this.debugBuffer+=text+'<br>';
        }
      }
    },

    addMessageListeners: function(messageEventLib) {
      this.messageListener.debug = this;
      messageEventLib.addMessageListener(this.idstr, "debug", this.messageListener);
    },

    createDebug: function() {
      if(this.debug) {
        var debugDiv = document.createElement("div");
        debugDiv.id="debugWindow";
        debugDiv.style.position="absolute";
        debugDiv.style.right="5px";
        debugDiv.style.top="5px";
        debugDiv.style.borderStyle="solid";
        debugDiv.style.borderColor="#000000";
        debugDiv.style.borderWidth="1px";
        debugDiv.style.backgroundColor="#EEEEEE";
        debugDiv.style.padding="5px";
        debugDiv.style.fontSize="12px";
        debugDiv.innerHTML="<b>Debug-window</b><br />"+this.debugBuffer;
        this.debugDiv = debugDiv;
        try {
          this.addDebug("- add debug window");
          document.body.insertBefore(debugDiv,document.body.firstChild);
        } catch(err) {
          this.addDebug("- delayed adding debug window (not ready)");
          var obj = this;

          setTimeout(function() {obj.createDebug(); }, this.frameInitTimestep);
        }
      }
    },
  
    debugChildInit: function() {
      var data = {
        idstr : arguments.callee.idstr,
        mode  : "debugInit"
      };
      var list = document.getElementsByTagName('iframe');
      for(var i=0;i<list.length;i++) {
        var iframe=list[i];

        iframe.contentWindow.postMessage(data, "*");
      }
    },

    messageListener: function(event) {
      if (typeof event.data === "object") {
        var data = event.data;
        if (data.idstr == arguments.callee.debug.idstr) {
          if (data.mode == "debug") {
            if (data.text !== undefined && data.text !== null) {
              arguments.callee.debug.addDebug("[child] "+data.text);
            }
          }
        }
      }
    },

    startDebug: function() {
    }
  });
});

  /**
 * Loads Google's Explorer Canvas library, when there is no native support for
 * the <canvas/> tag.
 */
$identify("org/mathdox/formulaeditor/Canvas.js");

var G_vmlCanvasManager;
if (!window.CanvasRenderingContext2D) {

  $require(
    "com/google/code/excanvas/excanvas.js",
    function() { return window.CanvasRenderingContext2D });

  $main(function(){

    /**
     * Workaround for bug in Google's Explorer Canvas. The standard fixElement
     * method will remove all siblings following the canvas tag. In addition to
     * not executing the fixElement of Explorer Canvas, this method wraps any
     * canvas element in a span inside a table, to work around the fact that
     * Internet Explorer doesn't like VML groups (which are used by Explorer
     * Canvas) inside block elements, such as <p>'s. See also:
     * http://keithdevens.com/weblog/archive/2006/Oct/18/invalid-source-html
     */
    G_vmlCanvasManager.fixElement_ = function(element) {

        if (element.tagName.toLowerCase() == "canvas") {

          // create table element
          var table = document.createElement("table");
          table.style.display = "inline";
          table.style.verticalAlign = element.style.verticalAlign;

          // create span element, and insert it into the table
          var span  = document.createElement("span");
          table.insertRow(0).insertCell(0).appendChild(span);

          // replace the canvas element by the table
          element.parentNode.replaceChild(table, element);

          // insert the canvas element into the span
          span.appendChild(element);

        }

        return element;

    };

    /**
     * Because the script tag that references excanvas.js file is dynamically
     * added to the DOM after the document is already loaded, it is necessary
     * to call the initialization code explicitly, instead of letting it wait
     * forever on the 'onreadystatechange' event.
     */
    if (document.readyState && document.readyState == "complete") {
      G_vmlCanvasManager.init_(document);
    }

  });

}
else {

  $main(function(){
    // skip
  });

}

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/Cursor.js");

$main(function(){

  /**
  * Represents the keyboard cursor.
  */
  org.mathdox.formulaeditor.Cursor = $extend(Object, {

    position : null,

    visible : false,

    initialize : function(position) {
      this.position = position;
    },

    /**
     * Handles an onkeydown event from the browser. Returns false when the event
     * has been handled and should not be handled by the browser, returns true
     * otherwise.
     */
    onkeydown : function(event, editor) {

      // only handle keypresses where alt, ctrl and shift are not held
      if (!event.altKey && !event.ctrlKey && !event.shiftKey) {

        // handle arrow keys, home and end
        switch(event.keyCode) {

          case 35: // end
            this.moveLast();
            editor.redraw();
            return false;

          case 36: // home
            this.moveFirst();
            editor.redraw();
            return false;

          case 37: // left arrow
            this.moveLeft();
            editor.redraw();
            return false;

          case 38: // up arrow
            this.moveUp();
            editor.redraw();
            return false;

          case 39: // right arrow
            this.moveRight();
            editor.redraw();
            return false;

          case 40: // down arrow
            this.moveDown();
            editor.redraw();
            return false;
	  
        }

      }

      // pass the event to the presentation tree
      return this.position.row.onkeydown(event, editor);

    },

    /**
     * Handles an onkeypress event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onkeypress : function(event, editor) {

      // pass the event to the presentation tree
      return this.position.row.onkeypress(event, editor);

    },

    /**
     * Handles an onmousedown event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onmousedown : function(event, editor, x, y) {
      var position = editor.presentation.getCursorPosition(x,y);

      if (position) {
	this.position.row.setHighlight(false);
	this.position = position;
      } else {
	editor.presentation.onmousedown(event, editor, x, y);
      }
      if (this.position === null || this.position === undefined) {
	this.position = editor.presentation.getFollowingCursorPosition();
      }

      editor.redraw();
    },

    moveRight : function() {

      var row   = this.position.row;
      var index = this.position.index;
      
      var newPosition = row.getFollowingCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveLeft : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getPrecedingCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveDown : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getLowerCursorPosition(index, this.getX());
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveUp : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getHigherCursorPosition(index, this.getX());
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveFirst : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getFirstCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveLast : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getLastCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    getX : function() {

      // TODO: use this in draw, rename
      var row   = this.position.row;
      var index = this.position.index;

      var dim0 = row.children[index-1] ? row.children[index - 1].dimensions : null;
      var dim1 = row.children[index]   ? row.children[index].dimensions     : null;

      if (dim0 === null && dim1 === null) {
        dim1 = row.dimensions;
      }
      if (dim0 === null && dim1 !== null) {
        dim0 = { left: row.dimensions.left, top: dim1.top, width:0, height: dim1.height };
      }
      if (dim1 === null && dim0 !== null) {
        dim1 = { left: dim0.left + dim0.width, top: dim0.top, width:0, height: dim0.height };
      }

      return Math.round(dim0.left + dim0.width + ((dim1.left - (dim0.left + dim0.width))/2));

    },

    draw : function(canvas, context) {

      if (this.visible) {

        var lineWidth = 2.0;
        var margin    = 2.0;
        var color     = "#66C";

        var row   = this.position.row;
        var index = this.position.index;

        var dim0 = row.children[index-1] ? row.children[index - 1].dimensions : null;
        var dim1 = row.children[index]   ? row.children[index].dimensions     : null;

        if (dim0 === null && dim1 === null) {
          dim1 = row.dimensions;
        }
        if (dim0 === null && dim1 !== null) {
          dim0 = { left: row.dimensions.left, top: dim1.top, width:0, height: dim1.height };
        }
        if (dim1 === null && dim0 !== null) {
          dim1 = { left: dim0.left + dim0.width, top: dim0.top, width:0, height: dim0.height };
        }

        var x      = Math.round(dim0.left + dim0.width + ((dim1.left - (dim0.left + dim0.width))/2));
        var top    = Math.round(Math.min(dim0.top, dim1.top) - margin);
        var bottom = Math.round(Math.max(dim0.top + dim0.height, dim1.top + dim1.height) + margin);

        // ensure that size of the cursor is at least height of the symbol 'f'
        var Symbol = org.mathdox.formulaeditor.presentation.Symbol;
        var fHeight = new Symbol("f").draw(canvas, context, 0, 0, true).height;
        fHeight = fHeight + 2 * margin;
        if (bottom - top < fHeight) {
          var delta = fHeight - (bottom - top);
          top = top - delta/2;
          bottom = bottom + delta/2;
        }

        var canvasContext = canvas.getContext();

        canvasContext.save();
        canvasContext.lineWidth = lineWidth;
        canvasContext.strokeStyle = color;
        canvasContext.beginPath();
        canvasContext.moveTo(x, top);
        canvasContext.lineTo(x, bottom);
        canvasContext.stroke();
        canvasContext.closePath();
        canvasContext.restore();

      }

    }

  });

});

  $package("org.mathdox.formulaeditor"); 

$identify("org/mathdox/formulaeditor/EventHandler.js"); 

$main(function(){ 
  org.mathdox.formulaeditor.EventHandler = $extend(Object, {
    initialize : function() { 

      // save the 'this' pointer so that it can be used in the event handlers 
      var handler = this;

      // register the onkeydown handler, if present
      if (this.onkeydown instanceof Function) {

        var saved1 = window.onkeydown;
        document.onkeydown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onkeydown(event) && saved1 && saved1(event);

        };

      }

      // register the onkeypress handler, if present
      if (this.onkeypress instanceof Function) {

        var saved2 = window.onkeypress;
        document.onkeypress = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          if (!("charCode" in event)) {
            event.charCode = event.keyCode; // MSIE doesn't set charCode
          }

          return handler.onkeypress(event) && saved2 && saved2(event);

        };

      }

      // register the onmousedown handler, if present
      if (this.onmousedown instanceof Function) {

        var saved3 = window.onclick;
        var saved3a = window.ontouchstart;
        document.onmousedown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(event) && saved3 && saved3(event);

        };

        document.ontouchstart = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(handler.rewriteTouchEvent(event)) && saved3a && saved3a(event);

        }

      }

      // register the onmouseup handler, if present
      if (this.onmouseup instanceof Function) {

        var saved4 = window.onclick;
        var saved4a = window.ontouchend;
        document.onmouseup = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseup(event) && saved4 && saved4(event);

        };

        document.ontouchend = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }
        
          return handler.onmouseup(handler.rewriteTouchEvent(event)) && saved5a && saved4a(event);
	}
      }

    },

    // see also http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/
    rewriteTouchEvent: function(event) {
      var touches = event.changedTouches;
      var first = touches[0];
      var type = "";

      switch(event.type)
      {
        case "touchstart": 
          type = "mousedown"; 
          break;
        case "touchmove":  
          type="mousemove"; 
          break;        
        case "touchend":
          type="mouseup"; 
          break;
        default: return;
      }
      
      // initMouseEvent(type, canBubble, cancelable, view, clickCount, 
      //           screenX, screenY, clientX, clientY, ctrlKey, 
      //           altKey, shiftKey, metaKey, button, relatedTarget);
    
      var simulatedEvent = document.createEvent("MouseEvent");
      simulatedEvent.initMouseEvent(type, true, true, window, 1, 
        first.screenX, first.screenY, 
        first.clientX, first.clientY, false, 
        false, false, false, 0/*left*/, null);
      simulatedEvent.mathdoxnoadjust = true;

      return simulatedEvent;
    }

  });

});
 
  $package("org.mathdox.formulaeditor"); 

$identify("org/mathdox/formulaeditor/EventHandlerLocal.js"); 

$main(function(){ 
  org.mathdox.formulaeditor.EventHandlerLocal = $extend(Object, {
    initialize : function(element) { 

      // save the 'this' pointer so that it can be used in the event handlers 
      var handler = this;

      // register the onkeydown handler, if present
      if (this.onkeydown instanceof Function) {

        var saved1 = element.onkeydown;
        element.onkeydown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onkeydown(event) && saved1 && saved1(event);

        };

      }

      // register the onkeypress handler, if present
      if (this.onkeypress instanceof Function) {

        var saved2 = element.onkeypress;
        element.onkeypress = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          if (!("charCode" in event)) {
            event.charCode = event.keyCode; // MSIE doesn't set charCode
          }

          return handler.onkeypress(event) && saved2 && saved2(event);

        };

      }

      // register the onmousedown handler, if present
      if (this.onmousedown instanceof Function) {

        var saved3 = element.onclick;
        var saved3a = element.ontouchstart;
        element.onmousedown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(event) && saved3 && saved3(event);

        };

        element.ontouchstart = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(handler.rewriteTouchEvent(event)) && saved3a && saved3a(event);

        }

      }

      // register the onmouseup handler, if present
      if (this.onmouseup instanceof Function) {

        var saved4 = element.onclick;
        var saved4a = element.ontouchend;
        element.onmouseup = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseup(event) && saved4 && saved4(event);

        };

        element.ontouchend = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }
        
          return handler.onmouseup(handler.rewriteTouchEvent(event)) && saved5a && saved4a(event);
	}
      }

      // register the onmousemove handler, if present
      if (this.onmousemove instanceof Function) {

        var saved5 = element.onmousemove;
        element.onmousemove = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousemove(event) && saved5 && saved5(event);

        };

      }

      // register the onmouseout handler, if present
      if (this.onmouseout instanceof Function) {

        var saved6 = element.onmouseout;
        element.onmouseout = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseout(event) && saved6 && saved6(event);

        };

      }

      // register the onmouseover handler, if present
      if (this.onmouseover instanceof Function) {

        var saved7 = element.onmouseover;
        element.onmouseover = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseover(event) && saved7 && saved7(event);

        };

      }

    },

    // see also http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/
    rewriteTouchEvent: function(event) {
      var touches = event.changedTouches;
      var first = touches[0];
      var type = "";

      switch(event.type)
      {
        case "touchstart": 
          type = "mousedown"; 
          break;
        case "touchmove":  
          type="mousemove"; 
          break;        
        case "touchend":
          type="mouseup"; 
          break;
        default: return;
      }
      
      // initMouseEvent(type, canBubble, cancelable, view, clickCount, 
      //           screenX, screenY, clientX, clientY, ctrlKey, 
      //           altKey, shiftKey, metaKey, button, relatedTarget);
    
      var simulatedEvent = element.createEvent("MouseEvent");
      simulatedEvent.initMouseEvent(type, true, true, window, 1, 
        first.screenX, first.screenY, 
        first.clientX, first.clientY, false, 
        false, false, false, 0/*left*/, null);
      simulatedEvent.mathdoxnoadjust = true;

      return simulatedEvent;
    }

  });

});
 
  $package("com.oreilly.javascript.tdg");

$identify("com/oreilly/javascript/tdg/XML.js");

$main(function(){
   /**
   * Class with static methods that facilitates usage of XML 
   * Note: modified to be initialized as an object and to use this
   * 
   * Several methods from JavaScript: The Definitive Guide, 5th edition
   * David Flanagan, 2006, O'Reilly, Sebastopol, ISBN-13: 978-0-596-10199-2
   * Chapter 21, starting at page 502, example 21-1, 21-4, 21-11
   */
  com.oreilly.javascript.tdg.XML = {

    /* example 21-1, page 503-504 */
    /** 
     * Create a new Document object. If no arguments are specified,
     * the document will be empty. If a root tag is specified, the document
     * will contain that single root tag. If the root tag has a namespace
     * prefix, the second argument must specify the URL that identifies the
     * namespace.
     */
    newDocument : function(rootTagName, namespaceURL) {
      if (!rootTagName) {
        rootTagName = "";
      }
      if (!namespaceURL) {
        namespaceURL = "";
      }
  
      if (document.implementation && document.implementation.createDocument) {
        // This is the W3C standard way to do it
        return document.implementation.createDocument(namespaceURL,
                rootTagName, null);
      } else { // This is the IE way to do it
        // Create an empty document as an ActiveX object
        // If there is no root element, this is all we have to do
        var doc = new ActiveXObject("MSXML2.DOMDocument");
  
        // If there is a root tag, initialize the document
        if (rootTagName) {
          // Look for a namespace prefix
          var prefix = "";
          var tagname = rootTagName;
          var p = rootTagName.indexOf(':');
          if ( p != -1) {
            prefix = rootTagName.substring(0, p);
            tagname = rootTagName.substring(p+1);
          }
  
          // If we have a namespace, we must have a namespace prefix
          // If we don't have a namespace, we discard any prefix
          if (namespaceURL) {
            if (!prefix) {
              prefix = "a0"; // What Firefox uses
            } 
  
          } else {
            prefix = "";
          }
          // Create the root element (with optional namespace) as a 
          // string of text
          var text = "<" + (prefix?(prefix+":"):"") + tagname +
            (namespaceURL
              ?(" xmlns:"+ prefix + '="' + namespaceURL +'"')
              :"") +
            "/>";
          // And parse that text into the empty document
          doc.loadXML(text);
        }
        return doc;
      }
    },
  
    /* example 21-4, page 505-506 */
  
    /**
     * Parse the XML document contained in the string argument and return
     * a Document object that represents it.
     */
    parse: function(text) {
      if (typeof DOMParser != "undefined" ) {
        // Mozilla, Firefox, and related browsers
        return (new DOMParser()).parseFromString(text, "application/xml");
      } else if (typeof ActiveXObject != "undefined") {
        // Internet Explorer.
        var doc = this.newDocument();        // Create an empty document
        doc.loadXML(text);                // Parse text into it
        return doc;                        // Return it
      } else {
        // As a last resort, try loading the document from a data: URL
        // This is suppossed to work in Safari. Thanks to Manos Batsis and
        // his Sariassa library (sarissa.sourceforge.net) for this technique.
        var url = "data:text/xml;charset=utf-8,"+encodeURIComponent(text);
        var request = new XMLHttpRequest();
        request.open("GET", url, false);
        request.send(null);
        return request.responseXML;
      }
    },
    /* Example 21-11, page 520 */
    /**
     * Serialize an XML Document or Eelement and return it as a string.
     */
    serialize : function(node) {
      if (typeof XMLSerializer != "undefined") {
        return (new XMLSerializer()).serializeToString(node);
      } else if (node.xml) {
        return node.xml;
      } else {
        throw "XML.serialize is not supported or can't serialize "+ node;
      }
    }
  };
});

  $package("com.oreilly.javascript.tdg");

$identify("com/oreilly/javascript/tdg/XMLHttp.js");

$main(function(){
  /**
   * Class with static methods that facilitates XML HTTP calls
   * Note: modified to be initialized as an object and to use this
   * 
   * Several methods from JavaScript: The Definitive Guide, 5th edition
   * David Flanagan, 2006, O'Reilly, Sebastopol, ISBN-13: 978-0-596-10199-2
   * Chapter 20, starting at page 478, example 20-1, 20-2, 20-3
   */
  com.oreilly.javascript.tdg.XMLHttp = {
    
    /* example 20-1, page 480-481 */
     
    // This is a list of XMLHttpRequest-creation factory functions to try
    _factories : [
      function() { return new XMLHttpRequest(); },
      function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
      function() { return new ActiveXObject("Microsoft.XMLHTTP"); }
    ],

    // When we find a factory that works, store it here.
    _factory : null,

    // Create and return a new XMLHttpRequest object.
    //
    // The first time we're called, try the list of factory functions until
    // we find one that returns a non-null value and does not throw an 
    // exception. Once we find a working factory, remember it for later use.
    //
    newRequest : function() {
      if (this._factory !== null) {
        return this._factory();
      }

      for (var i = 0; i < this._factories.length; i++) {
        try {
          var factory = this._factories[i];
          var request = factory();
          if (request !== null) {
            this._factory = factory;
            return request;
          }
        }
        catch (e) {
          continue;
        }
      }

      // If we ever get here, none of the factory candidates succeeded, 
      // so thown an exception now and for all future calls.
      this._factory = function() {
        throw new Error("XMLHttpRequest not supported");
      };
      this._factory(); // Throw an error
    },

    /* example 20-2, page 486 */
    getText : function(url, callback) {
      var request = this.newRequest();
      request.onreadystatechange = function() {
        if (request.readyState == 4 && request.status == 200) {
          callback(request.responseText);
        }
      };
      request.open("GET", url);
      request.send(null);
    },

    /* example 20-3, page 486 */
    getXML : function(url, callback) {
      var request = this.newRequest();
      request.onreadystatechange = function() {
        if (request.readyState == 4 && request.status == 200) {
          callback(request.responseXML);
        }
      };
      request.open("GET", url);
      request.send(null);
    },

    /* example 20-5, page 488 */
    /**
     * Send an HTTP POST request to the specified URL, using the names and
     * values of the properties of the values object as the body of the
     * request. Parse the server's response according to its content type and
     * pass the resulting value to the callback function. If an HTTP error
     * occurs, call the specified errorHandler function, or pass null to the
     * callback if no error handler is specified.
     **/
    post : function(url, values, callback, errorHandler) {
      var request = this.newRequest();
      request.onreadystatechange = function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            callback(request.responseText); // NOTE: example modified here
          } 
          else {
            if (errorHandler) {
              errorHandler(request.status, request.statusText);
            } else {
              callback(null);
            }
          }
        } 
      };

      request.open("POST", url);
      // This header tells the server how to interpret the body of the request.
      request.setRequestHeader("Content-Type", 
                               "application/x-www-form-urlencoded");
      // Encode the properties of the values object and send them as
      // the body of the request.
      request.send(this.encodeFormData(values));
    },

    /**
     * Encode the property name/value pairs of an object as if they were from
     * an HTML for, using application/x-www-urlencoded format
     */
    encodeFormData : function(data) {
      var pairs = [];
      var regexp = /%20/g; // A regular expression to match an encoded space

      for (var name in data) {
        var value = data[name].toString();
        // Create a name/value pair, but encode name and value first
        // The global function encodeURIComponent does almost what we want,
        // but it encodes spaces as %20 instead of as "+". We have to
        // fix that with String.replace()
        var pair = encodeURIComponent(name).replace(regexp,"+") + '=' +
          encodeURIComponent(value).replace(regexp,"+");
        pairs.push(pair);
      }

      // Concatenate all the name/value pairs, separating them with &
      return pairs.join('&');
    }
  };

});

  $package("org.mathdox.debug");

$identify("org/mathdox/debug/Debug.js");

$main(function() {
  org.mathdox.debug.Debug = $extend(Object, {

    //other variables
    debug             : true,
    debugBuffer       : "",
    debugDiv          : null,
    debugLevel        : 5,
    frameInitTimeStep : 10,
    idstr             : "MathDox Exercise System - PostDebug",
    
    initialize: function() {
      this.debugChildInit.idstr = this.idstr;
    },

    addDebug: function(text, level) {
      if (level === undefined || level === null) {
        level = 0;
      }

      if(this.debug && level <= this.debugLevel) {
        try {
          this.debugDiv.innerHTML+=text+'<br>';
        } catch(err) {
          this.debugBuffer+=text+'<br>';
        }
      }
    },

    addMessageListeners: function(messageEventLib) {
      this.messageListener.debug = this;
      messageEventLib.addMessageListener(this.idstr, "debug", this.messageListener);
    },

    createDebug: function() {
      if(this.debug) {
        var debugDiv = document.createElement("div");
        debugDiv.id="debugWindow";
        debugDiv.style.position="absolute";
        debugDiv.style.right="5px";
        debugDiv.style.top="5px";
        debugDiv.style.borderStyle="solid";
        debugDiv.style.borderColor="#000000";
        debugDiv.style.borderWidth="1px";
        debugDiv.style.backgroundColor="#EEEEEE";
        debugDiv.style.padding="5px";
        debugDiv.style.fontSize="12px";
        debugDiv.innerHTML="<b>Debug-window</b><br />"+this.debugBuffer;
        this.debugDiv = debugDiv;
        try {
          this.addDebug("- add debug window");
          document.body.insertBefore(debugDiv,document.body.firstChild);
        } catch(err) {
          this.addDebug("- delayed adding debug window (not ready)");
          var obj = this;

          setTimeout(function() {obj.createDebug(); }, this.frameInitTimestep);
        }
      }
    },
  
    debugChildInit: function() {
      var data = {
        idstr : arguments.callee.idstr,
        mode  : "debugInit"
      };
      var list = document.getElementsByTagName('iframe');
      for(var i=0;i<list.length;i++) {
        var iframe=list[i];

        iframe.contentWindow.postMessage(data, "*");
      }
    },

    messageListener: function(event) {
      if (typeof event.data === "object") {
        var data = event.data;
        if (data.idstr == arguments.callee.debug.idstr) {
          if (data.mode == "debug") {
            if (data.text !== undefined && data.text !== null) {
              arguments.callee.debug.addDebug("[child] "+data.text);
            }
          }
        }
      }
    },

    startDebug: function() {
    }
  });
});

  /**
 * Loads Google's Explorer Canvas library, when there is no native support for
 * the <canvas/> tag.
 */
$identify("org/mathdox/formulaeditor/Canvas.js");

var G_vmlCanvasManager;
if (!window.CanvasRenderingContext2D) {

  $require(
    "com/google/code/excanvas/excanvas.js",
    function() { return window.CanvasRenderingContext2D });

  $main(function(){

    /**
     * Workaround for bug in Google's Explorer Canvas. The standard fixElement
     * method will remove all siblings following the canvas tag. In addition to
     * not executing the fixElement of Explorer Canvas, this method wraps any
     * canvas element in a span inside a table, to work around the fact that
     * Internet Explorer doesn't like VML groups (which are used by Explorer
     * Canvas) inside block elements, such as <p>'s. See also:
     * http://keithdevens.com/weblog/archive/2006/Oct/18/invalid-source-html
     */
    G_vmlCanvasManager.fixElement_ = function(element) {

        if (element.tagName.toLowerCase() == "canvas") {

          // create table element
          var table = document.createElement("table");
          table.style.display = "inline";
          table.style.verticalAlign = element.style.verticalAlign;

          // create span element, and insert it into the table
          var span  = document.createElement("span");
          table.insertRow(0).insertCell(0).appendChild(span);

          // replace the canvas element by the table
          element.parentNode.replaceChild(table, element);

          // insert the canvas element into the span
          span.appendChild(element);

        }

        return element;

    };

    /**
     * Because the script tag that references excanvas.js file is dynamically
     * added to the DOM after the document is already loaded, it is necessary
     * to call the initialization code explicitly, instead of letting it wait
     * forever on the 'onreadystatechange' event.
     */
    if (document.readyState && document.readyState == "complete") {
      G_vmlCanvasManager.init_(document);
    }

  });

}
else {

  $main(function(){
    // skip
  });

}

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/Cursor.js");

$main(function(){

  /**
  * Represents the keyboard cursor.
  */
  org.mathdox.formulaeditor.Cursor = $extend(Object, {

    position : null,

    visible : false,

    initialize : function(position) {
      this.position = position;
    },

    /**
     * Handles an onkeydown event from the browser. Returns false when the event
     * has been handled and should not be handled by the browser, returns true
     * otherwise.
     */
    onkeydown : function(event, editor) {

      // only handle keypresses where alt, ctrl and shift are not held
      if (!event.altKey && !event.ctrlKey && !event.shiftKey) {

        // handle arrow keys, home and end
        switch(event.keyCode) {

          case 35: // end
            this.moveLast();
            editor.redraw();
            return false;

          case 36: // home
            this.moveFirst();
            editor.redraw();
            return false;

          case 37: // left arrow
            this.moveLeft();
            editor.redraw();
            return false;

          case 38: // up arrow
            this.moveUp();
            editor.redraw();
            return false;

          case 39: // right arrow
            this.moveRight();
            editor.redraw();
            return false;

          case 40: // down arrow
            this.moveDown();
            editor.redraw();
            return false;
	  
        }

      }

      // pass the event to the presentation tree
      return this.position.row.onkeydown(event, editor);

    },

    /**
     * Handles an onkeypress event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onkeypress : function(event, editor) {

      // pass the event to the presentation tree
      return this.position.row.onkeypress(event, editor);

    },

    /**
     * Handles an onmousedown event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onmousedown : function(event, editor, x, y) {
      var position = editor.presentation.getCursorPosition(x,y);

      if (position) {
	this.position.row.setHighlight(false);
	this.position = position;
      } else {
	editor.presentation.onmousedown(event, editor, x, y);
      }
      if (this.position === null || this.position === undefined) {
	this.position = editor.presentation.getFollowingCursorPosition();
      }

      editor.redraw();
    },

    moveRight : function() {

      var row   = this.position.row;
      var index = this.position.index;
      
      var newPosition = row.getFollowingCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveLeft : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getPrecedingCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveDown : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getLowerCursorPosition(index, this.getX());
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveUp : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getHigherCursorPosition(index, this.getX());
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveFirst : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getFirstCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    moveLast : function() {

      var row   = this.position.row;
      var index = this.position.index;

      var newPosition = row.getLastCursorPosition(index);
      if (newPosition !== null) {
        this.position = newPosition;
      }

      row.setHighlight(false);
    },

    getX : function() {

      // TODO: use this in draw, rename
      var row   = this.position.row;
      var index = this.position.index;

      var dim0 = row.children[index-1] ? row.children[index - 1].dimensions : null;
      var dim1 = row.children[index]   ? row.children[index].dimensions     : null;

      if (dim0 === null && dim1 === null) {
        dim1 = row.dimensions;
      }
      if (dim0 === null && dim1 !== null) {
        dim0 = { left: row.dimensions.left, top: dim1.top, width:0, height: dim1.height };
      }
      if (dim1 === null && dim0 !== null) {
        dim1 = { left: dim0.left + dim0.width, top: dim0.top, width:0, height: dim0.height };
      }

      return Math.round(dim0.left + dim0.width + ((dim1.left - (dim0.left + dim0.width))/2));

    },

    draw : function(canvas, context) {

      if (this.visible) {

        var lineWidth = 2.0;
        var margin    = 2.0;
        var color     = "#66C";

        var row   = this.position.row;
        var index = this.position.index;

        var dim0 = row.children[index-1] ? row.children[index - 1].dimensions : null;
        var dim1 = row.children[index]   ? row.children[index].dimensions     : null;

        if (dim0 === null && dim1 === null) {
          dim1 = row.dimensions;
        }
        if (dim0 === null && dim1 !== null) {
          dim0 = { left: row.dimensions.left, top: dim1.top, width:0, height: dim1.height };
        }
        if (dim1 === null && dim0 !== null) {
          dim1 = { left: dim0.left + dim0.width, top: dim0.top, width:0, height: dim0.height };
        }

        var x      = Math.round(dim0.left + dim0.width + ((dim1.left - (dim0.left + dim0.width))/2));
        var top    = Math.round(Math.min(dim0.top, dim1.top) - margin);
        var bottom = Math.round(Math.max(dim0.top + dim0.height, dim1.top + dim1.height) + margin);

        // ensure that size of the cursor is at least height of the symbol 'f'
        var Symbol = org.mathdox.formulaeditor.presentation.Symbol;
        var fHeight = new Symbol("f").draw(canvas, context, 0, 0, true).height;
        fHeight = fHeight + 2 * margin;
        if (bottom - top < fHeight) {
          var delta = fHeight - (bottom - top);
          top = top - delta/2;
          bottom = bottom + delta/2;
        }

        var canvasContext = canvas.getContext();

        canvasContext.save();
        canvasContext.lineWidth = lineWidth;
        canvasContext.strokeStyle = color;
        canvasContext.beginPath();
        canvasContext.moveTo(x, top);
        canvasContext.lineTo(x, bottom);
        canvasContext.stroke();
        canvasContext.closePath();
        canvasContext.restore();

      }

    }

  });

});

  $package("org.mathdox.formulaeditor"); 

$identify("org/mathdox/formulaeditor/EventHandler.js"); 

$main(function(){ 
  org.mathdox.formulaeditor.EventHandler = $extend(Object, {
    initialize : function() { 

      // save the 'this' pointer so that it can be used in the event handlers 
      var handler = this;

      // register the onkeydown handler, if present
      if (this.onkeydown instanceof Function) {

        var saved1 = window.onkeydown;
        document.onkeydown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onkeydown(event) && saved1 && saved1(event);

        };

      }

      // register the onkeypress handler, if present
      if (this.onkeypress instanceof Function) {

        var saved2 = window.onkeypress;
        document.onkeypress = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          if (!("charCode" in event)) {
            event.charCode = event.keyCode; // MSIE doesn't set charCode
          }

          return handler.onkeypress(event) && saved2 && saved2(event);

        };

      }

      // register the onmousedown handler, if present
      if (this.onmousedown instanceof Function) {

        var saved3 = window.onclick;
        var saved3a = window.ontouchstart;
        document.onmousedown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(event) && saved3 && saved3(event);

        };

        document.ontouchstart = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(handler.rewriteTouchEvent(event)) && saved3a && saved3a(event);

        }

      }

      // register the onmouseup handler, if present
      if (this.onmouseup instanceof Function) {

        var saved4 = window.onclick;
        var saved4a = window.ontouchend;
        document.onmouseup = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseup(event) && saved4 && saved4(event);

        };

        document.ontouchend = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }
        
          return handler.onmouseup(handler.rewriteTouchEvent(event)) && saved5a && saved4a(event);
	}
      }

    },

    // see also http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/
    rewriteTouchEvent: function(event) {
      var touches = event.changedTouches;
      var first = touches[0];
      var type = "";

      switch(event.type)
      {
        case "touchstart": 
          type = "mousedown"; 
          break;
        case "touchmove":  
          type="mousemove"; 
          break;        
        case "touchend":
          type="mouseup"; 
          break;
        default: return;
      }
      
      // initMouseEvent(type, canBubble, cancelable, view, clickCount, 
      //           screenX, screenY, clientX, clientY, ctrlKey, 
      //           altKey, shiftKey, metaKey, button, relatedTarget);
    
      var simulatedEvent = document.createEvent("MouseEvent");
      simulatedEvent.initMouseEvent(type, true, true, window, 1, 
        first.screenX, first.screenY, 
        first.clientX, first.clientY, false, 
        false, false, false, 0/*left*/, null);
      simulatedEvent.mathdoxnoadjust = true;

      return simulatedEvent;
    }

  });

});
 
  $package("org.mathdox.formulaeditor"); 

$identify("org/mathdox/formulaeditor/EventHandlerLocal.js"); 

$main(function(){ 
  org.mathdox.formulaeditor.EventHandlerLocal = $extend(Object, {
    initialize : function(element) { 

      // save the 'this' pointer so that it can be used in the event handlers 
      var handler = this;

      // register the onkeydown handler, if present
      if (this.onkeydown instanceof Function) {

        var saved1 = element.onkeydown;
        element.onkeydown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onkeydown(event) && saved1 && saved1(event);

        };

      }

      // register the onkeypress handler, if present
      if (this.onkeypress instanceof Function) {

        var saved2 = element.onkeypress;
        element.onkeypress = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          if (!("charCode" in event)) {
            event.charCode = event.keyCode; // MSIE doesn't set charCode
          }

          return handler.onkeypress(event) && saved2 && saved2(event);

        };

      }

      // register the onmousedown handler, if present
      if (this.onmousedown instanceof Function) {

        var saved3 = element.onclick;
        var saved3a = element.ontouchstart;
        element.onmousedown = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(event) && saved3 && saved3(event);

        };

        element.ontouchstart = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousedown(handler.rewriteTouchEvent(event)) && saved3a && saved3a(event);

        }

      }

      // register the onmouseup handler, if present
      if (this.onmouseup instanceof Function) {

        var saved4 = element.onclick;
        var saved4a = element.ontouchend;
        element.onmouseup = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseup(event) && saved4 && saved4(event);

        };

        element.ontouchend = function(event) {
          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }
        
          return handler.onmouseup(handler.rewriteTouchEvent(event)) && saved5a && saved4a(event);
	}
      }

      // register the onmousemove handler, if present
      if (this.onmousemove instanceof Function) {

        var saved5 = element.onmousemove;
        element.onmousemove = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmousemove(event) && saved5 && saved5(event);

        };

      }

      // register the onmouseout handler, if present
      if (this.onmouseout instanceof Function) {

        var saved6 = element.onmouseout;
        element.onmouseout = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseout(event) && saved6 && saved6(event);

        };

      }

      // register the onmouseover handler, if present
      if (this.onmouseover instanceof Function) {

        var saved7 = element.onmouseover;
        element.onmouseover = function(event) {

          if (!event) {
            event = window.event; // MSIE's non-standard way of supplying events
          }

          return handler.onmouseover(event) && saved7 && saved7(event);

        };

      }

    },

    // see also http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/
    rewriteTouchEvent: function(event) {
      var touches = event.changedTouches;
      var first = touches[0];
      var type = "";

      switch(event.type)
      {
        case "touchstart": 
          type = "mousedown"; 
          break;
        case "touchmove":  
          type="mousemove"; 
          break;        
        case "touchend":
          type="mouseup"; 
          break;
        default: return;
      }
      
      // initMouseEvent(type, canBubble, cancelable, view, clickCount, 
      //           screenX, screenY, clientX, clientY, ctrlKey, 
      //           altKey, shiftKey, metaKey, button, relatedTarget);
    
      var simulatedEvent = element.createEvent("MouseEvent");
      simulatedEvent.initMouseEvent(type, true, true, window, 1, 
        first.screenX, first.screenY, 
        first.clientX, first.clientY, false, 
        false, false, false, 0/*left*/, null);
      simulatedEvent.mathdoxnoadjust = true;

      return simulatedEvent;
    }

  });

});
 
  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/FormulaEditor.js");

// load make/maker functions
$require("com/oreilly/javascript/tdg/make.js");
// load XMLHttpRequest methods
$require("com/oreilly/javascript/tdg/XMLHttp.js");

var Drag;
$require("net/youngpup/dom-drag/dom-drag.js", function() { return Drag; });

$require("org/mathdox/debug/Debug.js");

$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/mathml/MathMLParser.js");
$require("org/mathdox/formulaeditor/Canvas.js");
$require("org/mathdox/formulaeditor/MathCanvasFill.js");
$require("org/mathdox/formulaeditor/Cursor.js");
$require("org/mathdox/formulaeditor/EventHandler.js");
$require("org/mathdox/formulaeditor/Services.js");

$require("org/mathdox/formulaeditor/version.js");

$require("org/mathdox/formulaeditor/Options.js");

$require("org/mathdox/formulaeditor/Palettes.js");

$require("org/mathdox/formulaeditor/modules/keywords.js");
$require("org/mathdox/formulaeditor/modules/variables.js");

$require("org/mathdox/formulaeditor/modules/arithmetic/abs.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/divide.js");
$require("org/mathdox/formulaeditor/modules/arith1/minus.js");
$require("org/mathdox/formulaeditor/modules/arith1/plus.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/power.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/product.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/root.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/sum.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/times.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");

$require("org/mathdox/formulaeditor/modules/calculus1/defint.js");
$require("org/mathdox/formulaeditor/modules/calculus1/diff.js");
$require("org/mathdox/formulaeditor/modules/calculus1/int.js");

$require("org/mathdox/formulaeditor/modules/complex1/complex_cartesian.js");

$require("org/mathdox/formulaeditor/modules/editor1/palette.js");

$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$require("org/mathdox/formulaeditor/modules/integer1/factorial.js");

$require("org/mathdox/formulaeditor/modules/interval1/interval_cc.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_co.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_oc.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_oo.js");

$require("org/mathdox/formulaeditor/modules/linalg/matrix.js");

$require("org/mathdox/formulaeditor/modules/limit1/limit.js");

$require("org/mathdox/formulaeditor/modules/list1/list.js");

$require("org/mathdox/formulaeditor/presentation/Editor.js");
$require("org/mathdox/formulaeditor/presentation/Root.js");

$require("org/mathdox/formulaeditor/modules/logic1/and.js");
$require("org/mathdox/formulaeditor/modules/logic1/equivalent.js");
$require("org/mathdox/formulaeditor/modules/logic1/implies.js");
$require("org/mathdox/formulaeditor/modules/logic1/not.js");
$require("org/mathdox/formulaeditor/modules/logic1/or.js");

$require("org/mathdox/formulaeditor/modules/nums1/rational.js");

$require("org/mathdox/formulaeditor/modules/permutation1/left_compose.js");
$require("org/mathdox/formulaeditor/modules/permutation1/permutation.js");

$require("org/mathdox/formulaeditor/modules/relation1/approx.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/relation1/geq.js");
$require("org/mathdox/formulaeditor/modules/relation1/gt.js");
$require("org/mathdox/formulaeditor/modules/relation1/leq.js");
$require("org/mathdox/formulaeditor/modules/relation1/lt.js");
$require("org/mathdox/formulaeditor/modules/relation1/neq.js");
// for rewriting 1<x<2
$require("org/mathdox/formulaeditor/modules/relation1/IntervalNotation.js");

$require("org/mathdox/formulaeditor/modules/set1/in.js");

$main(function(){

  /**
   * Maintain a list of all formula editors that are initialized.
   */
  var editors = [];

  var palettes;
 
  var debug = null;

  /**
   * Class that represents a formula editor.
   */
  org.mathdox.formulaeditor.FormulaEditor = $extend(Object, {

    /**
     * The textarea that is being replaced.
     */
    textarea : null,

    /**
     * The canvas that will be used for rendering formulae.
     */
    canvas : null,

    /**
     * The current presentation tree.
     */
    presentation : null,

    /**
     * The keyboard cursor.
     */
    cursor : null,

    /**
     * The palette (if any)
     */
    palette : null,

    /**
     * Boolean that indicates whether the palette should be shown
     */
    showPalette : true,

    /**
     * Indicates whether this formula editor has the focus.
     */
    hasFocus : false,

    addPalette : function() {
      //canvas.parentNode.insertBefore(palette, canvas);
      var palcanvas = document.createElement("canvas");

      if (! org.mathdox.formulaeditor.options.ignoreTextareaStyle) {
        // copy style attributes from the textarea to the canvas
        for (x in this.textarea.style) {
          try {
            palcanvas.style[x] = this.textarea.style[x];
          }
          catch(exception) {
            // skip
          }
        }
      }

      // fix for opera
      if ( G_vmlCanvasManager === undefined) {
        if (palcanvas.style.getPropertyValue("height") != "") {
          try {
            palcanvas.style.removeProperty("height");
          } catch(exception) {
            // skip
          }
        }
      }

      // set the style attributes that determine the look of the palette
      if (org.mathdox.formulaeditor.options.paletteStyle) {
        // use paletteStyle option if available
        palcanvas.setAttribute("style",
                org.mathdox.formulaeditor.options.paletteStyle);
      } else {
        // no paletteStyle option available -> set default style
        palcanvas.style.border          = "2px solid #99F";
        palcanvas.style.verticalAlign   = "middle";
        palcanvas.style.cursor          = "pointer";
        palcanvas.style.padding         = "0px";
        palcanvas.style.backgroundColor = "white";
      }

      // clear possible display none
      palcanvas.style.display = "";
      // set a classname so the user can extend the style
      palcanvas.className           = "formulaeditorpalette";

      if (!palettes) {
        palettes = [];
      }
      this.palette = new org.mathdox.formulaeditor.Palette();
      palettes.push(this.palette);

      // special case: draggable canvas TODO
      if (org.mathdox.formulaeditor.options.dragPalette !== undefined &&
          org.mathdox.formulaeditor.options.dragPalette === true) {
        // create root 
        var root = document.createElement("div");
        root.style.left = "150px";
        root.style.top = "0px";
        root.style.position = "relative";

        var subdiv = document.createElement("div");

        // float is a keyword, to change the css float style, use cssFloat
        subdiv.style.cssFloat="right";

        // create handle
        var handle = document.createElement("div");

        handle.style.width = "200px";
        handle.style.marginLeft = "50px";
        handle.style.height = "10px";
        handle.style.cursor = "move";

        subdiv.appendChild(handle);
        subdiv.appendChild(palcanvas);
        root.appendChild(subdiv);

        // add root, handle and palette to the document
        if (this.textarea.parentNode.tagName.toLowerCase() == "p") {
          // NOTE: should not be added inside a para
          var para = this.textarea.parentNode;
          var paraparent = this.textarea.parentNode.parentNode;
          // code to insert after the paragraph
          if (G_vmlCanvasManager) {
            paraparent.replaceChild(root, this.canvas.canvas);
            paraparent.insertBefore(this.canvas.canvas, root);
          } else {
            paraparent.replaceChild(root, para);
            paraparent.insertBefore(para, root);
          }
          // to insert before the paragraph use
          //paraparent.insertBefore(root, para);
        } else {
          this.textarea.parentNode.insertBefore(root, this.textarea);
        }

        // initialize dragging script
        Drag.init(handle, root);

        var borderTopColor = "";
        
        // getting computed style: see also page 380 of J:TDG 5th edition
        if (palcanvas.currentStyle) { // Try simple IE API first
          borderTopColor = palcanvas.currentStyle.borderTopColor;
        } else if (window.getComputedStyle) {  // Otherwise use W3C API
          borderTopColor = 
            window.getComputedStyle(palcanvas, null).borderTopColor;
        }

        if (borderTopColor !== "") {
          handle.style.backgroundColor = borderTopColor;
        } else {
          handle.style.backgroundColor = "red";
        }

          this.palette.htmlelement = root;
      } else {
        // insert palcanvas in the document before the textarea 
        // in case of G_vmlCanvasManager, check if the parent is a p
        // if it is then put the canvas after the paragraph
        if (G_vmlCanvasManager && this.textarea.parentNode.tagName.toLowerCase() == "p") {
          // NOTE: should not be added inside a para
          var para = this.textarea.parentNode;
          var paraparent = this.textarea.parentNode.parentNode;
          // code to insert after the paragraph
          paraparent.replaceChild(palcanvas, para);
          paraparent.insertBefore(para, palcanvas);
          // to insert before the paragraph use
          //paraparent.insertBefore(root, para);
        } else {
          this.textarea.parentNode.insertBefore(palcanvas, this.textarea);
        }
      }
      if (G_vmlCanvasManager) {
        /* reinitialize canvas */
        palcanvas = G_vmlCanvasManager.initElement(palcanvas);
      }

      // Initialize the canvas. This is only needed in Internet Explorer,
      // where Google's Explorer Canvas library handles canvases.
      // NOTE: this should be done after putting the canvas in the DOM tree
      
      this.palette.initialize(palcanvas);
    },
    /**
     * checkClass(classNames, className): function to help check if an HTML
     * element contains a certain class.
     */
    checkClass: function(classNames, className) {
      var words = classNames.split(" ");
      var i;

      for (i=0; i<words.length; i++) {
        if (words[i] == className) {
          return true;
        }
      }
      return false;
    },

    togglePalette:function () {
      if (this.palette) {
        // remove existing palette
        org.mathdox.formulaeditor.Palette.removePalette(this.palette);
      } else {
        // add new palette
        this.addPalette();
      }
    },
    /**
     * Hides the specified textarea and replaces it by a canvas that will be
     * used for rendering formulae.
     */
    initialize : function(textarea, canvas) {
      var x;

      if (textarea) {

        var Cursor    = org.mathdox.formulaeditor.Cursor;
        var MathCanvas = org.mathdox.formulaeditor.MathCanvas;

        // ensure that there isn't already an editor for this textarea
        for (var i=0; i<editors.length; i++) {
          if (editors[i].textarea == textarea) {
            return editors[i];
          }
        }

        // check whether a new canvas needs to be added.
        if (!canvas) {

          // create an HTML canvas
          canvas = document.createElement("canvas");

          // copy style attributes from the textarea to the canvas
          if (! org.mathdox.formulaeditor.options.ignoreTextareaStyle) {
            for (x in textarea.style) {
              try {
                canvas.style[x] = textarea.style[x];
              }
              catch(exception) {
                // skip
              }
            }
          }

          // fix for opera
          if ( G_vmlCanvasManager === undefined) {
  	    if (canvas.style.getPropertyValue("height") != "") {
                try {
                  canvas.style.removeProperty("height");
  	      } catch(exception) {
  	        // skip
  	      }
  	    }
  	  }

          canvas.className = "mathdoxformula";

          // set the style attributes that determine the look of the editor
          if (textarea.getAttribute("style") !== null && 
               textarea.getAttribute("style") !== undefined &&
               textarea.getAttribute("style").value !== undefined) {
            // same style as the textarea
            canvas.setAttribute("style", textarea.getAttribute("style"));
          } else if (org.mathdox.formulaeditor.options.inputStyle) {
            // textarea has no style use inputStyle option if available
            canvas.setAttribute("style",
                    org.mathdox.formulaeditor.options.inputStyle);
          } else {
            // textarea has no style and no inputStyle option available
            // set default style
            canvas.style.border        = "1px solid #99F";
            canvas.style.verticalAlign = "middle";
            canvas.style.cursor        = "text";
            canvas.style.padding       = "0px";
          }

          // insert canvas in the document before the textarea 
          // in case of G_vmlCanvasManager, check if the parent is a p
          // if it is then put the canvas after the paragraph
          
          if (G_vmlCanvasManager && textarea.parentNode.tagName.toLowerCase() == "p") {
            // NOTE: should not be added inside a para
            var para = textarea.parentNode;
            var paraparent = textarea.parentNode.parentNode;
            // code to insert after the paragraph
            paraparent.replaceChild(canvas, para);
            paraparent.insertBefore(para, canvas);
            // to insert before the paragraph use
            //paraparent.insertBefore(root, para);
          } else {
            textarea.parentNode.insertBefore(canvas, textarea);
          }

          // Initialize the canvas. This is only needed in Internet Explorer,
          // where Google's Explorer Canvas library handles canvases.
          if (G_vmlCanvasManager) {
            canvas = G_vmlCanvasManager.initElement(canvas);
          }

        }

        // register the textarea 
        this.textarea = textarea;

        // register a new mathcanvas
        this.canvas   = new MathCanvas(canvas);

        // check whether a palette needs to be added
        if (this.checkClass(textarea.className, "mathdoxpalette")) {
          /* specified: show a palette */
          this.showPalette = this.showPalette && true;
        } else if (this.checkClass(textarea.className, "mathdoxnopalette")) {
          /* specified: don't show a palette */
          this.showPalette = this.showPalette && false;
        } else if (org.mathdox.formulaeditor.options.paletteShow == "all") {
          /* when unspecified, always show a palette */
          this.showPalette = this.showPalette && true;
        } else if (org.mathdox.formulaeditor.options.paletteShow == "none") {
          /* when unspecified, never show a palette */
          this.showPalette = this.showPalette && false;
        } else if (org.mathdox.formulaeditor.options.paletteShow == "once") {
          /* only add a palette if no palette is present on the page yet */
          this.showPalette = this.showPalette && (!palettes);
        } else {
          /* default: show only one palette */
          /* only add a palette if no palette is present on the page yet */
          this.showPalette = this.showPalette && (!palettes);
        }

        this.showPalette = this.showPalette &&
          (this.checkClass(textarea.className, "mathdoxpalette") || 
          (!this.checkClass(textarea.className, "mathdoxnopalette") && 
            !palettes)
          );
        if (this.showPalette) { 
          this.addPalette();
        }

        // hide the textarea XXX
        if (!this.checkClass(textarea.className, "mathdoxvisibletextarea")) {
          textarea.style.display = "none";
        }

        this.load();

        // initialize the cursor, and draw the presentation tree
        this.cursor = new Cursor(this.presentation.getFollowingCursorPosition());
        this.draw();

        // register this editor in the list of editors.
        editors.push(this);

      }

    },

    load : function() {

      var Parser    = org.mathdox.formulaeditor.parsing.openmath.OpenMathParser;
      var Editor    = org.mathdox.formulaeditor.presentation.Editor;
      var Row       = org.mathdox.formulaeditor.presentation.Row;

      // read any OpenMath code that may be present in the textarea
      var paletteEnabled;
      try {
        var parsed = new Parser().parse(this.textarea.value);
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(parsed.getPresentation(this.getPresentationContext()), paletteEnabled);
        } else {
          this.presentation = new Row(parsed.getPresentation(this.getPresentationContext()));
          this.presentation.flatten();
        }
      }
      catch(exception) {
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(null, paletteEnabled);
        } else {
          this.presentation = new Row();
        }
      }

    },

    loadMathML: function(xmlString) {
      org.mathdox.formulaeditor.FormulaEditor.addDebug("loading MathML");
      var Parser    = org.mathdox.formulaeditor.parsing.mathml.MathMLParser;
      var Editor    = org.mathdox.formulaeditor.presentation.Editor;
      var Row       = org.mathdox.formulaeditor.presentation.Row;

      // read any OpenMath code that may be present in the textarea
      var paletteEnabled;
      //try {
        var parsed = new Parser().parse(xmlString, this.getPresentationContext());

        org.mathdox.formulaeditor.FormulaEditor.addDebug("parsed: "+parsed);
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(parsed, paletteEnabled);
        } else {
          this.presentation = new Row(parsed);
          this.presentation.flatten();
        }
      //}
/*      catch(exception) {
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(null, paletteEnabled);
        } else {
          this.presentation = new Row();
        }
      }*/
    },

    // TODO : move this to an onchange handler
    save : function() {

      var textarea = this.textarea;
      var openmathInfo = this.getOpenMath(true);

      // update the textarea
      if (org.mathdox.formulaeditor.options.indentXML && 
        org.mathdox.formulaeditor.options.indentXML === true) {
        textarea.value = this.indentXML(openmathInfo.value);
      } else {
        textarea.value = openmathInfo.value;
      }

      return { 
        success: openmathInfo.success,
        errorString: openmathInfo.errorString
      };
    },

    redraw : function() {
      this.canvas.clear();
      this.draw();
    },

    draw : function() {

      // TODO: move this code to a separate presentation node
      //       (equivalent to the DOM Document node)
      var dimensions;
      var drawContext = {};

      if (org.mathdox.formulaeditor.options.useBar) {
        dimensions = this.presentation.draw(this.canvas, drawContext, 0, 0, true);
      } else {
        /* add margin */
        var margin = 4.0;
        var formula_dimensions = this.presentation.draw(this.canvas, drawContext, 0, 0, true);
        dimensions = {
          top:    formula_dimensions.top    - margin,
          left:          formula_dimensions.left   - margin,
          width:  formula_dimensions.width  + 2 * margin,
          height: formula_dimensions.height + 2 * margin
        };
      }
      // XXX
      if (G_vmlCanvasManager) {
        var computedStyle;
        if (this.canvas.canvas.currentStyle !== undefined && this.canvas.canvas.currentStyle!== null) {
          // IE method 
          computedStyle = this.canvas.canvas.currentStyle;
        } else {
          computedStyle = getComputedStyle(this.canvas.canvas, null);
        }
        var dim_extra = { width:0, height:0};

        // adjust size horizontally
        var tmp;
        tmp = [ computedStyle.borderLeftWidth, 
          computedStyle.borderRightWidth, 
          computedStyle.paddingLeft, 
          computedStyle.paddingRight ];

        var i;
        var parsed;
        for (i=0;i<tmp.length;i++) {
          parsed = parseInt(tmp[i]);
          if (isFinite(parsed)) {
            dim_extra.width+=parsed;
          }
        }

        // adjust size vertically
        tmp = [ computedStyle.borderTopWidth, 
          computedStyle.borderBottomWidth, 
          computedStyle.paddingTop, 
          computedStyle.paddingBottom ];

        for (i=0;i<tmp.length;i++) {
          parsed = parseInt(tmp[i]);
          if (isFinite(parsed)) {
            dim_extra.height+=parsed;
          }
        }
        this.canvas.canvas.setAttribute("width", dimensions.width+dim_extra.width);
        this.canvas.canvas.setAttribute("height", dimensions.height+dim_extra.height);
      } else {
        this.canvas.canvas.setAttribute("width", dimensions.width);
        this.canvas.canvas.setAttribute("height", dimensions.height);
      }
      this.presentation.draw(this.canvas, drawContext, - dimensions.left, - dimensions.top);
      this.cursor.draw(this.canvas, drawContext);
    },

    /**
     * Handles an onkeydown event from the browser. Returns false when the event
     * has been handled and should not be handled by the browser, returns true
     * otherwise.
     */
    onkeydown : function(event) {

      // forward the event to the cursor object when we have the focus
      if(this.hasFocus) {
        // handle some events here
        if (event.keyCode == 116) {
          var Cursor    = org.mathdox.formulaeditor.Cursor;

          var saveResult = this.save();
          if (saveResult.success) {
            // formula can be parsed and transformed to OpenMath
            this.load();
            this.cursor = new Cursor(this.presentation.getFollowingCursorPosition());
            this.focus(); // XXX is this necessary ?
            this.redraw();
          } else {
            // formula cannot be parsed and transformed to OpenMath
            alert("The formula could not be interpreted correctly. "+
              "The error message was:\n"+saveResult.errorString);
          }

          return false;
        }
        this.focus(); // TODO: only necessary for crappy blinker implementation
        return this.cursor.onkeydown(event, this);
      }

    }, 
    decreaseSizes : function() {
      var i;
      for (i =0;i<palettes.length;i++) {
        if(palettes[i].canvas) {
          palettes[i].canvas.decreaseSize();
          palettes[i].redraw();
        }
      }
      for (i =0;i<editors.length;i++) {
        if(editors[i].canvas) {
          editors[i].canvas.decreaseSize();
          editors[i].redraw();
        }
      }
      return true;
    },
  
    increaseSizes : function() {
      var i;
      for (i=0;i<editors.length;i++) {
        if(editors[i].canvas) {
          editors[i].canvas.increaseSize();
          editors[i].redraw();
        }
      }
      for (i=0;i<palettes.length;i++) {
        if(palettes[i].canvas) {
          palettes[i].canvas.increaseSize();
          palettes[i].redraw();
        }
      }
      return true;
    },

    /**
     * Handles an onkeypress event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onkeypress : function(event) {

      // forward the event to the cursor object when we have the focus
      if (this.hasFocus) {
        var result = true;
        if (event.ctrlKey) {
          switch(event.charCode) {
            case 43: // '+' larger
              this.increaseSizes();
              result = false;
              break;
            case 45: // '-' smaller
              this.decreaseSizes();
              result = false;
              break;
          }
        }
  
        this.focus(); // TODO: only necessary for crappy blinker implementation
        if (result) {
          result = this.cursor.onkeypress(event, this);
        }

        return result;
      }

    },

    /**
     * Returns info about the mouse event, returning {x, y}, where x and y are
     * the relative positions in the canvas. If the mouseclick was not in the
     * canvas null is returned instead.
     */
    mouseeventinfo : function(event) {  

      // retrieve the screen coordinates of the mouse click
      var mouseX = event.clientX;
      var mouseY = event.clientY;

      // retrieve the page offset, needed to convert screen coordinates to
      // document coordinates
      var pageXOffset = window.pageXOffset;
      var pageYOffset = window.pageYOffset;

      var element;
      // MSIE provides the page offset in a different way *sigh*
      if (pageXOffset === null || pageXOffset === undefined) {
        element = document.documentElement;
        if (!element || !element.scrollLeft) {
          element = document.body;
        }
        pageXOffset = element.scrollLeft;
        pageYOffset = element.scrollTop;
      }

      // calculate the document coordinates of the mouse click
      if (!event.mathdoxnoadjust) {
        mouseX += pageXOffset;
        mouseY += pageYOffset;
      }

      // calculate the document coordinates of the canvas element
      element = this.canvas.canvas;
      var x      = 0;
      var y      = 0;
      var width  = element.offsetWidth;
      var height = element.offsetHeight;

      // check for padding and border
        
      var computedStyle;
      if (element.currentStyle !== undefined && element.currentStyle!== null) {
        // IE method 
        computedStyle = element.currentStyle;
      } else {
        computedStyle = getComputedStyle(element, null);
      }

      var tmpp,tmpb;

      // only add maximum of tmpp, tmpb
      // if only 1 is finite, that is the maximum
      tmpb = parseInt(computedStyle.borderLeftWidth);
      tmpp = parseInt(computedStyle.paddingLeft);

      if ( isFinite(tmpp) && isFinite(tmpb)) {
        if (tmpp>tmpb) {
          x += tmpp;
        } else {
          x += tmpb;
        }
      } else if (isFinite(tmpp)) {
        x += tmpp;
      } else if (isFinite(tmpb)) {
        x += tmpb;
      }

      tmpb = parseInt(computedStyle.borderTopWidth);
      tmpp = parseInt(computedStyle.paddingTop);
      // only add maximum of tmpp, tmpb
      // if only 1 is finite, that is the maximum
      if ( isFinite(tmpp) && isFinite(tmpb)) {
        if (tmpp>tmpb) {
          y += tmpp;
        } else {
          y += tmpb;
        }
      } else if (isFinite(tmpp)) {
        y += tmpp;
      } else if (isFinite(tmpb)) {
        y += tmpb;
      }

      while (element) {
        x += element.offsetLeft;
        y += element.offsetTop;

        element = element.offsetParent;
      }

      // check whether the mouse click falls in the canvas element
      if (x<=mouseX && mouseX<=x+width && y<=mouseY && mouseY<=y+height) {
        // we have focus
        // forward the mouse click to the cursor object
        return { x:mouseX-x, y:mouseY-y };
      }
      else {
        // we do not have focus
        return null;
      }

    },
    /**
     * Handles an onmousedown event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onmousedown : function(event) {
      // check whether the mouse click falls in the canvas element
      var mouseinfo = this.mouseeventinfo(event);


      if (mouseinfo) {
        // we have focus
        this.focus();
        // give focus to the window
        // XXX check if it is the right window
        window.focus();
        // forward the mouse click to the cursor object
        return this.cursor.onmousedown(event, this, mouseinfo.x, mouseinfo.y);
      }
      else {
        // we do not have focus
        this.blur();
        this.redraw();
      }

    },

    // TODO: only necessary for crappy blinker implementation
    blinker : 0,

    focus : function() {

      this.hasFocus = true;
      this.cursor.visible = true;

      // cursor blinking
      // TODO: move to cursor class
      var editor = this;
      var blinker = ++this.blinker;
      var blinkon;
      var blinkoff;
      blinkon = function() {
        if (editor.hasFocus && (blinker == editor.blinker)) {
          editor.cursor.visible = true;
          editor.redraw();
          window.setTimeout(blinkoff, 600);
        }
      };
      blinkoff = function() {
        if (editor.hasFocus && (blinker == editor.blinker)) {
          editor.cursor.visible = false;
          editor.redraw();
          window.setTimeout(blinkon, 400);
        }
      };
      blinkon();

    },

    blur : function() {
      if (this.hasFocus) {
        // on losing focus save changes to ORBEON if ORBEON is around
        if (ORBEON) {
          ORBEON.xforms.Document.setValue(this.textarea.id, 
            this.textarea.value);
        }
	org.mathdox.formulaeditor.FormulaEditor.lastFocused = this;
      }
      this.hasFocus = false;
      this.cursor.visible = false;
    },

    getMathML : function() {
      var mmlstring;
      try {
        mmlstring = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"+
          this.presentation.getSemantics(this.getExpressionParsingContext()).value.getMathML()+
          "</math>";
      }
      catch(exception) {
        mmlstring = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"+
          "<mtext>"+exception.toString()+"</mtext></math>";
      }

      return mmlstring;
    },

    /**
     * getOpenMath()
     *
     * function to get the OpenMath value of the formula in the formulaeditor
     * returns the contents of the formulaeditor as an OpenMath string.
     * 
     * extended with optional argument returnErrorInfo (boolean). If true
     * an array is returned instead with entries: 
     * - value (the OpenMath string);
     * - success (a boolean, true if no error has occurred);
     * - errorString (the exception converted to a string, which might be shown
     *   to the user).
     *
     * Usually an error occurs when there is an error in the entered formula.
     */
    getOpenMath : function(returnErrorInfo) {
      var omstring;
      var errorInfo;
      var success;

      if (returnErrorInfo === null || returnErrorInfo === undefined) {
        returnErrorInfo = false;
      }

      try {
        var semantics = this.presentation.getSemantics(this.getExpressionParsingContext());

        if (semantics === null || semantics.value === null) {
          omstring = "<OME>" +
	      "<OMS cd='moreerrors' name='encodingError'/>" +
                "<OMSTR>invalid expression entered. Presentation was: " +
                  this.presentation +
	        "</OMSTR>" +
	    "</OME>";

          success = false;
          errorString = null;
        } else {
          omstring = semantics.value.getOpenMath();
          success = true;
          errorString = null;
        }
      }
      catch(exception) {
        // IE doesn't provide a useful .toString for errors, use name and
        // message instead
        // old code: errorString = exception.toString();
        errorString = exception.name + " : "+exception.message;
        omstring =
            "<OME>" +
              "<OMS cd='moreerrors' name='encodingError'/>" +
              "<OMSTR>invalid expression entered" +
                errorString + 
	        ". "+
	        " Presentation was: "+
                this.presentation +
	      "</OMSTR>" +
            "</OME>";
        success = false;
      }

      omstring = "<OMOBJ xmlns='http://www.openmath.org/OpenMath' version='2.0' " + 
        "cdbase='http://www.openmath.org/cd'>" + omstring + "</OMOBJ>";
      
      if (returnErrorInfo) {
        /* return information about whether an error did occur */
        return { 
          errorString : errorString,
          success: success,
          value: omstring
        };
      } else {
        return omstring;
      }
    },
    indentXML : function(str) {
      var buffer=[];     // buffer to prevent slow string concatenation
      var oldpos;        // old position in string (written up till here)
      var pos;                 // current position in string
      var l;                 // length
      var indent=0;         // current indenting
      var indentstr="  ";// indenting done for each step
      var child;         // true if a child tag exists inside this one
                               // set to true if a tag is closed
                         // set to false if a tag is opened

      // help function that does the indenting
      var doIndent = function() {
        var i;

        if (buffer.length>0) {
          buffer.push("\n");
        }
        for (i=indent;i>0;i--) {
          buffer.push(indentstr);
        }
      };

      l=str.length; // store the length in l;

      oldpos=0; // written up to 0

      while ((pos = str.indexOf('<',oldpos))>=0) {
        if (pos>oldpos) {
          /* 
            indenting is not desired for text inside tags, unless after a child
          */
          if (child === true) {
            doIndent();
          }
          buffer.push(str.substr(oldpos,pos-oldpos));
          oldpos=pos;
        }

        pos++;
        c = str.charAt(pos);
        switch(c) {
          case '/': // closing tag
            indent -= 1;
            if (indent<0) {
              // shouldn't happen
              indent=0;
            }
            /*
             * don't indent if the tag only contains text (so no other tags, no
             * comments and no CDATA)
             */
            if (child === true) {
              doIndent();
            }
            pos = str.indexOf('>',pos);
            if (pos<0) {
              //alert("couldn't find closing >");
              return buffer.join("")+str.substr(oldpos);
            }
            pos+=1;
            child = true;
            break;
          case '!': // comment or CDATA
            pos++;
            c = str.charAt(pos);
            switch(c) {
              case '[' : // CDATA 
                child = true;
                pos = str.indexOf(']]>',pos);
                if (pos<0) {
                  //alert("couldn't find closing ]]>");
                  return buffer.join("")+str.substr(oldpos);
                }
                pos+=3;

                doIndent();

                break;
              case '-' : // XML Comment
                child = true;
                pos = str.indexOf('-->',pos);
                if (pos<0) {
                  //alert("couldn't find closing -->");
                  return buffer.join("")+str.substr(oldpos);
                }
                pos+=3;

                doIndent();

                break;
              default: // failure to parse the string
                //alert("couldn't parse");
                return buffer.join("")+str.substr(oldpos);
            }
            break;

          default: // opening tag or directly closed tag
            pos = str.indexOf('>',pos);
            if (pos<0) {
              //alert("couldn't find >, was expecting one though");
              return buffer.join("")+str.substr(oldpos);
            }

            doIndent();
            
            // in case of an opening tag, increase indenting
            if (str.charAt(pos-1) !='/') {
              child = false;
              indent += 1;
            } else {
              child = true;
            }
            pos+=1;
            break;
        }
        buffer.push(str.substr(oldpos,pos-oldpos));
        oldpos = pos;
        
      }
      if (oldpos<str.length) {
        buffer.push(str.substr(oldpos));
      }
      
      return buffer.join("");
    },
    /**
     * get the context for the expression parser
     * in the future this might be dependant on the editor
     * for now it is just an additional layer
     */
    getExpressionParsingContext: function() {
      return org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.getContext();
    },
    /**
     * get the context for the expression parser
     * in the future this might be dependant on the editor
     * for now it is just an additional layer
     */
    getPresentationContext: function() {
      Options = new org.mathdox.formulaeditor.Options();

      return Options.getPresentationContext();
    }
  });

  /**
   * Write debug info if debug option is on
   */
  org.mathdox.formulaeditor.FormulaEditor.addDebug= function(str) {
    if (debug !== undefined && debug!== null) {
      debug.addDebug(str);
    }
    return debug;
  },

  /**
   * Perform several cleanup operations
   * 
   * - Check all Formula Editor objects in editors
   *   + check if the textarea and canvas still exist (and are visible)
   *   + if the canvas doesn't exist anymore; remove the Formula Editor (and
   *     textarea)
   *   + if the textarea doesn't exist anymore, it should be reconstructed (?)
   * - Check all *mathdoxformula* canvases and remove those without Editor
   * - Check all *mathdoxformula* textareas and remove those without Editor
   * - Make sure for all editors that the textarea is placed directly after the
   *   canvas.
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanup = function() {
    this.cleanupEditors();
    this.cleanupCanvases();
    this.cleanupTextareas();
    this.cleanupGroup();
  };

  /**
   * Perform some cleanup operations
   * 
   * - Check all *mathdoxformula* canvases and remove those without Editor
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupCanvases = function() {
    var canvases = document.getElementsByTagName("canvas");

    for (i=0; i<canvases.length; i++) {
      var canvas = canvases[i];

      // retrieve the class attribute of the textarea
      classattribute = canvas.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = canvas.getAttribute("className");
      }

      // check whether this canvas is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {
        if (!this.getEditorByCanvas(canvas)) {
          /* delete canvas */
          canvas.parentNode.removeChild(canvas);
        }
      }
    }
  };

  /**
   * Perform some cleanup operations
   * 
   * - Check all Formula Editor objects in editors
   *   + check if the textarea and canvas still exist (and are visible)
   *   + if the canvas doesn't exist anymore; remove the Formula Editor (and
   *     textarea)
   *   + if the textarea doesn't exist anymore, remove the Formula Editor (and
   *     canvas) 
   *     in the future : maybe reconstructed it ?
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupEditors = function() {
    /* check all editors and remove those that cannot be repaired */
    for (var i=editors.length; i>0; i--) {
      var nodeCanvas = editors[i-1].canvas.canvas;
      var nodeTextarea = editors[i-1].textarea;

      // check editor for canvas and textarea
      if (!nodeCanvas || !nodeTextarea) {
        if (nodeCanvas &&nodeCanvas.parentNode) {
          nodeCanvas.parentNode.removeChild(nodeCanvas);
        }

        if (nodeTextarea && nodeTextarea.parentNode) {
          nodeTextarea.parentNode.removeChild(nodeTextarea);
        }

        delete editors[i-1];
        editors.splice(i-1, 1);
        // editor removed
      }
    }
  };

  /**
   * Perform some cleanup operations
   * 
   * - Make sure for all editors that the textarea is placed directly after the
   *   canvas.
   * 
   * returns true if all editors have a textarea and canvas and false otherwise
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupGroup = function() {
    // check again all editors and place textareas directly after the canvas
    var i;
    var structureCorrect = true;

    for (i=0;i<editors.length;i++) {
      var nodeCanvas = editors[i].canvas.canvas;
      var nodeTextarea = editors[i].textarea;

      // check if editor has a canvas and textarea
      if (nodeCanvas && nodeCanvas.parentNode && nodeTextarea && nodeTextarea.parentNode) {
        if (nodeCanvas.nextSibling && (nodeCanvas.nextSibling==nodeTextarea)) {
          // text area was positioned correctly
        } else {
          // text area is not positioned correctly: fix it
          // create a clone of the textarea 
          var tmpTextarea = nodeTextarea.cloneNode(true);

          // put the clone directly after the canvas
          if (nodeCanvas.nextSibling) {
            nodeCanvas.parentNode.insertBefore(tmpTextarea, nodeCanvas.nextSibling);
          } else {
            nodeCanvas.parentNode.appendChild(tmpTextarea);
          }

          // update the textarea in the editor 
          editors[i].textarea = tmpTextarea;

          // remove original textarea
          textarea.parentNode.removeChild(textarea);
        }
      } else {
        // no canvas or no textarea found
        structureCorrect = false;
      }
    }

    return structureCorrect;
  };

  /**
   * Perform some cleanup operations
   * 
   * - Check all *mathdoxformula* textareas and remove those without Editor
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupTextareas = function() {
    var textareas = document.getElementsByTagName("textarea");

    for (i=0; i<textareas.length; i++) {
      var textarea = textareas[i];

      // retrieve the class attribute of the textarea
      classattribute = textarea.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = textarea.getAttribute("className");
      }

      // check whether this textarea is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {
        var textareaObject = this.getEditorByTextArea(textarea);
        if (!textareaObject) {
          /* delete textarea */
          textarea.parentNode.removeChild(textarea);
        } else {
          // dirty... but works (forces page to render in some cases)
          // workaround for some bug
          // TODO : is this still necessary
          textarea.innerHTML = textareaObject.textarea.value;
        }
      }
    }  
  };

  /**
   * Add the static deleteEditor(editor) method, that deletes a formula editor
   * object. This can be useful when cleaning, for example after changes in the
   * HTML, like when a textarea has been removed.
   * 
   * editor - an index in the editors array or a FormulaEditor object
   *
   * It returns true if the editor was found and of the right type and false
   * otherwise.
   */
  org.mathdox.formulaeditor.FormulaEditor.deleteEditor = function(editor) {
    var i;

    if (typeof editor == "number") {
      /* editor is an index; check if it is valid */
      i=editor;
      if (i<0 || i>=editors.length) {
        /* wrong index */
        return false;
      }
    } else if (editor instanceof org.mathdox.formuleditor.FormulaEditor) {
      /* editor is a FormulaEditor object; look it up editor in editors array */
      i=0;
      while (i<editors.length && editors[i]!=editor) {
        i++;
      }

      /* if the editor is not found, return false */
      if (i==editors.length) {
        return false;
      }
    } else {
      /* not a number, and not a Formula Editor */
      return false;
    }

    var nodeCanvas = editors[i].canvas.canvas;
    var nodeTextarea = editors[i].textarea;
  
    // remove canvas (if exists)
    if (nodeCanvas &&nodeCanvas.parentNode) {
      nodeCanvas.parentNode.removeChild(nodeCanvas);
    }
    // remove textarea (if exists)
    if (nodeTextarea && nodeTextarea.parentNode) {
      nodeTextarea.parentNode.removeChild(nodeTextarea);
    }

    // remove editor object
    delete editors[i];
    editors.splice(i,1);

    return true;
  };

  /**
   * Add the static getEditorByCanvas(canvas) method, that returns the
   * formula editor corresponding to a certain canvas. 
   * 
   * canvas - a string or an HTMLElement
   *
   * NOTE: might not work in IE if canvas is not an HTMLElement (check)
   *
   * It returns null when none of the editors in the page corresponds to the 
   * canvas given as argument.
   */
  org.mathdox.formulaeditor.FormulaEditor.getEditorByCanvas = function(canvas) {
    var i;

    if (canvas === undefined || canvas === null) {
      /* no argument given, return null */
      return null;
    }
    /* if canvas is a string, it is an id */
    /* NOTE: testing with instanceof String does *not* work */
    if (typeof canvas == "string") {
      for (i=0; i<editors.length; i++) {
        if (canvas == editors[i].canvas.id) {
          return editors[i];
        }
      }
    /**
     * if textarea is an object in the HTML DOM tree, it is the textarea itself
     */
    } else if (canvas instanceof HTMLElement) {
      for (i=0; i<editors.length; i++) {
        if (editors[i].canvas.canvas == canvas) {
          return editors[i];
        }
      }
    }
    /* no editor found */
    return null;
  };

  /**
   * Add the static getEditorByTextArea(textarea) method, that returns the
   * formula editor corresponding to a certain textarea. 
   * 
   * textarea - a string or an HTMLTextAreaElement
   *
   * It returns null when none of the editors in the page corresponds to the 
   * textarea given as argument.
   */
  org.mathdox.formulaeditor.FormulaEditor.getEditorByTextArea = function(textarea) {
    var i;

    if (textarea === undefined || textarea === null) {
      /* no argument given, return null */
      return null;
    }
    /* if textarea is a string, it is an id */
    /* NOTE: testing with instanceof String does *not* work */
    if (typeof textarea == "string") {
      for (i=0; i<editors.length; i++) {
        if (textarea == editors[i].textarea.id) {
          return editors[i];
        }
      }
    /**
     * if textarea is an object in the HTML DOM tree, it is the textarea itself
     */
    } else if (textarea instanceof HTMLElement) {
      for (i=0; i<editors.length; i++) {
        if (editors[i].textarea == textarea) {
          return editors[i];
        }
      }
    }
    /* no editor found */
    return null;
  };

  /**
   * Add the static getFocusedEditor() method, that returns the formula editor
   * that currently has focus. Returns null when none of the editors in the page
   * have focus.
   */
  org.mathdox.formulaeditor.FormulaEditor.getFocusedEditor = function() {

    for (var i=0; i<editors.length; i++) {
      if (editors[i].hasFocus) {
        return editors[i];
      }
    }
    return null;

  };
  
  org.mathdox.formulaeditor.FormulaEditor.lastFocused = null;

  /**
   * Add the static getLastFocusedEditor() method, that returns the formula
   * editor that last had focus. Returns null when none of the editors in
   * the page have had focus.
   */
  org.mathdox.formulaeditor.FormulaEditor.getLastFocusedEditor = function() {
    var current = org.mathdox.formulaeditor.FormulaEditor.getFocusedEditor();

    if (current !== null) {
      return current;
    }
    
    return org.mathdox.formulaeditor.FormulaEditor.lastFocused;
  };
 
  /**
   * Update the editor list, based on the current tree, focusing on which
   * textareas are present.
   *
   * In effect, create a new editor for each *relevant* textarea that has no 
   * corresponding editor. Here relevant means having the class
   * mathdoxformulaeditor.
   * 
   * clean: boolean, if true also do the following:
   *   - remove all editors for which no textarea is present
   *   - remove all *relevant* canvases for which no editor is present
   *     (here relevant means having the class ???)
   */
  org.mathdox.formulaeditor.FormulaEditor.updateByTextAreas = function(clean) {
    /* let textareas be all the textareas in the document */

    var textareas = document.getElementsByTagName("textarea");

    var classattribute;

    /* do cleaning : TODO */
    var i,j;
    if (clean) {
      /* remove all editors for which no textarea is present */

      i=0;
      while (i<editors.length) {
        /* get the index of j, or textareas.length if not found */
        j=0;
        while (j<textareas.length && editors[i].textarea != textareas[j]) {
          j++;
        }
        
        if (j==textareas.length) {
          /* textarea not found, delete the editor */
          this.deleteEditor(i);
        } else {
          i=i+1;
        }
      }

      /* 
        remove all *relevant* canvases for which no editor is present 
        Here relevant means of the class: mathdoxformula
      */
      this.cleanupCanvases();
    }

    /* 
     * add new editors where needed: 
     * for each textarea:
     * - check if the class contains mathdoxformula
     * - check if no editor corresponds to it
     * - create a new editor and add it to the list of editors
     */

    for (i=0; i<textareas.length; i++) {
      var textarea = textareas[i];

      // retrieve the class attribute of the textarea
      classattribute = textarea.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = textarea.getAttribute("className");
      }

      // check whether this textarea is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {
        // create and initialize new editor
        // new should not be used as a statement: use a dummy variable
        var editor = new org.mathdox.formulaeditor.FormulaEditor(textarea);
      }
    }
  };


  /**
   * Class that represents a formula editor palette.
   */
  org.mathdox.formulaeditor.Palette = $extend(
    org.mathdox.formulaeditor.FormulaEditor, {

    // do nothing with a keydown
    onkeydown : function(event) {
      return true; 
    },
    // check for keypress (currently: zoom)
    onkeypress : function(event) {
      var result = true;

      if (event.ctrlKey) {
        switch(event.charCode) {
          case 43: // '+' larger
            this.increaseSizes();
            result = false;
            break;
          case 45: // '-' smaller
            this.decreaseSizes();
            result = false;
            break;
        }
      }

      return result; 
    },
    // handle a mouseclick
    onmousedown: function(event) {
      // check whether the mouse click falls in the canvas element
      var mouseinfo = this.mouseeventinfo(event);
      var noEditorNeeded;

      if (mouseinfo) {
        // we are clicked on
        var editor = org.mathdox.formulaeditor.FormulaEditor.getFocusedEditor();

        noEditorNeeded = 
          this.handleMouseClick(editor, mouseinfo.x, mouseinfo.y);

        if ((noEditorNeeded === false) && (editor === null)) {
          alert("No formulaeditor with focus. Please click on an editor\n"+
                "at the position where the symbol should be entered.");
        }

        return false;
      }
      else {
        // we are not clicked on 
        return true;
      }
    },
    // fake function, do not draw the cursor
    cursor : {
      draw: function() {
        return true;
      }
    },
    /**
     * containing HTMLElement if not the canvas
     * item that should be removed if this palette should be removed
     */
    htmlelement : null,
    // todo onmousedown : function(event) { }
    initialize : function(canvas) {
      if (!canvas) {
        /* first initalization, do nothing yet */
        return null;
      }
     
      var MathCanvas = org.mathdox.formulaeditor.MathCanvas;

      if (arguments.length > 0 ) { 
        this.canvas = new MathCanvas(canvas);
      }

      var highlight = true;
      if (org.mathdox.formulaeditor.options.paletteHighlight == false) {
        highlight = false;
      }

      if (highlight) {
        var palette = this;
        var redrawFunction = function() {
          palette.redraw();
        };
        var HandlerLocal = $extend(org.mathdox.formulaeditor.EventHandlerLocal, {
          // handler for onmousemove
          onmousemove: function(event) {
            var mouseinfo = palette.mouseeventinfo(event);
  
	    if (mouseinfo) {
              var pTabContainer = palette.presentation.children[0];
  
              /* mouse over update function */
              pTabContainer.handleMouseMove(mouseinfo.x,mouseinfo.y,redrawFunction);
 
	    }
            return true;
          },
          onmouseout: function(event) {
            var pTabContainer = palette.presentation.children[0];
  
            /* mouse out update function */
            pTabContainer.handleMouseMove(null,null,redrawFunction);

            return true;
          }
        });

        var handlerLocal = new HandlerLocal(canvas);
      }
 
      // default presentation: empty
      this.presentation = new org.mathdox.formulaeditor.presentation.Row();

      var url;
      if (org.mathdox.formulaeditor.options.paletteURL) {
        url = org.mathdox.formulaeditor.options.paletteURL;
      } else {
        org.mathdox.formulaeditor.Palette.description = 
          org.mathdox.formulaeditor.Palettes.defaultPalette;
        
        this.parseXMLPalette(org.mathdox.formulaeditor.Palette.description);
        this.draw();

        return;
      }

      if (!org.mathdox.formulaeditor.Palette.description) {
        org.mathdox.formulaeditor.Palette.description = "loading";
        var HTTP = com.oreilly.javascript.tdg.XMLHttp;

        var callback = function(responseText) {

          org.mathdox.formulaeditor.Palette.description = responseText;
            
          /* update palettes */
          for (var p=0; p<palettes.length; p++) {
            palettes[p].parseXMLPalette(org.mathdox.formulaeditor.Palette.description);
            palettes[p].draw();
          }
        };

        HTTP.getText(url, callback);
      } else if (org.mathdox.formulaeditor.Palette.description != "loading") {
        // set presentation and semantics
        this.parseXMLPalette(org.mathdox.formulaeditor.Palette.description);
        this.draw();
      }
    },
    handleMouseClick: function(editor,x,y) {
      var pTabContainer = this.presentation.children[0];
      /* wrapper function to be able to redraw after a tab switch */
      var palette = this;
      var redrawFunction = function() {
              palette.redraw();
      };
      var coords = pTabContainer.handleMouseClick(x,y,redrawFunction);

      if (editor === null) {
        if (coords === null) {
        /* nothing to enter, so no editor needed */
          return true; 
        } else {
          return false;
        }
      }

      var position = editor.cursor.position;

      if (coords === null) {
        return false;
      }
      var row = this.semantics.operands[coords.tab].operands[coords.row].operands[coords.col];

      var presentation = org.mathdox.formulaeditor.presentation;
      var rowPresentation = new presentation.Row(row.getPresentation(this.getPresentationContext()));
      rowPresentation.flatten();

      var moveright;
      if (rowPresentation.children) {
        for (var i=0;i<rowPresentation.children.length;i++) {
          //alert("inserting: "+i+" : "+toInsert.children[i]);

          moveright = position.row.insert(position.index, 
            rowPresentation.children[i], (i === 0));
          if (moveright) {
            position.index++;
          }
        }
      } else {
        moveright = position.row.insert(
          position.index, rowPresentation, true);

        if (moveright) {
          position.index++;
        }
      }
      editor.redraw();
      editor.save();
      return false;
    },
    parseXMLPalette : function(XMLstr) {
      var presentation;
      var Parser    = org.mathdox.formulaeditor.parsing.openmath.OpenMathParser;
      var Row       = org.mathdox.formulaeditor.presentation.Row;

      // read any OpenMath code that may be present in the textarea
      //try {
        this.semantics = new Parser().parse(XMLstr);
        presentation = new Row(this.semantics.getPresentation(this.getPresentationContext()));
        presentation.flatten();
        this.presentation = presentation;
        this.presentation.margin = 10.0;
      //}
      //catch(exception) {
      //  presentation = new Row();
      //}

      return presentation;
    }
  });

  /**
   * Remove this palette from the document
   * does three things:
   * - removes this palette from palettes
   * - removes it from the corresponding editor
   * - removes the canvas from the document
   */
  org.mathdox.formulaeditor.Palette.removePalette = function (palette) {
    /* palette should be defined */
    if (palette === null || palette === undefined) {
      return ;
    }

    var i;
    for (i=0; i<palettes.length; i++) {
      if (palettes[i] == palette) {
        // remove palette from the palettes array
        palettes.splice(i,1);
      }
    }
    // remove palette's canvas from the corresponding editor
    for (i=0; i<editors.length; i++) {
      if (editors[i].palette == palette) {
        editors[i].palette = null;
      }
    }

    // remove this palette's canvas from the page
    var palhtml;

    if (palette.htmlelement!== null && palette.htmlelement !== undefined) {
      palhtml = palette.htmlelement;
    } else {
      palhtml = palette.canvas.canvas;
    }

    palhtml.parentNode.removeChild(palhtml);
  };

  /**
   * When the document has finished loading, replace all textarea elements of
   * class 'mathdoxformula' with a formula editor.
   */

  // function that will be called upon loading
  var onload = function() {
    var options = new org.mathdox.formulaeditor.Options();
    if (options.getOption("debug") === true) {
      debug = new org.mathdox.debug.Debug();
      debug.createDebug();
    }


    // replace all textarea's of class 'mathdoxformula' with editors
    var textareas = document.getElementsByTagName("textarea");
    for (var i=0; i<textareas.length; i++) {
      var textarea = textareas[i];

      // retrieve the class attribute of the textarea
      var classattribute = textarea.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = textarea.getAttribute("className");
      }

      // check whether this textarea is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {

        // replace the textarea by a formula editor
        var editor = new org.mathdox.formulaeditor.FormulaEditor(textarea);

      }

    }

    // register key and mouse handlers that forward events to the editors
    var Handler = $extend(org.mathdox.formulaeditor.EventHandler, {

      onkeydown : function(event) {
        var result = true;
        for (var i=0; i<editors.length; i++) {
          var intermediate = editors[i].onkeydown(event);
          if (intermediate !== null && intermediate !== undefined &&
              intermediate === false) {
            result = false;
          }
        }
        return result;
      },

      onkeypress : function(event) {
        var result = true;

        for (var i=0; i<editors.length; i++) {
          var intermediate = editors[i].onkeypress(event);
          if (intermediate !== null && intermediate !== undefined && 
              intermediate === false) {
            result = false;
          }
        }
        return result;
      },

      onmousedown : function(event) {
        var result = true;
        var i; // counter
        if (palettes) {
          for (i=0;i<palettes.length;i++) {
            if (result) {
              result = result && palettes[i].onmousedown(event);
            }
          }
        }
        if (result) {
          // if not handled by palettes, then continue
          for (i=0; i<editors.length; i++) {
            var intermediate = editors[i].onmousedown(event);
            if (intermediate !== null && intermediate !== undefined &&
                intermediate === false) {
              result = false;
            }
          }
          return result;
        }
      }
    });
    var handler = new Handler();
    var Options = new org.mathdox.formulaeditor.Options();

    /* check for onload focus */
    var focus = Options.getOption("onloadFocus");
    if (typeof focus == "string") {
      var onloadTextArea = document.getElementById(focus);
      if (onloadTextArea) {
        var onloadEditor = org.mathdox.formulaeditor.FormulaEditor.getEditorByTextArea( onloadTextArea );
        if (onloadEditor) {
          onloadEditor.focus();
        }
      } 
    } else if (focus == true) {
      editors[0].focus();
    } 
  };

  // register the onload function as an event handler
  if (window.addEventListener) {

    // use the W3C standard way of registering event handlers
    // NOTE: Google Chrome indicates it's already finished loading, so no
    // eventlistener needs to be added.
    if (org.mathdox.formulaeditor.hasLoaded || 
      (document.readyState && document.readyState == "complete")) {
      onload();
    } else {
      window.addEventListener("load", onload, false);
    }
  } else {

    // document.body might not exist yet, if it doesn't call the check function
    // with a 50 ms delay (fixes a bug)
    
    var bodyChecker;

    bodyChecker = function() {
      if (!document.body) {
        setTimeout(bodyChecker,50);
      } else {
        if (document.body.attachEvent) {
          // use the MSIE-only way of registering event handlers
          if (document.readyState == "complete") {
            onload();
          } else {
            document.body.attachEvent("onload", onload);
          }
        } 
      }
    };
    bodyChecker();
  }

});

org.mathdox.formulaeditor.hasLoaded = false;

if (window.addEventListener) {
  var setLoaded = function() {
    org.mathdox.formulaeditor.hasLoaded = true;
  };

  // use the W3C standard way of registering event handlers
  window.addEventListener("load", setLoaded, false);
}

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/MathCanvas.js");

$require("org/mathdox/formulaeditor/Options.js");

$main(function(){

  /**
   * Adds mathematical symbol and string rendering to an HTML Canvas.
   */
  org.mathdox.formulaeditor.MathCanvas = $extend(Object, {

    /**
     * The HTML Canvas that is used for drawing mathematics.
     */
    canvas : null,

    /**
     * The name of the font that is used for drawing symbols and strings.
     */
    fontName : "cmr",

    /**
     * The font size that is used for drawing symbols and strings.
     */
    fontSizes : [ 50, 60, 70, 85, 100, 120, 144, 173, 207, 249, 298, 358, 430],
    fontSizeIdx : 7,

    /**
     * Contains previously loaded images.
     */
    imageCache : null,

    /**
     * Constructor which takes as parameter the HTML Canvas that will be used to
     * draw mathematics on. */ 
    initialize : function(canvas) {
      this.canvas = canvas;
      this.imageCache = {};
      if (org.mathdox.formulaeditor.options.fontSize) {
        var i = 0;
        while (i<this.fontSizes.length - 1 && 
          this.fontSizes[i]<org.mathdox.formulaeditor.options.fontSize) {
          i++;
        }
        this.fontSizeIdx = i;
      }
    },

    /**
     * Returns the CanvasRenderingContext2D object associated with the HTML
     * canvas.
     */
    getContext : function() {
      return this.canvas.getContext("2d");
    },

    /**
     * Draws the specified bracket (character) on the canvas, at the specified
     * position, using the current fontName and fontSize. The (x,y) coordinate
     * indicates where the left of the baseline of the symbol will appear.
     * The result of this method is one object containing the values
     * { left, top, width, height } that indicate the position and dimensions of
     * the bounding rectangle of the drawn symbol.
     * The optional parameter 'invisible' determines whether or not the symbol
     * should be drawn to the canvas. By default this parameter is 'false'.
     * Setting this parameter to 'true' can be used to obtain information about
     * the dimensions of the drawn symbol, without actually drawing on the
     * canvas.
     *
     * This function is like the drawSymbol function, except it has an extra
     * parameter minimumSize, which is used to determine the size of the
     * brackets. A bracket symbol will be used of at least that size. If no
     * symbol of that size is known it will be tried to construct it, if that
     * fails a smaller symbol will be used. See also drawSymbol.
     */
    drawBracket : function(bracket, x, y, minimumHeight, invisible, fontSizeModifier, center) {

      // retrieve font and symbol data
      var symbolData;
      var ex = this.getFontUnitEx(fontSizeModifier);

      // see if a standard symbol can be used
      for (var i=4 ; i>=1; i--) {
        var tmpData = this.getSymbolDataByPosition(bracket + i, fontSizeModifier);
        if (tmpData.height >= minimumHeight) {
          symbolData = tmpData;
        }
      }
 
      // variables used in both if and else clauses, declare them before the if
      var left, height, top, width, font, canvas, cache, drawImage, image;

      if (symbolData) {
        // draw a symbol 
        
        // calculate the position of the topleft corner, the width and the height
        if (symbolData.margin) {
          symbolData = this.extendObject(symbolData, {
            x: symbolData.x - symbolData.margin,
            width: symbolData.width + 2*symbolData.margin
          });
        }
        left   = x;
        top    = y - symbolData.height + symbolData.yadjust;
        width  = symbolData.width;
        height = symbolData.height;
        font = symbolData.font;
  
        // draw that part of the font image which contains the symbol
        if (!invisible) {
  
          canvas = this.canvas;
          cache  = this.imageCache;
  
          drawImage = function() {
            canvas.getContext("2d").drawImage(
              cache[font.image],
              symbolData.x, symbolData.y, symbolData.width, symbolData.height,
              left, top, width, height);
          };

          /* warning code used in both drawSymbol and drawBracket */
          if (cache[font.image] === null || cache[font.image] === undefined) {
            image = new Image();
            image.onload = function() {
              if (cache[font.image] instanceof Array) {
                var todo = cache[font.image];
  
                cache[font.image] = image;
  
                for (var i=0; i<todo.length; i++) {
                  todo[i](); // call stored drawImage functions
                }
              }
            };
            cache[font.image] = [];
  
            cache[font.image].push(drawImage);
  
            image.src = font.image;
          } else if (cache[font.image] instanceof Array) {
            cache[font.image].push(drawImage);
          } else {
            drawImage();
          }
 
        }
  
        // return the coordinates of the topleft corner, the width and height
        return {
          left:   left,
          top:    top,
          width:  width,
          height: height
        };
      } else {
        // construct a symbol
        var topSymbol = this.getSymbolDataByPosition(bracket+"u", fontSizeModifier);
        var bottomSymbol = this.getSymbolDataByPosition(bracket+"l", fontSizeModifier);
        var connection = this.getSymbolDataByPosition(bracket+"m", fontSizeModifier);

        if (!topSymbol.adjusted) {
          // get rid of aliased top/bottom
          // for top part
          topSymbol.adjusted = true;
          topSymbol.height -= 1;

          // for middle part
          if (connection.height > 2) {
            // get rid of aliased top/bottom
            connection.height -= 2;
            connection.y += 1;
          }

          // for bottom part
          bottomSymbol.height -= 1;
          bottomSymbol.y += 1;
        }

        left = x;
        height = Math.max(minimumHeight,
          topSymbol.height + bottomSymbol.height);
        top = y - height + bottomSymbol.yadjust;
        width = Math.max(topSymbol.width, connection.width,
          bottomSymbol.width);

        font = topSymbol.font;

        if (!invisible) {
  
          canvas = this.canvas;
          cache  = this.imageCache;
  
          drawImage = function() {
            var minXadjust = Math.min(topSymbol.xadjust,
              bottomSymbol.xadjust, connection.xadjust);
            var topPos = { 
              left: left + topSymbol.xadjust - minXadjust,
              top: top,
              width: topSymbol.width,
              height: topSymbol.height
            };
            var bottomPos = { 
              left: left + bottomSymbol.xadjust - minXadjust,
              top: top + height - bottomSymbol.height ,
              width: bottomSymbol.width,
              height: bottomSymbol.height
            };
            var connPos = { 
              left: left + connection.xadjust - minXadjust,
              top: topPos.top + topPos.height,
              width: connection.width,
              height: height - topPos.height - bottomPos.height
            };
            //alert("top: ("+topPos.left+", "+topPos.top+", "+topPos.width+", "+topPos.height+")\n"+"conn: ("+connPos.left+", "+connPos.top+", "+connPos.width+", "+connPos.height+")\n"+"bottom: ("+bottomPos.left+", "+bottomPos.top+", "+bottomPos.width+", "+bottomPos.height+")");
            //alert("font.image:"+font.image);
            canvas.getContext("2d").drawImage(
              cache[font.image],
              topSymbol.x, topSymbol.y, topSymbol.width, topSymbol.height,
              topPos.left, topPos.top, topPos.width, 
              topPos.height);
            if (connPos.height>0) {
              canvas.getContext("2d").drawImage(
                cache[font.image],
                connection.x, connection.y, connection.width, connection.height,
                connPos.left, connPos.top, 
                connPos.width, connPos.height);
            }
            canvas.getContext("2d").drawImage(
              cache[font.image],
              bottomSymbol.x, bottomSymbol.y, bottomSymbol.width, 
              bottomSymbol.height, bottomPos.left, 
              bottomPos.top, bottomPos.width, bottomPos.height);
          };
          
          /* warning code used in both drawSymbol and drawBracket */
          if (cache[font.image] === null || cache[font.image] === undefined) {
            image = new Image();
            image.onload = function() {
              if (cache[font.image] instanceof Array) {
                var todo = cache[font.image];
  
                cache[font.image] = image;
  
                for (var i=0; i<todo.length; i++) {
                  todo[i](); // call stored drawImage functions
                }
              }
            };
            cache[font.image] = [];
  
            cache[font.image].push(drawImage);
  
            image.src = font.image;
          } else if (cache[font.image] instanceof Array) {
            cache[font.image].push(drawImage);
          } else {
            drawImage();
          }
  
        }
        //alert("total: ("+left+", "+top+", "+width+", "+height+")");
         // return the coordinates of the topleft corner, the width and height
        return {
          left:   left,
          top:    top,
          width:  width,
          height: height
        };
      }
    },

    /**
     * Draws a grey/black box around on the edge of an element, depending on
     * the dimensions. It overwrites the character (that is stays inside its
     * dimensions). The box will be drawn around
     * (dimensions.left,dimensions.top) (upper left) and
     * (dimensions.left+dimensions.width - 1, dimensions.top+dimensions.height
     * - 1) (lower right). 
     *
     * if strokeStyle is defined, that style will be used to draw the
     * border of the box.
     *
     * if fillStyle is defined, the box is filled using that style
     * 
     * if both stokeStyle and fillStyle are defined, then a filled box is drawn
     * first, followed by a border.
     */
    drawBox: function(dimensions, strokeStyle, fillStyle) {
      var canvas = this.canvas;
      var context = this.getContext();

      context.save();
      
      // set styles
      if (fillStyle !== undefined) {
        context.fillStyle = fillStyle;
      }
      if (strokeStyle !== undefined) {
        context.strokeStyle = strokeStyle;
      }

      // draw a filled box
      if (fillStyle) {
        context.fillRect(dimensions.left, dimensions.top, dimensions.width, 
          dimensions.height);
      }

      // draw the box border
      if (!fillStyle || (fillStyle && strokeStyle)) {
        context.lineWidth = 1.0;
        context.strokeRect(dimensions.left, dimensions.top, 
          dimensions.width - 1 , dimensions.height - 1);
      } 

      context.restore();
    },
   
    /**
     * This function draws a box with based on dimensions, with border style
     * strokeStyle and fill style fillStyle.
     * 
     * if y is defined a baseline will be drawn as well (in the strokeStyle)
     * 
     * see also: drawBox
     */
    drawBoxWithBaseline: function(dimensions, y, strokeStyle, fillStyle) {
      this.drawBox(dimensions, fillStyle, strokeStyle);

      var canvas = this.canvas;
      var context = this.getContext();

      context.save();
      if (y) {
        if (strokeStyle !== undefined) {
          context.strokeStyle = strokeStyle;
        }
        context.beginPath();
        context.moveTo(dimensions.left, y);
        context.lineTo(dimensions.left + dimensions.width - 1, y);
        context.stroke();
        context.closePath();
      }
      context.restore();
    },

    // draw a box the size of the symbol of the letter 'f' 
    drawFBox : function(x, y, invisible, letter, typeface, fontSizeModifier) {
      var dim;
      if (letter === null || letter === undefined) {
        letter = "f";
      }
      var presentation = org.mathdox.formulaeditor.presentation;

      dim = this.drawSymbol(letter,x,y,true, typeface, fontSizeModifier);

      if (!invisible) {
        var context = this.getContext();
        context.save();
        context.fillStyle = "rgba(160,160,255,0.5)";
        context.fillRect(dim.left, dim.top, dim.width, dim.height);
        context.restore();
      }

      return dim;

    },


    /**
     * Draws the specified symbol (character) on the canvas, at the specified
     * position, using the current fontName and fontSize. The (x,y) coordinate
     * indicates where the left of the baseline of the symbol will appear.
     * The result of this method is one object containing the values
     * { left, top, width, height } that indicate the position and dimensions of
     * the bounding rectangle of the drawn symbol.
     * The optional parameter 'invisible' determines whether or not the symbol
     * should be drawn to the canvas. By default this parameter is 'false'.
     * Setting this parameter to 'true' can be used to obtain information about
     * the dimensions of the drawn symbol, without actually drawing on the
     * canvas.
     * If the typeface is "math" a slanted/italic symbol will be drawn if
     * possible.
     */
    drawSymbol : function(symbol, x, y, invisible, typeface, fontSizeModifier) {
      var mathCanvas = org.mathdox.formulaeditor.MathCanvas;
      if (mathCanvas.specialSymbols[symbol]!== undefined) {
        // special case combined symbol: 
        // draw all subsymbols and return maximum dimensions

        var dim = {
          top:    y,
          left:   x,
          width:  0,
          height: 0
        };
        var olddim;
        var i;
        var symbols = mathCanvas.specialSymbols[symbol];

        for (i=0; i< symbols.length; i++) {
          olddim = dim;
          dim = this.drawSymbol(symbols[i], x, y, invisible, typeface, fontSizeModifier);

          dim = {
            top: Math.min(olddim.top, dim.top),
            height: Math.max(olddim.top+olddim.height, dim.top+dim.height) - 
              Math.min(olddim.top, dim.top),
            left: Math.min(olddim.left, dim.left),
            width: Math.max(olddim.left+olddim.width, dim.left+dim.width) - 
              Math.min(olddim.left, dim.left)
          };
        }

        return dim;
      }

      // retrieve font and symbol data
      var symbolData = this.getSymbolData(symbol, typeface, fontSizeModifier);

      if (symbolData === null) {
	// draw an invisible box instead. Another option would be a red box
	var box =  this.drawFBox(x, y, true, null, typeface, fontSizeModifier);
	if (invisible !== true) {
	  this.drawBox(box, "rgba(255,0,0, 1.0)");
	}
	return box;
      }

      var font = symbolData.font;

      // calculate the position of the topleft corner, the width and the height
      var left   = x;
      var top    = y - symbolData.height + symbolData.yadjust;
      var width  = symbolData.width;
      var height = symbolData.height;

      // draw that part of the font image which contains the symbol
      if (!invisible) {

        var canvas = this.canvas;
        var cache  = this.imageCache;

        var drawImage = function() {
          canvas.getContext("2d").drawImage(
            cache[font.image],
            symbolData.x, symbolData.y, symbolData.width, symbolData.height,
            left, top, width, height);
        };

        /* warning code used in both drawSymbol and drawBracket */
        if (cache[font.image] === null || cache[font.image] === undefined) {
          var image = new Image();
          image.onload = function() {
            if (cache[font.image] instanceof Array) {
              var todo = cache[font.image];

              cache[font.image] = image;

              for (var i=0; i<todo.length; i++) {
                todo[i](); // call stored drawImage functions
              }
            }
          };
          cache[font.image] = [];

          cache[font.image].push(drawImage);

          image.src = font.image;
        } else if (cache[font.image] instanceof Array) {
          cache[font.image].push(drawImage);
        } else {
          drawImage();
        }
      }

      // return the coordinates of the topleft corner, the width and height
      return {
        left:   left,
        top:    top,
        width:  width,
        height: height
      };

    },

    /**
     * copy an old object, replacing only a few attributes
     */
    extendObject: function(oldObj, replace) {
      var newObj = {};
      var name; // index variable
      for (name in oldObj) {
        newObj[name] = oldObj[name];
      }
      for (name in replace) {
        newObj[name] = replace[name];
      }

      return newObj;
    },

    getSymbolData : function(symbol, typeface, fontSizeModifier) {
      // retrieve font and symbol data
      var symbolData;

      /* some special cases */
      if (symbol==' ') {
        symbolData = this.getSymbolDataByPosition(',', fontSizeModifier);
        if (symbolData) {
          symbolData = this.extendObject(symbolData, {
            x:symbolData.x+symbolData.width+1
          });
        }
      } else if (symbol == '_' ) { 
        symbolData = this.getSymbolDataByPosition('-', fontSizeModifier);
        if (symbolData) {
          symbolData = this.extendObject(symbolData, { 
            yadjust: 0 + symbolData.height 
          });
        }
      } else if (typeface == 'math') {
        symbolData = this.getSymbolDataByPosition("m"+ symbol, fontSizeModifier);
        if (! symbolData) {
          symbolData = this.getSymbolDataByPosition(symbol, fontSizeModifier);
        }
      } else {
        /* generic case */
        symbolData = this.getSymbolDataByPosition(symbol, fontSizeModifier);
      }

      /* some margins, '-', '+', middle dot */
      if (symbol == '-') {
        symbolData = this.extendObject(symbolData, { 
          margin: 2
        });
      } else if (symbol == '+') { 
        symbolData = this.extendObject(symbolData, { 
          margin: 2
        });
      } else if (symbol == '·') { // U+00B7 middle dot
        symbolData = this.extendObject(symbolData, { 
          margin: 2
        });
      }

      if (!symbolData) {
        if ((!symbol) || (symbol === '') || (symbol.charCodeAt(0) === 0)) {
          return null;
        }
      }

      if (symbolData) {
        if (symbolData.margin) {
          symbolData = this.extendObject(symbolData, {
            x: symbolData.x - symbolData.margin,
            width: symbolData.width + 2*symbolData.margin
          });
        }

        // return symboldata
        return symbolData;
      }
        
      if (!symbolData) {
        // should not happen any more
        console.log("ALERT: unsupported symbol '"+symbol+"' cannot be gotten by position");
      }

      // no symbol data found, return null
      return null;
    },

    getSymbolDataByPosition: function(symbol, fontSizeModifier) {
      var positionInfo = org.mathdox.formulaeditor.MathCanvas.symbolPositions[
        symbol];
      var fBP = org.mathdox.formulaeditor.MathCanvas.fontsByPosition;
      var fontSize = this.fontSizes[this.fontSizeIdx];
      var newFontSizeIndex;
      if (fontSizeModifier!== undefined && fontSizeModifier !== null) {
	newFontSizeIndex = this.fontSizeIdx + fontSizeModifier;
	if (0<=newFontSizeIndex && newFontSizeIndex < this.fontSizes.length) {
	  fontSize = this.fontSizes[newFontSizeIndex];
	} else if (newFontSizeIndex<0) {
	  fontSize = this.fontSizes[0];
	} else if (newFontSizeIndex>this.fontSizes.length) {
	  fontSize = this.fontSizes[this.fontSizes.length-1];
	}
      }

      if (!positionInfo) {
        //alert("no positioninfo : "+symbol);
        return null;
      }
      
      if (!fBP[positionInfo.font]) {
        alert("no metrics for this font");
        return null;
      }

      if (!fBP[positionInfo.font][fontSize]) {
        alert("no metrics for this fontsize: "+fontSize);
        return null;
      }
      
      if (positionInfo.row*16+positionInfo.col >=
        fBP[positionInfo.font][fontSize].length) {
        alert("positionInfo row: "+positionInfo.row+" col: "+positionInfo.col);
        alert("no metrics for this symbol: "+(positionInfo.row*16+positionInfo.col)+"/"+fBP[positionInfo.font][fontSize].length);
        return null;
      }

      return fBP[positionInfo.font][fontSize][ positionInfo.row * 16 +
        positionInfo.col ];
    },

    getFontUnitEm: function (fontSizeModifier) {
      var data = this.getSymbolDataByPosition("M", fontSizeModifier);

      return data.width;
    },

    getFontUnitEx: function (fontSizeModifier) {
      var data = this.getSymbolDataByPosition("x", fontSizeModifier);

      return data.height;
    },

    /**
     * Clears the canvas.
     */
    clear : function() {
      var canvas = this.canvas;
      var width  = canvas.getAttribute("width");
      var height = canvas.getAttribute("height");
      canvas.getContext("2d").clearRect(0, 0, width, height);
    },

    decreaseSize: function() {
      if ( this.fontSizeIdx>0) {
        this.fontSizeIdx = this.fontSizeIdx - 1;
      }
    },

    increaseSize: function() {
      if ( this.fontSizeIdx<this.fontSizes.length-1) {
        this.fontSizeIdx = this.fontSizeIdx + 1;
      }
    }

  });

  /**
   * Static function addFont to add fonts to the static MathCanvas in
   * fontsByPosition. Arguments are like jsMath.Img.AddFont:
   * - size: the size (in pt?) of the font
   * - data: a record with fontname: array
   *   where array contains 256 entries (relative width, relative height,
   *   yadjust, optional xadjust)
   *   followed by a list of horizontal positions, a list of vertical
   *   positions and the lower right coordinates of the picture
   */
  org.mathdox.formulaeditor.MathCanvas.addFont = function(size,data) {
    var fontSize = ""+size;

    if (!org.mathdox.formulaeditor.MathCanvas.fontsByPosition) {
      org.mathdox.formulaeditor.MathCanvas.fontsByPosition = {};
    }
    var fBP = org.mathdox.formulaeditor.MathCanvas.fontsByPosition;

    for (var fontName in data) {
      if (!fBP[fontName]) {
        fBP[fontName] = {};
      }
      var fBPN = fBP[fontName];
      var fontInput = data[fontName];
      var font = { image : $baseurl + "org/mathdox/formulaeditor/fonts/" +
          fontName + "/" + fontSize + ".png"};

      if (!fBPN[fontSize]) {
        fBPN[fontSize] = [];
      }
      var fontInfo = fBPN[fontSize];
      var length = fontInput.length;

      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 16; col ++) {
          var pos = row*16 + col;

          if (pos<length-3) {
            var xadjust = 0;
            var width = fontInput[pos][0];
            var height = fontInput[pos][1];
            var yadjust = fontInput[pos][2];
            
            if (fontInput[pos][3]) {
              xadjust = fontInput[pos][3];
            }
            var outputCharInfo = {
              x: fontInput[ length - 3 ][col] - xadjust,
              y: fontInput[ length - 2 ][row] - height + yadjust,
              width: width,
              height: height,
              xadjust: - xadjust,
              yadjust: yadjust, // XXX check the sign
              font:font
            };
          }
          
          fontInfo.push(outputCharInfo);
        }
      }
    }
  };

  // XXX: how to multiple alternatives for symbols (capital pi vs product,
  // emptyset vs o with stroke) ?
  // XXX: which symbols to choose for ',`,"
  org.mathdox.formulaeditor.MathCanvas.symbolsInFont = {
    bbold10: [
        // U+213E double-struck capital gamma
        // U+213F double-struck capital pi
        // U+2140 double-struck n-ary summation
      [  'ℾ', null, null, null, null,  'ℿ',  '⅀', null,
        // U+213D double-struck small gamma
        null, null, null, null, null,  'ℽ', null, null],
      [ null, null, null, null, null, null, null, null,
        // U+213C double-struck small pi
        null,  'ℼ', null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
        // U+2102 double-struck capital c
        // U+210D double-struck capital h
      [ null, null, null,  'ℂ', null, null, null,  'ℍ',
        // U+2115 double-struck capital n
        null, null, null, null, null, null,  'ℕ', null],
        // U+2119 double-struck capital p
        // U+211A double-struck capital q
        // U+211D double-struck capital r
      [  'ℙ',  'ℚ',  'ℝ', null, null, null, null, null,
        // U+2124 double-struck capital z
        null, null,  'ℤ', null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null]
    ],
    cmr10: [
      // U+0393 Greek capital letter gamma
      // U+0349 Greek capital letter delta
      // U+0398 Greek capital letter theta
      // U+039E Greek capital letter xi
      // U+039B Greek capital letter lamda
      // U+03A0 Greek capital letter pi
      // U+03A3 Greek capital letter sigma
      // U+03D2 Greek upsilon with hook symbol
      [  'Γ',  'Δ',  'Θ',  'Ξ',  'Λ',  'Π',  'Σ',  'ϒ',
      // U+03A6 Greek capital letter phi
      // U+03A8 Greek capital letter psi
      // U+03A9 Greek capital letter omega
         'Φ',  'Ψ',  'Ω', 'ff', 'fi', 'fl','ffi','ffl'],
      // U+00B4 Acute accent (spacing)
      // U+00B0 Degree sign
      [ null, null,  '`',  '´', null, null, null,  '°', 
      // U+00B8 Cedilla (spacing)
      // U+00DF Latin small letter sharp s
      // U+00E6 Latin small letter ae
      // U+0152 Latin small ligature oe
      // U+00F8 Latin small letter o with stroke
      // U+00C6 Latin capital ae
      // U+0152 Latin capital ligature oe
      // U+00D8 Latin capital letter o with stroke
         '¸',  'ß',  'æ',  'œ',  'ø',  'Æ',  'Œ',  'Ø'],
      [ null,  '!',  '"',  '#',  '$',  '%',  '&', '\'',
         '(',  ')',  '*',  '+',  ',', null,  '.',  '/'],
      [  '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
      // U+00A1 inverted exclamation mark
      // U+00BF inverted question mark
         '8',  '9',  ':',  ';',  '¡',  '=',  '¿',  '?'],
      [  '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',
         'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O'],
      [  'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
         'X',  'Y',  'Z',  '[', '``',  ']',  '^', '^.'],
      [ null,  'a',  'b',  'c',  'd',  'e',  'f',  'g',
         'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o'],
      [  'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
      // U+00A8 diaeresis (spacing)
         'x',  'y',  'z', null, null, null,  '~',  '¨']
    ],
    cmbx10: [
      // U+0393 Greek capital letter gamma
      // U+0349 Greek capital letter delta
      // U+0398 Greek capital letter theta
      // U+039B Greek capital letter lamda
      // U+039E Greek capital letter xi
      // U+03A0 Greek capital letter pi
      // U+03A3 Greek capital letter sigma
      // U+03D2 Greek upsilon with hook symbol
      [ 'bΓ', 'bΔ', 'bΘ', 'bΛ', 'bΞ', 'bΠ', 'bΣ', 'bϒ', 
      // U+03A6 Greek capital letter phi
      // U+03A8 Greek capital letter psi
      // U+03A9 Greek capital letter omega
        'bΦ', 'bΨ', 'bΩ','bff','bfi','bfl','bffi','bffl'],
      // U+00B4 Acute accent (spacing)
      // U+00B0 Degree sign
      [ null, null, 'b`', 'b´', null, null, null, 'b°',
      // U+00B8 Cedilla (spacing)
      // U+00DF Latin small letter sharp s
      // U+00E6 Latin small letter ae
      // U+0152 Latin small ligature oe
      // U+00F8 Latin small letter o with stroke
      // U+00C6 Latin capital ae
      // U+0152 Latin capital ligature oe
      // U+00D8 Latin capital letter o with stroke
        'b¸', 'bß', 'bæ', 'bœ', 'bø', 'bÆ', 'bŒ', 'bØ'],
      [ null, 'b!', 'b"', 'b#', 'b$', 'b%', 'b&','b\'',
        'b(', 'b)', 'b*', 'b+', 'b,', 'b-', 'b.', 'b/'],
      [ 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7',
      // U+00A1 inverted exclamation mark
      // U+00BF inverted question mark
        'b8', 'b9', 'b:', 'b;', 'b¡', 'b=', 'b¿', 'b?'],
      [ 'b@', 'bA', 'bB', 'bC', 'bD', 'bE', 'bF', 'bG',
        'bH', 'bI', 'bJ', 'bK', 'bL', 'bM', 'bN', 'bO'],
      [ 'bP', 'bQ', 'bR', 'bS', 'bT', 'bU', 'bV', 'bW',
        'bX', 'bY', 'bZ', 'b[','b``', 'b]', 'b^','b^.'],
      [ null, 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'bg',
        'bh', 'bi', 'bj', 'bk', 'bl', 'bm', 'bn', 'bo'],
      [ 'bp', 'bq', 'br', 'bs', 'bt', 'bu', 'bv', 'bw',
      // U+00A8 diaeresis (spacing)
        'bx', 'by', 'bz', null, null, null, 'b~', 'b¨']
    ],
    cmex10: [
      // U+230A left floor
      // U+230B right floor
      // U+2308 right ceiling
      // U+2309 right ceiling
      [ '(1', ')1', '[1', ']1', '⌊1', '⌋1', '⌈1', '⌉1',
        '{1', '}1', '<1', '>1', null, null, '/1','\\1'],
      [ '(2', ')2', '(3', ')3', '[3', ']3', '⌊3', '⌋3',
        '⌈3', '⌉3', '{3', '}3', '<3', '>3', '/3','\\3'],
      [ '(4', ')4', '[4', ']4', '⌊4', '⌋4', '⌈4', '⌉4',
        '{4', '}4', '<4', '>4', '/4','\\4', '/2','\\2'],
      [ '(u', ')u', '[u', ']u', '[l', ']l', '[m', ']m',
        '{u', '}u', '{l', '}l', '{m', '}m', null, null],
      [ '(l', ')l', '(m', ')m', '<2', '>2', null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        '[2', ']2', '⌊2', '⌋2', '⌈2', '⌉2', '{2', '}2'],
      [ 'v1', 'v2', 'v3', 'v4', 'vl', 'vm', 'vu', null,
        null, null, null, null, null, null, null, null]
    ],
    cmmi10: [
      // U+0393 Greek capital letter gamma
      // U+0349 Greek capital letter delta
      // U+0398 Greek capital letter theta
      // U+039E Greek capital letter xi
      // U+039B Greek capital letter lamda
      // U+03A0 Greek capital letter pi
      // U+03A3 Greek capital letter sigma
      // U+03D2 Greek upsilon with hook symbol
      [ 'mΓ', 'mΔ', 'mΘ', 'mΛ', 'mΞ', 'mΠ', 'mΣ', 'mϒ',
      // U+03A6 Greek capital letter phi
      // U+03A8 Greek capital letter psi
      // U+03A9 Greek capital letter omega
      // U+03B1 Greek small letter alpha
      // U+03B2 Greek small letter beta
      // U+03B3 Greek small letter gamma
      // U+03B4 Greek small letter delta
      // U+03F5 Greek lunate epsilon symbol
        'mΦ', 'mΨ', 'mΩ', 'mα', 'mβ', 'mγ', 'mδ', 'mϵ'],
      // U+03B6 Greek small letter zeta
      // U+03B7 Greek small letter eta
      // U+03B8 Greek small letter theta
      // U+03B9 Greek small letter iota
      // U+03BA Greek small letter kappa
      // U+03BB Greek small letter lamda
      // U+03BC Greek small letter mu
      // U+03BD Greek small letter nu
      [ 'mζ', 'mη', 'mθ', 'mι', 'mκ', 'λ', 'mμ', 'mν',
      // U+03BE Greek small letter xi
      // U+03C0 Greek small letter pi
      // U+03C1 Greek small letter rho
      // U+03C3 Greek small letter sigma
      // U+03C4 Greek small letter tau
      // U+03C5 Greek small letter upsilon
      // U+03D5 Greek phi symbol
      // U+03C7 Greek small letter chi
        'mξ', 'π', 'mρ', 'mσ', 'mτ', 'mυ', 'mϕ', 'mχ'],
      // U+03C8 Greek small letter psi
      // U+03C9 Greek small letter omega
      // U+03B5 Greek small letter epsilon
      // U+03D1 Greek theta symbol
      // U+03D6 Greek pi symbol
      // U+03F1 Greek rho symbol
      // U+03C2 Greek small letter final sigma
      // U+03C6 Greek small letter phi
      [ 'mψ', 'mω', 'mε', 'mϑ', 'mϖ', 'mϱ', 'mς', 'mφ',
        null, null, null, null, null, null, null, null],
      [ 'm0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7',
        'm8', 'm9', 'm.', 'm,',  '<', 'm/',  '>', 'm*'],
      // U+2202 Partial differential
      [  '∂', 'mA', 'mB', 'mC', 'mD', 'mE', 'mF', 'mG',
        'mH', 'mI', 'mJ', 'mK', 'mL', 'mM', 'mN', 'mO'],
      [ 'mP', 'mQ', 'mR', 'mS', 'mT', 'mU', 'mV', 'mW',
        'mX', 'mY', 'mZ', null, null, null, null, null],
      [ null, 'ma', 'mb', 'mc', 'md', 'me', 'mf', 'mg',
        'mh', 'mi', 'mj', 'mk', 'ml', 'mm', 'mn', 'mo'],
      [ 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw',
        'mx', 'my', 'mz', null, null, null, null, null]
    ],
    cmsy10: [
      // U+00B7 middle dot
      // U+00D7 multiplication sign
      // U+204E low asterisk
      // U+00F7 division sign
      // U+22C4 diamond operator 
      // U+00B1 plus-minus sign
      // U+2213 minus-or-plus sign
      [  '-',  '·',  '×',  '⁎',  '÷',  '⋄',  '±',  '∓',
      // U+2295 circled plus
      // U+2296 circled minus
      // U+2297 circled times
      // U+2298 circled division slash
      // U+2299 circled dot operator
      // U+25CB white circle
      // U+2218 ring operator
      // U+2219 bullet operator
         '⊕',  '⊖',  '⊗',  '⊘',  '⊙',  '○',  '∘',  '∙' ],
      // U+224D equivalent to
      // U+2261 identical to
      // U+2286 subset of or equal to
      // U+2287 superset of or equal to
      // U+2264 less than or equal to
      // U+2265 greater than or equal to
      // U+227C precedes or equal to
      // U+227D succeeds or equal to
      [  '≍',  '≡',  '⊆',  '⊇',  '≤',  '≥',  '≼',  '≽',
      // U+223C tilde operator
      // U+2248 almost equal to
      // U+2282 subset of
      // U+2283 superset of
      // U+226A much less-than
      // U+226B much greater-than
      // U+227A precedes
      // U+227B succeeds
         '∼',  '≈',  '⊂',  '⊃',  '≪',  '≫',  '≺',  '≻' ],
      // U+2190 leftwards arrow
      // U+2192 rightwards arrow
      // U+2191 upwards arrow
      // U+2193 downwards arrow
      // U+2194 left right arrow
      // U+2197 north east arrow
      // U+2198 south east arrow
      // U+2243 asymptotically equal to
      [  '←',  '→',  '↑',  '↓',  '↔',  '↗',  '↘',  '≃',
      // U+21D0 leftwards double arrow
      // U+21D2 rightwards double arrow
      // U+21D1 upwards double arrow
      // U+21D3 downwards double arrow
      // U+21D4 left right double arrow
      // U+2196 north west arrow
      // U+2199 south west arrow
      // U+221D proportional to
         '⇐',  '⇒',  '⇑',  '⇓',  '⇔',  '↖',  '↙',  '∝' ],
      // U+2032 [superscript] prime
      // U+221E infinity
      // U+2208 element of
      // U+220B contains as member
      // U+25B3 white up-pointing triangle
      // U+25BD white down-pointing triangle
      // U+2215 division slash
      [  '′',  '∞',  '∈',  '∋',  '△',  '▽',  '∕', null,
      // U+2200 for all
      // U+2203 there exists
      // U+00AC not sign
      // U+2205 empty set
      // U+211C black-letter capital r
      // U+2111 black-letter capital i
      // U+22A4 down tack
      // U+22A5 up tack
         '∀',  '∃',  '¬',  '∅',  'ℜ',  'ℑ',  '⊤', '⊥' ],
      // U+2135 alef symbol
      [  'ℵ', null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null ],
      [ null, null, null, null, null, null, null, null,
      // U+222A union
      // U+2229 intersection
      // U+2227 logical and
      // U+2228 logical or
      // U+228E multiset union
        null, null, null,  '∪',  '∩',  '⊎',  '∧',  '∨' ],
      // U+22A2 right tack
      // U+22A3 left tack
      // U+230A left floor
      // U+230B right floor
      [  '⊢',  '⊣',  '⌊',  '⌋',  '⌈',  '⌉',  '{',  '}',
      // U+27E8 mathematical left angle bracket
      // U+27E9 mathematical right angle bracket
      // U+2225 parallel to
      // U+2195 up down arrow
      // U+21D5 up down double arrow
      // U+2240 wreath product
         '⟨',  '⟩',  '|',  '∥',  '↕',  '⇕', '\\',  '≀' ],
      // U+221A square root
      // U+2210 n-ary coproduct
      // U+2207 nabla
      // U+222B integral
      // U+2294 square cup
      // U+2293 square cap
      // U+2291 square image of or equal to
      // U+2292 square original of or equal to
      [  '√',  '∐',  '∇',  '∫',  '⊔',  '⊓',  '⊑',  '⊒',
      // U+00A7 section sign
      // U+2020 dagger
      // U+2021 double dagger
      // U+00B6 pilcrow sign
      // U+2663 black club suit
      // U+2662 white diamond suit
      // U+2661 white heart suit
      // U+2660 black spade suit
         '§',  '†',  '‡',  '¶',  '♣',  '♢',  '♡',  '♠' ]
    ]
  };

  org.mathdox.formulaeditor.MathCanvas.specialSymbols = {
    // U+2146 differential D
    'ⅆ': [ 'd' ],
    // U+2260 not equal to
    // U+2215 division slash
    '≠': [ '=', '∕' ]
  };

  org.mathdox.formulaeditor.MathCanvas.fillSymbolPositions = function() {
    var sp,sif;
    if (!org.mathdox.formulaeditor.MathCanvas.symbolPositions) {
      org.mathdox.formulaeditor.MathCanvas.symbolPositions = {};
    }
    sp = org.mathdox.formulaeditor.MathCanvas.symbolPositions;
    sif = org.mathdox.formulaeditor.MathCanvas.symbolsInFont;

    for (var font in sif) {
      var symbolsArray = sif[font];
      for (var row = 0; row<symbolsArray.length; row++) {
        for (var col = 0; col<symbolsArray[row].length; col++) {
          var symbol = symbolsArray[row][col];
          if (symbol !== null && symbol !== undefined) {
            if (symbol in sp) {
              alert("duplicate entry for \""+symbol+"\"\n"+sp[symbol].font+
                ": ("+sp[symbol].row+", "+sp[symbol].col+")\n"+
                font+": ("+row+", "+col+")\n");
            } else {
              sp[symbol] = {
                font: font,
                row: row,
                col: col
              };
            }
          }
        }
      }
    }
  };

  org.mathdox.formulaeditor.MathCanvas.fillSymbolPositions();

});

  $package("org.mathdox.formulaeditor");
$identify("org/mathdox/formulaeditor/MathCanvasFill.js");
$require("org/mathdox/formulaeditor/MathCanvas.js");

$main(function(){
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmbx10:[[5,5,0],[7,5,0],[6,5,0],[6,5,0],[5,5,0],[6,5,0],[6,5,0],[6,5,0],
  [6,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0],[5,5,0],[7,5,0],[7,5,0],
  [2,4,0],[3,6,2,1],[3,2,-3],[3,2,-3,-1],[2,2,-3,-1],[4,2,-3],[4,2,-3],[2,2,-3,-2],
  [2,2,2,-1],[4,5,0],[6,4,0],[6,4,0],[4,5,1],[7,5,0],[8,6,1],[6,6,1],
  [3,1,-2],[2,5,0],[4,3,-2],[7,7,2],[4,6,1],[7,7,1],[6,5,0],[2,3,-2],
  [3,8,2],[3,8,2],[4,4,-2],[6,6,1],[2,2,1],[3,1,-1],[2,1,0],[4,8,2],
  [4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],
  [4,5,0],[4,5,0],[2,3,0],[2,4,1],[2,6,2],[6,3,0],[4,6,2],[4,5,0],
  [6,5,0],[6,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0],[5,5,0],[6,5,0],
  [6,5,0],[3,5,0],[4,6,1],[6,5,0],[5,5,0],[8,5,0],[6,5,0],[6,5,0],
  [5,5,0],[6,7,2],[6,5,0],[4,5,0],[6,5,0],[6,5,0],[6,5,0],[8,5,0],
  [6,5,0],[6,5,0],[5,5,0],[2,8,2],[3,3,-2,-1],[2,8,2],[2,2,-3,-1],[2,2,-3],
  [2,3,-2],[4,4,0],[5,5,0],[4,4,0],[5,5,0],[4,4,0],[3,5,0],[4,6,2],
  [5,5,0],[2,5,0],[3,7,2,1],[4,5,0],[2,5,0],[7,4,0],[5,4,0],[4,4,0],
  [5,6,2],[5,6,2],[3,4,0],[3,4,0],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-1],[8,1,-1],[3,2,-3,-1],[4,1,-4],[4,2,-3],
  [3,13,23,33,42,52,62,72,
  82,92,102,111,121,131,141,151],[9,17,26,34,42,51,59,67],[162,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmbx10:[[5,6,0],[7,6,0],[7,7,1],[6,6,0],[6,6,0],[7,6,0],[6,6,0],[7,6,0],
  [7,6,0],[7,6,0],[7,6,0],[6,6,0],[5,6,0],[5,6,0],[8,6,0],[8,6,0],
  [3,4,0],[4,6,2,1],[2,2,-4,-1],[2,2,-4,-2],[3,2,-4,-1],[3,2,-4,-1],[4,1,-4],[3,2,-4,-2],
  [3,2,2,-1],[5,6,0],[7,4,0],[7,4,0],[5,6,1],[8,6,0],[9,7,1],[7,7,1],
  [3,2,-2],[2,6,0],[4,4,-2],[7,8,2],[4,7,1],[8,7,1],[7,7,1],[2,3,-3],
  [3,8,2],[3,8,2],[4,4,-2],[7,6,1],[2,4,2],[3,2,-1],[2,2,0],[4,8,2],
  [5,6,0],[4,6,0],[5,6,0],[5,7,1],[5,6,0],[5,6,0],[5,7,1],[5,6,0],
  [5,7,1],[5,6,0],[2,4,0],[2,6,2],[2,6,2],[7,4,0],[4,6,2],[4,6,0],
  [7,6,0],[7,6,0],[6,6,0],[7,7,1],[7,6,0],[6,6,0],[6,6,0],[7,7,1],
  [7,6,0],[4,6,0],[5,7,1],[7,6,0],[6,6,0],[9,6,0],[7,6,0],[7,7,1],
  [6,6,0],[7,8,2],[7,7,1],[5,7,1],[6,6,0],[7,7,1],[7,6,0],[10,6,0],
  [7,6,0],[7,6,0],[6,6,0],[2,8,2,-1],[4,4,-2,-1],[2,8,2],[3,2,-4,-1],[2,2,-4],
  [2,4,-2],[5,4,0],[5,6,0],[4,4,0],[5,6,0],[4,4,0],[4,6,0],[5,6,2],
  [5,6,0],[3,6,0],[4,8,2,1],[5,6,0],[3,6,0],[8,4,0],[5,4,0],[5,4,0],
  [5,6,2],[5,6,2],[4,4,0],[4,4,0],[3,5,0],[5,4,0],[5,4,0],[7,4,0],
  [5,4,0],[5,6,2],[4,4,0],[5,1,-2],[9,1,-2],[3,2,-4,-1],[3,2,-4,-1],[3,2,-4,-1],
  [3,15,27,39,51,63,75,86,
  98,110,122,134,146,157,169,181],[11,21,31,41,51,61,71,81],[194,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmbx10:[[7,7,0],[9,7,0],[9,8,1],[8,7,0],[8,7,0],[9,7,0],[8,7,0],[9,7,0],
  [8,7,0],[9,7,0],[8,7,0],[8,7,0],[6,7,0],[6,7,0],[10,7,0],[10,7,0],
  [3,5,0],[4,7,2,1],[3,2,-5,-1],[3,2,-5,-2],[4,2,-5,-1],[4,2,-5,-1],[5,2,-5],[3,2,-5,-3],
  [4,2,2,-1],[6,7,0],[8,5,0],[9,5,0],[6,7,1],[10,7,0],[11,8,1],[12,9,1,3],
  [4,2,-2],[2,7,0,-1],[5,4,-3],[9,9,2],[5,9,1],[9,9,1],[9,8,1],[3,4,-3],
  [3,10,2,-1],[4,10,2],[5,5,-3],[9,9,2],[3,4,2],[4,2,-1],[3,2,0],[5,10,2],
  [6,8,1],[5,7,0],[6,7,0],[6,8,1],[6,7,0],[6,8,1],[6,8,1],[6,7,0],
  [6,10,1],[6,10,1],[3,5,0],[3,7,2],[2,7,2,-1],[9,3,-1],[5,7,2],[5,9,0],
  [9,7,0],[9,7,0],[8,7,0],[8,8,1],[9,7,0],[8,7,0],[7,7,0],[9,8,1],
  [9,7,0],[4,7,0],[6,8,1],[9,7,0],[7,7,0],[11,7,0],[9,7,0],[8,8,1],
  [8,7,0],[8,9,2],[9,8,1],[6,8,1],[8,7,0],[9,8,1],[9,7,0],[12,7,0],
  [12,7,0,3],[9,7,0],[7,7,0],[2,10,2,-1],[5,4,-3,-1],[2,10,2],[4,2,-5,-1],[3,2,-5],
  [3,4,-3],[6,5,0],[6,7,0],[5,5,0],[6,7,0],[5,5,0],[5,7,0],[6,7,2],
  [7,7,0],[3,7,0],[4,9,2,1],[6,9,0],[3,7,0],[10,9,0],[7,5,0],[6,5,0],
  [6,7,2],[6,7,2],[5,5,0],[5,5,0],[4,7,0],[7,5,0],[6,5,0],[8,5,0],
  [6,5,0],[6,7,2],[5,5,0],[6,1,-2],[12,1,-2],[8,5,-2,3],[4,2,-5,-1],[4,2,-5,-1],
  [4,18,32,46,59,73,87,101,
  115,128,142,156,170,184,198,211],[13,24,36,47,59,71,82,94],[227,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmbx10:[[8,9,0],[11,9,0],[10,10,1],[10,9,0],[9,9,0],[11,9,0],[10,9,0],[10,9,0],
  [10,9,0],[10,9,0],[10,9,0],[9,9,0],[8,9,0],[8,9,0],[11,9,0],[11,9,0],
  [4,6,0],[5,9,3,1],[3,3,-6,-1],[3,3,-6,-3],[5,2,-6,-1],[5,3,-6,-1],[5,2,-6,-1],[4,3,-6,-3],
  [5,3,3,-1],[7,9,0],[10,7,1],[11,7,1],[7,9,2],[12,9,0],[13,10,1,-1],[10,10,1],
  [4,2,-3],[2,9,0,-1],[6,5,-4],[11,12,3],[7,10,1],[11,10,1],[10,10,1],[2,5,-4,-1],
  [4,12,3,-1],[4,12,3],[5,6,-3,-1],[10,10,2],[2,5,3,-1],[4,2,-2],[2,2,0,-1],[6,12,3],
  [7,9,1],[5,8,0,-1],[7,8,0],[7,9,1],[7,8,0],[7,9,1],[7,9,1],[7,9,0],
  [7,9,1],[7,9,1],[2,6,0,-1],[2,9,3,-1],[2,9,3,-1],[10,4,-1],[6,9,3],[6,9,0],
  [10,10,1],[10,9,0],[9,9,0],[10,10,1],[10,9,0],[9,9,0],[8,9,0],[10,10,1],
  [11,9,0],[5,9,0],[7,10,1],[11,9,0],[8,9,0],[13,9,0],[11,9,0],[10,10,1],
  [9,9,0],[10,12,3],[11,10,1],[7,10,1],[9,9,0],[10,10,1],[10,9,0],[14,9,0],
  [10,9,0],[11,9,0],[8,9,0],[3,12,3,-1],[6,5,-4,-1],[3,12,3],[5,3,-6,-1],[2,3,-6,-1],
  [3,5,-4],[7,7,1],[8,9,0],[6,6,0],[8,10,1],[6,7,1],[6,9,0],[7,9,3],
  [8,9,0],[4,9,0],[5,12,3,1],[7,9,0],[4,9,0],[12,6,0],[8,6,0],[7,7,1],
  [8,9,3],[8,9,3],[6,6,0],[5,7,1],[5,8,0],[8,7,1],[7,6,0],[10,6,0],
  [7,6,0],[7,9,3],[6,6,0],[7,1,-3],[14,1,-3],[5,3,-6,-1],[5,2,-7,-1],[5,3,-6,-1],
  [5,22,38,55,72,89,106,122,
  139,156,173,190,206,223,240,257],[16,30,45,59,73,87,101,115],[275,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmbx10:[[9,10,0],[13,10,0],[12,11,1],[11,10,0],[10,10,0],[12,10,0],[10,10,0,-1],[11,10,0,-1],
  [11,10,0],[11,10,0,-1],[11,10,0],[11,10,0],[9,10,0],[9,10,0],[13,10,0],[13,10,0],
  [4,7,0],[5,10,3,1],[4,3,-7,-1],[4,3,-7,-3],[4,2,-7,-2],[6,3,-7,-1],[6,2,-7,-1],[4,3,-7,-4],
  [6,3,3,-1],[8,10,0],[12,8,1],[12,8,1],[8,10,2],[14,10,0],[15,11,1,-1],[12,12,1],
  [5,2,-4],[3,10,0,-1],[7,6,-4],[12,13,3,-1],[8,12,1],[13,12,1],[12,11,1],[3,5,-5,-1],
  [5,15,4,-1],[4,15,4,-1],[6,7,-4,-1],[11,11,2,-1],[3,6,3,-1],[5,2,-2],[3,3,0,-1],[6,15,4,-1],
  [8,11,1],[6,10,0,-1],[8,10,0],[8,11,1],[8,10,0],[8,11,1],[8,11,1],[7,11,1,-1],
  [8,11,1],[8,11,1],[3,7,0,-1],[3,10,3,-1],[3,10,3,-1],[11,5,-1,-1],[6,10,3,-1],[6,10,0,-1],
  [12,11,1],[12,10,0],[11,10,0],[11,11,1],[12,10,0],[10,10,0],[10,10,0],[12,11,1],
  [12,10,0],[6,10,0],[8,11,1],[12,10,0],[9,10,0],[15,10,0],[12,10,0],[12,11,1],
  [10,10,0],[12,13,3],[12,11,1],[8,11,1],[11,10,0],[12,11,1],[12,10,0],[17,10,0],
  [12,10,0],[12,10,0],[8,10,0,-1],[3,15,4,-1],[6,6,-4,-2],[3,15,4],[4,3,-7,-2],[3,3,-7,-1],
  [4,6,-4],[8,7,0],[9,10,0],[7,7,0],[9,11,1],[7,7,0],[7,10,0],[8,10,3],
  [9,10,0],[4,10,0],[5,13,3,1],[9,10,0],[5,10,0],[14,7,0],[9,7,0],[8,7,0],
  [9,10,3],[9,10,3],[7,7,0],[6,8,1],[6,10,1],[9,7,0],[8,7,0],[12,7,0],
  [9,7,0],[8,10,3],[7,7,0],[8,2,-3],[16,2,-3],[5,3,-7,-2],[6,2,-8,-1],[6,3,-7,-1],
  [6,26,45,65,85,104,124,144,
  164,183,203,223,243,262,282,302],[19,36,52,69,85,102,119,135],[324,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmbx10:[[11,12,0],[15,12,0,-1],[14,13,1,-1],[13,12,0],[13,12,0],[15,12,0],[12,12,0,-1],[13,12,0,-1],
  [12,12,0,-1],[13,12,0,-1],[13,12,0,-1],[13,12,0],[11,12,0],[11,12,0],[16,12,0],[16,12,0],
  [5,8,0],[6,12,4,1],[4,4,-8,-2],[4,4,-8,-4],[6,2,-9,-2],[7,4,-8,-1],[8,2,-9,-1],[5,3,-9,-5],
  [6,4,4,-2],[10,13,1],[14,9,1],[15,9,1],[10,12,2],[18,12,0],[19,13,1,-1],[14,14,1,-1],
  [6,3,-4],[4,12,0,-1],[8,6,-6],[15,16,4,-1],[8,14,1,-1],[15,14,1,-1],[15,13,1],[4,6,-6,-1],
  [6,17,4,-1],[5,17,4,-1],[8,8,-5,-1],[13,14,3,-1],[4,7,4,-1],[6,2,-3],[3,3,0,-1],[8,17,4,-1],
  [9,13,1],[8,12,0,-1],[8,12,0,-1],[9,13,1],[10,12,0],[8,12,1,-1],[9,13,1],[9,13,1,-1],
  [9,13,1],[9,13,1],[3,8,0,-1],[4,12,4,-1],[4,13,4,-1],[13,6,-1,-1],[8,13,4,-1],[8,12,0,-1],
  [14,13,1,-1],[14,12,0],[13,12,0],[12,13,1,-1],[14,12,0],[13,12,0],[12,12,0],[14,13,1,-1],
  [15,12,0],[7,12,0],[9,13,1],[15,12,0],[11,12,0],[18,12,0],[15,12,0],[13,13,1,-1],
  [13,12,0],[13,16,4,-1],[15,13,1],[9,13,1,-1],[13,12,0],[15,13,1],[15,13,1],[20,13,1],
  [15,12,0],[15,12,0],[10,12,0,-1],[3,17,4,-2],[8,7,-5,-2],[4,17,4],[6,3,-9,-2],[3,3,-9,-1],
  [3,7,-5,-1],[10,9,1],[11,13,1],[8,9,1],[11,13,1],[9,9,1],[8,12,0],[10,12,4],
  [11,12,0],[5,12,0],[6,16,4,1],[10,12,0],[5,12,0],[16,8,0],[11,8,0],[10,9,1],
  [11,12,4],[11,12,4],[8,8,0],[7,9,1],[7,12,1],[11,9,1],[10,8,0],[14,8,0],
  [10,8,0],[10,12,4],[8,8,0],[10,1,-4],[20,1,-4],[7,4,-8,-2],[7,2,-10,-1],[7,3,-9,-1],
  [7,31,54,78,102,125,149,173,
  196,220,244,268,291,315,339,362],[22,42,61,81,101,121,141,161],[388,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmbx10:[[13,14,0],[17,14,0,-1],[16,15,1,-1],[16,14,0],[14,14,0,-1],[18,14,0],[15,14,0,-1],[16,14,0,-1],
  [15,14,0,-1],[16,14,0,-1],[15,14,0,-1],[15,14,0],[12,14,0],[12,14,0],[19,14,0],[19,14,0],
  [5,9,0,-1],[8,13,4,2],[5,4,-10,-2],[5,4,-10,-5],[7,3,-10,-2],[8,4,-10,-2],[9,2,-11,-1],[5,4,-10,-6],
  [7,4,4,-2],[12,15,1],[16,10,1],[18,10,1],[11,13,2],[21,14,0],[22,15,1,-1],[16,16,1,-1],
  [7,3,-5],[3,15,0,-2],[10,7,-7],[17,18,4,-1],[10,17,2,-1],[17,17,2,-1],[16,15,1,-1],[4,7,-7,-1],
  [6,20,5,-2],[6,20,5,-1],[9,9,-6,-1],[16,16,3,-1],[4,8,4,-1],[7,3,-3],[4,4,0,-1],[10,20,5,-1],
  [11,15,1],[9,13,0,-1],[10,14,0,-1],[10,15,1,-1],[11,14,0],[10,14,1,-1],[10,15,1,-1],[11,15,1,-1],
  [10,15,1,-1],[10,15,1,-1],[4,9,0,-1],[4,13,4,-1],[3,15,5,-2],[16,6,-2,-1],[9,14,4,-1],[9,14,0,-1],
  [16,15,1,-1],[17,14,0],[15,14,0],[15,15,1,-1],[17,14,0],[15,14,0],[14,14,0],[16,15,1,-1],
  [18,14,0],[8,14,0],[11,15,1],[17,14,0],[13,14,0],[21,14,0],[18,14,0],[15,15,1,-1],
  [15,14,0],[16,18,4,-1],[18,15,1],[11,15,1,-1],[16,14,0],[17,15,1],[17,15,1],[24,15,1],
  [17,14,0],[17,14,0],[12,14,0,-1],[4,20,5,-2],[10,8,-6,-2],[4,20,5],[7,4,-10,-2],[4,4,-10,-1],
  [4,8,-6,-1],[12,10,1],[12,15,1],[10,10,1],[12,15,1],[10,10,1],[9,14,0],[12,13,4],
  [13,14,0],[5,14,0,-1],[8,18,4,2],[12,14,0],[5,14,0,-1],[19,9,0],[13,9,0],[11,10,1],
  [12,13,4],[12,13,4],[9,9,0],[9,10,1],[8,14,1],[13,10,1],[12,9,0],[17,9,0],
  [12,9,0],[12,13,4],[10,9,0],[12,1,-5],[23,1,-5],[7,5,-10,-3],[8,3,-11,-2],[8,3,-11,-2],
  [8,37,65,94,122,150,179,207,
  236,264,293,321,349,378,406,435],[26,50,74,98,122,145,169,193],[466,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmbx10:[[16,17,0],[21,17,0,-1],[19,18,1,-1],[18,17,0,-1],[17,17,0,-1],[21,17,0],[18,17,0,-1],[19,17,0,-1],
  [18,17,0,-1],[19,17,0,-1],[18,17,0,-1],[18,17,0],[15,17,0],[15,17,0],[23,17,0],[23,17,0],
  [6,11,0,-1],[9,16,5,2],[6,5,-12,-2],[6,5,-12,-5],[8,4,-12,-3],[10,5,-12,-2],[10,2,-13,-2],[7,5,-12,-7],
  [8,5,5,-3],[14,18,1],[20,12,1],[21,12,1],[13,17,3],[24,17,0,-1],[26,18,1,-2],[19,20,2,-1],
  [8,4,-6],[4,17,0,-2],[11,9,-8,-1],[21,22,5,-1],[12,20,2,-1],[21,20,2,-1],[19,18,1,-1],[5,9,-8,-2],
  [8,24,6,-2],[8,24,6,-1],[11,11,-7,-1],[19,20,4,-1],[4,9,5,-2],[8,3,-4],[4,4,0,-2],[12,24,6,-1],
  [12,17,1,-1],[10,16,0,-2],[12,16,0,-1],[12,17,1,-1],[13,16,0],[12,17,1,-1],[12,17,1,-1],[13,18,1,-1],
  [12,17,1,-1],[12,17,1,-1],[4,11,0,-2],[4,16,5,-2],[4,17,5,-2],[19,8,-2,-1],[11,17,5,-1],[11,17,0,-1],
  [19,18,1,-1],[19,17,0,-1],[19,17,0],[18,18,1,-1],[20,17,0],[18,17,0],[17,17,0],[20,18,1,-1],
  [21,17,0],[10,17,0],[13,18,1],[21,17,0],[16,17,0],[25,17,0,-1],[21,17,0],[19,18,1,-1],
  [18,17,0],[19,22,5,-1],[21,18,1],[13,18,1,-1],[18,17,0,-1],[20,18,1,-1],[21,18,1],[28,18,1],
  [20,17,0],[21,17,0],[15,17,0,-1],[4,24,6,-3],[11,9,-8,-3],[5,24,6],[8,5,-12,-3],[4,4,-13,-2],
  [5,9,-8,-1],[14,12,1],[15,18,1],[12,12,1],[15,18,1],[12,12,1],[10,17,0,-1],[14,16,5],
  [14,17,0,-1],[6,17,0,-1],[9,22,5,2],[15,17,0],[6,17,0,-1],[22,11,0,-1],[14,11,0,-1],[13,12,1],
  [15,16,5],[15,16,5],[11,11,0],[10,12,1],[10,17,1],[14,12,1,-1],[14,12,1],[20,12,1],
  [14,11,0],[14,16,5],[11,11,0],[14,1,-6],[28,1,-6],[9,5,-12,-3],[10,3,-14,-2],[10,4,-13,-2],
  [10,44,78,112,147,181,215,249,
  283,317,352,386,420,454,488,522],[32,61,90,118,147,176,204,233],[560,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmbx10:[[18,20,0,-1],[25,21,0,-1],[23,22,1,-1],[22,21,0,-1],[20,20,0,-1],[24,20,0,-1],[22,20,0,-1],[23,21,0,-1],
  [22,20,0,-1],[23,20,0,-1],[22,21,0,-1],[22,21,0],[18,21,0],[18,21,0],[27,21,0],[27,21,0],
  [8,13,0,-1],[10,19,6,2],[7,7,-14,-3],[7,7,-14,-7],[9,4,-15,-4],[11,7,-14,-3],[13,2,-16,-2],[7,6,-15,-9],
  [10,6,6,-3],[16,22,1,-1],[23,15,1,-1],[24,15,1,-1],[16,19,3],[29,20,0,-1],[31,22,1,-2],[23,24,2,-1],
  [10,4,-8],[6,21,0,-2],[13,11,-10,-1],[25,27,6,-1],[14,24,2,-1],[25,24,2,-1],[24,22,1,-1],[6,11,-10,-2],
  [8,30,8,-3],[9,30,8,-1],[13,14,-8,-2],[23,23,4,-1],[6,11,6,-2],[10,3,-5],[5,5,0,-2],[14,30,8,-1],
  [15,20,1,-1],[13,19,0,-2],[14,19,0,-1],[15,20,1,-1],[16,19,0],[14,20,1,-1],[15,20,1,-1],[16,21,1,-1],
  [15,20,1,-1],[15,20,1,-1],[5,13,0,-2],[5,19,6,-2],[6,21,6,-2],[23,9,-3,-1],[13,21,6,-1],[13,21,0,-1],
  [23,22,1,-1],[23,21,0,-1],[21,20,0,-1],[22,22,1,-1],[23,20,0,-1],[20,20,0,-1],[19,20,0,-1],[24,22,1,-1],
  [24,20,0,-1],[11,20,0,-1],[16,21,1],[24,20,0,-1],[18,20,0,-1],[30,20,0,-1],[24,20,0,-1],[23,22,1,-1],
  [20,20,0,-1],[23,27,6,-1],[24,21,1,-1],[16,22,1,-1],[21,20,0,-1],[24,21,1,-1],[25,21,1],[34,21,1],
  [24,20,0,-1],[25,20,0],[18,20,0,-1],[6,30,8,-3],[13,10,-10,-4],[6,30,8],[10,5,-15,-3],[5,6,-15,-2],
  [6,10,-10,-1],[16,15,1,-1],[17,22,1,-1],[13,15,1,-1],[17,22,1,-1],[15,15,1],[12,21,0,-1],[16,20,6,-1],
  [17,21,0,-1],[8,21,0,-1],[10,27,6,2],[16,21,0,-1],[8,21,0,-1],[27,13,0,-1],[17,13,0,-1],[16,15,1],
  [17,19,6,-1],[17,19,6,-1],[12,13,0,-1],[11,15,1,-1],[12,20,1],[17,14,1,-1],[17,14,1],[24,14,1],
  [17,13,0],[17,19,6],[13,13,0,-1],[17,2,-7],[34,2,-7],[11,6,-15,-4],[11,4,-17,-3],[11,5,-16,-3],
  [12,53,94,135,175,216,257,298,
  339,380,421,462,502,543,584,625],[37,72,106,140,175,209,243,278],[670,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmbx10:[[21,24,0,-1],[29,24,0,-2],[27,25,1,-2],[25,24,0,-1],[24,23,0,-1],[29,24,0,-1],[24,24,0,-2],[27,24,0,-2],
  [24,24,0,-2],[27,24,0,-2],[26,24,0,-1],[25,24,0,-1],[20,24,0,-1],[20,24,0,-1],[31,24,0,-1],[31,24,0,-1],
  [9,16,0,-1],[12,23,7,2],[8,7,-17,-4],[8,7,-17,-8],[11,6,-17,-4],[13,7,-17,-3],[15,3,-18,-2],[9,6,-18,-10],
  [11,7,7,-4],[19,25,1,-1],[27,17,1,-1],[29,17,1,-1],[18,23,4,-1],[34,24,0,-1],[37,25,1,-2],[27,28,2,-2],
  [11,5,-9],[6,24,0,-3],[15,13,-11,-1],[29,31,7,-2],[16,28,2,-2],[29,28,2,-2],[28,25,1,-1],[7,13,-11,-2],
  [10,35,9,-3],[10,35,9,-2],[15,16,-10,-2],[27,27,5,-2],[7,13,7,-2],[11,5,-5],[6,6,0,-2],[16,35,9,-2],
  [17,24,1,-1],[15,23,0,-2],[17,23,0,-1],[17,24,1,-1],[18,23,0,-1],[16,24,1,-2],[17,24,1,-1],[17,24,1,-2],
  [17,24,1,-1],[17,24,1,-1],[6,16,0,-2],[7,23,7,-2],[6,24,7,-3],[27,11,-3,-2],[15,24,7,-2],[15,24,0,-2],
  [27,25,1,-2],[28,24,0,-1],[25,24,0,-1],[24,25,1,-2],[27,24,0,-1],[24,24,0,-1],[22,24,0,-1],[27,25,1,-2],
  [29,24,0,-1],[13,24,0,-1],[18,25,1],[28,24,0,-1],[21,24,0,-1],[35,24,0,-1],[29,24,0,-1],[26,25,1,-2],
  [24,24,0,-1],[26,31,7,-2],[29,25,1,-1],[18,25,1,-2],[25,23,0,-1],[28,25,1,-1],[29,25,1],[40,25,1],
  [28,24,0,-1],[29,24,0],[20,24,0,-2],[6,35,9,-4],[16,13,-11,-4],[7,35,9],[11,6,-18,-4],[6,6,-18,-2],
  [6,13,-11,-2],[18,17,1,-1],[20,25,1,-1],[16,17,1,-1],[20,25,1,-1],[16,17,1,-1],[14,24,0,-1],[18,23,7,-1],
  [20,24,0,-1],[9,24,0,-1],[12,31,7,2],[19,24,0,-1],[9,24,0,-1],[31,16,0,-1],[20,16,0,-1],[18,17,1,-1],
  [20,23,7,-1],[20,23,7,-1],[14,16,0,-1],[14,17,1,-1],[13,23,1],[20,17,1,-1],[20,17,1],[28,17,1],
  [20,16,0],[20,23,7],[15,16,0,-1],[20,2,-8],[39,2,-8],[13,8,-17,-4],[14,4,-20,-3],[13,6,-18,-3],
  [14,64,113,162,211,260,309,359,
  408,457,506,555,604,653,703,752],[46,87,128,170,211,253,294,335],[806,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmbx10:[[26,28,0,-1],[35,29,0,-2],[32,30,1,-2],[31,29,0,-1],[28,28,0,-2],[35,28,0,-1],[30,29,0,-2],[32,29,0,-2],
  [30,29,0,-2],[32,29,0,-2],[30,29,0,-2],[30,29,0,-1],[24,29,0,-1],[24,29,0,-1],[37,29,0,-1],[37,29,0,-1],
  [11,19,0,-1],[14,28,9,3],[10,8,-21,-4],[10,8,-21,-9],[13,6,-21,-5],[15,9,-20,-4],[18,3,-22,-3],[10,7,-22,-13],
  [13,9,9,-5],[23,30,1,-1],[32,20,1,-1],[35,20,1,-1],[22,28,5,-1],[41,29,0,-1],[44,30,1,-3],[32,34,3,-2],
  [14,6,-11],[7,29,0,-4],[18,15,-14,-1],[35,37,8,-2],[19,34,3,-2],[35,34,3,-2],[33,30,1,-2],[8,15,-14,-3],
  [12,42,11,-4],[12,42,11,-2],[18,19,-12,-3],[32,32,6,-2],[8,15,8,-3],[13,5,-7],[7,7,0,-3],[19,42,11,-2],
  [21,28,1,-1],[18,27,0,-3],[20,27,0,-2],[20,28,1,-2],[22,27,0,-1],[20,28,1,-2],[20,28,1,-2],[21,29,1,-2],
  [20,28,1,-2],[20,28,1,-2],[7,19,0,-3],[7,27,8,-3],[7,30,9,-4],[32,13,-4,-2],[18,30,9,-2],[18,29,0,-2],
  [32,30,1,-2],[33,29,0,-1],[30,29,0,-1],[30,30,1,-2],[33,29,0,-1],[29,28,0,-1],[27,28,0,-1],[33,30,1,-2],
  [35,29,0,-1],[16,29,0,-1],[21,30,1,-1],[34,29,0,-1],[26,29,0,-1],[43,29,0,-1],[35,29,0,-1],[31,30,1,-2],
  [29,29,0,-1],[31,37,8,-2],[35,30,1,-1],[22,30,1,-2],[30,28,0,-1],[34,30,1,-1],[34,30,1,-1],[47,30,1,-1],
  [34,29,0,-1],[35,29,0],[25,29,0,-2],[7,42,11,-5],[19,15,-14,-5],[7,42,11,-1],[13,8,-21,-5],[7,7,-22,-3],
  [8,15,-14,-2],[22,20,1,-1],[24,30,1,-1],[19,20,1,-1],[24,30,1,-1],[20,20,1,-1],[17,29,0,-1],[22,28,9,-1],
  [25,29,0,-1],[11,29,0,-1],[14,38,9,3],[24,29,0,-1],[11,29,0,-1],[38,19,0,-1],[25,19,0,-1],[22,20,1,-1],
  [24,27,8,-1],[24,27,8,-1],[18,19,0,-1],[16,20,1,-1],[16,27,1],[25,20,1,-1],[23,20,1,-1],[32,20,1,-1],
  [24,19,0],[24,28,9],[18,19,0,-1],[24,2,-10],[48,2,-10],[16,9,-21,-5],[16,5,-24,-4],[16,7,-22,-4],
  [17,76,135,194,253,311,370,429,
  488,547,606,664,723,782,841,900],[55,104,154,203,253,302,352,401],[964,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmbx10:[[31,34,0,-1],[42,35,0,-2],[38,36,1,-3],[36,35,0,-2],[34,34,0,-2],[42,34,0,-1],[35,34,0,-3],[38,35,0,-3],
  [35,34,0,-3],[38,34,0,-3],[37,35,0,-2],[36,35,0,-1],[29,35,0,-1],[29,35,0,-1],[45,35,0,-1],[45,35,0,-1],
  [12,22,0,-2],[17,32,10,3],[12,10,-25,-5],[12,10,-25,-11],[16,7,-25,-6],[18,10,-24,-5],[22,3,-27,-3],[13,9,-26,-15],
  [16,10,10,-6],[27,36,1,-1],[39,24,1,-1],[42,24,1,-1],[26,32,5,-1],[48,34,0,-2],[52,36,1,-4],[38,40,3,-3],
  [15,7,-13,-1],[9,35,0,-4],[22,18,-16,-1],[41,44,10,-3],[22,40,3,-3],[41,40,3,-3],[39,36,1,-2],[9,18,-16,-4],
  [14,50,13,-5],[14,50,13,-3],[22,22,-15,-3],[38,38,7,-3],[9,18,10,-4],[16,6,-8],[8,8,0,-4],[22,50,13,-3],
  [24,34,1,-2],[21,32,0,-4],[24,33,0,-2],[24,34,1,-2],[26,33,0,-1],[24,33,1,-2],[24,34,1,-2],[25,35,1,-3],
  [24,34,1,-2],[24,34,1,-2],[8,22,0,-4],[8,32,10,-4],[9,35,10,-4],[38,15,-5,-3],[21,35,10,-3],[21,35,0,-3],
  [38,36,1,-3],[39,35,0,-2],[36,34,0,-1],[35,36,1,-3],[39,34,0,-1],[35,34,0,-1],[32,34,0,-1],[39,36,1,-3],
  [42,34,0,-1],[19,34,0,-1],[25,35,1,-1],[41,34,0,-1],[31,34,0,-1],[50,34,0,-2],[42,34,0,-1],[37,36,1,-3],
  [35,34,0,-1],[37,45,10,-3],[41,35,1,-1],[26,36,1,-3],[35,34,0,-2],[41,35,1,-1],[41,35,1,-1],[56,35,1,-1],
  [40,34,0,-1],[42,34,0],[29,34,0,-3],[9,50,13,-6],[22,18,-16,-6],[9,50,13,-1],[16,8,-26,-6],[8,8,-26,-4],
  [9,18,-16,-3],[27,24,1,-1],[29,35,1,-1],[23,24,1,-1],[29,35,1,-1],[24,24,1,-1],[20,35,0,-2],[27,33,10,-1],
  [29,34,0,-2],[12,34,0,-2],[17,44,10,3],[28,34,0,-1],[13,34,0,-2],[44,22,0,-2],[29,22,0,-2],[26,24,1,-1],
  [29,32,10,-1],[29,32,10,-1],[21,22,0,-1],[20,24,1,-1],[18,33,1,-1],[29,23,1,-2],[28,23,1,-1],[39,23,1,-1],
  [28,22,0,-1],[28,32,10,-1],[22,22,0,-1],[29,3,-12],[57,3,-12],[17,10,-25,-7],[20,6,-28,-4],[19,7,-27,-5],
  [21,91,162,233,303,374,445,516,
  586,657,728,798,869,940,1010,1081],[64,124,183,243,302,362,421,481],[1158,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmbx10:[[36,41,0,-2],[50,42,0,-3],[46,43,1,-3],[44,42,0,-2],[41,40,0,-2],[49,41,0,-2],[43,41,0,-3],[46,42,0,-3],
  [43,41,0,-3],[46,41,0,-3],[43,42,0,-3],[43,42,0,-1],[35,42,0,-1],[35,42,0,-1],[54,42,0,-1],[54,42,0,-1],
  [15,27,0,-2],[20,39,12,4],[13,12,-30,-7],[13,12,-30,-14],[18,9,-30,-8],[22,12,-29,-6],[26,4,-32,-4],[15,11,-31,-18],
  [19,12,12,-7],[32,43,1,-2],[46,28,1,-2],[50,28,1,-1],[31,40,7,-1],[58,41,0,-2],[63,43,1,-4],[46,48,4,-3],
  [18,8,-16,-1],[10,42,0,-5],[26,21,-20,-2],[50,53,12,-3],[28,49,4,-3],[50,49,4,-3],[48,43,1,-2],[11,21,-20,-4],
  [17,60,15,-6],[17,60,15,-3],[26,27,-18,-4],[46,46,8,-3],[11,22,12,-4],[19,6,-10],[10,10,0,-4],[28,60,15,-3],
  [30,40,1,-2],[25,39,0,-5],[28,39,0,-3],[29,40,1,-2],[31,39,0,-1],[28,40,1,-3],[29,40,1,-2],[30,41,1,-3],
  [29,40,1,-2],[29,40,1,-2],[10,27,0,-4],[11,39,12,-4],[10,43,13,-5],[46,18,-6,-3],[26,42,12,-3],[26,42,0,-3],
  [46,43,1,-3],[47,42,0,-2],[43,41,0,-2],[43,43,1,-3],[47,41,0,-2],[41,41,0,-2],[38,41,0,-2],[47,43,1,-3],
  [49,41,0,-2],[22,41,0,-2],[31,42,1,-1],[49,41,0,-2],[36,41,0,-2],[60,41,0,-2],[49,41,0,-2],[45,43,1,-3],
  [41,41,0,-2],[45,54,12,-3],[49,42,1,-2],[31,43,1,-3],[43,40,0,-2],[48,42,1,-2],[49,42,1,-1],[68,42,1,-1],
  [48,41,0,-2],[50,41,0,-1],[35,41,0,-3],[11,60,15,-7],[26,21,-20,-8],[11,60,15,-1],[19,10,-31,-7],[10,10,-31,-4],
  [11,21,-20,-3],[32,28,1,-1],[34,42,1,-2],[27,28,1,-2],[34,42,1,-2],[29,28,1,-1],[24,42,0,-2],[32,39,12,-1],
  [35,41,0,-2],[15,41,0,-2],[20,53,12,4],[33,41,0,-2],[16,41,0,-2],[54,27,0,-2],[35,27,0,-2],[31,28,1,-1],
  [34,39,12,-2],[34,39,12,-2],[24,27,0,-2],[23,28,1,-2],[22,39,1,-1],[35,28,1,-2],[34,28,1,-1],[47,28,1,-1],
  [34,27,0,-1],[34,39,12,-1],[27,27,0,-1],[34,3,-15],[68,3,-15],[21,12,-30,-8],[23,7,-34,-5],[22,9,-32,-6],
  [25,110,195,280,364,449,534,619,
  704,789,874,959,1043,1128,1213,1298],[77,149,220,292,363,434,506,577],[1390,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmex10:[[6,9,8,3],[3,9,8],[2,10,9,-1],[2,10,9],[2,10,9,-1],[2,10,9],[2,9,8,-1],[2,9,8],
  [2,9,8,-1],[2,9,8,-1],[3,9,8],[3,9,8],[1,5,5,-1],[2,5,5,-1],[4,9,8],[4,9,8],
  [7,14,13,3],[3,14,13],[4,18,17,-1],[4,18,17],[3,18,17,-1],[2,18,17],[3,18,17,-1],[3,18,17],
  [3,18,17,-1],[3,18,17],[4,18,17,-1],[4,18,17,-1],[4,18,17,-1],[5,18,17],[7,18,17],[7,18,17],
  [9,22,21,3],[4,22,21],[3,22,21,-1],[3,22,21],[4,22,21,-1],[3,22,21],[4,22,21,-1],[3,22,21],
  [4,22,21,-1],[4,22,21,-1],[4,22,21,-1],[5,22,21],[9,22,21],[9,22,21],[6,14,13],[6,14,13],
  [9,14,13,3],[5,14,13],[3,14,13,-2],[3,14,13],[3,14,13,-2],[3,14,13],[1,5,5,-2],[2,5,5,-1],
  [3,7,7,-2],[3,7,7,-1],[3,7,7,-2],[3,7,7,-1],[3,13,13,-1],[3,13,13,-2],[2,3,3,-2],[1,5,5,-2],
  [9,14,13,3],[5,14,13],[1,5,5,-2],[2,5,5,-3],[4,14,13],[4,14,13],[6,7,7],[8,10,10],
  [5,8,8],[7,16,16],[8,7,7],[11,10,10],[11,7,7,3],[11,10,10],[11,7,7,3],[11,10,10],
  [10,8,7,3],[7,7,7],[5,8,8],[6,7,7],[6,7,7],[6,7,7],[6,7,7],[6,7,7],
  [10,10,10],[9,10,10],[7,16,16],[8,10,10],[8,10,10],[8,10,10],[8,10,10],[8,10,10],
  [10,8,7,3],[9,10,10],[4,1,-4],[7,2,-4],[10,2,-4],[4,1,-4],[7,2,-4],[10,2,-4],
  [6,19,13,3],[2,14,13],[3,14,13,-1],[3,14,13],[3,14,13,-1],[3,14,13],[3,14,13,-1],[3,14,13,-1],
  [10,9,8,3],[6,13,13,-1],[6,17,17,-1],[6,21,21,-1],[5,13,13,-1],[2,5,5,-4],[4,5,4,-4],[3,5,5,-1],
  [3,5,5,-1],[4,4,4],[5,3,2,1],[4,3,2],[4,3,0],[4,3,0],[5,5,5],[5,4,4],
  [3,16,28,41,53,66,78,91,
  103,116,129,141,154,166,179,191],[11,42,72,103,134,165,196,226],[205,256]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmex10:[[3,10,9,-1],[3,11,10],[2,11,10,-1],[2,11,10],[3,11,10,-1],[3,10,10],[3,11,10,-1],[3,10,9],
  [3,11,10,-1],[3,11,10,-1],[3,9,9],[3,11,10],[1,5,5,-1],[3,5,5,-1],[4,10,10],[4,10,9],
  [4,15,14,-1],[4,15,14],[5,20,19,-1],[5,20,19],[2,20,19,-2],[3,20,19],[3,20,19,-2],[3,20,19],
  [3,20,19,-2],[3,20,19],[4,20,19,-1],[4,20,19,-1],[5,20,19,-1],[5,20,19],[8,20,19],[8,20,19],
  [5,25,24,-1],[5,25,24],[3,25,24,-2],[3,25,24],[3,25,24,-2],[3,25,24],[3,25,24,-2],[3,25,24],
  [5,25,24,-1],[5,25,24,-1],[5,25,24,-1],[5,25,24,-1],[10,25,24],[10,25,24],[6,15,14],[6,15,14],
  [5,16,15,-2],[5,16,15],[4,15,14,-2],[3,15,14],[4,16,15,-2],[3,16,15],[2,5,5,-2],[1,5,5,-2],
  [3,8,8,-3],[3,8,8,-1],[3,9,8,-3],[3,9,8,-1],[3,16,15,-1],[3,16,15,-3],[1,4,3,-3],[1,5,5,-2],
  [5,15,14,-2],[5,15,14],[2,5,5,-2],[2,5,5,-3],[4,15,14,-1],[4,15,14],[7,8,8],[9,12,12],
  [5,9,9],[8,18,18],[9,8,8],[12,12,12],[9,8,8],[12,12,12],[9,8,8],[12,12,12],
  [8,8,8],[7,8,8],[5,9,9],[7,8,8],[7,8,8],[7,8,8],[7,8,8],[7,8,8],
  [11,12,12],[10,12,12],[8,18,18],[9,12,12],[9,12,12],[9,12,12],[9,12,12],[9,12,12],
  [7,8,8],[10,12,12],[5,2,-4],[8,2,-4],[12,3,-4],[5,1,-5],[8,1,-5],[12,1,-5],
  [3,16,15,-1],[2,16,15],[3,15,15,-1],[3,16,15],[3,15,14,-1],[3,15,14],[4,15,14,-1],[4,15,14,-1],
  [7,10,10,-1],[7,14,14,-1],[7,19,19,-1],[7,24,24,-1],[5,15,15,-1],[1,5,5,-5],[4,6,5,-5],[3,5,5,-2],
  [4,5,5,-1],[4,5,5,-1],[5,3,2,1],[5,3,2,1],[5,3,0,1],[5,3,0,1],[6,5,5],[6,5,5],
  [4,19,34,49,64,79,94,109,
  124,139,154,169,184,199,215,230],[13,50,87,124,161,198,235,272],[246,308]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmex10:[[3,13,12,-1],[3,13,12],[2,13,12,-2],[3,13,12],[3,13,12,-2],[3,13,12],[3,13,12,-2],[3,13,12],
  [4,13,12,-1],[4,13,12,-1],[3,13,12,-1],[4,13,12],[1,8,7,-1],[4,8,7,-1],[6,13,12],[6,13,12],
  [5,19,18,-1],[5,19,18],[5,25,24,-2],[6,25,24],[4,25,24,-2],[3,25,24],[4,25,24,-2],[4,25,24],
  [4,25,24,-2],[4,25,24],[6,25,24,-1],[6,25,24,-1],[6,25,24,-1],[6,25,24,-1],[10,25,24],[10,25,24],
  [6,31,30,-2],[6,31,30],[4,31,30,-2],[4,31,30],[5,31,30,-2],[4,31,30],[5,31,30,-2],[4,31,30],
  [6,31,30,-1],[6,31,30,-1],[6,31,30,-1],[6,31,30,-1],[13,31,30],[13,31,30],[8,19,18],[8,19,18],
  [7,19,18,-2],[6,19,18],[4,19,18,-3],[4,19,18],[4,19,18,-3],[4,19,18],[1,6,6,-3],[2,6,6,-2],
  [5,10,10,-3],[4,10,10,-1],[5,10,9,-3],[4,10,9,-1],[4,20,19,-1],[4,20,19,-3],[2,5,4,-3],[1,6,6,-3],
  [7,19,18,-2],[6,19,18],[2,8,7,-2],[2,8,7,-4],[5,19,18,-1],[4,19,18,-1],[8,10,10],[11,14,14],
  [6,12,12],[10,23,23],[11,10,10],[15,14,14],[14,10,10,3],[15,14,14],[14,10,10,3],[15,14,14],
  [10,10,10],[9,10,10],[6,12,12],[8,10,10],[8,10,10],[8,10,10],[8,10,10],[8,10,10],
  [14,14,14],[13,14,14],[10,23,23],[11,14,14],[11,14,14],[11,14,14],[11,14,14],[11,14,14],
  [9,10,10],[13,14,14],[6,3,-5],[10,3,-5],[15,3,-5],[9,3,-5,3],[10,2,-6],[15,2,-6],
  [3,19,18,-2],[3,19,18],[3,19,18,-2],[3,19,18],[3,19,18,-2],[3,19,18],[5,19,18,-1],[5,19,18,-1],
  [10,13,12,-1],[10,19,18,-1],[10,25,24,-1],[10,31,30,-1],[7,19,18,-1],[1,7,6,-7],[4,7,6,-7],[4,6,6,-2],
  [5,6,6,-1],[5,6,6,-1],[6,4,2,1],[6,5,3,1],[6,4,0,1],[6,4,0,1],[8,6,6],[8,6,6],
  [4,22,39,57,75,92,110,127,
  145,162,180,198,215,233,250,268],[15,58,101,145,188,231,274,317],[287,359]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmex10:[[4,15,14,-1],[4,15,14],[3,15,14,-2],[3,15,14],[4,15,14,-2],[4,15,14],[4,15,14,-2],[4,15,14],
  [5,15,14,-1],[5,15,14,-1],[4,15,14,-1],[4,15,14,-1],[2,8,8,-1],[4,9,8,-1],[7,15,14],[7,15,14],
  [5,22,21,-2],[5,22,21],[7,30,29,-2],[7,30,29],[4,30,29,-3],[4,30,29],[4,30,29,-3],[4,30,29],
  [4,30,29,-3],[4,30,29],[7,30,29,-1],[7,30,29,-1],[7,30,29,-1],[7,30,29,-1],[12,30,29],[12,30,29],
  [7,37,36,-2],[7,37,36],[4,37,36,-3],[4,37,36],[5,37,36,-3],[5,37,36],[5,37,36,-3],[5,37,36],
  [7,37,36,-1],[7,37,36,-1],[8,37,36,-1],[7,37,36,-1],[15,37,36],[15,37,36],[9,22,21],[9,22,21],
  [7,23,22,-3],[7,23,22],[5,23,22,-3],[5,23,22],[5,23,22,-3],[5,23,22],[2,8,8,-3],[2,8,8,-3],
  [5,11,11,-4],[4,11,11,-2],[5,12,11,-4],[4,12,11,-2],[4,23,22,-2],[5,23,22,-4],[2,5,4,-4],[2,7,7,-3],
  [7,22,21,-3],[7,22,21],[2,9,8,-3],[2,9,8,-5],[6,22,21,-1],[5,22,21,-1],[10,12,12],[13,17,17],
  [8,14,14],[12,27,27],[13,12,12],[18,17,17],[13,12,12],[18,17,17],[13,12,12],[18,17,17],
  [12,12,12],[11,12,12],[8,14,14],[10,12,12],[10,12,12],[10,12,12],[10,12,12],[10,12,12],
  [17,17,17],[15,17,17],[12,27,27],[13,17,17],[13,17,17],[13,17,17],[13,17,17],[13,17,17],
  [11,12,12],[15,17,17],[7,3,-6],[12,3,-7],[18,3,-7],[7,2,-7],[12,2,-7],[18,2,-7],
  [4,23,22,-2],[3,23,22],[4,23,22,-2],[4,23,22],[4,22,21,-2],[4,23,22],[6,22,21,-1],[6,22,21,-1],
  [12,15,14,-1],[12,22,21,-1],[12,30,29,-1],[12,37,36,-1],[8,23,22,-1],[1,9,8,-8],[5,8,7,-8],[4,8,8,-3],
  [6,7,7,-1],[6,7,7,-1],[7,5,3,1],[7,5,3,1],[7,4,0,1],[7,4,0,1],[9,8,8],[9,7,7],
  [5,27,48,69,91,112,133,155,
  176,197,219,240,261,283,304,325],[19,72,124,177,229,281,334,386],[349,437]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmex10:[[4,18,17,-2],[5,18,17],[4,18,17,-2],[3,18,17],[5,18,17,-2],[4,18,17],[5,18,17,-2],[4,18,17],
  [6,18,17,-1],[6,18,17,-1],[5,18,17,-1],[5,18,17,-1],[1,10,9,-2],[4,10,9,-2],[8,18,17],[8,17,16],
  [6,26,25,-2],[6,26,25],[8,34,33,-2],[8,34,33],[5,34,33,-3],[4,34,33],[5,34,33,-3],[5,34,33],
  [5,34,33,-3],[5,34,33],[8,34,33,-1],[8,34,33,-1],[8,34,33,-1],[8,34,33,-1],[14,34,33],[14,34,33],
  [8,43,42,-3],[8,43,42],[5,43,42,-3],[5,43,42],[6,43,42,-3],[6,43,42],[6,43,42,-3],[6,43,42],
  [8,43,42,-2],[8,43,42,-2],[8,43,42,-2],[9,43,42,-1],[17,43,42],[17,43,42],[11,26,25],[11,26,25],
  [8,26,25,-4],[9,26,25],[6,26,25,-4],[5,26,25],[6,26,25,-4],[5,26,25],[2,9,9,-4],[2,9,9,-3],
  [5,13,13,-5],[6,13,13,-2],[5,14,13,-5],[6,14,13,-2],[6,27,26,-2],[5,27,26,-5],[3,6,5,-5],[1,9,9,-4],
  [8,26,25,-4],[9,26,25],[2,10,9,-4],[3,10,9,-6],[7,26,25,-1],[6,26,25,-1],[11,14,14],[15,20,20],
  [9,16,16],[14,31,31],[15,14,14],[21,20,20],[15,14,14],[21,20,20],[15,14,14],[21,20,20],
  [14,14,14],[13,14,14],[9,16,16],[11,14,14],[11,14,14],[11,14,14],[11,14,14],[11,14,14],
  [20,20,20],[18,20,20],[14,31,31],[15,20,20],[15,20,20],[15,20,20],[15,20,20],[15,20,20],
  [13,14,14],[18,20,20],[8,3,-8],[14,3,-8],[21,3,-8],[8,3,-8],[14,3,-8],[20,3,-8],
  [4,26,25,-3],[4,26,25],[5,26,25,-3],[5,26,25],[5,26,25,-3],[5,26,25],[7,26,25,-1],[7,26,25,-1],
  [14,18,17,-1],[14,26,25,-1],[14,34,33,-1],[14,43,42,-1],[10,26,25,-1],[2,10,9,-9],[6,9,8,-9],[5,9,9,-3],
  [7,9,9,-1],[7,9,9,-1],[8,5,3,1],[8,5,3,1],[8,5,0,1],[8,5,0,1],[11,9,9],[11,9,9],
  [6,31,56,82,107,132,157,182,
  207,232,257,282,307,332,358,383],[23,84,146,208,269,331,392,454],[410,514]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmex10:[[5,21,20,-2],[6,21,20],[4,21,20,-3],[4,21,20],[5,21,20,-3],[5,21,20],[5,21,20,-3],[5,21,20],
  [6,21,20,-2],[6,21,20,-2],[6,21,20,-1],[6,21,20,-1],[2,12,11,-2],[5,12,11,-2],[8,21,20,-1],[8,21,20,-1],
  [7,31,30,-3],[8,31,30],[9,42,41,-3],[9,41,40],[5,42,41,-4],[5,42,41],[6,42,41,-4],[6,42,41],
  [6,42,41,-4],[6,42,41],[9,41,40,-2],[9,42,41,-2],[9,41,40,-2],[10,41,40,-1],[16,41,40,-1],[16,41,40,-1],
  [9,52,51,-4],[10,52,51],[6,52,51,-4],[6,52,51],[7,52,51,-4],[7,52,51],[7,52,51,-4],[7,52,51],
  [10,52,51,-2],[10,52,51,-2],[10,52,51,-2],[11,52,51,-1],[20,52,51,-1],[20,52,51,-1],[12,31,30,-1],[12,31,30,-1],
  [10,32,31,-5],[10,32,31],[7,31,30,-5],[6,31,30],[7,31,30,-5],[6,31,30],[2,11,11,-5],[2,11,11,-4],
  [7,16,16,-6],[7,16,16,-2],[7,17,16,-6],[6,17,16,-3],[7,32,31,-2],[7,32,31,-6],[3,7,6,-6],[1,11,11,-5],
  [10,31,30,-5],[10,31,30],[2,12,11,-5],[2,12,11,-8],[7,31,30,-2],[8,31,30,-1],[13,17,17,-1],[17,24,24,-1],
  [10,19,19,-1],[15,38,38,-1],[17,17,17,-1],[24,24,24,-1],[17,17,17,-1],[24,24,24,-1],[17,17,17,-1],[24,24,24,-1],
  [16,17,17,-1],[14,17,17,-1],[10,19,19,-1],[13,17,17,-1],[13,17,17,-1],[13,17,17,-1],[13,17,17,-1],[13,17,17,-1],
  [23,24,24,-1],[20,24,24,-1],[15,38,38,-1],[17,24,24,-1],[17,24,24,-1],[17,24,24,-1],[17,24,24,-1],[17,24,24,-1],
  [14,17,17,-1],[20,24,24,-1],[10,4,-9],[17,4,-9],[25,4,-9],[10,3,-10],[17,3,-10],[25,3,-10],
  [5,31,30,-3],[5,31,30],[6,31,30,-3],[6,31,30],[6,31,30,-3],[6,31,30],[8,31,30,-2],[8,31,30,-2],
  [16,21,20,-2],[16,31,30,-2],[16,42,41,-2],[16,52,51,-2],[11,32,31,-2],[2,12,11,-11],[8,11,10,-11],[5,11,11,-4],
  [9,11,11,-1],[8,10,10,-2],[9,6,4,1],[9,6,4,1],[9,6,0,1],[9,6,0,1],[12,11,11,-1],[12,10,10,-1],
  [7,38,68,98,128,158,188,218,
  248,278,309,339,369,399,429,459],[26,100,174,248,322,396,470,544],[492,616]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmex10:[[6,24,23,-3],[6,24,23,-1],[4,25,24,-4],[5,25,24],[5,25,24,-4],[6,25,24],[5,25,24,-4],[6,25,24],
  [8,25,24,-2],[8,25,24,-2],[6,25,24,-2],[7,24,23,-1],[2,14,13,-2],[7,14,13,-2],[10,25,24,-1],[10,24,23,-1],
  [9,37,36,-3],[9,37,36],[10,49,48,-4],[11,49,48],[6,49,48,-5],[6,49,48],[7,49,48,-5],[7,49,48],
  [7,49,48,-5],[7,49,48],[11,49,48,-2],[11,49,48,-2],[11,49,48,-2],[11,49,48,-2],[19,49,48,-1],[19,49,48,-1],
  [11,61,60,-4],[12,61,60],[7,61,60,-5],[7,61,60],[8,61,60,-5],[8,61,60],[8,61,60,-5],[8,61,60],
  [12,61,60,-2],[12,61,60,-2],[12,61,60,-2],[12,61,60,-2],[24,61,60,-1],[24,61,60,-1],[14,37,36,-1],[14,37,36,-1],
  [12,37,36,-5],[12,37,36],[8,37,36,-6],[7,37,36],[8,37,36,-6],[7,37,36],[2,12,12,-6],[2,12,12,-5],
  [8,19,19,-7],[8,19,19,-3],[8,19,18,-7],[8,19,18,-3],[8,38,37,-3],[8,38,37,-7],[4,8,7,-7],[2,12,12,-6],
  [12,37,36,-5],[12,37,36],[3,14,13,-5],[3,14,13,-9],[9,36,35,-2],[9,37,36,-1],[15,20,20,-1],[21,28,28,-1],
  [12,23,23,-1],[18,45,45,-1],[20,20,20,-1],[28,28,28,-1],[20,20,20,-1],[28,28,28,-1],[20,20,20,-1],[28,28,28,-1],
  [19,20,20,-1],[17,20,20,-1],[12,23,23,-1],[15,20,20,-1],[15,20,20,-1],[15,20,20,-1],[15,20,20,-1],[15,20,20,-1],
  [27,28,28,-1],[24,28,28,-1],[18,45,45,-1],[21,28,28,-1],[21,28,28,-1],[21,28,28,-1],[20,28,28,-1],[20,28,28,-1],
  [17,20,20,-1],[24,28,28,-1],[12,4,-11],[20,5,-11],[29,5,-11],[11,3,-12],[20,3,-12],[29,3,-12],
  [5,37,36,-4],[5,37,36],[7,37,36,-4],[6,37,36],[7,37,36,-4],[6,37,36],[9,37,36,-2],[9,37,36,-2],
  [19,25,24,-2],[19,37,36,-2],[19,49,48,-2],[19,61,60,-2],[13,37,36,-2],[1,14,13,-14],[8,13,12,-14],[6,12,12,-5],
  [9,12,12,-2],[9,12,12,-2],[11,8,5,1],[11,8,5,1],[11,7,0,1],[11,7,0,1],[14,12,12,-1],[14,12,12,-1],
  [9,45,81,117,154,190,226,262,
  298,334,370,406,443,479,515,551],[31,120,209,297,386,475,564,652],[591,739]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmex10:[[7,29,28,-3],[7,29,28,-1],[6,29,28,-4],[6,29,28],[7,29,28,-4],[7,29,28],[7,29,28,-4],[7,29,28],
  [10,29,28,-2],[10,29,28,-2],[8,29,28,-2],[8,29,28,-1],[2,16,15,-3],[7,16,15,-3],[12,29,28,-1],[12,29,28,-1],
  [10,44,43,-4],[9,44,43,-1],[12,58,57,-5],[12,58,57,-1],[7,58,57,-6],[7,58,57],[8,58,57,-6],[8,58,57],
  [8,58,57,-6],[8,58,57],[12,58,57,-3],[12,58,57,-3],[13,58,57,-3],[13,58,57,-2],[23,58,57,-1],[23,58,57,-1],
  [14,72,71,-5],[14,72,71],[8,72,71,-6],[8,72,71],[9,72,71,-6],[9,72,71],[9,72,71,-6],[9,72,71],
  [13,72,71,-3],[13,72,71,-3],[14,72,71,-3],[14,72,71,-2],[29,72,71,-1],[29,72,71,-1],[17,44,43,-1],[17,44,43,-1],
  [14,44,43,-7],[14,44,43],[9,44,43,-7],[9,44,43],[9,44,43,-7],[9,44,43],[3,15,15,-7],[3,15,15,-6],
  [9,22,22,-9],[9,22,22,-4],[9,23,22,-9],[9,23,22,-4],[9,45,44,-4],[9,45,44,-9],[4,9,8,-9],[2,15,15,-7],
  [13,45,43,-7],[14,45,43],[3,16,15,-7],[3,16,15,-11],[11,44,43,-2],[10,44,43,-2],[18,24,24,-1],[25,34,34,-1],
  [14,27,27,-1],[22,54,54,-1],[25,24,24,-1],[34,34,34,-1],[25,24,24,-1],[34,34,34,-1],[25,24,24,-1],[34,34,34,-1],
  [23,24,24,-1],[21,24,24,-1],[14,27,27,-1],[18,24,24,-1],[18,24,24,-1],[18,24,24,-1],[18,24,24,-1],[18,24,24,-1],
  [33,34,34,-1],[29,34,34,-1],[22,54,54,-1],[25,34,34,-1],[25,34,34,-1],[25,34,34,-1],[25,34,34,-1],[25,34,34,-1],
  [21,24,24,-1],[29,34,34,-1],[14,5,-13],[24,6,-13],[35,6,-13],[14,4,-14],[24,3,-15],[35,3,-15],
  [6,44,43,-5],[6,44,43],[8,44,43,-5],[8,44,43],[8,44,43,-5],[8,44,43],[12,44,43,-2],[12,44,43,-2],
  [23,29,28,-2],[23,44,43,-2],[23,58,57,-2],[23,72,71,-2],[16,45,44,-2],[2,16,15,-16],[10,15,14,-16],[7,15,15,-6],
  [12,15,15,-2],[12,15,15,-2],[12,9,6,1],[13,9,6,1],[12,8,0,1],[13,8,0,1],[17,15,15,-1],[17,15,15,-1],
  [11,54,98,141,184,228,271,315,
  358,401,445,488,532,575,619,662],[39,145,252,358,465,571,678,785],[709,888]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmex10:[[8,36,34,-4],[8,36,34,-1],[7,36,34,-5],[7,36,34],[8,36,34,-5],[8,36,34],[8,36,34,-5],[8,36,34],
  [11,36,34,-3],[11,36,34,-3],[10,36,34,-2],[9,36,34,-2],[2,19,18,-4],[8,19,18,-4],[14,36,34,-1],[14,36,34,-1],
  [12,53,51,-5],[11,53,51,-1],[15,71,69,-6],[15,71,69,-1],[8,71,69,-7],[8,71,69],[10,71,69,-7],[10,71,69],
  [10,71,69,-7],[10,71,69],[15,71,69,-3],[15,71,69,-3],[16,71,69,-3],[16,71,69,-2],[28,71,69,-1],[28,71,69,-1],
  [16,88,86,-6],[16,88,86,-1],[9,88,86,-8],[9,88,86],[11,88,86,-8],[11,88,86],[11,88,86,-8],[11,88,86],
  [16,88,86,-4],[16,88,86,-4],[17,88,86,-4],[17,88,86,-3],[35,88,86,-1],[35,88,86,-1],[21,53,51,-1],[21,53,51,-1],
  [17,54,52,-8],[16,54,52,-1],[11,53,51,-9],[10,53,51],[11,53,51,-9],[10,53,51],[3,18,18,-9],[3,18,18,-7],
  [10,27,27,-11],[10,27,27,-5],[10,27,26,-11],[10,28,27,-5],[10,54,53,-5],[10,54,53,-11],[4,10,9,-11],[2,18,18,-9],
  [17,53,51,-8],[16,53,51,-1],[4,19,18,-8],[4,19,18,-13],[13,53,51,-3],[13,53,51,-2],[22,29,29,-1],[30,41,41,-1],
  [17,33,33,-1],[27,65,65,-1],[30,29,29,-1],[42,41,41,-1],[30,29,29,-1],[42,41,41,-1],[30,29,29,-1],[42,41,41,-1],
  [28,29,29,-1],[25,29,29,-1],[17,33,33,-1],[22,29,29,-1],[22,29,29,-1],[22,29,29,-1],[22,29,29,-1],[22,29,29,-1],
  [40,41,41,-1],[35,41,41,-1],[27,65,65,-1],[30,41,41,-1],[30,41,41,-1],[30,41,41,-1],[30,41,41,-1],[30,41,41,-1],
  [25,29,29,-1],[35,41,41,-1],[17,6,-16],[29,7,-16],[42,7,-16],[16,4,-17],[29,4,-18],[42,4,-18],
  [8,53,51,-6],[8,53,51],[9,53,51,-6],[9,53,51],[9,53,51,-6],[9,53,51],[13,53,51,-3],[13,53,51,-3],
  [27,35,34,-3],[27,52,51,-3],[27,70,69,-3],[27,87,86,-3],[19,54,53,-3],[2,19,18,-20],[12,19,17,-20],[9,18,18,-7],
  [14,18,18,-3],[14,18,18,-3],[15,11,7,1],[15,11,7,1],[15,10,0,1],[15,10,0,1],[20,18,18,-1],[20,18,18,-1],
  [13,65,117,169,221,273,325,377,
  428,480,532,584,636,688,740,792],[45,173,300,428,555,683,810,938],[849,1062]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmex10:[[9,42,40,-5],[10,42,40,-1],[8,42,40,-6],[8,42,40],[10,42,40,-6],[10,42,40],[10,42,40,-6],[10,42,40],
  [12,42,40,-4],[12,42,40,-4],[11,42,40,-3],[11,42,40,-2],[3,22,21,-4],[10,22,21,-4],[16,42,40,-2],[16,42,40,-2],
  [13,62,60,-6],[14,62,60,-1],[17,83,81,-7],[17,83,81,-1],[10,83,81,-8],[10,83,81],[12,83,81,-8],[12,83,81],
  [12,83,81,-8],[12,83,81],[17,83,81,-4],[17,83,81,-4],[19,83,81,-4],[19,83,81,-3],[32,83,81,-2],[32,83,81,-2],
  [18,103,101,-8],[18,103,101,-1],[11,103,101,-9],[11,103,101],[13,103,101,-9],[13,103,101],[13,103,101,-9],[13,103,101],
  [19,103,101,-4],[19,103,101,-4],[20,103,101,-4],[20,103,101,-3],[40,103,101,-2],[40,103,101,-2],[24,62,60,-2],[24,62,60,-2],
  [20,63,61,-9],[19,63,61,-1],[12,62,60,-11],[12,62,60],[12,62,60,-11],[12,62,60],[3,21,21,-11],[3,21,21,-9],
  [12,31,31,-13],[13,31,31,-5],[12,32,31,-13],[13,32,31,-5],[13,63,62,-5],[12,63,62,-13],[5,12,11,-13],[3,21,21,-10],
  [20,62,60,-9],[19,62,60,-1],[5,22,21,-9],[4,22,21,-16],[15,62,60,-3],[14,62,60,-3],[26,34,34,-1],[35,48,48,-1],
  [19,38,38,-2],[31,76,76,-1],[35,34,34,-1],[49,48,48,-1],[35,34,34,-1],[49,48,48,-1],[35,34,34,-1],[49,48,48,-1],
  [33,34,34,-1],[30,34,34,-1],[19,38,38,-2],[26,34,34,-1],[26,34,34,-1],[26,34,34,-1],[25,34,34,-2],[25,34,34,-2],
  [46,48,48,-1],[41,48,48,-1],[31,76,76,-1],[35,48,48,-1],[35,48,48,-1],[35,48,48,-1],[34,48,48,-2],[35,48,48,-1],
  [30,34,34,-1],[41,48,48,-1],[19,7,-19],[34,8,-19],[49,8,-19],[19,5,-20],[34,5,-21],[49,5,-21],
  [9,62,60,-7],[9,62,60],[11,62,60,-7],[11,62,60],[11,62,60,-7],[11,62,60],[15,62,60,-4],[15,62,60,-4],
  [32,42,40,-3],[32,62,60,-3],[32,83,81,-3],[32,103,101,-3],[23,63,62,-3],[3,22,21,-23],[14,22,20,-23],[10,21,21,-8],
  [16,21,21,-3],[16,21,21,-3],[17,13,8,1],[18,13,8,1],[17,12,0,1],[18,12,0,1],[24,21,21,-1],[24,21,21,-1],
  [16,78,141,203,265,328,390,453,
  515,578,640,703,765,828,890,953],[55,209,362,515,669,822,976,1129],[1021,1278]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmex10:[[11,50,48,-6],[12,50,48,-1],[9,50,48,-8],[9,50,48],[11,50,48,-8],[11,50,48],[11,50,48,-8],[11,50,48],
  [16,50,48,-4],[16,50,48,-4],[12,50,48,-4],[13,50,48,-3],[3,27,26,-5],[12,27,26,-5],[20,50,48,-2],[20,50,48,-2],
  [16,75,73,-7],[17,75,73,-1],[21,99,97,-8],[21,99,97,-1],[11,99,97,-10],[12,99,97],[14,99,97,-10],[14,99,97],
  [14,99,97,-10],[14,99,97],[21,99,97,-5],[21,99,97,-5],[22,99,97,-5],[22,99,97,-4],[39,99,97,-2],[39,99,97,-2],
  [22,124,122,-9],[22,124,122,-1],[13,124,122,-11],[13,124,122],[15,124,122,-11],[15,124,122],[15,124,122,-11],[15,124,122],
  [23,124,122,-5],[23,124,122,-5],[24,124,122,-5],[24,124,122,-4],[48,124,122,-2],[48,124,122,-2],[29,75,73,-2],[29,74,72,-2],
  [24,75,73,-11],[23,75,73,-1],[14,75,73,-13],[14,75,73],[14,75,73,-13],[14,75,73],[4,25,25,-13],[3,25,25,-11],
  [15,38,38,-15],[14,38,38,-7],[15,38,37,-15],[14,38,37,-7],[14,76,75,-7],[15,76,75,-15],[6,14,13,-15],[3,25,25,-12],
  [24,75,73,-11],[23,75,73,-1],[6,26,25,-11],[5,26,25,-19],[18,75,73,-4],[18,75,73,-3],[30,41,41,-2],[42,58,58,-2],
  [23,46,46,-2],[37,92,92,-2],[42,41,41,-2],[58,58,58,-2],[42,41,41,-2],[58,58,58,-2],[42,41,41,-2],[58,58,58,-2],
  [39,41,41,-2],[35,41,41,-2],[23,46,46,-2],[30,41,41,-2],[30,41,41,-2],[30,41,41,-2],[30,41,41,-2],[30,41,41,-2],
  [55,58,58,-2],[49,58,58,-2],[37,92,92,-2],[42,58,58,-2],[42,58,58,-2],[42,58,58,-2],[42,58,58,-2],[42,58,58,-2],
  [35,41,41,-2],[49,58,58,-2],[23,8,-23],[41,9,-23],[60,9,-23],[23,6,-24],[41,6,-25],[59,6,-25],
  [10,75,73,-9],[10,75,73],[12,75,73,-9],[13,75,73],[12,75,73,-9],[13,75,73],[19,75,73,-4],[19,75,73,-4],
  [38,50,48,-4],[38,75,73,-4],[38,99,97,-4],[38,124,122,-4],[27,75,74,-4],[3,27,26,-28],[16,26,24,-28],[12,25,25,-10],
  [19,25,25,-4],[19,25,25,-4],[20,14,9,1],[21,14,9,1],[20,14,0,1],[21,14,0,1],[28,25,25,-2],[28,25,25,-2],
  [19,93,168,243,318,392,467,542,
  617,692,766,841,916,991,1066,1140],[66,249,433,617,800,984,1167,1351],[1222,1530]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmex10:[[14,59,57,-7],[13,59,57,-2],[11,59,57,-9],[10,59,57,-1],[13,59,57,-9],[13,59,57,-1],[13,59,57,-9],[13,59,57,-1],
  [18,59,57,-5],[18,59,57,-5],[16,59,57,-4],[16,59,57,-3],[3,32,31,-7],[14,32,31,-7],[24,59,57,-2],[24,59,57,-2],
  [20,89,87,-8],[20,89,87,-1],[25,118,116,-10],[25,118,116,-1],[14,118,116,-12],[14,118,116],[16,118,116,-12],[17,118,116],
  [16,118,116,-12],[17,118,116],[25,118,116,-6],[25,118,116,-6],[26,118,116,-6],[27,118,116,-4],[47,118,116,-2],[47,118,116,-2],
  [26,147,145,-11],[27,147,145,-1],[15,147,145,-13],[15,147,145],[18,147,145,-13],[18,147,145],[18,147,145,-13],[18,147,145],
  [26,147,145,-7],[26,147,145,-7],[29,147,145,-6],[28,147,145,-5],[58,147,145,-2],[58,147,145,-2],[35,89,87,-2],[35,89,87,-2],
  [28,89,87,-14],[28,89,87,-1],[17,89,87,-16],[17,89,87],[17,89,87,-16],[17,89,87],[4,30,30,-16],[4,30,30,-13],
  [18,45,45,-18],[17,45,45,-8],[18,45,44,-18],[17,45,44,-8],[17,90,89,-8],[18,90,89,-18],[7,17,16,-18],[3,30,30,-15],
  [28,90,87,-14],[28,90,87,-1],[6,31,30,-14],[6,31,30,-23],[21,89,87,-5],[21,89,87,-4],[36,49,49,-2],[50,69,69,-2],
  [28,55,55,-2],[45,109,109,-2],[50,49,49,-2],[70,69,69,-2],[50,49,49,-2],[70,69,69,-2],[50,49,49,-2],[70,69,69,-2],
  [47,49,49,-2],[42,49,49,-2],[28,55,55,-2],[36,49,49,-2],[36,49,49,-2],[36,49,49,-2],[36,49,49,-2],[36,49,49,-2],
  [66,69,69,-2],[58,69,69,-2],[45,109,109,-2],[50,69,69,-2],[50,69,69,-2],[50,69,69,-2],[50,69,69,-2],[50,69,69,-2],
  [42,49,49,-2],[58,69,69,-2],[29,10,-27,1],[49,10,-28],[71,10,-28],[27,7,-29],[49,7,-30],[71,7,-30],
  [12,89,87,-11],[12,89,87],[14,89,87,-11],[15,89,87],[14,89,87,-11],[15,89,87],[22,89,87,-5],[22,89,87,-5],
  [45,59,57,-5],[45,89,87,-5],[45,118,116,-5],[45,147,145,-5],[32,90,89,-5],[3,32,31,-34],[19,31,29,-34],[14,30,30,-12],
  [23,30,30,-5],[23,30,30,-5],[25,17,11,2],[25,17,11,1],[25,17,0,2],[25,17,0,1],[34,30,30,-2],[34,29,29,-2],
  [22,112,202,292,382,472,561,651,
  741,831,921,1011,1100,1190,1280,1370],[78,298,519,740,960,1181,1401,1622],[1468,1836]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmex10:[[16,72,69,-9],[16,72,69,-2],[13,72,69,-11],[12,72,69,-1],[16,72,69,-11],[15,72,69,-1],[16,72,69,-11],[15,72,69,-1],
  [22,72,69,-6],[22,72,69,-6],[19,72,69,-5],[18,72,69,-4],[4,39,37,-8],[17,39,37,-8],[28,72,69,-3],[28,72,69,-3],
  [23,107,104,-10],[23,107,104,-2],[30,143,140,-12],[30,143,140,-2],[17,143,140,-14],[17,143,140],[20,143,140,-14],[20,143,140],
  [20,143,140,-14],[20,143,140],[30,143,140,-7],[30,143,140,-7],[32,143,140,-7],[32,143,140,-5],[56,143,140,-3],[56,143,140,-3],
  [32,178,175,-13],[31,178,175,-2],[18,178,175,-16],[19,178,175],[21,178,175,-16],[22,178,175],[21,178,175,-16],[22,178,175],
  [31,178,175,-8],[31,178,175,-8],[34,178,175,-8],[34,178,175,-6],[69,178,175,-3],[69,178,175,-3],[42,107,104,-3],[42,107,104,-3],
  [33,108,105,-17],[33,108,105,-2],[20,107,104,-19],[21,107,104],[20,107,104,-19],[21,107,104],[5,37,36,-19],[5,37,36,-16],
  [21,54,54,-22],[20,54,54,-10],[21,54,53,-22],[20,54,53,-10],[20,108,107,-10],[21,108,107,-22],[8,20,19,-22],[3,37,36,-18],
  [33,107,104,-17],[33,107,104,-2],[7,37,36,-17],[8,37,36,-27],[25,107,104,-6],[25,107,104,-5],[43,59,59,-3],[60,83,83,-3],
  [33,66,66,-3],[53,132,132,-3],[60,59,59,-3],[83,83,83,-3],[60,59,59,-3],[83,83,83,-3],[60,59,59,-3],[83,83,83,-3],
  [56,59,59,-3],[50,59,59,-3],[33,66,66,-3],[43,59,59,-3],[43,59,59,-3],[43,59,59,-3],[43,59,59,-3],[43,59,59,-3],
  [79,83,83,-3],[69,83,83,-3],[53,132,132,-3],[60,83,83,-3],[60,83,83,-3],[60,83,83,-3],[60,83,83,-3],[60,83,83,-3],
  [50,59,59,-3],[69,83,83,-3],[34,11,-33,1],[60,12,-34,1],[86,12,-34],[33,8,-35],[59,9,-36],[85,9,-36],
  [14,107,104,-13],[14,107,104,-1],[17,107,104,-13],[17,107,104,-1],[17,107,104,-13],[17,107,104,-1],[26,107,104,-7],[26,107,104,-7],
  [55,72,69,-6],[55,107,104,-6],[55,143,140,-6],[55,178,175,-6],[38,109,107,-6],[3,39,37,-41],[23,38,35,-41],[16,37,36,-15],
  [27,36,36,-6],[27,36,36,-6],[30,21,13,2],[29,21,13,1],[30,20,0,2],[29,20,0,1],[40,36,36,-3],[40,35,35,-3],
  [27,135,243,350,458,566,674,782,
  890,998,1106,1213,1321,1429,1537,1645],[93,358,623,888,1153,1418,1683,1947],[1762,2205]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmmi10:[[5,5,0],[6,5,0],[6,6,1],[5,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0],
  [5,5,0],[5,5,0],[6,5,0],[5,3,0],[4,6,1],[4,5,2],[3,5,0],[3,3,0],
  [4,7,2],[4,5,2],[4,5,0],[3,3,0],[4,3,0],[4,5,0],[4,5,2],[4,3,0],
  [3,7,2],[4,3,0],[4,5,2],[4,3,0],[4,3,0],[4,3,0],[4,7,2],[4,5,2],
  [5,7,2],[5,3,0],[3,5,1],[4,5,0],[6,3,0],[4,5,2],[3,4,1],[5,5,2],
  [7,3,-1],[9,2,0,2],[7,3,-1],[9,2,0,2],[4,3,-1,2],[2,3,-1],[4,4,0],[4,4,0],
  [4,5,1],[3,3,0],[4,4,0],[4,6,2],[4,6,2],[3,5,2],[4,6,1],[4,5,2],
  [4,6,1],[4,6,2],[2,1,0],[2,2,1],[5,5,1],[3,7,2],[5,5,1],[4,4,0],
  [4,6,1],[5,5,0],[6,5,0],[6,6,1],[6,5,0],[6,5,0],[6,5,0],[6,6,1],
  [6,5,0],[4,5,0],[5,6,1],[6,5,0],[5,5,0],[7,5,0],[8,5,0,2],[6,6,1],
  [6,5,0],[6,7,2],[6,6,1],[5,6,1],[5,5,0],[6,6,1],[6,5,0],[7,5,0],
  [8,5,0,2],[6,5,0],[5,5,0],[3,5,0],[3,7,2],[3,7,2],[7,2,-1],[9,2,-1,2],
  [3,5,0],[4,3,0],[3,5,0],[3,3,0],[4,5,0],[3,3,0],[4,7,2],[4,5,2],
  [4,5,0],[2,5,0],[3,7,2],[4,5,0],[2,5,0],[6,3,0],[4,3,0],[4,3,0],
  [4,5,2],[3,5,2],[3,3,0],[3,3,0],[3,5,0],[4,3,0],[4,3,0],[5,3,0],
  [4,3,0],[4,5,2],[3,3,0],[2,3,0],[3,5,2],[5,5,2],[4,2,-3,-1],[3,1,-4,-2],
  [3,11,19,28,36,44,53,61,
  69,77,86,94,102,111,119,127],[9,17,26,34,42,51,59,67],[137,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmmi10:[[6,6,0],[7,6,0],[6,7,1],[6,6,0],[7,6,0],[7,6,0],[7,6,0],[6,6,0],
  [5,6,0],[6,6,0],[7,6,0],[5,5,1],[5,8,2],[5,6,2],[4,6,0],[3,4,0],
  [4,8,2],[4,6,2],[4,6,0],[3,4,0],[5,4,0],[5,6,0],[5,6,2],[5,4,0],
  [4,8,2],[5,4,0],[4,6,2],[5,5,1],[4,4,0],[5,4,0],[5,8,2],[5,6,2],
  [5,8,2],[5,4,0],[4,5,1],[5,6,0],[7,4,0],[4,6,2],[4,5,1],[5,6,2],
  [8,3,-1],[8,3,0],[8,3,-1],[8,3,0],[2,3,-1],[2,3,-1],[4,4,0],[4,4,0],
  [4,5,1],[3,4,0,-1],[4,4,0],[4,6,2],[4,6,2],[4,6,2],[4,7,1],[4,6,2],
  [4,7,1],[4,6,2],[2,1,0],[2,3,2],[6,6,1],[4,8,2],[6,6,1],[4,4,0],
  [5,7,1],[6,6,0],[6,6,0],[6,7,1],[7,6,0],[6,6,0],[6,6,0],[6,7,1],
  [7,6,0],[4,6,0],[5,7,1],[7,6,0],[5,6,0],[9,6,0],[9,6,0,2],[6,7,1],
  [6,6,0],[6,8,2],[6,7,1],[6,7,1],[6,6,0],[6,7,1],[6,6,0],[9,6,0],
  [9,6,0,2],[6,6,0],[6,6,0],[3,6,0],[3,8,2],[3,8,2],[8,2,-1],[8,2,-1],
  [4,6,0],[4,4,0],[4,6,0],[4,5,1],[4,6,0],[4,4,0],[5,8,2],[4,6,2],
  [5,6,0],[3,6,0],[3,8,2],[4,6,0],[2,6,0],[7,4,0],[5,4,0],[4,5,1],
  [4,6,2],[4,6,2],[4,4,0],[4,5,1],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [5,4,0],[4,6,2],[4,4,0],[3,4,0],[3,6,2],[5,6,2],[4,2,-4,-1],[4,2,-4,-2],
  [3,13,23,33,43,53,63,73,
  83,93,103,113,123,133,143,153],[11,21,31,41,51,61,71,81],[164,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmmi10:[[8,7,0],[8,7,0],[8,8,1],[7,7,0],[8,7,0],[9,7,0],[8,7,0],[7,7,0],
  [7,7,0],[7,7,0],[8,7,0],[6,6,1],[6,9,2],[6,7,2],[5,8,0],[4,6,1],
  [5,9,2],[5,7,2],[5,8,1],[4,6,1],[6,6,1],[6,7,0],[6,7,2],[6,5,0],
  [5,9,2],[6,5,0],[5,7,2],[6,5,0],[5,5,0],[6,6,1],[6,9,2],[6,7,2],
  [7,9,2],[6,6,1],[5,6,1],[6,8,1],[8,5,0],[5,7,2],[4,6,1],[7,7,2],
  [10,3,-2],[12,3,0,2],[10,3,-2],[10,3,0],[5,3,-2,2],[3,3,-2],[5,5,0],[5,5,0],
  [5,6,1],[3,5,0,-1],[5,5,0],[5,7,2],[5,7,2],[5,7,2],[5,8,1],[5,7,2],
  [5,8,1],[5,7,2],[2,1,0],[2,3,2],[6,7,1,-1],[5,10,2],[6,7,1,-1],[5,5,0],
  [6,9,1],[7,7,0],[8,7,0],[8,8,1],[8,7,0],[8,7,0],[8,7,0],[8,8,1],
  [9,7,0],[5,7,0],[7,8,1],[9,7,0],[7,7,0],[11,7,0],[11,7,0,2],[8,8,1],
  [8,7,0],[8,9,2],[8,8,1],[7,8,1],[7,7,0],[8,8,1],[8,8,1],[11,8,1],
  [11,7,0,2],[8,7,0],[8,7,0],[4,9,1],[4,9,2],[4,9,2],[10,3,-1],[12,3,-1,2],
  [4,7,0],[5,6,1],[5,8,1],[5,5,0],[6,8,1],[5,5,0],[6,9,2],[5,7,2],
  [6,7,0],[3,7,0],[4,9,2],[5,7,0],[3,7,0],[9,5,0],[6,6,1],[5,5,0],
  [6,7,2,1],[5,7,2],[5,5,0],[5,5,0],[4,8,1],[6,6,1],[5,6,1],[7,6,1],
  [6,6,1],[5,7,2],[5,5,0],[3,5,0],[5,7,2,1],[7,7,2],[5,2,-5,-2],[5,2,-5,-2],
  [4,15,27,39,50,62,74,85,
  97,108,120,132,143,155,167,178],[13,24,36,47,59,71,82,94],[191,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmmi10:[[9,9,0],[10,9,0],[9,10,1],[8,9,0],[10,9,0],[11,9,0],[10,9,0],[9,9,0],
  [8,9,0],[9,9,0],[9,9,0,-1],[8,7,1],[7,12,3],[7,9,3],[6,10,1],[5,7,1],
  [6,12,3],[6,9,3],[6,9,0],[4,7,1],[7,7,1],[7,10,1],[7,9,3],[7,6,0],
  [6,12,3],[7,6,0],[6,9,3],[7,7,1],[6,7,1],[7,7,1],[7,12,3],[7,9,3],
  [8,12,3],[8,7,1],[5,7,1],[7,10,1],[10,7,1],[6,9,3],[5,8,2],[8,9,3],
  [12,4,-2],[15,4,0,3],[15,4,-2,3],[15,4,0,3],[6,4,-2,3],[3,4,-2],[6,6,0],[6,6,0],
  [6,7,1],[4,6,0,-1],[6,6,0],[6,9,3],[6,9,3],[6,9,3],[6,9,1],[6,9,3],
  [6,9,1],[6,9,3],[2,2,0,-1],[2,5,3,-1],[8,8,1,-1],[6,12,3],[8,8,1,-1],[6,6,0],
  [7,10,1],[9,9,0],[9,9,0],[9,10,1],[10,9,0],[10,9,0],[9,9,0],[9,10,1],
  [11,9,0],[6,9,0],[8,10,1],[11,9,0],[8,9,0],[12,9,0],[14,9,0,3],[9,10,1],
  [9,9,0],[9,12,3],[9,10,1],[8,10,1],[9,9,0],[9,10,1],[8,10,1,-1],[12,10,1],
  [13,9,0,3],[9,9,0],[9,9,0],[4,10,1],[3,12,3,-1],[4,12,3],[12,4,-1],[15,4,-1,3],
  [5,10,1],[6,7,1],[5,10,1],[6,7,1],[6,10,1],[5,7,1],[7,12,3],[6,9,3],
  [7,9,0],[4,8,0],[6,11,3,1],[6,10,1],[3,10,1],[11,7,1],[7,7,1],[6,7,1],
  [7,9,3,1],[6,9,3],[6,6,0],[5,7,1],[4,9,1],[7,7,1],[6,7,1],[9,7,1],
  [7,7,1],[6,9,3],[6,7,1],[4,6,0],[6,9,3,1],[8,9,3],[6,3,-6,-2],[5,2,-6,-3],
  [5,19,33,47,61,75,89,104,
  118,132,146,160,174,188,202,216],[16,30,45,59,73,87,101,115],[232,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmmi10:[[10,10,0],[11,10,0],[11,11,1],[10,10,0],[11,10,0],[13,10,0],[11,10,0,-1],[10,10,0],
  [9,10,0],[10,10,0],[10,10,0,-1],[9,8,1],[9,13,3],[8,10,3],[7,11,1],[6,7,1],
  [7,13,3],[7,10,3],[7,11,1],[5,8,1],[8,8,1],[8,11,1],[8,9,3],[8,7,0],
  [7,13,3],[8,7,1],[7,10,3],[8,7,1],[8,7,1],[8,8,1],[8,13,3],[9,10,3],
  [9,13,3],[9,8,1],[6,8,1],[8,11,1],[12,7,1],[6,10,3,-1],[6,9,2],[9,10,3],
  [14,4,-3],[14,4,0],[14,4,-3],[17,4,0,3],[3,4,-3],[3,4,-3],[7,7,0],[7,7,0],
  [7,8,1],[5,7,0,-1],[7,7,0],[7,10,3],[7,10,3],[7,10,3],[7,11,1],[7,10,3],
  [7,11,1],[7,10,3],[2,2,0,-1],[2,5,3,-1],[9,9,1,-1],[7,15,4],[9,9,1,-1],[7,7,0],
  [8,11,1],[10,10,0],[11,10,0],[11,11,1],[12,10,0],[11,10,0],[11,10,0],[11,11,1],
  [13,10,0],[7,10,0],[8,11,1,-1],[13,10,0],[9,10,0],[15,10,0],[16,10,0,3],[11,11,1],
  [11,10,0],[11,13,3],[11,11,1],[9,11,1],[10,10,0],[10,11,1,-1],[11,11,1],[14,11,1],
  [15,10,0,3],[11,10,0],[10,10,0],[5,12,1],[4,13,3,-1],[5,13,3],[12,4,-1,-1],[12,4,-2,-1],
  [6,11,1],[7,8,1],[6,11,1],[6,8,1],[8,11,1],[6,8,1],[8,13,3],[7,10,3],
  [8,11,1],[4,11,1],[7,13,3,1],[7,11,1],[4,11,1],[12,8,1],[8,8,1],[7,8,1],
  [8,10,3,1],[7,10,3],[6,8,1],[6,8,1],[5,10,1],[8,8,1],[7,8,1],[10,8,1],
  [8,8,1],[7,10,3],[7,8,1],[4,8,1],[6,10,3,1],[8,10,3,-1],[7,3,-7,-2],[6,3,-7,-3],
  [6,22,39,55,72,89,105,122,
  138,155,172,188,205,221,238,255],[19,36,52,69,85,102,119,135],[273,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmmi10:[[13,12,0],[13,13,0,-1],[13,13,1],[12,12,0],[13,12,0,-1],[15,12,0],[13,12,0,-1],[12,12,0],
  [11,12,0],[12,12,0],[13,12,0,-1],[11,9,1],[10,16,4],[10,12,4],[8,14,1],[7,9,1],
  [8,16,4],[9,12,4],[8,13,1],[5,9,1,-1],[9,9,1,-1],[9,13,1,-1],[10,12,4],[8,8,0,-1],
  [8,16,4],[10,9,1],[9,12,4],[10,9,1],[9,9,1],[9,9,1],[10,16,4],[10,12,4],
  [11,16,4],[11,9,1],[8,9,1],[10,13,1],[14,9,1],[8,12,4,-1],[7,10,2],[11,12,4],
  [15,6,-3,-1],[15,6,1,-1],[15,6,-3,-1],[15,6,1,-1],[3,4,-4,-1],[3,5,-3,-1],[8,9,0],[8,9,0],
  [8,9,1],[6,8,0,-1],[8,8,0],[8,12,4],[8,12,4],[8,12,4],[8,13,1],[8,12,4,-1],
  [8,13,1],[8,12,4],[3,2,0,-1],[3,6,4,-1],[11,11,1,-1],[7,17,4,-1],[11,11,1,-1],[9,9,0],
  [10,14,1],[13,13,0],[13,12,0],[13,13,1],[14,12,0],[13,12,0],[13,12,0],[13,13,1],
  [15,12,0],[9,12,0],[10,13,1,-1],[15,12,0],[11,12,0],[18,12,0],[18,12,0,3],[13,13,1],
  [13,12,0],[13,16,4],[13,13,1],[10,13,1,-1],[12,12,0],[12,13,1,-1],[12,13,1,-1],[17,13,1,-1],
  [18,12,0,3],[13,12,0],[12,12,0,-1],[6,14,1],[5,17,4,-1],[5,16,4,-1],[15,5,-2,-1],[15,5,-2,-1],
  [7,13,1],[9,9,1],[7,13,1],[8,9,1],[9,13,1],[8,9,1],[9,16,4,-1],[8,12,4],
  [9,13,1,-1],[5,13,1],[8,16,4,1],[8,13,1,-1],[5,13,1],[15,9,1],[10,9,1],[8,9,1],
  [10,12,4,1],[8,12,4],[8,9,1],[7,9,1],[6,12,1],[10,9,1],[8,9,1],[12,9,1],
  [9,9,1],[9,12,4],[8,9,1],[5,9,1],[8,12,4,1],[10,12,4,-1],[8,4,-8,-3],[7,3,-9,-4],
  [7,27,46,66,86,106,126,146,
  166,186,206,226,246,266,286,306],[22,42,61,81,101,121,141,161],[328,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmmi10:[[15,14,0],[15,15,0,-1],[14,16,1,-1],[14,15,0],[15,14,0,-1],[18,14,0],[15,14,0,-1],[14,14,0],
  [13,14,0],[14,14,0],[15,15,0,-1],[12,10,1],[12,18,4],[11,14,5],[9,16,1],[7,10,1,-1],
  [10,19,5],[10,14,5],[10,15,1],[6,10,1,-1],[10,10,1,-1],[10,15,1,-1],[12,14,5],[10,9,0,-1],
  [9,19,5],[12,10,1],[10,14,5],[12,10,1],[11,10,1],[11,10,1],[11,18,4,-1],[12,14,5],
  [13,18,4],[13,10,1],[9,10,1],[12,16,1],[17,10,1],[9,13,4,-1],[9,12,3],[12,14,5,-1],
  [18,7,-4,-1],[18,7,1,-1],[18,7,-4,-1],[18,7,1,-1],[4,6,-4,-1],[4,6,-4,-1],[10,10,0],[10,10,0],
  [10,10,1],[7,9,0,-2],[8,9,0,-1],[10,14,5],[10,14,4],[8,14,5,-1],[10,15,1],[9,15,5,-1],
  [10,15,1],[10,14,5],[3,3,0,-1],[3,7,4,-1],[13,12,1,-1],[8,20,5,-1],[13,12,1,-1],[10,10,0],
  [12,16,1],[15,15,0],[16,14,0],[15,16,1,-1],[17,14,0],[16,14,0],[15,14,0],[15,16,1,-1],
  [18,14,0],[10,14,0],[12,15,1,-1],[18,14,0],[13,14,0],[21,14,0],[18,14,0],[14,16,1,-1],
  [15,14,0],[14,19,4,-1],[15,15,1],[12,16,1,-1],[14,14,0],[15,15,1,-1],[15,15,1,-1],[20,15,1,-1],
  [17,14,0],[16,14,0],[14,14,0,-1],[6,16,1,-1],[6,20,5,-1],[6,20,5,-1],[18,6,-2,-1],[18,6,-2,-1],
  [8,15,1],[10,10,1],[8,15,1,-1],[9,10,1],[11,15,1],[9,10,1],[10,19,4,-1],[10,14,5],
  [10,15,1,-1],[6,15,1],[9,19,5,1],[10,15,1,-1],[6,15,1],[17,10,1],[12,10,1],[10,10,1],
  [11,13,4,1],[9,13,4],[9,10,1],[8,10,1,-1],[7,14,1],[11,10,1],[10,10,1],[14,10,1],
  [11,10,1],[10,14,5],[9,10,1,-1],[6,10,1],[9,14,5,1],[12,14,5,-1],[10,5,-10,-3],[8,4,-10,-5],
  [8,32,56,80,104,128,151,175,
  199,223,247,271,295,319,343,367],[26,50,74,98,122,145,169,193],[393,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmmi10:[[17,17,0,-1],[18,18,0,-1],[17,18,1,-1],[16,18,0],[18,17,0,-1],[20,17,0,-1],[19,17,0,-1],[17,17,0],
  [16,17,0],[17,17,0],[18,17,0,-1],[14,12,1,-1],[15,22,5],[13,16,5],[10,18,1,-1],[8,12,1,-1],
  [11,22,5,-1],[12,17,6],[10,18,1,-1],[7,12,1,-1],[12,12,1,-1],[12,18,1,-1],[14,17,6],[12,11,0,-1],
  [11,22,5],[14,12,1],[12,17,6],[14,12,1],[13,12,1],[13,12,1],[13,22,5,-1],[15,16,5],
  [16,22,5],[15,12,1],[11,12,1],[14,18,1],[20,12,1],[11,16,5,-1],[10,14,3],[14,17,6,-1],
  [22,8,-5,-1],[22,8,1,-1],[22,8,-5,-1],[22,8,1,-1],[5,7,-5,-1],[5,7,-5,-1],[12,12,0],[12,12,0],
  [10,12,1,-1],[8,11,0,-2],[10,11,0,-1],[10,17,6,-1],[12,17,5],[10,17,6,-1],[10,17,1,-1],[11,17,6,-1],
  [10,17,1,-1],[10,17,6,-1],[3,3,0,-2],[3,8,5,-2],[15,14,1,-2],[10,24,6,-1],[15,14,1,-2],[12,12,0],
  [13,19,1,-1],[18,18,0],[18,17,0,-1],[18,18,1,-1],[19,17,0,-1],[18,17,0,-1],[17,17,0,-1],[18,18,1,-1],
  [20,17,0,-1],[12,17,0],[14,18,1,-1],[21,17,0,-1],[15,17,0,-1],[24,17,0,-1],[20,17,0,-1],[17,18,1,-1],
  [18,17,0,-1],[17,22,5,-1],[17,18,1,-1],[15,18,1,-1],[17,17,0],[18,18,1,-1],[18,18,1,-1],[24,18,1,-1],
  [25,17,0,4],[18,17,0,-1],[17,17,0,-1],[7,19,1,-1],[7,24,6,-1],[7,24,6,-1],[22,6,-3,-1],[22,7,-3,-1],
  [10,18,1],[11,12,1,-1],[9,18,1,-1],[10,12,1,-1],[12,18,1,-1],[10,12,1,-1],[13,22,5,-1],[12,16,5],
  [12,18,1,-1],[7,17,1],[11,21,5,1],[12,18,1,-1],[6,18,1,-1],[21,12,1],[14,12,1],[11,12,1,-1],
  [13,16,5,1],[10,16,5,-1],[11,12,1],[9,12,1,-1],[8,16,1],[13,12,1],[12,12,1],[17,12,1],
  [13,12,1],[12,16,5],[11,12,1,-1],[7,12,1],[10,16,5,1],[14,17,6,-1],[11,5,-12,-4],[10,3,-13,-6],
  [10,38,67,96,124,153,182,211,
  239,268,297,326,354,383,412,440],[32,61,90,118,147,176,204,233],[472,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmmi10:[[20,20,0,-1],[22,21,0,-1],[21,22,1,-1],[19,21,0,-1],[22,20,0,-1],[25,20,0,-1],[23,20,0,-1],[21,21,0],
  [19,20,0],[20,20,0],[21,21,0,-2],[17,14,1,-1],[18,27,6],[16,20,7],[13,22,1,-1],[10,14,1,-1],
  [13,27,6,-1],[15,20,7],[13,22,1,-1],[9,14,1,-1],[15,14,1,-1],[15,22,1,-1],[17,20,7],[15,13,0,-1],
  [13,27,6],[17,14,1],[15,20,7],[16,14,1,-1],[15,14,1],[16,14,1],[16,26,6,-1],[17,19,6,-1],
  [19,26,6],[18,14,1],[13,15,1],[17,22,1],[24,14,1],[13,19,6,-2],[12,17,4],[17,20,7,-1],
  [27,9,-6,-1],[27,9,1,-1],[27,9,-6,-1],[27,9,1,-1],[6,8,-6,-1],[6,8,-6,-1],[14,16,1],[14,16,1],
  [13,15,1,-1],[11,13,0,-2],[12,14,0,-1],[13,21,7,-1],[14,20,6],[12,20,7,-1],[13,21,1,-1],[13,21,7,-1],
  [13,21,1,-1],[13,21,7,-1],[4,3,0,-2],[4,9,6,-2],[18,18,2,-2],[12,30,8,-1],[18,17,1,-2],[15,14,0],
  [16,22,1,-1],[20,21,0,-1],[21,20,0,-1],[21,22,1,-1],[23,20,0,-1],[22,20,0,-1],[21,20,0,-1],[21,22,1,-1],
  [25,20,0,-1],[14,20,0,-1],[17,21,1,-2],[25,20,0,-1],[18,20,0,-1],[30,20,0,-1],[25,20,0,-1],[21,22,1,-1],
  [21,20,0,-1],[21,27,6,-1],[21,21,1,-1],[18,22,1,-1],[21,20,0],[20,21,1,-2],[22,21,1,-1],[30,21,1,-1],
  [29,20,0,4],[21,20,0,-1],[20,20,0,-1],[9,23,1,-1],[7,28,7,-2],[9,28,7,-1],[27,8,-3,-1],[27,8,-3,-1],
  [12,22,1],[14,14,1,-1],[11,22,1,-1],[12,14,1,-1],[14,22,1,-1],[12,14,1,-1],[15,27,6,-1],[14,19,6],
  [15,22,1,-1],[9,21,1],[13,26,6,1],[14,22,1,-1],[7,22,1,-1],[25,14,1],[17,14,1],[13,14,1,-1],
  [16,19,6,1],[12,19,6,-1],[13,14,1],[12,14,1,-1],[10,20,1],[16,14,1],[14,14,1],[20,14,1],
  [16,14,1],[15,19,6],[13,14,1,-1],[9,14,1],[12,19,6,1],[16,20,7,-2],[13,6,-15,-5],[12,5,-15,-7],
  [11,46,80,115,149,183,218,252,
  286,321,355,390,424,458,493,527],[37,72,106,140,175,209,243,278],[565,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmmi10:[[24,24,0,-1],[26,25,0,-1],[25,25,1,-1],[22,25,0,-1],[26,23,0,-1],[29,24,0,-1],[26,24,0,-2],[23,24,0,-1],
  [22,24,0],[23,24,0,-1],[25,24,0,-2],[20,16,1,-1],[20,31,7],[19,23,8],[15,26,1,-1],[12,16,1,-1],
  [15,31,7,-1],[16,23,8,-1],[15,25,1,-1],[10,16,1,-1],[18,16,1,-1],[18,25,1,-1],[19,23,8,-1],[17,15,0,-1],
  [16,31,7],[19,16,1,-1],[16,23,8,-1],[19,16,1,-1],[17,16,1,-1],[17,16,1,-1],[19,31,7,-1],[20,22,7,-1],
  [21,31,7,-1],[21,16,1],[15,17,1],[18,25,1,-1],[27,16,1,-1],[15,22,7,-2],[13,19,4,-1],[20,23,8,-1],
  [31,11,-7,-1],[31,11,1,-1],[31,11,-7,-1],[31,11,1,-1],[7,9,-7,-1],[7,9,-7,-1],[16,19,1],[16,19,1,-1],
  [15,17,1,-1],[12,16,0,-3],[15,16,0,-1],[15,24,8,-1],[15,23,7,-1],[15,24,8,-1],[15,24,1,-1],[16,24,8,-1],
  [15,24,1,-1],[15,24,8,-1],[4,4,0,-3],[4,11,7,-3],[22,21,2,-2],[13,35,9,-2],[22,21,2,-2],[17,17,0],
  [19,26,1,-1],[24,25,0,-1],[25,24,0,-1],[25,25,1,-1],[27,24,0,-1],[25,24,0,-1],[25,24,0,-1],[25,25,1,-1],
  [29,24,0,-1],[16,24,0,-1],[20,25,1,-2],[30,24,0,-1],[21,24,0,-1],[35,24,0,-1],[29,24,0,-1],[25,25,1,-1],
  [25,24,0,-1],[25,31,7,-1],[25,25,1,-1],[21,25,1,-1],[24,23,0],[24,25,1,-2],[25,25,1,-2],[35,25,1,-1],
  [28,24,0,-1],[25,24,0,-1],[23,24,0,-2],[11,27,1,-1],[9,33,8,-2],[11,33,8,-1],[30,9,-4,-2],[30,9,-4,-2],
  [14,25,1],[16,16,1,-1],[14,25,1,-1],[14,16,1,-1],[17,25,1,-1],[14,16,1,-1],[18,31,7,-1],[17,22,7],
  [18,25,1,-1],[9,24,1,-1],[15,30,7,1],[17,25,1,-1],[8,25,1,-1],[28,16,1,-1],[19,16,1,-1],[15,16,1,-1],
  [18,22,7,1],[15,22,7,-1],[14,16,1,-1],[14,16,1,-1],[12,23,1],[18,16,1,-1],[15,16,1,-1],[23,16,1,-1],
  [17,16,1,-1],[16,22,7,-1],[15,16,1,-1],[9,16,1,-1],[14,22,7,1],[19,24,8,-2],[16,8,-17,-6],[13,5,-18,-9],
  [14,55,96,138,179,221,262,303,
  345,386,427,469,510,551,593,634],[46,87,128,170,211,253,294,335],[679,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmmi10:[[29,28,0,-1],[31,30,0,-2],[29,30,1,-2],[27,30,0,-1],[30,28,0,-2],[35,28,0,-1],[31,28,0,-2],[28,29,0,-1],
  [26,28,0,-1],[28,28,0,-1],[30,29,0,-3],[24,20,1,-1],[24,37,8,-1],[23,28,9],[18,31,1,-1],[15,19,1,-1],
  [19,38,9,-1],[20,28,9,-1],[18,30,1,-1],[12,20,1,-2],[21,20,1,-2],[21,30,1,-2],[23,27,9,-1],[20,19,0,-2],
  [18,38,9,-1],[23,19,1,-1],[20,28,9,-1],[23,19,1,-1],[20,19,1,-1],[21,20,1,-1],[22,38,9,-2],[24,28,9,-1],
  [25,38,9,-1],[25,19,1],[17,20,1,-1],[22,30,1,-1],[33,19,1,-1],[18,27,8,-3],[16,24,5,-1],[24,28,9,-2],
  [37,12,-9,-2],[37,13,1,-2],[37,12,-9,-2],[37,13,1,-2],[7,10,-9,-2],[8,10,-9,-2],[19,22,1,-1],[19,22,1,-1],
  [18,20,1,-1],[15,19,0,-3],[18,19,0,-1],[18,28,9,-1],[19,27,8,-1],[17,28,9,-2],[18,29,1,-1],[18,28,9,-2],
  [18,29,1,-1],[18,28,9,-1],[5,5,0,-3],[6,13,8,-3],[26,25,2,-3],[17,42,11,-2],[26,25,2,-3],[21,20,0],
  [23,31,1,-1],[29,30,0,-1],[30,28,0,-1],[30,30,1,-2],[32,28,0,-1],[31,28,0,-1],[30,28,0,-1],[30,30,1,-2],
  [36,28,0,-1],[20,28,0,-1],[24,29,1,-2],[36,28,0,-1],[26,28,0,-1],[42,28,0,-1],[36,28,0,-1],[29,30,1,-2],
  [30,28,0,-1],[29,37,8,-2],[30,29,1,-1],[25,30,1,-2],[28,28,0,-1],[30,29,1,-2],[30,29,1,-2],[41,29,1,-2],
  [34,28,0,-1],[31,28,0,-1],[28,28,0,-2],[12,32,1,-2],[10,39,9,-3],[12,39,9,-2],[37,11,-5,-2],[37,11,-5,-2],
  [17,30,1],[20,20,1,-1],[16,30,1,-1],[17,20,1,-1],[20,30,1,-1],[17,20,1,-1],[21,38,9,-2],[20,28,9],
  [21,30,1,-2],[11,28,1,-1],[18,36,9,1],[19,30,1,-2],[10,30,1,-1],[34,20,1,-1],[23,20,1,-1],[19,20,1,-1],
  [23,27,8,2],[18,27,8,-1],[17,20,1,-1],[16,20,1,-2],[13,27,1,-1],[22,20,1,-1],[19,20,1,-1],[28,20,1,-1],
  [21,20,1,-1],[20,28,9,-1],[18,20,1,-1],[11,20,1,-1],[16,28,9,1],[23,28,9,-3],[19,9,-21,-7],[17,6,-22,-10],
  [16,66,115,165,214,264,313,363,
  412,462,511,561,610,660,709,759],[55,104,154,203,253,302,352,401],[813,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmmi10:[[34,34,0,-2],[37,35,0,-2],[35,37,2,-2],[32,35,0,-1],[36,34,0,-2],[42,34,0,-2],[38,34,0,-2],[34,35,0,-1],
  [31,34,0,-1],[33,34,0,-1],[36,35,0,-3],[28,23,1,-2],[28,45,10,-1],[27,33,11],[21,36,1,-2],[17,23,1,-2],
  [22,45,10,-2],[24,33,11,-1],[21,36,1,-2],[14,23,1,-2],[25,23,1,-2],[25,35,1,-2],[27,33,11,-1],[24,22,0,-2],
  [21,45,10,-1],[27,23,1,-1],[24,33,11,-1],[27,23,1,-1],[24,23,1,-1],[25,23,1,-1],[26,44,10,-2],[28,32,10,-1],
  [31,44,10,-1],[30,23,1],[20,25,2,-1],[27,36,1,-1],[39,23,1,-1],[22,32,10,-3],[19,28,6,-1],[29,33,11,-2],
  [45,14,-11,-2],[45,15,1,-2],[45,14,-11,-2],[45,15,1,-2],[9,12,-11,-2],[9,12,-11,-2],[23,26,1,-1],[23,26,1,-1],
  [21,25,2,-2],[17,23,0,-4],[20,23,0,-2],[21,34,11,-2],[22,33,10,-1],[20,34,11,-2],[21,35,2,-2],[22,34,11,-2],
  [21,35,2,-2],[21,34,11,-2],[6,6,0,-4],[6,16,10,-4],[30,29,2,-4],[20,50,13,-2],[30,29,2,-4],[25,24,0],
  [26,36,1,-2],[35,35,0,-1],[35,34,0,-2],[36,37,2,-2],[38,34,0,-2],[37,34,0,-1],[36,34,0,-1],[36,37,2,-2],
  [42,34,0,-2],[24,34,0,-1],[28,35,1,-3],[43,34,0,-1],[30,34,0,-2],[50,34,0,-2],[42,34,0,-2],[35,37,2,-2],
  [35,34,0,-2],[35,45,10,-2],[35,35,1,-2],[30,37,2,-2],[34,34,0,-1],[35,36,2,-3],[36,35,1,-2],[50,35,1,-2],
  [41,34,0,-1],[37,34,0,-1],[34,34,0,-2],[15,38,1,-2],[13,47,11,-3],[15,46,11,-2],[45,13,-6,-2],[45,13,-6,-2],
  [20,36,1],[23,23,1,-2],[19,35,1,-2],[19,23,1,-2],[24,35,1,-2],[19,23,1,-2],[25,45,10,-2],[24,32,10],
  [25,35,1,-2],[14,34,1,-1],[21,43,10,1],[23,35,1,-2],[11,35,1,-2],[41,23,1,-1],[27,23,1,-1],[21,23,1,-2],
  [26,32,10,2],[20,32,10,-2],[21,23,1,-1],[19,23,1,-2],[16,32,1,-1],[26,23,1,-1],[22,23,1,-1],[33,23,1,-1],
  [25,23,1,-1],[23,32,10,-1],[21,23,1,-2],[14,23,1,-1],[19,32,10,1],[28,34,11,-3],[22,10,-25,-9],[19,7,-26,-13],
  [20,79,139,198,258,317,377,436,
  495,555,614,674,733,793,852,912],[64,124,183,243,302,362,421,481],[977,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmmi10:[[41,41,0,-2],[44,43,0,-3],[42,44,2,-2],[38,43,0,-2],[43,40,0,-3],[50,41,0,-2],[45,41,0,-3],[41,42,0,-1],
  [37,41,0,-1],[40,41,0,-1],[43,42,0,-4],[34,28,1,-2],[34,54,12,-1],[31,40,13,-1],[25,43,1,-2],[21,27,1,-2],
  [26,55,13,-2],[29,40,13,-1],[25,43,1,-2],[17,27,1,-3],[30,27,1,-3],[30,42,1,-3],[33,39,13,-1],[28,26,0,-3],
  [26,54,13,-1],[33,27,1,-1],[29,40,13,-1],[32,27,1,-2],[30,27,1,-1],[30,27,1,-1],[32,53,12,-2],[34,39,13,-1],
  [37,53,12,-1],[36,27,1],[25,29,2,-1],[32,43,1,-1],[48,27,1,-1],[26,39,12,-4],[24,34,7,-1],[34,39,13,-3],
  [53,18,-13,-3],[53,17,1,-3],[53,18,-13,-3],[53,17,1,-3],[10,15,-13,-3],[11,15,-13,-3],[27,31,1,-1],[27,31,1,-1],
  [26,29,2,-2],[20,27,0,-5],[25,27,0,-2],[25,40,13,-2],[27,40,12,-1],[24,40,13,-3],[25,42,2,-2],[26,41,13,-3],
  [25,42,2,-2],[25,40,13,-2],[7,7,0,-5],[7,19,12,-5],[37,35,3,-4],[24,60,15,-3],[37,35,3,-4],[30,28,-1],
  [32,45,2,-2],[41,43,0,-2],[43,41,0,-2],[42,44,2,-3],[46,41,0,-2],[43,41,0,-2],[43,41,0,-2],[42,44,2,-3],
  [50,41,0,-2],[28,41,0,-2],[34,43,2,-4],[51,41,0,-2],[36,41,0,-2],[60,41,0,-2],[50,41,0,-2],[42,44,2,-2],
  [43,41,0,-2],[42,54,12,-2],[43,43,2,-2],[35,44,2,-3],[41,40,0,-1],[41,43,2,-4],[43,43,2,-3],[59,43,2,-3],
  [50,41,0,-1],[43,41,0,-2],[40,41,0,-3],[17,47,2,-3],[15,56,13,-4],[17,56,13,-3],[53,15,-7,-3],[53,16,-7,-3],
  [24,43,1],[28,28,1,-2],[23,42,1,-2],[24,28,1,-2],[29,42,1,-2],[24,28,1,-2],[30,54,12,-3],[28,40,13],
  [30,42,1,-3],[17,40,1,-1],[25,52,13,1],[27,42,1,-3],[14,42,1,-2],[49,28,1,-1],[33,28,1,-1],[26,28,1,-2],
  [31,38,12,2],[25,39,12,-2],[25,28,1,-1],[22,28,1,-3],[19,38,1,-1],[31,27,1,-1],[27,27,1,-1],[40,27,1,-1],
  [31,28,1,-1],[28,39,13,-1],[26,27,1,-2],[17,27,1,-1],[23,39,13,1],[33,40,13,-4],[27,13,-30,-10],[24,9,-31,-15],
  [24,95,167,238,309,381,452,524,
  595,666,738,809,880,952,1023,1095],[77,149,220,292,363,434,506,577],[1172,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmr10:[[4,5,0],[6,5,0],[5,6,1],[5,5,0],[5,5,0],[5,5,0],[5,5,0],[5,5,0],
  [5,5,0],[5,5,0],[5,5,0],[5,5,0],[4,5,0],[4,5,0],[6,5,0],[6,5,0],
  [2,3,0],[3,5,2,1],[2,2,-3],[2,2,-3,-1],[2,2,-3,-1],[3,2,-3],[3,2,-3],[2,2,-3,-2],
  [2,2,2,-1],[4,5,0],[5,4,0],[6,4,0],[4,5,1],[6,5,0],[7,6,1],[5,6,1],
  [2,1,-2],[2,5,0],[3,2,-3],[6,7,2],[4,6,1],[6,7,1],[5,6,1],[2,2,-3],
  [3,7,2],[2,7,2],[3,4,-2],[5,5,1],[2,2,1],[2,1,-1],[2,1,0],[3,7,2],
  [4,6,1],[3,5,0],[4,5,0],[4,6,1],[4,5,0],[4,6,1],[4,6,1],[4,6,1],
  [4,6,1],[4,6,1],[2,3,0],[2,4,1],[2,6,2],[5,3,0],[3,6,2],[3,5,0],
  [5,5,0],[5,5,0],[5,5,0],[5,6,1],[5,5,0],[5,5,0],[5,5,0],[5,6,1],
  [5,5,0],[3,5,0],[3,6,1],[5,5,0],[4,5,0],[6,5,0],[5,5,0],[5,6,1],
  [5,5,0],[5,7,2],[5,6,1],[4,6,1],[5,5,0],[5,6,1],[5,5,0],[7,5,0],
  [7,5,0,2],[5,5,0],[4,5,0],[2,8,2],[3,3,-2,-1],[2,8,2],[2,1,-4,-1],[2,1,-4],
  [2,3,-2],[4,4,0],[4,5,0],[3,4,0],[4,5,0],[3,4,0],[3,5,0],[4,5,2],
  [4,5,0],[2,5,0],[3,7,2,1],[4,5,0],[2,5,0],[6,3,0],[4,3,0],[4,4,0],
  [4,5,2],[4,5,2],[3,3,0],[3,4,0],[3,5,0],[4,3,0],[4,3,0],[5,3,0],
  [4,3,0],[4,5,2],[3,3,0],[4,1,-1],[7,1,-1],[2,2,-3,-1],[3,1,-4],[3,1,-4],
  [3,11,20,28,37,45,54,63,
  71,80,88,97,105,114,122,131],[9,17,26,34,42,51,59,67],[141,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmr10:[[5,6,0],[7,6,0],[6,7,1],[6,6,0],[5,6,0],[6,6,0],[6,6,0],[6,6,0],
  [6,6,0],[6,6,0],[6,6,0],[5,6,0],[4,6,0],[4,6,0],[7,6,0],[7,6,0],
  [2,4,0],[3,6,2,1],[2,2,-4,-1],[2,2,-4,-1],[2,1,-4,-1],[4,2,-4],[4,1,-4],[2,2,-4,-2],
  [2,2,2,-1],[4,6,0],[6,5,1],[6,4,0],[4,5,1],[7,6,0],[8,7,1],[6,7,1],
  [2,1,-2],[2,6,0],[3,3,-3],[6,8,2],[4,7,1],[7,7,1],[6,7,1],[2,3,-3],
  [3,8,2],[3,8,2],[4,4,-2],[6,6,1],[2,3,2],[3,1,-1],[2,1,0],[4,8,2],
  [4,7,1],[4,6,0],[4,6,0],[4,7,1],[4,6,0],[4,7,1],[4,7,1],[4,7,1],
  [4,7,1],[4,7,1],[2,4,0],[2,6,2],[2,6,2],[6,2,-1],[4,6,2],[4,6,0],
  [6,7,1],[6,6,0],[6,6,0],[6,7,1],[6,6,0],[6,6,0],[5,6,0],[6,7,1],
  [6,6,0],[3,6,0],[4,7,1],[6,6,0],[5,6,0],[7,6,0],[6,6,0],[6,7,1],
  [5,6,0],[6,8,2],[6,7,1],[4,7,1],[6,6,0],[6,7,1],[6,6,0],[8,6,0],
  [6,6,0],[6,6,0],[5,6,0],[2,8,2],[3,3,-3,-1],[2,8,2],[2,2,-4,-1],[2,2,-4],
  [2,3,-3],[4,5,1],[5,7,1],[4,4,0],[4,6,0],[4,4,0],[3,6,0],[4,6,2],
  [5,6,0],[2,6,0],[3,8,2,1],[4,6,0],[2,6,0],[7,4,0],[5,4,0],[4,4,0],
  [5,6,2],[4,6,2],[3,4,0],[3,5,1],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-2],[8,1,-2],[3,2,-4,-1],[4,2,-4],[2,2,-4,-1],
  [3,14,24,34,44,55,65,75,
  85,95,106,116,126,136,147,157],[11,21,31,41,51,61,71,81],[169,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmr10:[[6,7,0],[8,7,0],[8,8,1],[7,7,0],[7,7,0],[7,7,0],[7,7,0],[8,7,0],
  [7,7,0],[7,7,0],[7,7,0],[7,7,0],[6,7,0],[6,7,0],[8,7,0],[8,7,0],
  [3,5,0],[4,7,2,1],[2,2,-5,-1],[2,2,-5,-2],[3,2,-5,-1],[3,2,-5,-1],[5,1,-5],[3,3,-5,-2],
  [3,2,2,-1],[5,7,0],[7,6,1],[8,6,1],[5,7,1],[9,7,0],[10,8,1],[8,9,1],
  [3,2,-2],[2,8,0],[4,3,-4],[8,9,2],[5,9,1],[8,9,1],[8,9,1],[2,3,-4],
  [3,10,2,-1],[3,10,2],[5,5,-3],[8,7,1],[2,3,2],[3,2,-1],[2,1,0],[5,10,2],
  [5,8,1],[3,7,0,-1],[5,7,0],[5,8,1],[5,7,0],[5,8,1],[5,8,1],[5,8,1],
  [5,10,1],[5,10,1],[2,5,0],[2,7,2],[2,7,2],[8,3,-1],[5,7,2],[5,9,0],
  [8,8,1],[7,7,0],[7,7,0],[7,8,1],[7,7,0],[7,7,0],[6,7,0],[8,8,1],
  [7,7,0],[4,7,0],[5,8,1],[8,7,0],[6,7,0],[9,7,0],[7,7,0],[8,8,1],
  [7,7,0],[8,9,2],[8,8,1],[5,8,1],[7,7,0],[7,8,1],[8,8,1],[10,8,1],
  [10,7,0,2],[8,7,0],[6,7,0],[2,10,2,-1],[4,3,-4,-1],[2,10,2],[3,2,-5,-1],[2,2,-5],
  [2,3,-4],[5,5,0],[6,7,0],[4,6,1],[6,8,1],[5,6,1],[4,7,0],[5,7,2],
  [6,7,0],[3,7,0],[4,9,2,1],[5,9,0],[3,7,0],[8,9,0],[6,5,0],[5,6,1],
  [6,7,2],[6,7,2],[4,5,0],[4,5,0],[4,7,1],[6,6,1],[5,5,0],[7,5,0],
  [5,5,0],[5,7,2],[4,5,0],[5,1,-2],[10,1,-2],[4,2,-5,-1],[3,2,-5,-1],[3,2,-5,-1],
  [4,16,28,40,52,64,76,88,
  99,111,123,135,147,159,171,183],[13,24,36,47,59,71,82,94],[197,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmr10:[[7,9,0],[10,9,0],[9,10,1],[8,9,0],[8,9,0],[9,9,0],[8,9,0],[9,9,0],
  [8,9,0],[9,9,0],[8,9,0],[8,9,0],[7,9,0],[7,9,0],[10,9,0],[10,9,0],
  [3,6,0],[4,9,3,1],[3,3,-6,-1],[3,3,-6,-2],[4,2,-6,-1],[4,3,-6,-1],[4,2,-6,-1],[3,3,-6,-3],
  [4,3,3,-1],[6,10,1],[9,7,1],[9,7,1],[6,8,1],[11,9,0],[12,10,1],[12,10,1,3],
  [3,2,-3],[2,9,0,-1],[5,5,-4],[10,12,3],[6,10,1],[10,10,1],[9,10,1],[2,5,-4,-1],
  [3,12,3,-1],[4,12,3],[6,5,-4],[9,8,1],[2,5,3,-1],[4,1,-2],[2,2,0,-1],[6,12,3],
  [6,9,1],[4,8,0,-1],[6,8,0],[6,9,1],[6,8,0],[6,9,1],[6,9,1],[6,9,1],
  [6,9,1],[6,9,1],[2,6,0,-1],[2,9,3,-1],[2,9,3,-1],[9,4,-1],[5,9,3],[5,9,0],
  [9,10,1],[9,9,0],[8,9,0],[8,10,1],[9,9,0],[8,9,0],[8,9,0],[9,10,1],
  [9,9,0],[4,9,0],[6,10,1],[9,9,0],[7,9,0],[11,9,0],[9,9,0],[9,10,1],
  [8,9,0],[9,12,3],[9,10,1],[6,10,1],[9,9,0],[9,10,1],[9,10,1],[12,10,1],
  [9,9,0],[9,9,0],[7,9,0],[2,12,3,-1],[5,5,-4,-1],[2,12,3],[4,2,-6,-1],[2,2,-6,-1],
  [3,5,-4],[6,7,1],[7,10,1],[5,7,1],[7,10,1],[5,7,1],[5,9,0],[6,9,3],
  [7,9,0],[3,8,0],[4,11,3,1],[6,9,0],[3,9,0],[10,6,0],[7,6,0],[6,7,1],
  [7,9,3],[7,9,3],[5,6,0],[5,7,1],[4,9,1],[7,7,1],[6,6,0],[9,6,0],
  [7,6,0],[6,9,3],[5,6,0],[6,1,-3],[12,1,-3],[8,6,-3,3],[4,1,-7,-1],[4,2,-6,-1],
  [5,19,34,48,63,77,92,106,
  121,135,150,164,179,193,208,222],[16,30,45,59,73,87,101,115],[239,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmr10:[[9,10,0],[11,10,0],[11,11,1],[10,10,0],[9,10,0],[10,10,0],[10,10,0],[10,10,0],
  [10,10,0],[9,10,0,168],[10,10,0],[9,10,0],[8,10,0],[8,10,0],[12,10,0],[12,10,0],
  [4,7,0],[4,10,3,1],[3,3,-7,-1],[3,3,-7,-3],[5,2,-7,-1],[5,3,-7,-1],[5,2,-7,-1],[3,3,-7,-4],
  [4,3,3,-2],[7,11,1],[10,8,1],[11,8,1],[7,10,2],[13,10,0],[13,11,1,-1],[11,12,1],
  [4,2,-4],[2,10,0,-1],[5,5,-5],[11,13,3],[7,12,1],[11,12,1],[11,11,1],[2,5,-5,-1],
  [4,15,4,-1],[3,15,4,-1],[5,7,-4,-1],[10,9,1],[2,5,3,-1],[4,2,-2],[2,2,0,-1],[7,15,4],
  [7,11,1],[5,10,0,-1],[7,10,0],[7,11,1],[7,10,0],[7,11,1],[7,11,1],[7,11,1],
  [7,11,1],[7,11,1],[2,6,0,-1],[2,9,3,-1],[2,10,3,-1],[10,5,-1],[6,10,3],[6,10,0],
  [11,11,1],[10,10,0],[10,10,0],[10,11,1],[10,10,0],[9,10,0],[9,10,0],[11,11,1],
  [10,10,0],[5,10,0],[7,11,1],[11,10,0],[9,10,0],[13,10,0],[10,10,0],[11,11,1],
  [9,10,0],[11,13,3],[11,11,1],[7,11,1],[10,10,0],[10,11,1],[11,11,1],[14,11,1],
  [11,10,0],[11,10,0],[8,10,0],[3,15,4,-1],[5,5,-5,-2],[3,15,4],[5,3,-7,-1],[2,2,-8,-1],
  [2,5,-5,-1],[7,8,1],[8,11,1],[6,8,1],[8,11,1],[6,8,1],[5,10,0],[7,10,3],
  [8,10,0],[4,10,0],[4,13,3,1],[8,10,0],[4,10,0],[12,7,0],[8,7,0],[7,8,1],
  [8,10,3],[8,10,3],[5,7,0],[5,8,1],[5,10,1],[8,8,1],[7,6,0],[10,6,0],
  [8,6,0],[7,9,3],[6,6,0],[7,1,-3],[14,1,-3],[5,3,-7,-1],[5,2,-8,-1],[5,2,-8,-1],
  [6,23,40,57,74,91,108,125,
  142,159,176,193,210,227,244,262],[19,36,52,69,85,102,119,135],[281,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmr10:[[10,12,0],[14,12,0],[12,13,1,-1],[12,13,0],[11,12,0],[13,12,0],[11,12,0,-1],[12,12,0,-1],
  [11,12,0,-1],[12,12,0,-1],[12,12,0],[11,12,0],[9,12,0],[9,12,0],[14,12,0],[14,12,0],
  [5,8,0],[5,12,4,1],[4,4,-8,-1],[4,4,-8,-3],[5,3,-8,-2],[6,4,-8,-1],[7,1,-9,-1],[4,4,-9,-4],
  [5,4,4,-2],[8,13,1],[12,9,1],[13,9,1],[8,11,2],[15,12,0],[16,13,1,-1],[12,14,1,-1],
  [5,3,-4],[3,13,0,-1],[6,6,-6],[13,16,4,-1],[7,14,1,-1],[13,14,1,-1],[13,14,1],[3,6,-6,-1],
  [5,17,4,-1],[4,17,4,-1],[7,8,-5,-1],[12,12,2,-1],[3,6,4,-1],[5,2,-3],[3,2,0,-1],[7,17,4,-1],
  [8,13,1],[7,12,0,-1],[8,12,0],[8,13,1],[8,12,0],[8,13,1],[8,13,1],[8,13,1,-1],
  [8,13,1],[8,13,1],[3,8,0,-1],[3,12,4,-1],[3,13,4,-1],[12,5,-2,-1],[6,13,4,-1],[6,12,0,-1],
  [12,13,1,-1],[13,13,0],[11,12,0],[11,13,1,-1],[12,12,0],[11,12,0],[11,12,0],[12,13,1,-1],
  [13,12,0],[6,12,0],[8,13,1],[13,12,0],[10,12,0],[15,12,0],[13,12,0],[12,13,1,-1],
  [11,12,0],[12,16,4,-1],[13,13,1],[8,13,1,-1],[12,12,0],[13,13,1],[13,13,1],[18,13,1],
  [13,12,0],[13,12,0],[9,12,0,-1],[3,17,4,-2],[6,6,-6,-2],[3,17,4],[5,3,-9,-2],[3,3,-9,-1],
  [3,6,-6,-1],[9,9,1],[9,13,1],[7,9,1],[9,13,1],[7,9,1],[6,12,0],[9,12,4],
  [9,12,0],[5,12,0],[5,16,4,1],[9,12,0],[5,12,0],[14,8,0],[9,8,0],[8,9,1],
  [9,12,4],[9,12,4],[7,8,0],[7,9,1],[6,12,1],[9,9,1],[9,9,1],[12,9,1],
  [9,8,0],[9,12,4],[7,8,0],[9,1,-4],[17,1,-4],[6,4,-8,-2],[6,3,-9,-1],[6,3,-9,-1],
  [7,27,48,68,89,109,130,150,
  171,191,211,232,252,273,293,314],[22,42,61,81,101,121,141,161],[337,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmr10:[[12,14,0],[15,15,0,-1],[14,16,1,-1],[14,15,0],[13,14,0],[15,14,0],[13,14,0,-1],[14,15,0,-1],
  [13,14,0,-1],[14,14,0,-1],[13,15,0,-1],[13,15,0],[11,15,0],[11,15,0],[16,15,0],[16,15,0],
  [5,9,0],[6,14,5,1],[4,4,-10,-2],[4,4,-10,-4],[6,3,-10,-2],[6,4,-10,-2],[8,1,-11,-1],[5,5,-10,-5],
  [6,5,5,-2],[10,16,1],[13,10,1,-1],[15,10,1],[10,13,2],[18,14,0],[19,15,1,-1],[14,16,1,-1],
  [6,3,-5],[3,15,0,-1],[7,6,-8],[15,18,4,-1],[8,16,1,-1],[15,17,2,-1],[15,16,1],[4,6,-8,-1],
  [5,20,5,-2],[5,20,5,-1],[8,9,-6,-1],[14,14,2,-1],[3,7,4,-1],[6,2,-3],[3,3,0,-1],[8,20,5,-1],
  [10,15,1],[8,14,0,-1],[8,14,0,-1],[10,15,1],[10,14,0],[8,15,1,-1],[10,15,1],[9,15,1,-1],
  [10,15,1],[10,15,1],[3,9,0,-1],[3,13,4,-1],[3,15,5,-1],[14,6,-2,-1],[8,15,5,-1],[8,15,0,-1],
  [14,16,1,-1],[15,15,0],[13,14,0],[13,16,1,-1],[15,14,0],[13,14,0],[13,14,0],[14,16,1,-1],
  [15,14,0],[7,14,0],[10,15,1],[15,14,0],[12,14,0],[18,14,0],[15,14,0],[14,16,1,-1],
  [13,14,0],[14,19,4,-1],[15,15,1],[9,16,1,-1],[14,14,0],[15,15,1],[15,15,1],[21,15,1],
  [15,14,0],[15,14,0],[11,14,0,-1],[4,20,5,-2],[7,7,-7,-3],[4,20,5],[6,3,-11,-2],[3,3,-11,-1],
  [3,7,-7,-1],[10,10,1],[11,15,1],[9,10,1],[11,15,1],[9,10,1],[8,15,0],[10,14,5],
  [11,14,0],[5,14,0],[6,19,5,1],[11,14,0],[5,14,0],[17,9,0],[11,9,0],[10,10,1],
  [11,13,4],[11,13,4],[8,9,0],[8,10,1],[7,14,1],[11,10,1],[11,10,1],[14,10,1],
  [11,9,0],[11,13,4],[8,9,0],[10,1,-5],[20,1,-5],[7,4,-10,-2],[8,3,-11,-1],[6,3,-11,-2],
  [8,33,57,82,106,131,155,180,
  205,229,254,278,303,327,352,377],[26,50,74,98,122,145,169,193],[404,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmr10:[[14,17,0],[18,18,0,-1],[17,18,1,-1],[16,18,0],[14,17,0,-1],[18,17,0],[15,17,0,-1],[17,17,0,-1],
  [15,17,0,-1],[17,17,0,-1],[16,17,0,-1],[15,17,0],[13,17,0],[13,17,0],[20,17,0],[20,17,0],
  [6,11,0],[6,16,5,1],[5,5,-12,-2],[5,5,-12,-5],[6,4,-12,-3],[8,5,-12,-2],[10,2,-13,-1],[6,5,-13,-6],
  [6,5,5,-3],[12,18,1],[16,12,1,-1],[18,12,1],[12,16,3],[21,17,0],[23,18,1,-1],[17,20,2,-1],
  [7,4,-6],[3,18,0,-2],[9,8,-9],[18,22,5,-1],[10,20,2,-1],[18,20,2,-1],[17,19,1,-1],[3,8,-9,-2],
  [6,24,6,-2],[6,24,6,-1],[10,11,-7,-1],[17,16,2,-1],[3,8,5,-2],[7,2,-4],[3,3,0,-2],[10,24,6,-1],
  [11,17,1],[8,16,0,-2],[10,16,0,-1],[10,17,1,-1],[12,17,0],[10,17,1,-1],[10,17,1,-1],[11,18,1,-1],
  [10,17,1,-1],[10,17,1,-1],[3,11,0,-2],[3,16,5,-2],[3,18,6,-2],[17,6,-3,-1],[9,17,5,-1],[9,17,0,-1],
  [17,18,1,-1],[18,18,0],[16,17,0],[15,18,1,-1],[17,17,0],[16,17,0],[15,17,0],[17,18,1,-1],
  [18,17,0],[8,17,0],[11,18,1,-1],[18,17,0],[14,17,0],[22,17,0],[18,17,0],[17,18,1,-1],
  [15,17,0],[17,22,5,-1],[18,18,1],[11,18,1,-1],[17,17,0],[18,18,1],[18,18,1],[25,18,1],
  [18,17,0],[18,17,0],[13,17,0,-1],[5,24,6,-2],[9,8,-9,-3],[4,24,6],[6,4,-13,-3],[3,3,-13,-2],
  [4,8,-9,-1],[11,12,1,-1],[13,18,1],[10,12,1],[13,18,1],[10,12,1],[9,17,0],[12,16,5],
  [13,17,0],[6,16,0],[6,21,5,1],[13,17,0],[7,17,0],[20,11,0],[13,11,0],[12,12,1],
  [13,16,5],[13,16,5],[9,11,0],[9,12,1],[8,16,1],[13,12,1],[13,12,1],[17,12,1],
  [13,11,0],[13,16,5],[10,11,0],[12,1,-6],[24,1,-6],[7,5,-12,-3],[8,3,-13,-2],[8,3,-13,-2],
  [10,39,69,98,128,157,187,216,
  246,275,305,334,364,393,423,453],[32,61,90,118,147,176,204,233],[485,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmr10:[[16,20,0,-1],[22,21,0,-1],[20,22,1,-1],[20,21,0],[18,20,0,-1],[20,20,0,-1],[19,20,0,-1],[20,21,0,-1],
  [19,20,0,-1],[20,20,0,-1],[19,21,0,-1],[19,21,0],[16,21,0],[16,21,0],[24,21,0],[24,21,0],
  [7,13,0,-1],[9,19,6,2],[6,6,-15,-3],[6,6,-15,-6],[8,4,-15,-3],[9,6,-15,-3],[11,2,-16,-2],[6,6,-15,-8],
  [8,6,6,-3],[14,22,1],[20,14,1,-1],[22,14,1],[13,19,3,-1],[26,20,0],[27,22,1,-2],[20,24,2,-1],
  [8,4,-8],[4,21,0,-2],[9,10,-11,-1],[22,27,6,-1],[12,24,2,-1],[22,24,2,-1],[20,22,1,-1],[4,9,-11,-2],
  [8,30,8,-2],[8,30,8,-1],[11,13,-9,-2],[20,20,3,-1],[4,9,6,-2],[8,3,-5],[4,3,0,-2],[12,30,8,-1],
  [13,21,1,-1],[11,20,0,-2],[12,20,0,-1],[13,21,1,-1],[14,20,0],[12,21,1,-1],[13,21,1,-1],[13,21,1,-1],
  [13,21,1,-1],[13,21,1,-1],[4,13,0,-2],[4,19,6,-2],[4,22,7,-2],[20,8,-3,-1],[11,21,6,-1],[11,21,0,-1],
  [20,22,1,-1],[21,21,0],[18,20,0,-1],[19,22,1,-1],[20,20,0,-1],[18,20,0,-1],[17,20,0,-1],[21,22,1,-1],
  [20,20,0,-1],[10,20,0],[13,21,1,-1],[21,20,0,-1],[16,20,0,-1],[25,20,0,-1],[20,20,0,-1],[20,22,1,-1],
  [18,20,0,-1],[21,27,6,-1],[21,21,1,-1],[14,22,1,-1],[19,20,0,-1],[20,21,1,-1],[22,21,1],[30,21,1],
  [21,20,0],[22,20,0],[16,20,0,-1],[5,30,8,-3],[10,9,-11,-4],[5,30,8],[8,5,-15,-3],[4,4,-16,-2],
  [4,9,-11,-2],[14,14,1,-1],[16,22,1],[11,14,1,-1],[15,22,1,-1],[12,14,1],[10,21,0,-1],[14,20,6],
  [16,21,0],[7,20,0,-1],[9,26,6,2],[15,21,0],[7,21,0,-1],[24,13,0],[16,13,0],[14,14,1],
  [16,19,6],[15,19,6,-1],[11,13,0],[10,14,1,-1],[10,19,1],[15,14,1,-1],[15,14,1],[21,14,1],
  [15,13,0],[15,19,6],[12,13,0],[15,1,-7],[29,1,-7],[10,6,-15,-3],[10,4,-16,-2],[9,4,-16,-3],
  [12,47,82,118,153,188,223,259,
  294,329,365,400,435,471,506,541],[37,72,106,140,175,209,243,278],[580,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmr10:[[19,24,0,-1],[26,25,0,-1],[24,25,1,-1],[22,25,0,-1],[21,23,0,-1],[24,24,0,-1],[21,24,0,-2],[23,24,0,-2],
  [22,24,0,-1],[23,24,0,-2],[22,24,0,-1],[21,24,0,-1],[17,24,0,-1],[17,24,0,-1],[27,24,0,-1],[27,24,0,-1],
  [8,15,0,-1],[10,22,7,2],[7,7,-17,-3],[7,7,-17,-7],[9,5,-17,-4],[11,7,-17,-3],[13,2,-19,-2],[7,7,-18,-9],
  [9,7,7,-4],[15,25,1,-1],[23,17,1,-1],[25,17,1,-1],[15,22,4,-1],[29,24,0,-1],[32,25,1,-2],[24,27,2,-1],
  [8,5,-9,-1],[4,25,0,-3],[11,11,-13,-1],[25,31,7,-2],[14,28,2,-1],[26,28,2,-1],[24,26,1,-1],[4,11,-13,-3],
  [9,35,9,-3],[8,35,9,-2],[13,16,-10,-2],[23,23,3,-2],[4,11,7,-3],[10,3,-6],[4,4,0,-3],[13,35,9,-2],
  [15,24,1,-1],[12,23,0,-3],[15,23,0,-1],[15,24,1,-1],[15,23,0,-1],[15,24,1,-1],[15,24,1,-1],[15,24,1,-2],
  [15,24,1,-1],[15,24,1,-1],[4,15,0,-3],[4,22,7,-3],[4,25,8,-3],[23,9,-4,-2],[14,24,7,-1],[14,24,0,-1],
  [24,25,1,-1],[24,25,0,-1],[22,24,0,-1],[22,25,1,-1],[23,24,0,-1],[22,24,0,-1],[20,24,0,-1],[24,25,1,-1],
  [24,24,0,-1],[11,24,0,-1],[15,25,1,-1],[24,24,0,-1],[19,24,0,-1],[29,24,0,-1],[24,24,0,-1],[24,25,1,-1],
  [21,24,0,-1],[24,31,7,-1],[24,25,1,-1],[16,25,1,-1],[23,23,0,-1],[24,25,1,-1],[25,25,1],[35,25,1],
  [25,24,0],[26,24,0],[18,24,0,-1],[5,35,9,-4],[11,11,-13,-5],[6,35,9],[9,6,-18,-4],[4,4,-19,-3],
  [5,11,-13,-2],[16,17,1,-1],[17,25,1,-1],[13,17,1,-1],[17,25,1,-1],[14,17,1,-1],[12,24,0,-1],[16,23,7,-1],
  [18,24,0,-1],[8,23,0,-1],[10,30,7,2],[17,24,0,-1],[8,24,0,-1],[27,15,0,-1],[18,15,0,-1],[15,17,1,-1],
  [17,22,7,-1],[17,22,7,-1],[12,15,0,-1],[12,17,1,-1],[12,22,1],[18,16,1,-1],[18,16,1],[24,16,1],
  [18,15,0],[18,22,7],[13,15,0,-1],[17,2,-8],[34,2,-8],[11,7,-17,-4],[11,4,-19,-3],[11,4,-19,-3],
  [14,56,99,141,184,226,269,311,
  354,396,439,481,524,566,609,651],[46,87,128,170,211,253,294,335],[698,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmr10:[[23,28,0,-1],[31,30,0,-2],[28,30,1,-2],[27,30,0,-1],[25,28,0,-1],[29,28,0,-1],[26,28,0,-2],[28,29,0,-2],
  [26,28,0,-2],[28,28,0,-2],[27,29,0,-1],[25,29,0,-1],[21,29,0,-1],[21,29,0,-1],[32,29,0,-1],[32,29,0,-1],
  [10,19,0,-1],[11,28,9,2],[8,8,-21,-4],[8,8,-21,-8],[11,5,-21,-5],[13,8,-21,-4],[16,3,-22,-2],[9,8,-22,-11],
  [10,9,9,-5],[19,30,1,-1],[28,20,1,-1],[30,20,1,-1],[18,26,4,-1],[35,28,0,-1],[39,30,1,-2],[28,34,3,-2],
  [10,5,-11,-1],[5,30,0,-3],[14,13,-16,-1],[30,37,8,-2],[17,34,3,-2],[30,34,3,-2],[29,31,1,-1],[6,13,-16,-3],
  [10,42,11,-4],[10,42,11,-2],[16,18,-13,-2],[28,28,4,-2],[6,13,8,-3],[12,3,-7],[5,5,0,-3],[17,42,11,-2],
  [18,29,1,-1],[15,28,0,-3],[17,28,0,-2],[18,29,1,-1],[19,28,0,-1],[17,29,1,-2],[18,29,1,-1],[18,29,1,-2],
  [18,29,1,-1],[18,29,1,-1],[5,18,0,-3],[5,26,8,-3],[5,30,9,-3],[28,10,-5,-2],[15,30,9,-2],[15,29,0,-2],
  [28,30,1,-2],[29,30,0,-1],[26,28,0,-1],[26,30,1,-2],[28,28,0,-1],[26,28,0,-1],[24,28,0,-1],[29,30,1,-2],
  [29,28,0,-1],[13,28,0,-1],[19,29,1,-1],[30,28,0,-1],[23,28,0,-1],[35,28,0,-1],[29,28,0,-1],[28,30,1,-2],
  [25,28,0,-1],[28,37,8,-2],[29,29,1,-1],[19,30,1,-2],[27,28,0,-1],[29,29,1,-1],[30,29,1],[42,29,1],
  [29,28,0,-1],[31,28,0],[21,28,0,-2],[7,42,11,-4],[14,13,-16,-6],[7,42,11],[11,7,-22,-5],[5,5,-23,-3],
  [5,13,-16,-3],[20,20,1,-1],[21,30,1,-1],[16,20,1,-1],[21,30,1,-1],[16,20,1,-1],[14,29,0,-1],[19,28,9,-1],
  [21,29,0,-1],[10,28,0,-1],[11,37,9,2],[20,29,0,-1],[10,29,0,-1],[33,19,0,-1],[21,19,0,-1],[19,20,1,-1],
  [21,27,8,-1],[21,27,8,-1],[14,19,0,-1],[14,20,1,-1],[14,27,1],[21,20,1,-1],[21,19,1],[29,19,1],
  [22,18,0],[21,27,9],[16,18,0,-1],[21,2,-10],[41,2,-10],[13,8,-21,-5],[14,5,-23,-3],[13,5,-23,-4],
  [17,67,118,169,220,271,322,373,
  423,474,525,576,627,678,729,780],[55,104,154,203,253,302,352,401],[835,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmr10:[[28,34,0,-1],[37,35,0,-2],[34,36,1,-2],[32,35,0,-1],[29,34,0,-2],[35,34,0,-1],[31,34,0,-2],[34,35,0,-2],
  [31,34,0,-2],[34,34,0,-2],[32,35,0,-2],[30,35,0,-1],[25,35,0,-1],[25,35,0,-1],[39,35,0,-1],[39,35,0,-1],
  [12,22,0,-1],[13,32,10,2],[10,10,-25,-5],[10,10,-25,-10],[13,7,-25,-6],[16,9,-25,-4],[18,2,-27,-3],[10,10,-26,-13],
  [12,9,10,-6],[23,36,1,-1],[32,23,1,-2],[36,23,1,-1],[22,31,5,-1],[42,34,0,-1],[46,37,2,-3],[34,39,3,-2],
  [12,6,-13,-1],[6,35,0,-4],[16,15,-19,-1],[36,44,10,-2],[20,40,3,-2],[36,40,3,-2],[34,38,2,-2],[7,15,-19,-4],
  [13,50,13,-4],[13,50,13,-2],[19,22,-15,-3],[34,33,4,-2],[6,16,10,-4],[14,3,-9],[6,6,0,-4],[20,50,13,-2],
  [22,35,2,-1],[17,33,0,-4],[20,33,0,-2],[21,35,2,-2],[23,34,0,-1],[20,35,2,-2],[21,35,2,-2],[22,35,1,-2],
  [21,35,2,-2],[21,34,1,-2],[6,22,0,-4],[6,32,10,-4],[6,36,11,-4],[34,12,-6,-2],[19,35,10,-2],[19,35,0,-2],
  [34,36,1,-2],[35,35,0,-1],[31,34,0,-1],[31,37,2,-2],[34,34,0,-1],[31,34,0,-1],[29,34,0,-1],[34,37,2,-2],
  [35,34,0,-1],[16,34,0,-1],[21,35,1,-2],[36,34,0,-1],[28,34,0,-1],[43,34,0,-1],[35,34,0,-1],[34,36,1,-2],
  [30,34,0,-1],[34,45,10,-2],[35,35,1,-1],[23,37,2,-2],[33,34,0,-1],[35,35,1,-1],[36,35,1],[50,35,1],
  [35,34,0,-1],[37,34,0],[26,34,0,-2],[8,50,13,-5],[16,15,-19,-7],[7,50,13,-1],[14,8,-26,-5],[6,6,-27,-4],
  [7,15,-19,-3],[23,23,1,-2],[25,35,1,-1],[20,23,1,-1],[25,35,1,-1],[20,23,1,-1],[17,35,0,-1],[23,34,11,-1],
  [26,34,0,-1],[12,33,0,-1],[13,43,10,2],[24,34,0,-1],[12,34,0,-1],[39,22,0,-1],[26,22,0,-1],[23,23,1,-1],
  [25,32,10,-1],[25,32,10,-1],[17,22,0,-1],[17,23,1,-1],[16,32,1,-1],[26,23,1,-1],[25,23,1],[35,23,1],
  [26,22,0],[25,32,10],[19,22,0,-1],[25,2,-12],[49,2,-12],[15,10,-25,-6],[17,5,-28,-4],[15,6,-27,-5],
  [20,81,142,203,264,325,387,448,
  509,570,631,692,753,814,875,937],[64,124,183,243,302,362,421,481],[1003,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmr10:[[33,41,0,-2],[45,43,0,-2],[40,44,2,-3],[38,43,0,-1],[35,40,0,-2],[41,41,0,-2],[37,41,0,-3],[40,42,0,-3],
  [37,41,0,-3],[40,41,0,-3],[38,42,0,-2],[36,42,0,-1],[31,42,0,-1],[31,42,0,-1],[47,42,0,-1],[47,42,0,-1],
  [13,26,0,-2],[16,39,13,3],[12,12,-30,-6],[11,12,-30,-12],[16,8,-30,-7],[19,11,-30,-5],[22,2,-33,-4],[12,11,-32,-16],
  [15,11,12,-7],[27,43,1,-1],[39,28,1,-2],[44,28,1,-1],[26,38,6,-2],[51,41,0,-1],[54,44,2,-4],[40,48,4,-3],
  [15,7,-16,-1],[7,43,0,-5],[19,18,-23,-2],[43,53,12,-3],[24,49,4,-3],[43,49,4,-3],[41,45,2,-2],[8,18,-23,-5],
  [15,60,15,-5],[14,60,15,-3],[23,27,-18,-3],[40,40,5,-3],[7,19,12,-5],[17,4,-11],[7,7,0,-5],[24,60,15,-3],
  [26,42,2,-2],[20,40,0,-5],[24,40,0,-3],[25,42,2,-2],[27,40,0,-1],[24,42,2,-3],[25,42,2,-2],[26,42,2,-3],
  [25,42,2,-2],[25,42,2,-2],[7,26,0,-5],[7,38,12,-5],[7,43,13,-5],[40,15,-7,-3],[22,43,13,-3],[22,42,0,-3],
  [40,43,1,-3],[42,43,0,-1],[37,41,0,-2],[37,44,2,-3],[40,41,0,-2],[37,41,0,-2],[34,41,0,-2],[41,44,2,-3],
  [41,41,0,-2],[19,41,0,-1],[26,43,2,-2],[42,41,0,-2],[33,41,0,-2],[50,41,0,-2],[41,41,0,-2],[40,44,2,-3],
  [35,41,0,-2],[40,54,12,-3],[42,43,2,-2],[27,44,2,-3],[39,40,0,-2],[41,43,2,-2],[43,43,2,-1],[59,43,2,-1],
  [42,41,0,-1],[44,41,0],[30,41,0,-3],[8,60,15,-7],[19,18,-23,-9],[9,60,15,-1],[16,9,-32,-7],[7,7,-33,-5],
  [8,18,-23,-4],[28,28,1,-2],[30,42,1,-1],[23,28,1,-2],[30,42,1,-2],[24,28,1,-1],[19,42,0,-2],[28,40,13,-1],
  [31,41,0,-1],[13,40,0,-2],[16,53,13,3],[30,41,0,-1],[13,41,0,-2],[47,27,0,-1],[31,27,0,-1],[27,28,1,-1],
  [30,39,12,-1],[30,39,12,-2],[21,26,0,-1],[20,28,1,-2],[19,38,1,-1],[31,27,1,-1],[29,27,1,-1],[41,27,1,-1],
  [31,26,0],[29,39,13,-1],[23,26,0,-1],[30,2,-15],[59,2,-15],[18,12,-30,-7],[20,7,-33,-5],[18,7,-33,-6],
  [24,97,171,244,317,391,464,538,
  611,684,758,831,904,978,1051,1125],[77,149,220,292,363,434,506,577],[1205,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmsy10:[[5,1,-1],[2,1,-1],[4,4,0,-1],[3,4,0],[5,5,1],[4,4,0],[5,5,0],[5,5,1],
  [5,5,1],[5,5,1],[5,5,1],[5,5,1],[5,5,1],[7,7,2],[3,4,0],[3,4,0],
  [5,4,0],[5,4,0],[5,6,1],[5,6,1],[5,6,1],[5,6,1],[5,6,1],[5,6,1],
  [5,2,-1],[5,4,0],[5,5,1],[5,5,1],[7,5,1],[7,5,1],[5,5,1],[5,5,1],
  [7,3,0],[7,3,0],[3,7,2],[3,7,2],[7,3,0],[7,7,2],[7,7,2],[5,4,0],
  [7,4,0],[7,4,0],[4,7,2],[4,7,2],[7,4,0],[7,7,2],[7,7,2],[5,3,0],
  [2,4,0],[7,3,0],[4,5,1],[4,5,1],[6,5,0],[6,6,2],[4,7,2,-1],[1,3,0],
  [4,5,0],[4,5,0],[5,3,0],[4,7,1],[5,6,1],[5,5,0],[5,5,0],[5,5,0],
  [4,5,0],[6,6,1],[5,6,1],[4,6,1],[6,5,0],[4,6,1],[6,6,1],[5,6,1],
  [6,6,1],[5,5,0],[6,6,1],[5,6,1],[5,6,1],[8,6,1],[9,7,1,2],[6,6,1],
  [6,6,1],[6,6,1],[6,6,1],[5,6,1],[6,5,0],[6,6,1,1],[5,6,1],[8,6,1],
  [6,5,0],[5,6,1],[6,5,0],[5,5,1],[5,5,0],[5,5,1],[5,4,0],[5,4,0],
  [4,5,0],[4,5,0],[2,8,2,-1],[2,8,2],[2,8,2,-1],[2,8,2],[3,8,2],[3,8,2],
  [3,8,2],[2,8,2],[2,7,2],[3,8,2],[3,8,2],[4,8,2],[3,8,2],[2,5,1],
  [6,8,7],[5,5,0],[6,6,1],[4,7,2],[5,4,0],[5,5,0],[5,6,1],[5,6,1],
  [3,7,2],[3,7,2],[3,7,2],[4,7,2],[6,6,1],[5,6,1],[5,6,1],[5,6,1],
  [3,13,23,33,43,53,63,73,
  83,93,103,113,123,133,142,152],[9,24,38,52,66,80,95,109],[164,121]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmsy10:[[5,2,-1,-1],[2,2,-1],[4,4,0,-1],[4,4,0],[6,6,1],[4,4,0],[6,6,0],[6,6,2],
  [6,6,1],[6,6,1],[6,6,1],[6,6,1],[6,6,1],[8,8,2],[4,4,0],[4,4,0],
  [6,4,0],[6,4,0],[6,8,2],[6,8,2],[6,7,2],[6,7,2],[6,7,2],[6,7,2],
  [6,2,-1],[6,4,0],[6,6,1],[6,6,1],[8,6,1],[8,6,1],[5,6,1,-1],[6,6,1],
  [8,4,0],[8,4,0],[4,8,2],[4,8,2],[8,4,0],[8,8,2],[8,8,2],[6,4,0],
  [8,6,1],[8,6,1],[5,8,2],[5,8,2],[8,6,1],[8,8,2],[8,8,2],[6,4,0],
  [2,5,0],[8,4,0],[5,6,1],[5,6,1],[7,6,0],[7,6,2],[4,8,2,-1],[1,4,0],
  [5,6,0],[4,6,0],[5,3,0],[4,7,1],[6,7,1],[6,7,1],[6,6,0],[6,6,0],
  [5,6,0],[7,7,1],[6,7,1],[5,7,1],[7,6,0],[5,7,1],[7,7,1],[5,7,1],
  [7,7,1],[5,6,0],[7,7,1],[6,7,1],[5,7,1],[9,7,1],[9,8,1,1],[7,7,1],
  [6,7,1],[6,7,1,-1],[7,7,1],[6,7,1],[7,6,0],[7,7,1,1],[6,7,1],[9,7,1],
  [7,6,0],[6,7,1],[6,6,0],[5,6,1],[5,5,0],[5,6,1],[5,5,0],[5,5,0],
  [5,6,0],[5,6,0],[3,8,2,-1],[3,8,2],[3,8,2,-1],[3,8,2],[3,8,2,-1],[3,8,2],
  [2,8,2,-1],[3,8,2],[1,8,2,-1],[2,8,2,-1],[4,8,2],[5,8,2],[4,8,2],[2,6,1],
  [7,9,8],[6,6,0],[7,7,1],[4,8,2],[5,5,0],[5,5,0],[6,8,2],[6,8,2],
  [3,8,2],[3,8,2],[3,8,2],[5,8,2],[6,7,1],[6,8,2],[6,7,1],[6,7,1],
  [3,15,27,39,51,63,75,87,
  99,111,123,135,147,159,171,183],[11,28,45,62,80,97,114,131],[196,145]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmsy10:[[6,1,-2,-1],[2,1,-2],[6,5,0,-1],[5,5,0],[8,7,1],[5,5,0],[8,7,0],[8,7,2],
  [8,7,1],[8,7,1],[8,7,1],[8,7,1],[8,7,1],[10,11,3],[5,5,0],[5,5,0],
  [8,5,0],[8,5,0],[7,9,2],[6,9,2,-1],[6,9,2,-1],[6,9,2,-1],[6,9,2,-1],[7,9,2],
  [8,3,-1],[8,5,0],[7,7,1],[6,7,1,-1],[10,7,1],[10,7,1],[6,7,1,-1],[6,7,1,-1],
  [10,5,0],[10,5,0],[5,9,2],[5,9,2],[10,5,0],[10,9,2],[10,9,2],[8,5,0],
  [10,5,0],[10,5,0],[6,9,2],[6,9,2],[10,7,1],[10,9,2],[10,9,2],[8,6,1],
  [3,6,0],[10,6,1],[6,7,1],[5,7,1,-1],[9,7,0],[9,7,2],[6,9,2,-1],[2,5,0],
  [6,8,1],[5,7,0],[7,3,-1],[5,9,1],[7,9,1],[7,8,1],[8,7,0],[8,7,0],
  [6,7,0],[8,9,1],[7,8,1],[6,8,1],[8,7,0],[6,8,1],[9,8,1],[6,9,2],
  [8,8,1],[7,7,0],[9,9,2],[8,8,1],[7,8,1],[11,8,1],[13,9,1,3],[8,8,1],
  [8,8,1],[7,9,2,-1],[9,8,1],[7,8,1],[8,8,0],[8,8,1,1],[7,8,1],[11,8,1],
  [8,7,0],[8,9,2],[8,7,0],[7,7,1],[7,7,1],[7,7,1],[6,7,1],[6,7,1],
  [6,7,0],[6,7,0],[4,11,3,-1],[3,11,3],[4,11,3,-1],[3,11,3],[3,11,3,-1],[3,11,3,-1],
  [3,11,3,-1],[3,11,3],[1,11,3,-1],[3,11,3,-1],[3,11,3,-1],[6,11,3],[5,11,3],[3,7,1],
  [9,11,10],[7,7,0],[8,8,1],[5,11,3],[6,6,0],[6,6,0],[7,9,2],[7,9,2],
  [4,9,2],[4,9,2],[4,9,2],[6,9,2],[8,10,2],[8,10,2],[8,9,1],[8,10,2],
  [4,18,32,46,60,74,88,102,
  116,130,144,158,172,186,199,213],[13,33,53,73,93,113,133,152],[229,169]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmsy10:[[8,2,-2,-1],[2,2,-2,-1],[7,6,0,-1],[6,6,0],[9,8,1],[6,6,0],[9,8,0],[9,8,2],
  [9,8,1],[9,8,1],[9,8,1],[9,8,1],[9,8,1],[12,12,3],[6,6,0],[6,6,0],
  [9,6,0],[9,6,0],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],
  [9,4,-1],[9,6,0],[8,8,1,-1],[8,8,1,-1],[12,8,1],[12,8,1],[8,8,1,-1],[8,8,1,-1],
  [11,4,-1,-1],[11,4,-1],[4,11,3,-1],[4,11,2,-1],[10,4,-1,-1],[12,12,3],[12,12,3],[9,6,0],
  [11,8,1,-1],[11,8,1],[7,12,3],[7,12,3],[12,8,1],[12,12,3],[12,12,3],[9,7,1],
  [3,7,0],[12,7,1],[6,8,1,-1],[6,8,1,-1],[10,9,0],[10,9,3],[7,12,3,-1],[2,6,0],
  [7,10,1],[6,9,0],[8,4,-1],[6,11,1],[9,10,1],[9,10,1],[9,8,0],[9,8,0],
  [7,9,0],[10,10,1],[8,10,1],[7,10,1],[10,9,0],[7,10,1],[10,10,1],[8,11,2],
  [10,10,1],[9,9,0,1],[10,11,2],[9,10,1],[8,10,1],[14,10,1],[13,11,1,1],[10,10,1],
  [9,10,1],[9,11,2,-1],[10,10,1],[8,10,1],[10,9,0],[10,10,1,1],[8,10,1],[13,10,1],
  [10,9,0],[9,11,2],[9,9,0],[8,8,1],[8,9,1],[8,8,1],[8,8,1],[8,7,0],
  [7,9,0],[7,9,0],[3,12,3,-2],[4,12,3],[3,12,3,-2],[4,12,3],[4,12,3,-1],[4,12,3,-1],
  [3,12,3,-1],[4,12,3],[1,12,3,-1],[4,12,3,-1],[4,12,3,-1],[7,14,4],[6,12,3],[3,8,1],
  [10,13,12,-1],[9,9,0],[10,10,1],[6,12,3],[8,7,0],[8,8,0],[8,10,2,-1],[9,10,2],
  [5,12,3],[5,12,3],[5,12,3],[7,12,3],[9,11,2],[9,11,2],[9,10,1],[9,11,2],
  [5,22,39,56,73,90,107,124,
  141,157,174,191,208,225,242,259],[17,41,65,90,114,138,162,186],[278,206]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmsy10:[[9,1,-3,-1],[2,3,-2,-1],[7,7,0,-2],[5,7,0,-1],[10,9,1],[7,7,0],[10,10,0],[10,10,3],
  [11,11,2],[11,11,2],[11,11,2],[11,11,2],[11,11,2],[14,13,3],[7,7,0],[7,7,0],
  [10,7,0],[10,7,0],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],
  [11,5,-1],[10,7,0],[9,9,1,-1],[9,9,1,-1],[14,9,1],[14,9,1],[9,9,1,-1],[9,9,1,-1],
  [13,5,-1,-1],[13,5,-1],[5,13,3,-1],[5,13,3,-1],[12,5,-1,-1],[14,13,3],[14,13,3],[10,7,0],
  [13,9,1,-1],[13,9,1],[8,13,3],[8,13,3],[14,9,1],[14,13,3],[14,13,3],[10,8,1],
  [4,8,0],[14,8,1],[7,9,1,-1],[8,9,1,-1],[12,10,0],[12,10,3],[7,13,3,-2],[2,5,-1],
  [8,11,1],[7,10,0],[9,4,-1],[7,12,1],[10,11,1],[10,11,1],[9,10,0,-1],[10,10,0],
  [8,10,0],[11,11,1],[10,11,1],[8,11,1],[11,10,0],[8,11,1],[12,11,1],[9,12,2],
  [12,11,1],[10,10,0,1],[12,12,2],[11,11,1],[9,11,1],[16,11,1],[15,12,1,1],[11,11,1],
  [11,11,1],[10,12,2,-1],[12,11,1],[9,11,1],[11,10,0],[11,11,1,1],[10,11,1],[15,11,1],
  [12,10,0],[10,12,2],[11,10,0],[9,10,1],[9,10,1],[9,10,1],[8,10,1,-1],[9,10,1],
  [8,10,0],[8,10,0],[4,15,4,-2],[4,15,4],[4,15,4,-2],[4,15,4],[5,15,4,-1],[5,15,4,-1],
  [4,15,4,-1],[4,15,4],[2,15,4,-1],[5,15,4,-1],[5,15,4,-1],[8,15,4],[7,15,4],[4,11,2],
  [11,15,14,-1],[10,10,0],[11,11,1],[7,13,3],[9,9,0],[9,9,0],[9,11,2,-1],[9,11,2,-1],
  [5,13,3,-1],[6,13,3],[6,13,3],[8,13,3],[11,13,2],[10,14,3],[11,11,1],[11,13,2],
  [6,26,46,66,86,106,125,145,
  165,185,205,225,245,265,285,305],[20,48,77,105,134,162,190,219],[327,243]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmsy10:[[11,2,-3,-1],[3,3,-3,-1],[9,9,0,-2],[7,8,0,-1],[12,10,1,-1],[9,9,0],[12,12,0,-1],[12,12,3,-1],
  [12,12,2,-1],[12,12,2,-1],[12,12,2,-1],[12,12,2,-1],[12,12,2,-1],[15,17,4,-1],[7,7,-1,-1],[7,7,-1,-1],
  [12,9,0,-1],[12,8,0,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],
  [12,5,-2,-1],[12,8,-1,-1],[11,11,1,-1],[11,11,1,-1],[15,11,1,-1],[15,11,1,-1],[11,11,1,-1],[11,11,1,-1],
  [15,7,-1,-1],[15,7,-1,-1],[7,16,4,-1],[7,16,4,-1],[15,7,-1,-1],[15,16,4,-1],[15,16,4,-1],[12,8,0,-1],
  [15,10,1,-1],[15,10,1,-1],[10,16,4],[10,16,4],[17,10,1],[15,16,4,-1],[15,16,4,-1],[12,9,1,-1],
  [5,10,0],[15,9,1,-1],[9,11,1,-1],[9,11,1,-1],[13,13,0,-1],[13,13,4,-1],[9,17,4,-2],[1,7,-1,-1],
  [10,13,1],[8,12,0,-1],[10,5,-1,-1],[8,15,2],[12,14,1],[11,13,1,-1],[12,12,0,-1],[12,12,0,-1],
  [9,12,0,-1],[14,14,1],[12,13,1],[9,13,1],[13,12,0],[10,13,1],[14,13,1],[11,14,2],
  [14,13,1],[12,12,0,1],[15,14,2],[13,13,1],[11,13,1],[19,13,1],[18,15,1,1],[13,13,1,-1],
  [13,13,1],[12,15,3,-2],[14,13,1],[11,13,1],[14,13,0],[13,13,1,1],[12,13,1],[18,13,1],
  [14,12,0],[13,15,3],[13,12,0],[10,12,1,-1],[10,12,1,-1],[10,12,1,-1],[10,12,1,-1],[10,12,1,-1],
  [9,12,0,-1],[9,12,0,-1],[4,18,5,-3],[5,18,5],[5,18,5,-3],[5,18,5],[7,18,5,-1],[7,18,5,-1],
  [5,18,5,-1],[4,18,5,-1],[1,18,5,-2],[5,18,5,-2],[7,18,5,-1],[10,18,5],[7,18,5,-1],[3,12,2,-1],
  [14,18,17,-1],[12,12,0],[14,13,1],[7,17,4,-1],[10,11,0,-1],[10,11,0,-1],[11,14,3,-1],[11,14,3,-1],
  [6,16,4,-1],[6,16,4,-1],[6,16,4,-1],[9,16,4,-1],[13,16,3],[12,16,3,-1],[12,14,1,-1],[12,16,3,-1],
  [7,31,55,79,103,127,151,174,
  198,222,246,270,294,318,342,366],[23,57,91,125,159,193,227,261],[392,290]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmsy10:[[13,2,-4,-1],[3,2,-4,-1],[10,10,0,-3],[8,10,0,-1],[14,12,1,-1],[10,10,0],[14,14,0,-1],[14,14,4,-1],
  [14,14,2,-1],[14,14,2,-1],[14,14,2,-1],[14,14,2,-1],[14,14,2,-1],[18,20,5,-1],[8,8,-1,-1],[8,8,-1,-1],
  [14,10,0,-1],[14,10,0,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],
  [14,6,-2,-1],[14,9,-1,-1],[13,12,1,-1],[13,12,1,-1],[18,14,2,-1],[18,14,2,-1],[13,12,1,-1],[13,12,1,-1],
  [18,8,-1,-1],[18,8,-1,-1],[8,18,4,-1],[8,18,4,-1],[18,8,-1,-1],[18,18,4,-1],[18,18,4,-1],[14,10,0,-1],
  [18,12,1,-1],[18,12,1,-1],[12,18,4],[12,18,4],[19,12,1],[18,18,4,-1],[18,18,4,-1],[14,10,1,-1],
  [6,11,-1],[18,10,1,-1],[11,12,1,-1],[11,12,1,-1],[16,15,0,-1],[16,15,5,-1],[11,20,5,-2],[2,8,-1,-1],
  [11,15,1],[9,14,0,-1],[12,7,-1,-1],[9,18,2],[14,16,1,-1],[13,16,1,-1],[14,14,0,-1],[14,14,0,-1],
  [11,14,0,-1],[16,16,1],[14,16,1],[11,15,1],[16,14,0],[12,16,1],[17,15,1],[12,18,3],
  [17,15,1],[14,14,0,1],[16,17,3,-1],[15,16,1],[13,16,1],[23,15,1],[21,17,1,1],[15,15,1,-1],
  [15,15,1],[14,18,3,-2],[17,15,1],[13,16,1],[16,15,0],[15,15,1,1],[14,15,1],[21,15,1],
  [16,14,0,-1],[15,17,3],[16,14,0],[12,13,1,-1],[12,13,1,-1],[12,13,1,-1],[11,13,1,-1],[12,13,1,-1],
  [10,14,0,-1],[11,14,0,-1],[6,20,5,-3],[6,20,5],[6,20,5,-3],[6,20,5],[8,20,5,-1],[8,20,5,-1],
  [5,20,5,-2],[5,20,5,-1],[2,20,5,-2],[6,20,5,-2],[8,22,6,-1],[12,22,6],[8,20,5,-1],[4,14,2,-1],
  [16,21,20,-1],[15,14,0],[15,15,1,-1],[9,20,5,-1],[12,12,0,-1],[12,12,0,-1],[14,16,3,-1],[13,16,3,-1],
  [7,20,5,-1],[7,19,5,-1],[7,18,4,-1],[11,18,4,-1],[15,18,3],[14,19,4,-1],[14,16,1,-1],[14,18,3,-1],
  [8,37,66,95,123,152,181,209,
  238,267,295,324,353,382,410,439],[27,68,109,150,191,232,273,314],[471,348]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmsy10:[[15,2,-5,-2],[3,4,-4,-2],[12,12,0,-3],[10,11,0,-1],[17,14,1,-1],[12,12,0],[17,16,0,-1],[17,16,4,-1],
  [17,16,2,-1],[17,16,2,-1],[17,16,2,-1],[17,16,2,-1],[17,16,2,-1],[22,24,6,-1],[10,10,-1,-1],[10,10,-1,-1],
  [17,12,0,-1],[17,12,0,-1],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],
  [17,6,-3,-1],[17,11,-1,-1],[15,14,1,-2],[15,14,1,-2],[22,16,2,-1],[22,16,2,-1],[15,14,1,-2],[15,14,1,-2],
  [22,10,-1,-1],[22,10,-1,-1],[10,22,5,-1],[10,22,5,-1],[22,10,-1,-1],[22,22,5,-1],[22,22,5,-1],[17,12,0,-1],
  [22,14,1,-1],[22,14,1,-1],[14,22,5],[14,22,5],[22,14,1,-1],[22,22,5,-1],[22,22,5,-1],[17,12,1,-1],
  [7,13,-1],[22,12,1,-1],[12,14,1,-2],[12,14,1,-2],[19,18,0,-1],[19,18,6,-1],[13,24,6,-3],[2,10,-1,-1],
  [14,18,1],[11,17,0,-1],[14,7,-2,-1],[10,21,2,-1],[16,19,1,-1],[16,18,1,-1],[17,16,0,-1],[17,16,0,-1],
  [13,17,0,-1],[19,20,2],[16,18,1],[13,18,1],[19,17,0],[14,18,1],[20,18,1],[14,20,3,-1],
  [20,19,2],[17,17,0,1],[19,20,3,-1],[18,18,1],[16,18,1],[27,19,2],[25,21,2,1],[18,18,1,-1],
  [18,19,2],[17,20,3,-2],[20,18,1],[16,18,1],[19,18,0],[18,18,1,1],[15,18,1,-1],[24,18,1,-1],
  [19,17,0,-1],[18,21,4],[18,17,0,-1],[14,16,1,-1],[14,16,1,-1],[14,16,1,-1],[14,16,1,-1],[14,16,1,-1],
  [13,17,0,-1],[13,17,0,-1],[6,24,6,-4],[7,24,6],[6,24,6,-4],[7,24,6],[9,24,6,-2],[9,24,6,-1],
  [6,24,6,-2],[6,24,6,-1],[2,24,6,-2],[6,24,6,-3],[10,26,7,-1],[14,26,7],[10,24,6,-1],[5,16,2,-1],
  [20,24,23,-1],[17,17,0],[18,18,1,-1],[11,24,6,-1],[14,15,0,-1],[14,15,0,-1],[16,20,4,-2],[16,20,4,-1],
  [8,22,5,-1],[9,23,6,-1],[9,22,5,-1],[13,22,5,-1],[18,22,4],[17,22,4,-1],[17,19,1,-1],[17,22,4,-1],
  [10,45,79,114,148,183,217,252,
  286,321,355,390,424,459,493,528],[34,83,132,181,230,279,329,378],[565,419]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmsy10:[[19,2,-6,-2],[4,4,-5,-2],[15,15,0,-4],[11,13,-1,-2],[20,17,1,-1],[15,15,0],[20,20,0,-1],[20,20,5,-1],
  [20,20,3,-1],[20,20,3,-1],[20,20,3,-1],[20,20,3,-1],[20,20,3,-1],[27,28,7,-1],[12,12,-1,-1],[12,12,-1,-1],
  [20,14,0,-1],[20,13,-1,-1],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],
  [20,8,-3,-1],[20,13,-1,-1],[19,18,2,-2],[19,18,2,-2],[27,19,2,-1],[27,19,2,-1],[19,18,2,-2],[18,17,1,-2],
  [27,11,-2,-1],[27,11,-2,-1],[11,26,6,-2],[11,26,6,-2],[27,11,-2,-1],[27,27,6,-1],[27,26,6,-1],[20,13,-1,-1],
  [27,17,1,-1],[27,17,1,-1],[17,26,6],[17,27,6],[27,17,1,-1],[27,27,6,-1],[27,26,6,-1],[20,14,1,-1],
  [7,16,-1,-1],[27,14,1,-1],[15,18,2,-2],[15,18,2,-2],[23,21,0,-1],[23,22,7,-1],[15,28,7,-4],[3,12,-1,-1],
  [17,22,1],[14,21,0,-1],[17,9,-2,-1],[13,26,3,-1],[20,22,1,-1],[19,22,1,-1],[20,20,0,-1],[20,20,0,-1],
  [15,20,0,-1],[23,23,2],[19,22,1,-1],[16,22,1],[23,20,0],[17,22,1],[24,21,1],[17,25,4,-1],
  [24,22,2],[20,20,0,1],[24,24,4,-1],[21,22,1,-1],[18,22,1,-1],[33,23,2],[30,25,2,1],[22,22,1,-1],
  [22,22,2],[20,25,4,-3],[25,21,1],[19,22,1],[23,21,0],[21,21,1,1],[19,22,2,-1],[29,22,2,-1],
  [23,20,0,-1],[21,24,4],[22,20,0,-1],[17,19,1,-1],[17,19,1,-1],[17,19,1,-1],[17,19,1,-1],[17,19,1,-1],
  [15,20,0,-1],[16,21,0,-1],[8,30,8,-5],[8,30,8],[8,30,8,-5],[8,30,8],[11,30,8,-2],[11,30,8,-2],
  [7,30,8,-3],[7,30,8,-1],[2,30,8,-3],[8,30,8,-3],[11,31,8,-2],[17,31,8],[12,30,8,-1],[6,20,3,-1],
  [23,30,28,-2],[20,20,0,-1],[22,21,1,-1],[13,28,7,-1],[17,18,0,-1],[17,18,0,-1],[19,23,4,-2],[20,23,4,-1],
  [9,27,6,-2],[11,28,7,-1],[11,27,6,-1],[16,27,6,-1],[22,25,4],[20,26,5,-1],[20,22,1,-1],[20,25,4,-1],
  [12,53,95,136,177,218,260,301,
  342,384,425,466,507,549,590,631],[39,98,157,216,274,333,392,451],[676,500]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmsy10:[[22,3,-7,-2],[4,5,-6,-3],[17,17,0,-5],[13,15,-1,-2],[23,19,1,-2],[17,17,0],[23,23,0,-2],[23,23,6,-2],
  [24,23,3,-1],[24,23,3,-1],[24,23,3,-1],[24,23,3,-1],[24,23,3,-1],[31,33,8,-1],[14,15,-1,-1],[14,15,-1,-1],
  [23,17,0,-2],[23,15,-1,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],
  [24,9,-4,-1],[23,16,-1,-2],[22,21,2,-2],[22,21,2,-2],[30,23,3,-2],[30,23,3,-2],[22,21,2,-2],[22,21,2,-2],
  [30,13,-2,-2],[30,13,-2,-2],[13,31,7,-2],[13,31,7,-2],[30,13,-2,-2],[31,31,7,-2],[31,31,7,-2],[24,15,-1,-1],
  [30,19,1,-2],[30,19,1,-2],[19,31,7,-1],[19,31,7,-1],[32,19,1,-1],[31,31,7,-1],[31,31,7,-1],[24,16,1,-1],
  [8,18,-1,-1],[31,16,1,-1],[18,21,2,-2],[18,21,2,-2],[27,25,0,-2],[27,25,8,-2],[18,33,8,-4],[4,13,-2,-1],
  [19,25,1],[15,24,0,-2],[19,10,-3,-2],[15,30,3,-1],[24,26,1,-1],[23,25,1,-1],[23,23,0,-2],[23,23,0,-2],
  [18,24,0,-1],[26,27,2,-1],[22,25,1,-1],[19,25,1],[26,24,0],[19,25,1,-1],[29,26,2],[20,28,4,-1],
  [28,26,2],[23,24,0,1],[28,28,4,-1],[24,25,1,-1],[22,25,1,-1],[37,26,2,-1],[35,29,2,1],[25,25,1,-2],
  [25,26,2],[24,29,5,-3],[29,25,1],[22,25,1],[26,25,0,-1],[25,25,1,1],[22,26,2,-1],[35,26,2,-1],
  [27,24,0,-1],[24,29,5,-1],[25,24,0,-1],[20,22,1,-1],[20,22,1,-1],[20,22,1,-1],[19,22,1,-2],[19,22,1,-2],
  [18,24,0,-1],[17,24,0,-2],[10,35,9,-5],[10,35,9],[10,35,9,-5],[10,35,9],[13,35,9,-2],[13,35,9,-2],
  [9,35,9,-3],[8,35,9,-2],[2,35,9,-4],[9,35,9,-4],[13,37,10,-2],[19,37,10,-1],[13,35,9,-2],[7,23,3,-1],
  [27,35,33,-2],[24,24,0,-1],[26,26,2,-1],[15,33,8,-1],[19,21,0,-2],[19,21,0,-2],[22,27,5,-3],[22,27,5,-2],
  [11,31,7,-2],[12,32,8,-2],[12,31,7,-2],[19,31,7,-1],[25,30,5,-1],[23,31,6,-2],[24,27,2,-1],[24,30,5,-1],
  [14,64,114,163,213,263,312,362,
  412,461,511,561,610,660,710,759],[48,119,190,260,331,402,472,543],[814,603]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmsy10:[[26,3,-9,-3],[5,5,-8,-3],[20,20,0,-6],[16,18,-1,-2],[28,24,2,-2],[20,20,0],[28,28,0,-2],[28,28,7,-2],
  [28,28,4,-2],[28,28,4,-2],[28,28,4,-2],[28,28,4,-2],[28,28,4,-2],[37,39,9,-2],[17,17,-2,-2],[17,17,-2,-2],
  [28,20,0,-2],[28,18,-1,-2],[26,33,6,-3],[26,33,6,-3],[26,32,6,-3],[26,32,6,-3],[26,32,6,-3],[26,32,6,-3],
  [28,10,-5,-2],[28,18,-2,-2],[26,25,2,-3],[26,25,2,-3],[37,27,3,-2],[37,27,3,-2],[26,24,2,-3],[26,24,2,-3],
  [37,15,-3,-2],[37,15,-3,-2],[15,37,8,-3],[15,37,8,-3],[37,15,-3,-2],[37,37,8,-2],[37,37,8,-2],[28,18,-1,-2],
  [37,23,1,-2],[37,23,1,-2],[23,37,8,-1],[23,37,8,-1],[39,23,1,-1],[37,37,8,-2],[37,37,8,-2],[28,20,1,-2],
  [10,22,-1,-1],[37,20,1,-2],[21,25,2,-3],[21,25,2,-3],[32,30,0,-2],[32,30,9,-2],[22,39,9,-5],[3,16,-2,-2],
  [23,30,1],[19,29,0,-2],[23,12,-3,-2],[18,36,4,-1],[28,31,1,-2],[27,30,1,-2],[28,28,0,-2],[28,28,0,-2],
  [21,29,0,-2],[32,32,2,-1],[27,30,1,-1],[22,30,1],[32,28,0],[23,30,1,-1],[34,30,2],[24,34,5,-1],
  [34,30,2],[27,28,0,1],[34,33,5,-1],[29,30,1,-1],[26,30,1,-1],[45,31,2,-1],[42,34,2,2],[30,30,1,-2],
  [30,30,2],[29,35,6,-4],[35,29,1],[27,30,1],[32,30,0,-1],[30,30,2,1],[26,30,2,-1],[42,30,2,-1],
  [32,28,0,-2],[29,34,6,-1],[31,28,0,-1],[23,26,1,-2],[23,26,1,-2],[23,26,1,-2],[23,26,1,-2],[23,26,1,-2],
  [21,29,0,-2],[21,29,0,-2],[11,42,11,-7],[11,42,11],[11,42,11,-7],[10,42,11,-1],[15,42,11,-3],[15,42,11,-3],
  [10,42,11,-4],[10,42,11,-2],[3,42,11,-4],[10,42,11,-5],[15,44,12,-3],[23,44,12,-1],[17,42,11,-2],[7,28,4,-2],
  [32,42,40,-3],[29,28,0,-1],[31,30,2,-2],[18,39,9,-2],[23,25,0,-2],[23,25,0,-2],[27,33,6,-3],[27,33,6,-2],
  [14,38,9,-2],[14,38,9,-2],[14,38,9,-2],[22,37,8,-2],[30,36,6,-1],[28,37,7,-2],[28,32,2,-2],[28,36,6,-2],
  [17,77,136,196,255,314,374,433,
  493,552,612,671,730,790,849,909],[58,142,227,311,396,481,565,650],[974,721]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmsy10:[[30,3,-11,-4],[6,6,-9,-4],[24,24,0,-7],[19,22,-1,-3],[34,28,2,-2],[24,24,0],[34,33,0,-2],[34,34,9,-2],
  [34,33,4,-2],[34,33,4,-2],[34,33,4,-2],[34,33,4,-2],[34,33,4,-2],[45,47,11,-2],[20,20,-2,-2],[20,20,-2,-2],
  [34,24,0,-2],[34,22,-1,-2],[30,39,7,-4],[30,39,7,-4],[30,38,7,-4],[30,39,7,-4],[30,38,7,-4],[30,39,7,-4],
  [34,12,-6,-2],[34,22,-2,-2],[30,29,2,-4],[30,29,2,-4],[45,32,4,-2],[45,32,4,-2],[30,29,2,-4],[30,29,2,-4],
  [45,18,-3,-2],[45,18,-3,-2],[18,44,10,-3],[18,44,10,-3],[45,18,-3,-2],[45,45,10,-2],[45,44,10,-2],[34,22,-1,-2],
  [45,28,2,-2],[45,28,2,-2],[28,44,10,-1],[28,44,10,-1],[47,28,2,-1],[45,45,10,-2],[45,44,10,-2],[34,23,1,-2],
  [12,26,-2,-1],[45,23,1,-2],[25,29,2,-4],[25,29,2,-4],[38,35,0,-3],[39,36,11,-2],[26,46,11,-6],[4,19,-3,-2],
  [28,35,1],[23,34,0,-2],[28,14,-4,-2],[21,42,4,-2],[33,38,2,-2],[32,36,1,-2],[34,33,0,-2],[34,33,0,-2],
  [26,34,0,-2],[38,39,3,-1],[32,37,2,-1],[27,37,2],[37,34,0,-1],[27,37,2,-1],[41,36,2],[28,41,6,-2],
  [39,37,3,-1],[33,34,0,2],[39,40,6,-2],[35,37,2,-1],[31,37,2,-1],[54,38,3,-1],[50,41,3,2],[37,37,2,-2],
  [35,37,3,-1],[34,42,7,-5],[40,36,2,-1],[32,37,2],[38,36,0,-1],[35,36,2,1],[32,37,3,-1],[50,37,3,-1],
  [38,34,0,-2],[35,41,7,-1],[37,34,0,-1],[28,32,2,-2],[28,31,1,-2],[28,32,2,-2],[28,31,1,-2],[28,31,1,-2],
  [25,34,0,-2],[26,34,0,-2],[13,50,13,-8],[13,50,13,-1],[13,50,13,-8],[13,50,13,-1],[18,50,13,-3],[18,50,13,-3],
  [12,50,13,-5],[12,50,13,-2],[3,50,13,-5],[12,50,13,-6],[18,52,14,-3],[28,52,14,-1],[20,50,13,-2],[9,33,4,-2],
  [39,49,47,-3],[34,34,0,-1],[37,36,2,-2],[21,46,11,-2],[27,30,0,-3],[27,30,0,-3],[31,39,7,-4],[31,39,7,-3],
  [16,45,10,-3],[17,46,11,-2],[17,45,10,-2],[27,44,10,-2],[36,43,7,-1],[34,44,8,-2],[34,38,2,-2],[34,43,7,-2],
  [21,92,164,235,306,378,449,521,
  592,663,735,806,878,949,1020,1092],[68,170,271,373,475,576,678,780],[1170,865]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmsy10:[[36,3,-13,-5],[7,7,-11,-5],[30,29,0,-8],[23,26,-2,-3],[40,34,2,-3],[29,29,0],[40,40,0,-3],[40,40,10,-3],
  [40,40,5,-3],[40,40,5,-3],[40,40,5,-3],[40,40,5,-3],[40,40,5,-3],[53,56,13,-3],[24,24,-3,-3],[24,24,-3,-3],
  [40,28,-1,-3],[40,26,-2,-3],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],
  [40,15,-7,-3],[40,26,-3,-3],[37,35,3,-4],[37,35,3,-4],[53,38,4,-3],[53,38,4,-3],[37,35,3,-4],[37,35,3,-4],
  [53,22,-4,-3],[53,22,-4,-3],[22,53,12,-4],[22,53,12,-4],[53,22,-4,-3],[53,53,12,-3],[53,53,12,-3],[40,26,-2,-3],
  [53,33,2,-3],[53,33,2,-3],[34,53,12,-1],[34,53,12,-1],[55,33,2,-2],[53,54,12,-3],[53,53,12,-3],[40,28,1,-3],
  [15,31,-2,-1],[53,28,1,-3],[31,35,3,-4],[31,35,3,-4],[46,43,0,-3],[46,43,13,-3],[30,56,13,-8],[5,23,-3,-3],
  [33,43,2],[27,41,0,-3],[33,16,-5,-3],[25,51,5,-2],[40,45,2,-2],[38,43,1,-3],[40,40,0,-3],[40,40,0,-3],
  [30,41,0,-3],[46,46,3,-1],[39,44,2,-1],[32,44,2],[45,41,0,-1],[33,44,2,-1],[48,43,2,-1],[34,49,7,-2],
  [48,44,3,-1],[40,41,0,2],[48,48,7,-2],[43,44,2,-1],[38,44,2,-1],[65,45,3,-1],[60,49,3,2],[43,44,2,-3],
  [43,44,3,-1],[41,50,8,-6],[49,43,2,-1],[37,44,2,-1],[46,43,0,-1],[42,43,2,1],[37,44,3,-2],[60,44,3,-2],
  [45,41,0,-3],[42,49,8,-1],[44,41,0,-2],[33,38,2,-3],[33,38,2,-3],[33,38,2,-3],[33,38,2,-3],[33,38,2,-3],
  [30,41,0,-3],[30,41,0,-3],[15,60,15,-10],[15,60,15,-1],[15,60,15,-10],[15,60,15,-1],[22,60,15,-4],[22,60,15,-4],
  [14,60,15,-6],[14,60,15,-3],[3,60,15,-7],[15,60,15,-7],[22,62,16,-4],[34,62,16,-1],[24,60,15,-3],[10,40,5,-3],
  [47,60,57,-4],[40,41,0,-2],[45,43,2,-2],[25,56,13,-3],[33,36,0,-3],[33,36,0,-3],[38,47,9,-5],[38,47,9,-3],
  [18,55,13,-4],[20,55,13,-3],[20,54,12,-3],[32,53,12,-3],[44,51,8,-1],[40,53,10,-3],[40,45,2,-3],[40,51,8,-3],
  [25,111,196,282,368,454,539,625,
  711,797,882,968,1054,1140,1225,1311],[82,204,326,448,570,692,814,936],[1404,1039]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmti10:[[5,5,0],[6,5,0],[5,6,1,-1],[5,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0,-1],
  [5,5,0,-1],[5,5,0,-1],[6,5,0],[6,7,2],[5,7,2],[5,7,2],[7,7,2],[9,7,2,2],
  [3,3,0],[4,5,2,1],[1,2,-3,-2],[2,2,-3,-2],[2,2,-3,-2],[2,2,-3,-2],[2,2,-3,-2],[2,2,-3,-3],
  [2,2,2,-1],[4,7,2],[5,3,0],[5,3,0],[4,5,1],[7,5,0],[6,6,1,-1],[8,6,1,2],
  [3,1,-2],[3,5,0],[3,2,-3,-1],[5,7,2,-1],[5,5,0],[5,7,1,-1],[6,6,1],[2,2,-3,-1],
  [3,7,2,-1],[3,7,2],[3,3,-2,-1],[5,5,1,-1],[2,3,2],[3,1,-1],[2,1,0],[5,8,2],
  [4,6,1],[3,5,0,-1],[4,6,1],[4,6,1],[4,7,2],[4,6,1],[4,6,1],[4,5,0,-1],
  [4,6,1],[4,6,1],[2,3,0],[2,5,2],[3,6,2],[5,3,0,-1],[3,6,2],[3,5,0,-1],
  [5,5,0,-1],[5,5,0],[6,5,0],[5,6,1,-1],[6,5,0],[6,5,0],[6,5,0],[5,6,1,-1],
  [6,5,0],[4,5,0],[5,6,1],[6,5,0],[5,5,0],[7,5,0],[6,5,0],[5,6,1,-1],
  [5,5,0],[5,7,2,-1],[5,6,1],[5,6,1],[5,5,0,-1],[5,6,1,-1],[5,5,0,-1],[7,5,0,-1],
  [8,5,0,2],[5,5,0,-1],[5,5,0],[3,8,2],[2,3,-2,-2],[3,8,2],[2,1,-4,-2],[2,1,-4,-1],
  [2,3,-2,-1],[4,3,0],[4,5,0],[4,3,0],[4,5,0],[4,3,0],[4,7,2],[4,5,2],
  [4,5,0],[3,5,0],[4,7,2,1],[4,5,0],[2,5,0],[6,3,0],[4,3,0],[4,3,0],
  [4,5,2],[4,5,2],[4,3,0],[3,3,0],[3,5,0],[4,3,0],[4,3,0],[5,3,0],
  [4,3,0],[4,5,2],[3,3,0],[3,1,-1,-1],[6,1,-1,-1],[6,4,-1,2],[2,1,-4,-2],[2,1,-4,-2],
  [3,11,20,28,37,45,54,62,
  71,79,88,96,105,113,122,130],[9,17,26,34,42,51,59,67],[140,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmti10:[[6,6,0],[6,6,0],[6,7,1,-1],[5,6,0],[6,6,0],[7,6,0],[7,6,0],[6,6,0,-1],
  [5,6,0,-1],[6,6,0,-1],[6,6,0],[7,8,2,1],[6,8,2,1],[6,8,2,1],[9,8,2,1],[9,8,2,1],
  [3,4,0],[4,6,2,1],[2,2,-4,-2],[3,2,-4,-2],[3,1,-4,-2],[3,2,-4,-2],[3,1,-4,-2],[3,2,-4,-3],
  [2,2,2,-1],[6,8,2,1],[6,4,0],[6,4,0],[4,5,1],[8,6,0],[8,7,1,-1],[9,7,1,2],
  [3,1,-2],[2,6,0,-1],[3,3,-3,-1],[6,8,2,-1],[6,6,0],[6,7,1,-1],[6,7,1,-1],[1,3,-3,-2],
  [3,8,2,-1],[3,8,2],[4,4,-2,-1],[5,6,1,-1],[2,3,2],[3,1,-1],[1,1,0,-1],[5,8,2],
  [4,7,1,-1],[3,6,0,-1],[5,7,1],[5,7,1],[4,8,2],[5,7,1],[4,7,1,-1],[4,7,1,-1],
  [5,7,1],[5,7,1],[2,4,0,-1],[3,6,2],[3,6,2],[6,2,-1,-1],[4,6,2],[4,6,0,-1],
  [6,7,1,-1],[6,6,0],[6,6,0],[6,7,1,-1],[7,6,0],[6,6,0],[6,6,0],[6,7,1,-1],
  [7,6,0],[4,6,0],[5,7,1],[7,6,0],[5,6,0],[8,6,0],[7,6,0],[6,7,1,-1],
  [6,6,0],[6,8,2,-1],[6,7,1],[5,7,1],[6,6,0,-1],[6,7,1,-1],[6,6,0,-1],[8,6,0,-1],
  [9,6,0,2],[6,6,0,-1],[6,6,0],[4,8,2],[3,3,-3,-2],[3,8,2],[2,2,-4,-2],[1,2,-4,-2],
  [2,3,-3,-1],[5,4,0],[3,6,0,-1],[4,4,0],[5,6,0],[4,4,0],[5,8,2,1],[4,6,2],
  [5,6,0],[3,6,0],[4,8,2,1],[4,6,0],[3,6,0],[7,4,0],[5,4,0],[4,4,0],
  [4,6,2],[4,6,2],[4,4,0],[4,5,1],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-2,-1],[7,1,-2,-1],[3,2,-4,-2],[3,2,-4,-2],[3,2,-4,-2],
  [3,14,24,34,44,54,64,75,
  85,95,105,115,126,136,146,156],[11,21,31,41,51,61,71,81],[168,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmti10:[[7,7,0],[8,7,0],[7,8,1,-1],[7,7,0],[8,7,0],[9,7,0],[7,7,0,-1],[7,7,0,-2],
  [7,7,0,-1],[6,7,0,-2],[7,7,0,-1],[9,9,2,1],[7,9,2,1],[8,9,2,1],[11,9,2,1],[11,9,2,1],
  [3,5,0,-1],[5,7,2,1],[2,2,-5,-3],[3,2,-5,-3],[3,2,-5,-3],[4,2,-5,-2],[4,1,-5,-2],[3,3,-5,-4],
  [3,2,2,-1],[7,9,2,1],[7,6,1,-1],[7,6,1,-1],[6,7,1],[10,7,0],[10,8,1,-1],[10,9,1,2],
  [3,2,-2,-1],[3,8,0,-1],[4,3,-4,-2],[8,9,2,-1],[6,8,1,-1],[8,9,1,-1],[7,9,1,-1],[2,3,-4,-2],
  [4,10,2,-1],[4,10,2],[4,5,-3,-2],[7,7,1,-1],[3,3,2],[3,2,-1,-1],[2,1,0,-1],[6,10,2],
  [5,8,1,-1],[4,7,0,-1],[5,8,1,-1],[5,8,1,-1],[5,9,2],[5,8,1,-1],[5,8,1,-1],[6,8,1,-1],
  [5,10,1,-1],[6,10,1],[2,5,0,-1],[3,7,2],[4,7,2],[7,3,-1,-1],[5,7,2],[6,9,0],
  [7,8,1,-1],[7,7,0],[8,7,0],[7,8,1,-1],[8,7,0],[8,7,0],[8,7,0],[7,8,1,-1],
  [9,7,0],[5,7,0],[6,8,1,-1],[9,7,0],[7,7,0],[10,7,0],[9,7,0],[7,8,1,-1],
  [8,7,0],[7,9,2,-1],[8,8,1],[7,8,1],[7,7,0,-1],[7,8,1,-2],[7,8,1,-2],[9,8,1,-2],
  [11,7,0,2],[7,7,0,-2],[7,7,0],[5,10,2],[4,3,-4,-2],[3,10,2,-1],[4,2,-5,-2],[2,2,-5,-2],
  [2,3,-4,-2],[5,6,1,-1],[4,8,1,-1],[4,6,1,-1],[5,8,1,-1],[4,6,1,-1],[6,9,2,1],[5,7,2],
  [6,7,0],[3,7,0,-1],[5,9,2,1],[5,9,0],[2,7,0,-1],[9,9,0],[5,5,0,-1],[4,6,1,-1],
  [5,7,2],[4,7,2,-1],[4,5,0,-1],[5,5,0],[3,7,0,-1],[5,6,1,-1],[4,6,1,-1],[6,6,1,-1],
  [6,6,1],[4,7,2,-1],[5,5,0],[5,1,-2,-1],[10,1,-2,-1],[8,5,-2,2],[4,2,-5,-2],[4,2,-5,-2],
  [4,16,28,40,51,63,75,87,
  99,111,123,135,146,158,170,182],[13,24,36,47,59,71,82,94],[195,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmti10:[[9,9,0],[8,9,0,-1],[9,10,1,-1],[8,9,0],[8,9,0,-1],[10,9,0],[9,9,0,-1],[8,9,0,-2],
  [8,9,0,-1],[8,9,0,-2],[8,9,0,-1],[10,12,3,1],[9,12,3,1],[9,12,3,1],[12,12,3,1],[13,12,3,1],
  [3,7,1,-1],[5,9,3,1],[3,3,-6,-3],[3,3,-6,-4],[4,2,-6,-3],[4,3,-6,-3],[4,2,-6,-3],[3,3,-6,-5],
  [3,3,3,-1],[8,12,3,1],[8,7,1,-1],[8,7,1,-1],[6,8,1,-1],[12,9,0],[10,10,1,-2],[13,10,1,3],
  [3,2,-3,-1],[4,9,0,-1],[5,5,-4,-2],[9,12,3,-1],[8,10,1,-1],[9,10,1,-1],[9,10,1,-1],[3,5,-4,-2],
  [5,12,3,-1],[5,12,3],[5,5,-4,-2],[8,8,1,-1],[2,5,3,-1],[3,1,-2,-1],[2,2,0,-1],[8,12,3],
  [6,9,1,-1],[5,8,0,-1],[6,9,1,-1],[6,9,1,-1],[6,11,3],[6,9,1,-1],[6,9,1,-1],[7,9,1,-1],
  [6,9,1,-1],[6,9,1,-1],[3,6,0,-1],[3,9,3,-1],[4,9,3],[9,4,-1,-1],[5,9,3,-1],[5,9,0,-2],
  [9,10,1,-1],[9,9,0],[9,9,0],[9,10,1,-1],[10,9,0],[9,9,0],[9,9,0],[9,10,1,-1],
  [10,9,0],[6,9,0],[7,10,1,-1],[10,9,0],[8,9,0],[12,9,0],[10,9,0],[9,10,1,-1],
  [9,9,0],[9,12,3,-1],[9,10,1],[7,10,1,-1],[8,9,0,-2],[8,10,1,-2],[9,10,1,-2],[10,10,1,-2],
  [13,9,0,3],[9,9,0,-2],[8,9,0,-1],[5,12,3,-1],[5,5,-4,-3],[6,12,3,1],[4,3,-6,-3],[2,2,-6,-3],
  [3,5,-4,-2],[6,7,1,-1],[5,10,1,-1],[5,7,1,-1],[6,10,1,-1],[5,7,1,-1],[7,12,3,1],[6,9,3],
  [6,9,0,-1],[3,9,1,-1],[6,11,3,1],[5,10,1,-1],[3,9,0,-1],[9,7,1,-1],[6,7,1,-1],[6,7,1,-1],
  [7,9,3],[5,9,3,-1],[5,6,0,-1],[4,7,1,-1],[4,9,1,-1],[6,7,1,-1],[5,7,1,-1],[8,7,1,-1],
  [7,7,1],[6,9,3,-1],[6,7,1],[6,1,-3,-1],[11,1,-3,-1],[10,6,-3,3],[4,2,-6,-3],[4,2,-6,-3],
  [5,19,34,48,62,77,91,106,
  120,135,149,163,178,192,207,221],[16,30,45,59,73,87,101,115],[237,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmti10:[[9,10,0,-1],[10,10,0,-1],[9,11,1,-2],[9,10,0],[10,10,0,-1],[11,10,0,-1],[10,10,0,-1],[9,10,0,-3],
  [9,10,0,-2],[9,10,0,-3],[10,10,0,-1],[12,13,3,1],[10,13,3,1],[10,13,3,1],[14,13,3,1],[15,13,3,1],
  [4,8,1,-1],[6,10,3,1],[2,3,-7,-4],[4,3,-7,-4],[4,2,-7,-4],[4,3,-7,-4],[5,2,-7,-3],[4,3,-7,-6],
  [4,3,3,-1],[9,13,3,1],[9,8,1,-1],[9,8,1,-1],[7,10,2,-1],[13,10,0,-1],[13,11,1,-2],[15,12,1,3],
  [4,2,-4,-1],[5,10,0,-1],[6,5,-5,-2],[11,13,3,-1],[9,11,1,-1],[10,12,1,-2],[11,11,1,-1],[3,5,-5,-3],
  [6,15,4,-2],[6,15,4],[6,7,-4,-2],[9,9,1,-2],[3,5,3,-1],[4,2,-2,-1],[2,2,0,-1],[9,15,4],
  [7,11,1,-1],[6,10,0,-1],[7,11,1,-1],[7,11,1,-1],[7,13,3],[7,11,1,-1],[7,11,1,-1],[7,11,1,-2],
  [7,11,1,-1],[7,11,1,-1],[4,6,0,-1],[4,9,3,-1],[5,10,3],[10,5,-1,-1],[6,10,3,-1],[6,10,0,-2],
  [9,11,1,-2],[9,10,0,-1],[10,10,0,-1],[10,11,1,-2],[10,10,0,-1],[10,10,0,-1],[10,10,0,-1],[10,11,1,-2],
  [11,10,0,-1],[7,10,0],[8,11,1,-1],[11,10,0,-1],[8,10,0,-1],[13,10,0,-1],[11,10,0,-1],[9,11,1,-2],
  [10,10,0,-1],[9,13,3,-2],[9,11,1,-1],[8,11,1,-1],[10,10,0,-2],[10,11,1,-2],[9,11,1,-3],[12,11,1,-3],
  [15,10,0,3],[10,10,0,-3],[9,10,0,-1],[6,15,4,-1],[6,5,-5,-3],[6,15,4,1],[5,3,-7,-3],[2,2,-8,-3],
  [3,5,-5,-2],[7,8,1,-1],[6,11,1,-1],[6,8,1,-1],[7,11,1,-1],[6,8,1,-1],[8,13,3,1],[7,10,3],
  [7,11,1,-1],[4,11,1,-1],[6,13,3,1],[6,11,1,-1],[4,11,1,-1],[11,8,1,-1],[8,8,1,-1],[7,8,1,-1],
  [8,10,3],[6,10,3,-1],[6,8,1,-1],[5,8,1,-1],[5,10,1,-1],[7,8,1,-1],[6,8,1,-1],[9,8,1,-1],
  [8,8,1],[7,10,3,-1],[6,8,1,-1],[7,1,-3,-1],[14,1,-3,-1],[11,7,-3,3],[5,2,-8,-3],[5,2,-8,-3],
  [6,23,40,56,73,90,107,124,
  141,158,175,192,209,226,243,260],[19,36,52,69,85,102,119,135],[279,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmti10:[[11,12,0,-1],[12,12,0,-1],[12,13,1,-2],[10,13,0,-1],[12,12,0,-1],[14,12,0,-1],[13,12,0,-1],[12,12,0,-3],
  [11,12,0,-2],[11,12,0,-3],[12,12,0,-1],[14,16,4,1],[12,16,4,1],[12,16,4,1],[17,16,4,1],[17,16,4,1],
  [5,9,1,-1],[7,12,4,1],[3,4,-8,-5],[5,4,-8,-5],[5,3,-8,-4],[6,4,-8,-4],[6,1,-9,-4],[4,4,-9,-8],
  [5,4,4,-1],[11,16,4,1],[12,9,1,-1],[12,9,1,-1],[9,11,2,-1],[15,12,0,-1],[16,13,1,-2],[17,14,1,3],
  [5,3,-4,-1],[5,13,0,-2],[6,6,-6,-3],[12,16,4,-2],[11,13,1,-1],[13,14,1,-2],[12,14,1,-2],[4,6,-6,-3],
  [7,17,4,-2],[7,17,4],[7,8,-5,-3],[11,11,1,-2],[3,6,4,-1],[5,2,-3,-1],[2,2,0,-2],[11,17,4],
  [8,13,1,-2],[6,12,0,-2],[9,13,1,-1],[9,13,1,-1],[8,16,4],[9,13,1,-1],[8,13,1,-2],[9,13,1,-2],
  [9,13,1,-1],[9,13,1,-1],[4,8,0,-2],[5,12,4,-1],[5,13,4,-1],[12,5,-2,-2],[7,13,4,-1],[7,13,0,-3],
  [12,13,1,-2],[11,13,0,-1],[12,12,0,-1],[12,13,1,-2],[13,12,0,-1],[12,12,0,-1],[12,12,0,-1],[12,13,1,-2],
  [14,12,0,-1],[8,12,0,-1],[10,13,1,-1],[14,12,0,-1],[10,12,0,-1],[16,12,0,-1],[14,12,0,-1],[12,13,1,-2],
  [12,12,0,-1],[12,16,4,-2],[12,13,1,-1],[10,13,1,-1],[11,12,0,-3],[12,13,1,-3],[12,13,1,-3],[16,13,1,-3],
  [17,12,0,3],[12,12,0,-3],[11,12,0,-1],[7,17,4,-1],[7,6,-6,-4],[7,17,4,1],[5,3,-9,-4],[3,3,-9,-4],
  [3,6,-6,-3],[8,9,1,-1],[6,13,1,-2],[7,9,1,-1],[9,13,1,-1],[6,9,1,-2],[9,16,4,1],[8,12,4,-1],
  [8,13,1,-1],[5,12,1,-1],[7,16,4,1],[8,13,1,-1],[5,13,1,-1],[14,9,1,-1],[9,9,1,-1],[8,9,1,-1],
  [9,12,4],[8,12,4,-1],[8,9,1,-1],[6,9,1,-1],[6,12,1,-1],[9,9,1,-1],[8,9,1,-1],[11,9,1,-1],
  [8,9,1,-1],[8,12,4,-1],[7,9,1,-1],[9,1,-4,-1],[16,1,-4,-2],[13,8,-4,3],[6,3,-9,-4],[6,3,-9,-4],
  [7,27,47,68,88,109,129,149,
  170,190,210,231,251,271,292,312],[22,42,61,81,101,121,141,161],[335,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmti10:[[13,14,0,-1],[14,15,0,-1],[13,16,1,-3],[12,15,0,-1],[14,14,0,-1],[16,14,0,-1],[15,14,0,-1],[13,15,0,-4],
  [12,14,0,-3],[13,14,0,-4],[14,15,0,-2],[17,19,4,1],[13,19,4,1],[14,19,4,1],[20,20,5,1],[20,20,5,1],
  [6,10,1,-1],[8,13,4,1],[4,4,-10,-5],[5,4,-10,-6],[6,3,-10,-5],[7,4,-10,-5],[8,1,-11,-4],[5,5,-10,-9],
  [5,4,4,-2],[13,19,4,1],[14,10,1,-1],[13,10,1,-2],[10,13,2,-1],[18,14,0,-1],[18,16,1,-3],[15,17,2,-2],
  [5,3,-5,-2],[6,15,0,-2],[8,6,-8,-3],[15,18,4,-2],[13,16,1,-1],[14,17,2,-3],[14,16,1,-2],[4,6,-8,-4],
  [8,20,5,-3],[8,20,5],[8,9,-6,-4],[12,13,2,-3],[4,7,4,-1],[6,2,-3,-1],[3,3,0,-2],[13,20,5],
  [10,15,1,-2],[8,14,0,-2],[10,15,1,-1],[11,15,1,-1],[9,18,4,-1],[10,15,1,-2],[10,15,1,-2],[10,15,1,-3],
  [9,15,1,-2],[9,15,1,-2],[4,9,0,-2],[5,13,4,-1],[6,15,5,-1],[14,6,-2,-2],[8,15,5,-1],[8,15,0,-3],
  [13,16,1,-3],[13,15,0,-1],[14,14,0,-1],[14,16,1,-3],[15,14,0,-1],[14,14,0,-1],[14,14,0,-1],[14,16,1,-3],
  [16,14,0,-1],[9,14,0,-1],[12,15,1,-1],[17,14,0,-1],[12,14,0,-1],[19,14,0,-1],[16,14,0,-1],[13,16,1,-3],
  [14,14,0,-1],[13,19,4,-3],[14,15,1,-1],[12,16,1,-1],[13,14,0,-3],[13,15,1,-4],[14,15,1,-4],[18,15,1,-4],
  [21,14,0,4],[14,14,0,-4],[13,14,0,-1],[8,20,5,-1],[8,7,-7,-5],[9,20,5,1],[6,4,-10,-5],[3,3,-11,-5],
  [4,6,-8,-4],[9,10,1,-2],[8,15,1,-2],[8,10,1,-2],[10,15,1,-2],[8,10,1,-2],[10,19,4,1],[9,14,5,-1],
  [10,15,1,-1],[6,14,1,-1],[9,18,4,1],[9,15,1,-1],[5,15,1,-1],[16,10,1,-1],[11,10,1,-1],[9,10,1,-2],
  [11,13,4],[8,13,4,-2],[9,10,1,-1],[8,10,1,-1],[7,14,1,-1],[11,10,1,-1],[9,10,1,-1],[13,10,1,-1],
  [10,10,1,-1],[10,13,4,-1],[9,10,1,-1],[9,1,-5,-2],[19,1,-5,-2],[7,4,-10,-5],[7,3,-11,-5],[6,3,-11,-5],
  [8,32,57,81,106,130,155,179,
  204,228,252,277,301,326,350,375],[26,50,74,98,122,145,169,193],[402,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmti10:[[16,17,0,-1],[17,18,0,-1],[16,18,1,-3],[15,18,0,-1],[17,17,0,-1],[20,17,0,-1],[17,17,0,-2],[15,17,0,-5],
  [15,17,0,-3],[15,17,0,-5],[17,17,0,-2],[20,22,5,1],[16,22,5,1],[17,22,5,1],[23,22,5,1],[24,22,5,1],
  [6,12,1,-2],[9,16,5,1],[4,5,-12,-7],[6,5,-12,-8],[7,3,-12,-6],[8,5,-12,-6],[9,2,-13,-5],[5,5,-13,-11],
  [6,5,5,-2],[15,22,5,1],[16,12,1,-2],[16,12,1,-2],[13,16,3,-1],[22,17,0,-1],[23,18,1,-3],[24,20,2,4],
  [7,4,-6,-2],[7,18,0,-2],[9,8,-9,-4],[18,22,5,-2],[15,18,1,-2],[18,20,2,-3],[17,19,1,-3],[4,8,-9,-5],
  [10,24,6,-3],[10,24,6],[10,11,-7,-4],[15,16,2,-3],[5,8,5,-1],[7,2,-4,-2],[4,3,0,-2],[15,24,6],
  [12,17,1,-2],[9,16,0,-2],[12,17,1,-2],[12,17,1,-2],[11,21,5,-1],[12,17,1,-2],[12,17,1,-2],[12,17,1,-3],
  [12,17,1,-2],[12,17,1,-2],[6,11,0,-2],[7,16,5,-1],[7,18,6,-1],[17,6,-3,-2],[9,18,6,-2],[10,18,0,-4],
  [16,18,1,-3],[16,18,0,-1],[17,17,0,-1],[17,18,1,-3],[18,17,0,-1],[17,17,0,-1],[17,17,0,-1],[17,18,1,-3],
  [20,17,0,-1],[11,17,0,-1],[13,18,1,-2],[20,17,0,-1],[14,17,0,-1],[23,17,0,-1],[20,17,0,-1],[16,18,1,-3],
  [17,17,0,-1],[16,22,5,-3],[17,18,1,-1],[15,18,1,-1],[16,17,0,-4],[17,18,1,-4],[16,18,1,-5],[22,18,1,-5],
  [24,17,0,4],[16,17,0,-5],[15,17,0,-2],[10,24,6,-1],[9,8,-9,-6],[10,24,6,1],[7,4,-13,-6],[3,3,-13,-6],
  [4,8,-9,-5],[11,12,1,-2],[9,18,1,-2],[10,12,1,-2],[12,18,1,-2],[10,12,1,-2],[12,22,5,1],[11,16,5,-1],
  [12,18,1,-1],[6,17,1,-2],[10,21,5,1],[11,18,1,-1],[6,18,1,-2],[19,12,1,-2],[12,12,1,-2],[11,12,1,-2],
  [13,16,5],[10,16,5,-2],[10,12,1,-2],[9,12,1,-1],[7,16,1,-2],[12,12,1,-2],[10,12,1,-2],[15,12,1,-2],
  [12,12,1,-1],[11,16,5,-2],[10,12,1,-1],[12,1,-6,-2],[22,1,-6,-3],[8,5,-12,-6],[8,3,-13,-6],[8,3,-13,-6],
  [10,39,68,98,127,156,186,215,
  245,274,303,333,362,391,421,450],[32,61,90,118,147,176,204,233],[482,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmti10:[[20,20,0,-1],[20,21,0,-2],[19,22,1,-4],[18,21,0,-1],[20,20,0,-2],[24,20,0,-1],[21,20,0,-2],[19,21,0,-6],
  [18,20,0,-4],[18,20,0,-6],[20,21,0,-2],[23,27,6,1],[19,27,6,1],[20,27,6,1],[28,27,6,1],[29,27,6,1],
  [8,14,1,-2],[11,19,6,1],[5,7,-14,-8],[6,7,-14,-10],[8,5,-14,-8],[9,5,-15,-8],[11,2,-16,-6],[7,6,-15,-13],
  [7,6,6,-3],[18,27,6,1],[19,14,1,-2],[18,14,1,-3],[14,19,3,-2],[27,20,0,-1],[27,22,1,-4],[21,24,2,-3],
  [8,4,-8,-2],[8,21,0,-3],[10,10,-11,-5],[21,27,6,-3],[19,22,1,-2],[21,24,2,-4],[21,22,1,-3],[5,10,-11,-6],
  [11,30,8,-4],[12,30,8],[12,13,-9,-5],[18,18,2,-4],[5,9,6,-2],[8,2,-5,-2],[4,3,0,-3],[18,30,8],
  [14,21,1,-3],[11,20,0,-3],[14,21,1,-2],[15,21,1,-2],[13,26,6,-1],[14,21,1,-3],[14,21,1,-3],[14,21,1,-4],
  [14,21,1,-2],[13,21,1,-3],[6,13,0,-3],[7,19,6,-2],[9,22,7,-1],[20,8,-3,-3],[11,22,7,-2],[11,21,0,-5],
  [19,22,1,-4],[19,21,0,-1],[20,20,0,-2],[20,22,1,-4],[22,20,0,-1],[21,20,0,-1],[21,20,0,-1],[20,22,1,-4],
  [24,20,0,-1],[14,20,0,-1],[16,21,1,-2],[24,20,0,-1],[17,20,0,-1],[27,20,0,-2],[24,20,0,-1],[19,22,1,-4],
  [21,20,0,-1],[19,27,6,-4],[20,21,1,-1],[17,22,1,-2],[19,20,0,-5],[20,21,1,-5],[20,21,1,-6],[27,21,1,-6],
  [28,20,0,4],[21,20,0,-5],[19,20,0,-2],[11,30,8,-2],[10,9,-11,-8],[12,30,8,1],[8,5,-15,-7],[4,4,-16,-7],
  [5,9,-11,-6],[13,14,1,-3],[11,22,1,-3],[11,14,1,-3],[14,22,1,-3],[11,14,1,-3],[15,27,6,1],[14,19,6,-1],
  [14,22,1,-2],[8,20,1,-2],[12,25,6,1],[13,22,1,-2],[7,22,1,-2],[23,14,1,-2],[15,14,1,-2],[12,14,1,-3],
  [15,19,6],[12,19,6,-3],[13,14,1,-2],[11,14,1,-2],[9,20,1,-2],[15,14,1,-2],[13,14,1,-2],[19,14,1,-2],
  [14,14,1,-1],[13,19,6,-2],[12,14,1,-2],[14,1,-7,-2],[27,1,-7,-3],[10,7,-14,-7],[10,4,-16,-7],[9,4,-16,-7],
  [12,47,82,117,152,187,222,257,
  293,328,363,398,433,468,503,539],[37,72,106,140,175,209,243,278],[577,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmti10:[[22,24,0,-2],[24,25,0,-2],[22,25,1,-5],[20,25,0,-2],[24,23,0,-2],[27,24,0,-2],[25,24,0,-2],[22,24,0,-7],
  [20,24,0,-5],[21,24,0,-7],[23,24,0,-3],[27,31,7,1],[22,31,7,1],[23,31,7,1],[33,31,7,1],[33,31,7,1],
  [10,16,1,-2],[13,22,7,2],[6,7,-17,-9],[8,7,-17,-11],[10,5,-17,-9],[11,7,-17,-9],[12,1,-19,-8],[7,7,-18,-16],
  [9,7,7,-3],[21,31,7,1],[22,16,1,-3],[22,16,1,-3],[17,23,4,-2],[31,24,0,-2],[31,25,1,-5],[24,28,2,-4],
  [9,5,-9,-3],[10,25,0,-3],[12,11,-13,-6],[25,31,7,-4],[21,25,1,-3],[24,28,2,-5],[24,26,1,-4],[6,11,-13,-7],
  [13,35,9,-5],[13,35,9],[14,16,-10,-6],[22,21,2,-4],[6,11,7,-2],[9,3,-6,-3],[5,4,0,-3],[21,35,9],
  [15,24,1,-4],[12,23,0,-4],[17,24,1,-2],[17,24,1,-3],[15,30,7,-1],[17,24,1,-3],[16,24,1,-4],[17,24,1,-5],
  [16,24,1,-3],[16,24,1,-3],[8,15,0,-3],[9,22,7,-2],[9,25,8,-2],[23,9,-4,-4],[13,25,8,-2],[13,25,0,-6],
  [22,25,1,-5],[22,25,0,-2],[23,24,0,-2],[23,25,1,-5],[25,24,0,-2],[24,24,0,-2],[23,24,0,-2],[23,25,1,-5],
  [27,24,0,-2],[15,24,0,-2],[19,25,1,-3],[28,24,0,-2],[20,24,0,-2],[32,24,0,-2],[27,24,0,-2],[22,25,1,-5],
  [23,24,0,-2],[22,31,7,-5],[23,25,1,-2],[20,25,1,-2],[22,23,0,-6],[23,25,1,-6],[23,25,1,-7],[31,25,1,-7],
  [33,24,0,5],[24,24,0,-6],[22,24,0,-2],[13,35,9,-2],[12,11,-13,-9],[14,35,9,1],[9,6,-18,-9],[5,4,-19,-8],
  [6,11,-13,-7],[16,16,1,-3],[13,25,1,-3],[13,16,1,-3],[16,25,1,-3],[13,16,1,-3],[17,31,7,1],[16,22,7,-1],
  [17,25,1,-2],[10,24,-294,-2],[15,30,7,2],[15,25,1,-2],[8,25,1,-3],[27,16,1,-2],[18,16,1,-2],[15,16,1,-3],
  [18,22,7],[14,22,7,-3],[15,16,1,-2],[13,16,1,-2],[10,23,1,-3],[17,16,1,-2],[15,16,1,-2],[22,16,1,-2],
  [17,16,1,-1],[16,22,7,-2],[14,16,1,-2],[16,2,-8,-3],[32,2,-8,-4],[11,7,-17,-9],[12,4,-19,-8],[10,4,-19,-9],
  [14,56,98,141,183,225,267,310,
  352,394,437,479,521,563,606,648],[46,87,128,170,211,253,294,335],[694,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmti10:[[27,28,0,-2],[28,30,0,-3],[27,30,1,-6],[25,30,0,-2],[28,28,0,-3],[33,28,0,-2],[29,28,0,-3],[27,29,0,-8],
  [24,28,0,-6],[26,28,0,-8],[28,29,0,-4],[32,38,9,1],[26,38,9,1],[27,38,9,1],[39,38,9,1],[40,38,9,1],
  [11,20,1,-3],[16,28,9,2],[6,9,-20,-12],[9,9,-20,-14],[11,6,-20,-11],[13,8,-21,-11],[15,3,-22,-9],[9,8,-22,-19],
  [10,8,8,-4],[25,38,9,1],[27,20,1,-3],[26,20,1,-4],[21,27,5,-2],[37,28,0,-2],[37,30,1,-6],[30,34,3,-4],
  [11,5,-11,-3],[12,30,0,-4],[14,13,-16,-7],[30,37,8,-4],[26,30,1,-3],[29,34,3,-6],[28,31,1,-5],[7,13,-16,-9],
  [16,42,11,-6],[16,42,11],[16,18,-13,-8],[26,26,3,-5],[7,13,8,-3],[11,3,-7,-3],[6,5,0,-4],[26,42,11],
  [19,29,1,-4],[15,28,0,-4],[20,29,1,-3],[20,29,1,-3],[19,36,8,-1],[20,29,1,-4],[20,29,1,-4],[20,29,1,-6],
  [19,29,1,-4],[19,29,1,-4],[9,18,0,-4],[10,26,8,-3],[12,30,9,-2],[28,10,-5,-4],[16,30,9,-3],[15,30,0,-8],
  [27,30,1,-6],[27,30,0,-2],[29,28,0,-2],[28,30,1,-6],[30,28,0,-2],[29,28,0,-2],[28,28,0,-2],[28,30,1,-6],
  [33,28,0,-2],[19,28,0,-2],[23,29,1,-3],[34,28,0,-2],[24,28,0,-2],[39,28,0,-2],[33,28,0,-2],[27,30,1,-6],
  [28,28,0,-2],[27,37,8,-6],[28,29,1,-2],[23,30,1,-3],[26,28,0,-7],[27,29,1,-8],[28,29,1,-8],[37,29,1,-8],
  [40,28,0,6],[28,28,0,-8],[26,28,0,-3],[16,42,11,-3],[14,13,-16,-11],[16,42,11,1],[11,7,-22,-11],[5,5,-23,-10],
  [7,13,-16,-8],[18,20,1,-4],[15,30,1,-4],[16,20,1,-4],[19,30,1,-4],[16,20,1,-4],[20,38,9,1],[18,28,9,-2],
  [19,30,1,-3],[11,28,1,-3],[17,36,9,2],[18,30,1,-3],[10,30,1,-3],[32,20,1,-3],[21,20,1,-3],[17,20,1,-4],
  [21,27,8],[17,27,8,-4],[17,20,1,-3],[15,20,1,-3],[13,27,1,-3],[20,20,1,-3],[18,20,1,-3],[26,20,1,-3],
  [20,20,1,-2],[19,28,9,-3],[17,20,1,-2],[20,2,-10,-3],[38,2,-10,-5],[13,9,-20,-11],[14,5,-23,-10],[12,5,-23,-11],
  [17,67,118,168,219,270,320,371,
  421,472,522,573,624,674,725,775],[55,104,154,203,253,302,352,401],[831,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmti10:[[32,34,0,-3],[34,35,0,-3],[32,37,2,-7],[30,35,0,-2],[34,34,0,-3],[39,34,0,-3],[35,34,0,-4],[31,35,0,-10],
  [29,34,0,-7],[31,34,0,-10],[34,35,0,-4],[40,45,10,2],[32,45,10,2],[34,45,10,2],[47,45,10,2],[49,45,10,2],
  [13,23,1,-4],[18,32,10,2],[8,10,-24,-14],[11,11,-24,-16],[14,7,-24,-13],[15,9,-25,-13],[17,2,-27,-11],[10,9,-26,-23],
  [12,10,10,-5],[30,45,10,1],[32,23,1,-4],[31,23,1,-5],[24,33,6,-3],[45,34,0,-2],[44,37,2,-8],[36,40,3,-5],
  [13,7,-13,-4],[14,35,0,-5],[18,15,-19,-8],[36,44,10,-5],[31,36,1,-4],[35,40,3,-7],[34,37,2,-6],[9,15,-19,-10],
  [19,50,13,-7],[18,50,13,-1],[20,22,-15,-9],[31,31,3,-6],[8,16,10,-3],[13,3,-9,-4],[6,6,0,-5],[30,50,13,-1],
  [23,35,2,-5],[18,33,0,-5],[23,34,1,-4],[24,35,2,-4],[22,43,10,-2],[23,34,1,-5],[23,34,1,-5],[24,34,1,-7],
  [24,35,2,-4],[23,34,1,-5],[10,22,0,-5],[12,32,10,-3],[14,36,11,-2],[33,12,-6,-5],[18,36,11,-4],[18,35,0,-9],
  [32,36,1,-7],[32,35,0,-2],[33,34,0,-3],[33,37,2,-7],[35,34,0,-3],[34,34,0,-3],[33,34,0,-3],[33,37,2,-7],
  [39,34,0,-3],[23,34,0,-2],[27,36,2,-4],[39,34,0,-3],[28,34,0,-3],[46,34,0,-3],[39,34,0,-3],[32,37,2,-7],
  [33,34,0,-3],[32,45,10,-7],[33,36,2,-3],[28,37,2,-3],[32,34,0,-8],[33,36,2,-9],[33,35,1,-10],[45,36,2,-10],
  [48,34,0,7],[34,34,0,-9],[31,34,0,-4],[19,50,13,-3],[17,15,-19,-13],[19,50,13,1],[13,8,-26,-13],[6,6,-27,-12],
  [8,15,-19,-10],[22,23,1,-5],[18,35,1,-5],[18,23,1,-5],[23,35,1,-5],[18,23,1,-5],[25,45,10,2],[22,32,10,-2],
  [24,35,1,-3],[13,34,1,-4],[20,43,10,2],[22,35,1,-3],[11,35,1,-4],[38,23,1,-4],[25,23,1,-4],[20,23,1,-5],
  [25,32,10],[20,32,10,-5],[20,23,1,-4],[18,23,1,-3],[15,32,1,-4],[24,23,1,-4],[21,23,1,-4],[31,23,1,-4],
  [24,23,1,-2],[22,32,10,-4],[20,23,1,-3],[23,2,-12,-4],[45,2,-12,-6],[16,11,-24,-13],[16,6,-27,-12],[14,6,-27,-13],
  [20,81,141,202,263,324,385,445,
  506,567,628,688,749,810,871,932],[64,124,183,243,302,362,421,481],[998,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmti10:[[39,41,0,-3],[41,43,0,-4],[39,44,2,-8],[35,43,0,-3],[41,40,0,-4],[48,41,0,-3],[43,41,0,-4],[38,42,0,-12],
  [34,41,0,-9],[37,41,0,-12],[40,42,0,-5],[47,55,13,2],[38,55,13,2],[40,55,13,2],[56,55,13,2],[58,55,13,2],
  [15,28,1,-5],[21,39,13,2],[9,12,-29,-17],[13,12,-29,-20],[16,9,-29,-16],[18,11,-30,-16],[21,2,-33,-13],[12,12,-31,-28],
  [14,12,12,-6],[37,55,13,2],[38,28,1,-5],[37,28,1,-6],[29,39,7,-4],[53,41,0,-3],[53,44,2,-9],[42,48,4,-7],
  [16,8,-16,-5],[17,43,0,-6],[21,18,-23,-10],[43,53,12,-6],[37,43,1,-5],[42,49,4,-8],[41,45,2,-7],[9,18,-23,-13],
  [22,60,15,-9],[22,60,15,-1],[24,27,-18,-11],[37,37,4,-8],[10,19,12,-4],[15,4,-11,-5],[7,7,0,-6],[36,60,15,-1],
  [27,42,2,-6],[21,40,0,-7],[28,42,2,-5],[29,42,2,-5],[26,52,12,-2],[28,42,2,-6],[27,42,2,-7],[29,42,2,-8],
  [28,42,2,-5],[27,42,2,-6],[12,26,0,-6],[14,38,12,-4],[16,43,13,-3],[40,15,-7,-6],[21,43,13,-5],[22,43,0,-11],
  [39,43,1,-8],[38,43,0,-3],[41,41,0,-3],[40,44,2,-8],[43,41,0,-3],[41,41,0,-3],[41,41,0,-3],[40,44,2,-8],
  [48,41,0,-3],[27,41,0,-3],[32,43,2,-5],[48,41,0,-3],[34,41,0,-3],[56,41,0,-4],[48,41,0,-3],[39,44,2,-8],
  [40,41,0,-3],[39,54,12,-8],[40,43,2,-3],[34,44,2,-4],[38,40,0,-10],[40,43,2,-11],[40,43,2,-12],[54,43,2,-12],
  [57,41,0,8],[40,41,0,-12],[38,41,0,-4],[23,60,15,-4],[20,18,-23,-16],[23,60,15,996],[16,10,-31,-15],[7,7,-33,-15],
  [10,18,-23,-12],[26,27,1,-6],[21,42,1,-6],[22,28,1,-6],[27,42,1,-6],[22,28,1,-6],[29,54,12,2],[26,39,13,-3],
  [28,42,1,-4],[15,40,1,-5],[23,52,13,2],[26,42,1,-4],[13,42,1,-5],[45,28,1,-5],[30,28,1,-5],[24,28,1,-6],
  [31,38,12],[24,38,12,-6],[24,28,1,-5],[21,28,1,-4],[17,38,1,-5],[28,28,1,-5],[25,28,1,-5],[37,28,1,-5],
  [28,28,1,-3],[26,40,13,-5],[25,28,1,-3],[28,2,-15,-5],[55,2,-15,-7],[18,11,-30,-16],[20,7,-33,-14],[17,7,-33,-16],
  [24,97,170,243,316,389,462,535,
  608,681,754,827,900,973,1046,1119],[77,149,220,292,363,434,506,577],[1198,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{bbold10:[[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],
  [4,5,0],[4,5,0],[4,5,0],[4,3,0],[4,7,2],[3,5,2],[3,5,0],[3,3,0],
  [3,7,2],[4,5,2],[3,5,0],[2,3,0],[4,3,0],[3,5,0],[4,5,2],[4,3,0],
  [3,7,2],[4,3,0],[4,5,2],[4,3,0],[3,3,0],[4,3,0],[3,7,2],[3,5,2],
  [3,7,2],[2,5,0],[4,3,-2],[5,7,2],[4,7,1],[4,8,2],[5,5,0],[2,3,-2],
  [3,8,2],[2,8,2],[4,5,1],[5,5,1],[2,4,2],[3,1,-1],[2,2,0],[4,8,2],
  [4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,7,0],[4,5,0],[4,5,0],
  [4,5,0],[4,5,0],[2,3,0],[2,5,2],[5,5,1],[2,2,-1],[5,5,1],[6,5,0,2],
  [4,5,0],[4,5,0],[4,5,0],[4,5,0],[5,5,0],[4,5,0],[4,5,0],[4,5,0],
  [5,5,0],[2,5,0],[4,5,0],[4,5,0],[4,5,0],[5,5,0],[5,5,0],[6,5,0,2],
  [4,5,0],[4,7,2],[4,5,0],[4,5,0],[4,5,0],[5,5,0],[4,5,0],[6,5,0],
  [6,5,0,2],[4,5,0],[4,5,0],[3,8,2],[4,8,2],[2,8,2],[3,8,2],[2,8,2],
  [2,3,-2],[3,3,0],[4,5,0],[3,3,0],[3,5,0],[3,3,0],[3,5,0],[3,5,2],
  [4,5,0],[2,5,0],[3,7,2],[4,5,0],[2,5,0],[5,3,0],[4,3,0],[3,3,0],
  [4,5,2],[3,5,2],[4,3,0],[3,3,0],[3,5,0],[4,3,0],[3,3,0],[5,3,0],
  [3,3,0],[3,5,2],[3,3,0],[3,1,-1],[2,8,2],[6,1,-1],[6,4,-1,2],[5,3,0],
  [3,10,16,23,30,37,44,51,
  58,65,72,79,86,93,100,106],[9,18,27,36,45,54,63,72],[114,79]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{bbold10:[[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],
  [5,6,0],[5,6,0],[5,6,0],[5,4,0],[4,8,2],[4,6,2],[4,6,0],[4,4,0],
  [3,8,2],[4,6,2],[4,6,0],[2,4,0],[4,4,0],[4,6,0],[4,6,2],[4,4,0],
  [3,8,2],[4,4,0],[4,6,2],[5,4,0],[4,4,0],[4,4,0],[4,8,2],[4,6,2],
  [4,8,2],[2,6,0],[4,4,-2],[6,8,2],[5,8,1],[5,10,3],[6,6,0],[2,4,-2],
  [3,9,2],[2,9,2],[5,6,1],[6,6,1],[2,4,2],[3,1,-1],[2,2,0],[5,9,2],
  [4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],
  [4,6,0],[4,6,0],[2,4,0],[2,6,2],[6,6,1],[2,2,-1],[6,6,1],[5,6,0],
  [4,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],
  [5,6,0],[2,6,0],[5,6,0],[5,6,0],[5,6,0],[6,6,0],[5,6,0],[5,6,0],
  [5,6,0],[5,8,2],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[7,6,0],
  [5,6,0],[5,6,0],[5,6,0],[3,9,2],[5,9,2],[2,9,2],[3,9,2],[2,9,2],
  [2,4,-2],[4,4,0],[5,6,0],[4,4,0],[4,6,0],[4,4,0],[3,6,0],[4,6,2],
  [4,6,0],[2,6,0],[3,8,2],[4,6,0],[2,6,0],[6,4,0],[4,4,0],[4,4,0],
  [5,6,2],[4,6,2],[4,4,0],[3,4,0],[3,6,0],[4,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-2],[2,9,2],[7,1,-2],[6,4,-2,2],[6,4,0],
  [3,11,20,28,36,45,53,61,
  70,78,86,95,103,111,119,128],[11,22,33,43,54,65,76,87],[137,94]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{bbold10:[[6,7,0],[6,7,0],[6,8,1],[6,7,0],[6,7,0],[6,7,0],[6,7,0],[6,7,0],
  [6,7,0],[6,7,0],[6,7,0],[5,6,1],[5,9,2],[5,8,3],[5,8,1],[5,6,1],
  [4,9,2],[5,7,2],[5,8,1],[3,5,0],[5,5,0],[5,7,0],[5,7,2],[5,5,0],
  [4,9,2],[5,5,0],[5,7,2],[5,6,1],[5,5,0],[5,6,1],[5,9,2],[5,7,2],
  [5,9,2],[3,8,1],[5,4,-3],[7,9,2],[6,9,1],[6,11,3],[7,8,1],[3,4,-3],
  [4,11,3],[3,11,3],[7,7,1],[7,7,1],[3,4,2],[4,1,-2],[3,3,1],[5,11,3],
  [5,8,1],[5,7,0],[5,7,0],[5,8,1],[5,7,0],[5,8,1],[5,8,1],[5,7,0],
  [5,8,1],[5,8,1],[3,6,1],[3,7,2],[8,6,1],[3,3,-1],[7,6,1,-1],[6,8,1],
  [5,8,1],[6,7,0],[6,7,0],[6,8,1],[7,7,0],[6,7,0],[6,7,0],[6,8,1],
  [7,7,0],[3,7,0],[6,8,1],[6,7,0],[6,7,0],[7,7,0],[7,7,0],[6,8,1],
  [6,7,0],[6,9,2],[6,7,0],[6,8,1],[6,7,0],[7,8,1],[6,7,0],[8,7,0],
  [8,7,0,2],[6,7,0],[6,7,0],[4,11,3],[5,11,3],[3,11,3],[4,11,3],[3,11,3],
  [3,4,-3],[5,6,1],[6,8,1],[5,6,1],[5,8,1],[5,6,1],[4,7,0],[5,8,3],
  [5,7,0],[3,7,0],[4,10,3],[5,7,0],[3,7,0],[7,5,0],[5,5,0],[5,6,1],
  [6,7,2],[5,7,2],[5,5,0],[4,6,1],[4,8,1],[5,6,1],[5,5,0],[7,5,0],
  [5,5,0],[5,8,3],[5,5,0],[4,1,-2],[3,11,3],[8,1,-2],[7,5,-2,2],[7,6,1],
  [4,13,23,33,42,52,62,72,
  81,91,101,110,120,130,139,149],[13,25,38,51,63,76,89,101],[160,110]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{bbold10:[[7,8,0],[7,8,0],[7,10,1],[7,8,0],[7,8,0],[7,8,0],[7,8,0],[7,9,0],
  [7,8,0],[7,8,0],[7,9,0],[7,7,1],[6,12,3],[6,8,3],[6,10,1],[6,7,1],
  [5,12,3],[6,9,3],[6,10,1],[3,5,0],[6,5,0],[6,9,0],[6,8,3],[6,5,0],
  [5,12,3],[6,5,0],[6,9,3],[7,6,1],[6,5,0],[6,6,1],[6,12,3],[6,8,3],
  [6,12,3],[3,9,1],[6,5,-4],[9,11,3],[7,10,1],[7,13,4],[9,10,1],[3,5,-4],
  [4,12,3],[4,12,3],[8,8,1],[9,8,1],[3,6,3],[5,1,-2],[3,4,1],[7,12,3],
  [6,9,1],[6,8,0],[6,8,0],[6,9,1],[6,8,0],[6,9,1],[6,9,1],[6,8,0],
  [6,9,1],[6,9,1],[3,7,1],[3,9,3],[9,7,1],[3,4,-1],[8,7,1,-1],[7,10,1],
  [6,10,1],[7,8,0],[7,8,0],[7,10,1],[8,8,0],[7,8,0],[7,8,0],[7,10,1],
  [8,8,0],[3,8,0],[7,9,1],[7,8,0],[7,8,0],[8,8,0],[8,8,0],[7,10,1],
  [7,8,0],[7,12,3],[7,8,0],[7,10,1],[7,8,0],[8,9,1],[7,8,0],[10,8,0],
  [7,8,0],[7,8,0],[7,8,0],[4,12,3],[7,12,3],[4,12,3],[4,12,3],[4,12,3],
  [3,6,-3],[6,7,1],[7,10,1],[6,7,1],[6,10,1],[6,7,1],[5,9,0],[6,9,3],
  [6,9,0],[3,8,0],[5,11,3],[6,9,0],[3,9,0],[8,6,0],[6,6,0],[6,7,1],
  [7,9,3],[6,9,3],[6,6,0],[5,7,1],[5,10,1],[6,6,1],[6,5,0],[8,5,0],
  [6,5,0],[6,8,3],[6,5,0],[5,2,-2],[3,12,3],[10,2,-2],[6,6,-3],[8,6,1],
  [5,16,28,40,52,63,75,87,
  99,110,122,134,146,157,169,181],[17,32,47,63,78,93,109,124],[194,135]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{bbold10:[[7,10,0,-1],[8,10,0],[9,11,1],[8,10,0],[8,10,0,-1],[7,10,0,-1],[9,10,0],[8,10,0],
  [9,10,0],[8,10,0],[9,10,0],[8,8,1],[8,13,3],[6,9,3],[6,11,1],[6,8,1],
  [6,13,3],[8,10,3],[6,11,1],[3,6,0],[8,6,0],[6,10,0],[8,9,3],[7,6,0],
  [6,13,3],[7,6,0],[7,10,3],[8,7,1],[6,6,0],[7,7,1],[6,13,3],[6,9,3],
  [7,13,3],[4,11,1],[8,6,-4],[10,13,3],[8,13,2],[8,16,5],[10,11,1],[4,6,-4],
  [4,15,4,-1],[4,15,4],[8,10,2,-1],[10,10,2],[4,6,3],[5,2,-2],[4,4,1],[8,15,4],
  [7,11,1],[6,9,0,-1],[7,10,0],[7,11,1],[7,9,0],[7,10,1],[7,11,1],[7,9,0],
  [7,11,1],[7,11,1],[4,8,1],[4,10,3],[10,9,1,-1],[4,3,-2],[10,9,1,-1],[8,11,1],
  [7,11,1],[8,10,0],[7,10,0,-1],[9,11,1],[8,10,0,-1],[7,10,0,-1],[7,10,0,-1],[9,11,1],
  [8,10,0,-1],[3,10,0,-1],[8,11,1],[7,10,0,-1],[7,10,0,-1],[8,10,0,-1],[8,10,0,-1],[9,11,1],
  [7,10,0,-1],[9,13,3],[7,10,0,-1],[8,11,1],[8,10,0],[8,11,1,-1],[8,10,0],[12,10,0],
  [12,10,0,3],[8,10,0],[9,10,0],[4,15,4,-1],[8,15,4],[4,15,4],[4,15,4,-1],[4,15,4],
  [4,6,-4],[6,8,1],[9,11,1],[6,8,1],[6,11,1],[6,8,1],[6,10,0],[6,10,3],
  [8,10,0],[4,10,0],[5,13,3],[8,10,0],[3,10,0],[10,7,0],[8,7,0],[6,8,1],
  [9,10,3],[6,10,3],[8,7,0],[5,8,1],[6,11,1],[7,7,1],[7,6,0],[9,6,0],
  [6,6,0],[7,9,3],[6,6,0],[6,1,-3],[3,15,4,-1],[11,1,-3],[8,6,-4],[9,7,1],
  [5,19,33,47,61,74,88,102,
  116,130,144,158,171,185,199,213],[19,37,55,73,92,110,128,146],[228,158]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{bbold10:[[9,12,0,-1],[10,12,0],[10,13,1],[10,12,0],[10,12,0],[9,12,0,-1],[10,12,0],[10,12,0],
  [10,12,0],[10,12,0],[10,12,0],[9,9,1],[9,16,4],[8,12,4],[8,13,1],[8,9,1],
  [7,16,4],[9,12,4],[8,13,1],[4,8,0],[9,8,0],[8,12,0],[9,12,4],[8,8,0],
  [7,16,4],[8,8,0],[8,12,4],[9,9,1],[7,8,0],[8,9,1],[7,16,4],[8,12,4],
  [8,16,4],[4,13,1,-1],[9,7,-5],[12,16,4],[9,15,2],[10,19,6],[12,13,1],[4,7,-5],
  [5,18,5,-1],[5,18,5],[11,12,2],[12,12,2],[4,7,4],[6,1,-3],[4,4,1],[9,18,5],
  [9,12,1],[8,11,0],[9,11,0],[9,12,1],[9,11,0],[9,12,1],[9,12,1],[9,11,0],
  [9,12,1],[9,12,1],[4,9,1],[4,12,4],[12,10,1,-1],[4,4,-2],[12,10,1,-1],[9,13,1],
  [8,13,1],[10,12,0],[9,12,0,-1],[10,13,1],[10,12,0,-1],[9,12,0,-1],[9,12,0,-1],[10,13,1],
  [10,12,0,-1],[3,12,0,-1],[9,13,1],[9,12,0,-1],[9,12,0,-1],[10,12,0,-1],[10,12,0,-1],[10,13,1],
  [9,12,0,-1],[10,16,4],[9,12,0,-1],[9,13,1],[10,12,0],[10,13,1,-1],[10,12,0],[13,12,0],
  [10,12,0],[10,12,0],[10,12,0],[5,18,5,-1],[9,18,5],[5,18,5],[5,18,5,-1],[5,18,5],
  [4,7,-5],[8,9,1],[10,13,1],[8,9,1],[8,13,1],[8,9,1],[7,12,0],[8,12,4],
  [9,12,0],[4,12,0],[6,16,4],[9,12,0],[4,12,0],[11,8,0],[9,8,0],[8,9,1],
  [10,12,4],[8,12,4],[9,8,0],[6,9,1],[7,13,1],[8,9,1],[7,8,0],[11,8,0],
  [8,8,0],[7,12,4],[8,8,0],[7,1,-4],[3,18,5,-1],[14,1,-4],[9,7,-5],[11,9,1],
  [6,23,40,56,73,89,106,123,
  139,156,172,189,206,222,239,255],[22,44,65,87,109,130,152,174],[274,189]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{bbold10:[[11,14,0,-1],[12,14,0],[11,15,1,-1],[12,14,0],[12,14,0,-1],[11,14,0,-1],[11,14,0,-1],[12,14,0],
  [12,14,0,-1],[12,14,0],[11,14,0,-1],[11,10,1],[10,18,4,-1],[9,13,4],[9,15,1],[9,10,1],
  [7,18,4,-1],[10,13,4,-1],[9,15,1],[4,9,0,-1],[10,9,0,-1],[9,14,0],[10,13,4,-1],[9,9,0,-1],
  [7,18,4,-1],[10,9,0],[9,13,4,-1],[11,10,1],[9,9,0],[9,10,1,-1],[9,18,4],[9,13,4],
  [9,18,4,-1],[4,15,1,-1],[11,8,-6],[14,18,4,-1],[10,18,2,-1],[11,23,7],[14,15,1,-1],[5,8,-6],
  [6,20,5,-1],[6,20,5],[12,14,2,-1],[14,14,2,-1],[5,8,4],[8,1,-4],[5,5,1],[11,20,5],
  [9,14,1,-1],[9,13,0,-1],[9,13,0,-1],[9,14,1,-1],[9,13,0,-1],[9,14,1,-1],[9,14,1,-1],[9,13,0,-1],
  [9,14,1,-1],[9,14,1,-1],[5,10,1],[5,13,4],[14,12,1,-1],[5,4,-3],[14,12,1,-1],[10,15,1,-1],
  [9,15,1,-1],[12,14,0],[11,14,0,-1],[11,15,1,-1],[12,14,0,-1],[11,14,0,-1],[11,14,0,-1],[11,15,1,-1],
  [12,14,0,-1],[4,14,0,-1],[10,15,1,-1],[11,14,0,-1],[11,14,0,-1],[12,14,0,-1],[12,14,0,-1],[11,15,1,-1],
  [11,14,0,-1],[11,18,4,-1],[11,14,0,-1],[10,15,1,-1],[12,14,0],[12,15,1,-1],[12,14,0],[16,14,0],
  [11,14,0,-1],[12,14,0],[11,14,0,-1],[6,20,5,-1],[11,20,5],[6,20,5],[6,20,5,-1],[6,20,5],
  [5,8,-6],[9,10,1],[11,15,1,-1],[9,10,1],[9,15,1],[9,10,1],[7,14,0,-1],[9,13,4],
  [10,14,0,-1],[5,14,0],[7,18,4],[10,14,0,-1],[4,14,0,-1],[13,9,0,-1],[10,9,0,-1],[9,10,1],
  [11,13,4,-1],[9,13,4],[10,9,0,-1],[8,10,1],[7,15,1,-1],[9,10,1,-1],[9,9,0],[13,9,0],
  [9,9,0],[9,13,4],[9,9,0],[9,2,-4],[4,20,5,-1],[16,2,-4],[11,8,-6],[13,10,1],
  [8,28,47,67,87,107,127,147,
  167,187,207,227,247,267,287,307],[26,52,78,104,130,156,182,208],[329,226]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{bbold10:[[13,17,0,-1],[14,17,0],[14,18,1,-1],[14,17,0],[14,17,0,-1],[13,17,0,-1],[14,17,0,-1],[14,17,0],
  [14,17,0,-1],[14,17,0],[14,17,0,-1],[13,12,1],[12,22,5,-1],[11,16,5],[11,18,1],[11,12,1],
  [9,22,5,-1],[12,16,5,-1],[11,18,1],[5,11,0,-1],[12,11,0,-1],[11,17,0],[12,16,5,-1],[11,11,0,-1],
  [9,22,5,-1],[12,11,0],[11,16,5,-1],[13,12,1],[11,11,0],[11,12,1,-1],[11,22,5],[11,16,5],
  [11,22,5,-1],[5,18,1,-1],[12,9,-8,-1],[17,22,5,-1],[13,21,2,-1],[13,27,8,-1],[17,18,1,-1],[5,9,-8,-1],
  [7,24,6,-1],[7,24,6],[15,16,2,-1],[17,16,2,-1],[5,10,5,-1],[9,2,-4],[5,6,1,-1],[13,24,6],
  [11,17,1,-1],[11,16,0,-1],[11,16,0,-1],[11,17,1,-1],[11,16,0,-1],[11,17,1,-1],[11,17,1,-1],[11,16,0,-1],
  [11,17,1,-1],[11,17,1,-1],[5,12,1,-1],[5,16,5,-1],[17,14,1,-1],[5,6,-3,-1],[17,14,1,-1],[13,18,1,-1],
  [11,18,1,-1],[14,17,0],[13,17,0,-1],[14,18,1,-1],[14,17,0,-1],[13,17,0,-1],[13,17,0,-1],[14,18,1,-1],
  [14,17,0,-1],[5,17,0,-1],[13,18,1,-1],[13,17,0,-1],[13,17,0,-1],[15,17,0,-1],[14,17,0,-1],[14,18,1,-1],
  [13,17,0,-1],[14,22,5,-1],[13,17,0,-1],[13,18,1,-1],[14,17,0],[14,18,1,-1],[14,17,0],[19,17,0],
  [14,17,0,-1],[14,17,0],[14,17,0,-1],[7,24,6,-1],[13,24,6],[7,24,6],[7,24,6,-1],[7,24,6],
  [5,10,-7,-1],[11,12,1],[14,18,1,-1],[11,12,1],[11,18,1],[11,12,1],[9,17,0,-1],[11,16,5],
  [12,17,0,-1],[5,17,0,-1],[9,22,5],[12,17,0,-1],[5,17,0,-1],[15,11,0,-1],[12,11,0,-1],[11,12,1],
  [14,16,5,-1],[11,16,5],[12,11,0,-1],[9,12,1],[9,18,1,-1],[11,12,1,-1],[11,11,0],[15,11,0],
  [11,11,0],[11,16,5],[11,11,0],[10,2,-5],[5,24,6,-1],[19,2,-5],[12,10,-7,-1],[15,12,1],
  [9,33,57,81,105,129,153,177,
  201,225,249,273,296,320,344,368],[33,64,95,126,158,189,220,251],[395,273]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{bbold10:[[15,20,0,-2],[17,20,0],[17,21,1,-1],[17,20,0],[17,20,0,-1],[15,20,0,-2],[17,20,0,-1],[17,20,0],
  [17,20,0,-1],[17,20,0],[17,20,0,-1],[16,14,1],[14,27,6,-1],[13,19,6],[13,22,1],[13,14,1],
  [10,26,6,-1],[14,19,6,-1],[13,22,1],[6,13,0,-1],[14,13,0,-1],[13,20,0],[14,19,6,-1],[13,13,0,-1],
  [10,26,6,-1],[14,13,0],[13,19,6,-1],[16,14,1],[13,13,0],[13,14,1,-1],[13,26,6],[13,19,6],
  [13,26,6,-1],[7,21,1,-1],[14,12,-9,-1],[20,26,6,-1],[15,25,3,-1],[16,32,10,-1],[20,21,1,-1],[6,12,-9,-1],
  [8,30,8,-2],[8,30,8],[17,20,3,-1],[20,20,3,-1],[6,12,6,-1],[11,2,-5],[6,7,1,-1],[15,30,8],
  [14,20,1,-1],[13,19,0,-1],[14,19,0,-1],[14,20,1,-1],[14,19,0,-1],[14,20,1,-1],[14,20,1,-1],[14,19,0,-1],
  [14,20,1,-1],[14,20,1,-1],[6,14,1,-1],[6,19,6,-1],[20,16,1,-2],[6,7,-4,-1],[20,16,1,-2],[15,21,1,-1],
  [14,21,1,-1],[17,20,0],[15,20,0,-2],[17,21,1,-1],[17,20,0,-2],[15,20,0,-2],[15,20,0,-2],[17,21,1,-1],
  [17,20,0,-2],[6,20,0,-2],[15,21,1,-1],[15,20,0,-2],[15,20,0,-2],[16,20,0,-2],[17,20,0,-2],[17,21,1,-1],
  [15,20,0,-2],[17,26,6,-1],[15,20,0,-2],[15,21,1,-1],[17,20,0],[17,21,1,-2],[17,20,0],[23,20,0],
  [17,20,0,-1],[17,20,0],[17,20,0,-1],[8,30,8,-2],[15,30,8],[8,30,8],[8,30,8,-2],[8,30,8],
  [6,11,-9,-1],[13,14,1],[16,21,1,-1],[13,14,1],[13,21,1],[13,14,1],[10,21,0,-1],[13,19,6],
  [14,20,0,-1],[6,20,0,-1],[10,26,6],[14,20,0,-1],[6,20,0,-1],[19,13,0,-1],[14,13,0,-1],[13,14,1],
  [16,19,6,-1],[13,19,6],[14,13,0,-1],[11,14,1],[10,21,1,-1],[13,14,1,-1],[13,13,0],[19,13,0],
  [13,13,0],[13,19,6],[13,13,0],[12,2,-6],[6,30,8,-2],[23,2,-6],[14,11,-9,-1],[19,14,1],
  [11,40,68,97,126,154,183,211,
  240,269,297,326,355,383,412,441],[38,75,113,150,187,225,262,299],[472,325]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{bbold10:[[18,24,0,-2],[20,24,0],[20,25,1,-1],[20,24,0],[20,24,0,-1],[18,24,0,-2],[20,24,0,-1],[20,24,0],
  [20,24,0,-1],[20,24,0],[20,24,0,-1],[18,17,1],[17,32,7,-1],[15,23,8],[15,26,1],[15,17,1],
  [13,31,7,-1],[17,23,7,-1],[15,26,1],[7,15,0,-1],[17,15,0,-1],[15,24,0],[17,22,7,-1],[15,15,0,-1],
  [13,31,7,-1],[17,15,0],[15,23,7,-1],[18,16,1],[16,15,0],[15,16,1,-1],[16,31,7],[15,22,7],
  [16,31,7,-1],[8,25,1,-2],[17,14,-11,-1],[24,31,7,-1],[18,30,3,-1],[19,39,12,-1],[24,25,1,-1],[8,14,-11,-1],
  [10,35,9,-2],[10,35,9],[21,23,3,-1],[24,23,3,-1],[8,14,7,-1],[13,3,-6],[8,8,1,-1],[18,35,9],
  [16,24,1,-1],[17,23,0,-1],[16,23,0,-1],[16,24,1,-1],[16,23,0,-1],[16,24,1,-1],[16,24,1,-1],[16,23,0,-1],
  [16,24,1,-1],[16,24,1,-1],[8,17,1,-1],[8,23,7,-1],[24,19,1,-2],[8,8,-5,-1],[24,19,1,-2],[18,25,1,-1],
  [16,25,1,-1],[20,24,0],[18,24,0,-2],[20,25,1,-1],[20,24,0,-2],[18,24,0,-2],[18,24,0,-2],[20,25,1,-1],
  [20,24,0,-2],[7,24,0,-2],[18,25,1,-1],[18,24,0,-2],[18,24,0,-2],[20,24,0,-2],[20,24,0,-2],[20,25,1,-1],
  [18,24,0,-2],[20,31,7,-1],[18,24,0,-2],[18,25,1,-1],[20,24,0],[20,25,1,-2],[20,24,0],[28,24,0],
  [20,24,0,-1],[20,24,0],[20,24,0,-1],[10,35,9,-2],[18,35,9],[10,35,9],[10,35,9,-2],[10,35,9],
  [8,13,-11,-1],[15,17,1],[20,25,1,-1],[15,17,1],[15,25,1],[15,17,1],[13,25,0,-1],[15,24,8],
  [17,24,0,-1],[8,24,0,-1],[12,32,8],[17,24,0,-1],[7,24,0,-1],[22,16,0,-1],[17,16,0,-1],[15,17,1],
  [20,23,7,-1],[15,23,7],[17,16,0,-1],[13,17,1],[13,25,1,-1],[15,16,1,-1],[16,15,0],[22,15,0],
  [15,15,0],[16,23,8],[15,15,0],[15,2,-8],[7,35,9,-2],[28,2,-8],[17,13,-11,-1],[22,16,1],
  [13,48,82,117,151,185,220,254,
  289,323,358,392,427,461,496,530],[47,92,137,182,226,271,316,361],[568,392]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{bbold10:[[21,29,0,-3],[23,29,0,-1],[24,30,1,-2],[23,29,0,-1],[23,29,0,-2],[21,29,0,-3],[24,29,0,-2],[23,29,0,-1],
  [24,29,0,-2],[23,29,0,-1],[24,29,0,-2],[21,20,1,-1],[20,38,8,-2],[18,27,9,-1],[18,31,1,-1],[18,20,1,-1],
  [14,37,8,-2],[20,27,8,-2],[18,31,1,-1],[8,18,0,-2],[20,18,0,-2],[18,29,0,-1],[20,26,8,-2],[18,18,0,-2],
  [14,37,8,-2],[19,18,0,-1],[18,27,8,-2],[21,19,1,-1],[17,18,0,-1],[18,19,1,-2],[17,37,8,-1],[18,26,8,-1],
  [18,37,8,-2],[9,30,1,-2],[21,17,-13,-1],[28,37,8,-2],[21,36,4,-2],[23,46,14,-1],[28,30,1,-2],[9,17,-13,-1],
  [11,42,11,-3],[11,42,11,-1],[25,28,4,-2],[28,28,4,-2],[9,16,8,-1],[14,2,-8,-1],[9,9,1,-1],[21,42,11,-1],
  [19,28,1,-2],[19,27,0,-2],[19,27,0,-2],[19,28,1,-2],[19,27,0,-2],[19,28,1,-2],[19,28,1,-2],[19,27,0,-2],
  [19,28,1,-2],[19,28,1,-2],[9,20,1,-1],[9,27,8,-1],[28,23,1,-3],[9,9,-6,-1],[28,23,1,-3],[21,30,1,-2],
  [19,30,1,-2],[23,29,0,-1],[21,29,0,-3],[24,30,1,-2],[24,29,0,-3],[21,29,0,-3],[21,29,0,-3],[24,30,1,-2],
  [24,29,0,-3],[8,29,0,-3],[21,30,1,-2],[21,29,0,-3],[21,29,0,-3],[23,29,0,-3],[24,29,0,-3],[24,30,1,-2],
  [21,29,0,-3],[24,37,8,-2],[21,29,0,-3],[21,30,1,-2],[23,29,0,-1],[24,30,1,-3],[23,29,0,-1],[33,29,0,-1],
  [24,29,0,-2],[23,29,0,-1],[24,29,0,-2],[11,42,11,-3],[21,42,11,-1],[11,42,11,-1],[11,42,11,-3],[11,42,11,-1],
  [9,16,-13,-1],[18,20,1,-1],[23,30,1,-2],[18,20,1,-1],[18,30,1,-1],[18,20,1,-1],[14,30,0,-2],[18,28,9,-1],
  [20,29,0,-2],[9,28,0,-1],[15,37,9],[20,29,0,-2],[8,29,0,-2],[26,19,0,-2],[20,19,0,-2],[18,20,1,-1],
  [23,27,8,-2],[18,27,8,-1],[20,19,0,-2],[14,20,1,-1],[14,30,1,-2],[18,19,1,-2],[18,18,0,-1],[26,18,0,-1],
  [18,18,0,-1],[18,27,9,-1],[18,18,0,-1],[16,2,-10,-1],[8,42,11,-3],[32,2,-10,-1],[21,16,-13,-1],[26,19,1,-1],
  [16,57,98,140,181,222,263,304,
  346,387,428,469,511,552,593,634],[56,110,163,217,271,325,378,432],[680,469]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{bbold10:[[25,34,0,-4],[28,34,0,-1],[29,36,1,-2],[28,34,0,-1],[29,34,0,-2],[25,34,0,-4],[29,34,0,-2],[28,35,0,-1],
  [29,34,0,-2],[28,34,0,-1],[29,35,0,-2],[26,23,1,-1],[24,46,10,-2],[21,33,11,-1],[21,37,1,-1],[21,23,1,-1],
  [18,45,10,-2],[24,32,10,-2],[21,37,1,-1],[9,22,0,-2],[24,22,0,-2],[21,35,0,-1],[24,32,10,-2],[22,22,0,-2],
  [18,45,10,-2],[23,22,0,-1],[22,32,10,-2],[26,23,1,-1],[21,22,0,-1],[22,23,1,-2],[21,45,10,-1],[21,32,10,-1],
  [22,45,10,-2],[10,35,1,-3],[24,20,-16,-2],[34,44,10,-2],[26,43,5,-2],[27,55,17,-2],[34,36,1,-2],[10,20,-16,-2],
  [13,51,13,-4],[13,51,13,-1],[30,34,5,-2],[34,34,5,-2],[10,19,10,-2],[17,3,-9,-1],[10,10,1,-2],[25,51,13,-1],
  [23,34,1,-2],[23,32,0,-2],[23,33,0,-2],[23,34,1,-2],[23,32,0,-2],[23,33,1,-2],[23,34,1,-2],[23,32,0,-2],
  [23,34,1,-2],[23,34,1,-2],[10,23,1,-2],[10,32,10,-2],[33,27,1,-4],[10,11,-7,-2],[33,27,1,-4],[26,36,1,-2],
  [23,36,1,-2],[28,34,0,-1],[25,34,0,-4],[29,36,1,-2],[28,34,0,-4],[25,34,0,-4],[25,34,0,-4],[29,36,1,-2],
  [28,34,0,-4],[9,34,0,-4],[26,35,1,-2],[25,34,0,-4],[25,34,0,-4],[28,34,0,-4],[28,34,0,-4],[29,36,1,-2],
  [25,34,0,-4],[29,45,10,-2],[25,34,0,-4],[26,36,1,-2],[28,34,0,-1],[28,35,1,-4],[28,34,0,-1],[39,34,0,-1],
  [29,34,0,-2],[28,34,0,-1],[29,34,0,-2],[13,51,13,-4],[25,51,13,-1],[13,51,13,-1],[13,51,13,-4],[13,51,13,-1],
  [10,20,-15,-2],[21,23,1,-1],[28,36,1,-2],[21,23,1,-1],[21,36,1,-1],[21,23,1,-1],[18,36,0,-2],[21,33,11,-1],
  [24,35,0,-2],[10,34,0,-2],[18,45,11],[24,35,0,-2],[9,35,0,-2],[32,22,0,-2],[24,22,0,-2],[21,23,1,-1],
  [28,32,10,-2],[21,32,10,-1],[24,22,0,-2],[17,23,1,-1],[18,36,1,-2],[22,23,1,-2],[21,22,0,-1],[31,22,0,-1],
  [21,22,0,-1],[21,33,11,-1],[21,22,0,-1],[20,2,-12,-1],[9,51,13,-4],[39,2,-12,-1],[24,20,-15,-2],[31,23,1,-1],
  [19,69,118,168,217,267,316,366,
  415,465,514,564,614,663,713,762],[66,130,195,260,324,389,453,518],[816,563]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{bbold10:[[31,41,0,-4],[34,41,0,-1],[34,43,1,-3],[34,41,0,-1],[34,41,0,-3],[31,41,0,-4],[34,41,0,-3],[34,42,0,-1],
  [34,41,0,-3],[34,41,0,-1],[34,42,0,-3],[31,28,1,-1],[28,54,12,-3],[26,39,13,-1],[26,43,1,-1],[26,28,1,-1],
  [20,54,12,-3],[28,39,12,-3],[26,43,1,-1],[11,26,0,-3],[28,26,0,-3],[26,42,0,-1],[28,38,12,-3],[25,26,0,-3],
  [20,54,12,-3],[28,26,0,-1],[25,39,12,-3],[31,27,1,-1],[26,26,0,-1],[25,27,1,-3],[26,54,12,-1],[26,38,12,-1],
  [26,54,12,-3],[12,42,1,-4],[29,23,-19,-2],[40,53,12,-3],[30,51,5,-3],[32,66,20,-2],[40,43,1,-3],[12,23,-19,-2],
  [16,60,15,-4],[16,60,15,-1],[35,40,5,-3],[40,40,5,-3],[12,23,12,-2],[21,3,-11,-1],[12,12,1,-2],[31,60,15,-1],
  [27,40,1,-3],[27,39,0,-3],[27,39,0,-3],[27,40,1,-3],[27,39,0,-3],[27,40,1,-3],[27,40,1,-3],[27,39,0,-3],
  [27,40,1,-3],[27,40,1,-3],[12,28,1,-2],[12,39,12,-2],[41,33,2,-4],[12,12,-9,-2],[41,33,2,-4],[30,43,1,-3],
  [27,43,1,-3],[34,41,0,-1],[31,41,0,-4],[34,43,1,-3],[34,41,0,-4],[31,41,0,-4],[31,41,0,-4],[34,43,1,-3],
  [34,41,0,-4],[11,41,0,-4],[30,42,1,-3],[31,41,0,-4],[31,41,0,-4],[34,41,0,-4],[34,41,0,-4],[34,43,1,-3],
  [31,41,0,-4],[34,54,12,-3],[31,41,0,-4],[30,43,1,-3],[34,41,0,-1],[34,42,1,-4],[34,41,0,-1],[47,41,0,-1],
  [34,41,0,-3],[34,41,0,-1],[34,41,0,-3],[16,60,15,-4],[31,60,15,-1],[16,60,15,-1],[16,60,15,-4],[16,60,15,-1],
  [12,23,-19,-2],[26,28,1,-1],[33,43,1,-3],[26,28,1,-1],[26,43,1,-1],[26,28,1,-1],[20,42,0,-3],[26,40,13,-1],
  [28,42,0,-3],[12,41,0,-2],[21,54,13],[28,42,0,-3],[11,42,0,-3],[37,27,0,-3],[28,27,0,-3],[26,28,1,-1],
  [33,39,12,-3],[26,39,12,-1],[28,27,0,-3],[21,28,1,-1],[20,43,1,-3],[25,27,1,-3],[26,26,0,-1],[37,26,0,-1],
  [26,26,0,-1],[26,39,13,-1],[26,26,0,-1],[24,3,-14,-1],[11,60,15,-4],[47,3,-14,-1],[29,23,-19,-2],[37,27,1,-1],
  [23,82,142,201,261,320,380,439,
  499,558,618,677,737,796,856,915],[79,157,234,312,389,467,544,622],[980,675]]});
});

  $package("org.mathdox.formulaeditor.options");

$identify("org/mathdox/formulaeditor/Options.js");

// currently only org.mathdox.formulaeditor.options should be created
// further functions could be placed in an org.mathdox.formulaeditor.options
// record.

// ancientOrbeon: if set to true: do not warn about old orbeon
// contextParsingExpression: set to an object describing the context for the ExpressionParser
// debug: is debug enabled ?
// decimalMark: character for decimal mark
// - '.' : use period as in US
// - ',' : use comma as in Europe
// dragPalette: if set to true: enable draggable Palette
// fontSize: set font size 
// paletteHighlight: highlight Palette
// - true (default): highlight Palette onmouseover
// - false: do not highlight Palette
// indentXML: indent created XML
// inputStyle: set default style for Editor Canvases
// modeArith1Divide: set mode for handling arith1.divide
// - normal: automatically put unary minus and times expressions as enumerators
// - restricted: only parse power and higher priority (default)
// optionArith1PowerInversePrefix
// - true : allow sin^-1(x) -> arcsin(x)
// - false : (default)
// optionArith1PowerPrefix
// - true : allow sin^2(x)
// - false : (default)
// optionArith1UnaryMinusBrackets
// - true: lower priority unary_minus, e.g. 1 + (-2)
// - false: "normal" priority unary_minus e.g. 1 + -2 (default)
// optionInterval1Brackets
// - object with 4 strings
//   lo: left symbol for left-open interval
//   lc: left symbol for left-closed interval
//   ro: right symbol for right-open interval
//   rc: right symbol for right-closed interval
//   default: { lo: "(", lc: "[", ro: ")", rc: "]" }
// optionListSeparatorFixed
// - list separator for non-editable lists
//   default : same as getListSeparator()
// optionResizeBrackets
// - true : use Bracketed when loading openmath
// - false : do not use Bracketed
//   NOTE: Bracketed can only be deleted completely.
// optionVerboseStyle
// - "true": add style to divide and times
// - "false": (default)
// onloadFocus: set focus on load 
// - true gives focus to the first formulaeditor
// - <id> as string gives focus to the formulaeditor corresponding to the
//   textarea with id <id>
// paletteShow : default behaviour when showing palettes, choices : 
// - "all" gives a palette if not specified by class
// - "none" gives no palette if not specified by class
// - "one" (default) gives a palette if not specified by class when there
//   is none in the page yet, 
// paletteStyle: set default style for Palette Canvases
// paletteURL: url for palette
// styleArith1Times: behavior for times symbol
// - "dot" show a middle dot (default)
// - "cross" show a cross
// - "star" show an asterisk
// styleTransc1Log: behavior for logarithm symbol
// - "function" log(10, x)
// - "prefix"   ^10 log (x)
// - "postfix"  log_10(x)
// undo: whether to enable experimental undo
// - true (default): enable undo
// - false: disable undo
// useBar : enable Bar to turn palette on/off
// - true (default): enable bar
// - false: disable bar

$main(function() {
  org.mathdox.formulaeditor.Options = $extend(Object, {
    defaultOptions : {
      debug: false,
      decimalMark: '.',
      featureUndo: true,
      modeArith1Divide: 'restricted',
      optionVerboseStyle: 'false',
      optionArith1UnaryMinusBrackets : 'false',
      optionInterval1Brackets : {lo: '(', lc: '[', ro: ')', rc:']'},
      optionResizeBrackets: true,
      styleArith1Divide: 'mfrac',
      styleArith1Times: 'dot',
      styleTransc1Log: 'function',
      symbolArith1Times: '·' // U+00B7 Middle dot
    },
    getOption : function(name) {
      if (org.mathdox.formulaeditor.options[name] !== undefined) {
        return org.mathdox.formulaeditor.options[name];
      } else if (this.defaultOptions[name] !== undefined) {
        return this.defaultOptions[name];
      } else {
	return null;
      }
    },
    getArith1DivideMode : function () {
      var option = this.getOption("modeArith1Divide");

      if (option == 'normal' || option == 'restricted' || option == 'inline') {
      	return option;
      } else {
        return "restricted";
      }
    },
    /*
    getArith1DivideSymbol : function () {
      if (option == 'colon') {
        return ':'; // normal colon, 
        // NOTE: it might be better to return U+2236 ratio, but that would be
        // confusing to the user
      } else if (option == 'div') {
        return '÷'; // U+00F7 is division sign 
      } else if (option == 'slash') {
        return '∕'; // U+2215 is division slash
      } else {
        return '∕'; // U+2215 is division slash
      }
    }, */
    getArith1PowerOptionInversePrefix : function () {
      var option = this.getOption("optionArith1PowerInversePrefix");

      if (option == 'true') {
      	return "true";
      } else {
        return "false";
      }
    },
    getArith1PowerOptionPrefix : function () {
      var option = this.getOption("optionArith1PowerPrefix");

      if (option == 'true') {
      	return "true";
      } else {
        return "false";
      }
    },
    getArith1TimesStyle : function () {
      var option = this.getOption("styleArith1Times");

      if (option == 'dot' || option == 'cross' || option == 'star') {
	return option;
      }

      return this.defaultOptions.styleArith1Times;
    },
    getArith1TimesSymbol : function () {
      var option = this.getOption("styleArith1Times");

      if (option == 'dot') {
        return '·'; // U+00B7 Middle dot
      } else if (option == 'cross') {
        return '×'; // U+00D7 is cross
      } else if (option == 'star') {
        return '*';
      }
      return this.defaultOptions.symbolArith1Times;
    },
    getArith1UnaryMinusOptionBrackets : function() {
     var option = this.getOption("optionArith1UnaryMinusBrackets");

      if (option == 'true') {
      	return "true";
      } else {
        return "false";
      }
    },
    getDecimalMark: function() {
      var mark = this.getOption("decimalMark");
      if (mark === '.' || mark === ',') {
        return mark;
      } else { 
        // use default 
        return this.defaultOptions.decimalMark;
      }
    },
    getInterval1BracketsOption: function() {
     var option = this.getOption("optionInterval1Brackets");

      if (typeof option === "object" && typeof option.lo === "string" && typeof option.lc === "string" && typeof option.ro === "string" && typeof option.rc === "string") {
      	return option;
      } else {
        console.log("ERROR: invalid option for Interval1Brackets: "+option);
	return this.defaultOptions.optionInterval1Brackets;
      }
    },
    getListSeparator : function() {
      var mark = this.getDecimalMark();
      
      if (mark === '.') {
        return ',';
      } else if (mark === ',') {
        return ';';
      } else { // should not happen
        alert("Options: unable to get listseparator.");
        return null;
      }
    },
    getListSeparatorFixed : function() {
      var option = this.getOption("optionListSeparatorFixed");
      var sep = this.getListSeparator();
      
      if (option !== null) {
	return option;
      } else {
	return sep;
      }
    },
    getResizeBracketsOption : function() {
      var option = this.getOption("optionResizeBrackets");

      if (option == true || option == false) {
        return option;
      } 

      return this.defaultOptions.optionResizeBrackets;
    },

    getTransc1LogStyle : function () {
      var option = this.getOption("styleTransc1Log");

      if (option == 'prefix' || option == 'postfix' || option == 'function') {
        return option;
      } 

      return this.defaultOptions.styleTransc1Log;
    },
    getVerboseStyleOption : function() {
      var option = this.getOption("optionVerboseStyle");

      if (option == 'true' || option == 'false') {
        return option;
      } 

      return this.defaultOptions.optionVerboseStyle;
    },

    getExpressionParsingContext: function() {
      return {
        decimalMark                    : this.getDecimalMark(),
        listSeparator                  : this.getListSeparator(),
        optionArith1DivideMode         : this.getArith1DivideMode(),
        optionArith1PowerInversePrefix : this.getArith1PowerOptionInversePrefix(),
        optionArith1PowerPrefix        : this.getArith1PowerOptionPrefix(),
        optionArith1UnaryMinusBrackets : this.getArith1UnaryMinusOptionBrackets(),
        styleTransc1Log                : this.getTransc1LogStyle(),
        symbolArith1Times              : this.getArith1TimesSymbol()
      };
    },

    getPresentationContext: function() {
      return {
        decimalMark                    : this.getDecimalMark(),
        listSeparator                  : this.getListSeparator(),
        listSeparatorFixed             : this.getListSeparatorFixed(),
        modeArith1Divide               : this.getArith1DivideMode(),
        optionArith1UnaryMinusBrackets : this.getArith1UnaryMinusOptionBrackets(),
        optionInterval1Brackets        : this.getInterval1BracketsOption(),
        optionResizeBrackets           : this.getResizeBracketsOption(),
        styleTransc1Log                : this.getTransc1LogStyle(),
        symbolArith1Times              : this.getArith1TimesSymbol()
      };
    }
  });
});


    $identify("org/mathdox/formulaeditor/OrbeonForms.js");

$require("org/mathdox/formulaeditor/FormulaEditor.js");

var ORBEON;

$main(function(){

  if (ORBEON && ORBEON.xforms && ORBEON.xforms.Document) {

    /**
     * Extend the save function of the formula editor to use the orbeon update
     * mechanism, see also:
     * http://www.orbeon.com/ops/doc/reference-xforms-2#xforms-javascript
     */
    org.mathdox.formulaeditor.FormulaEditor =
      $extend(org.mathdox.formulaeditor.FormulaEditor, {

        save : function() {

          // call the parent function
          arguments.callee.parent.save.apply(this, arguments);

          // let orbeon know about the change of textarea content
          var textarea = this.textarea;
          if (textarea.id) {
            ORBEON.xforms.Document.setValue(textarea.id, textarea.value);
          }

        }

    });

    /**
     * Override Orbeon's xformsHandleResponse method so that it initializes any
     * canvases that might have been added by the xforms engine.
     */

    /* prevent an error if the xformsHandleResponse doesn't exist */
    var xformsHandleResponse;

    var oldXformsHandleResponse;
    var newXformsHandleResponse;
    var ancientOrbeon;
    
    if (xformsHandleResponse) {
      oldXformsHandleResponse = xformsHandleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponse) {
      oldXformsHandleResponse = ORBEON.xforms.Server.handleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponseDom) {
      oldXformsHandleResponse = ORBEON.xforms.Server.handleResponseDom;
    } else if (ORBEON.xforms.server && ORBEON.xforms.server.AjaxServer && ORBEON.xforms.server.AjaxServer.handleResponseDom) {
      // orbeon 3.9
      oldXformsHandleResponse = ORBEON.xforms.server.AjaxServer.handleResponseDom;
    } else {
      if (org.mathdox.formulaeditor.options.ancientOrbeon !== undefined &&
        org.mathdox.formulaeditor.options.ancientOrbeon == true) {
	ancientOrbeon = true;
      } else {
	ancientOrbeon = false;
        alert("ERROR: detected orbeon, but could not add response handler");
      }
    }
    newXformsHandleResponse = function(request) {

      // call the overridden method
      if (ancientOrbeon != true ) {
        oldXformsHandleResponse.apply(this, arguments);
      }

      // go through all canvases in the document
      var canvases = document.getElementsByTagName("canvas");
      for (var i=0; i<canvases.length; i++) {

        // initialize a FormulaEditor for each canvas
        var canvas = canvases[i];
        if (canvas.nextSibling) {
          if (canvas.nextSibling.tagName.toLowerCase() == "textarea") {

            var FormulaEditor = org.mathdox.formulaeditor.FormulaEditor;
            var editor = new FormulaEditor(canvas.nextSibling, canvas);

            // (re-)load the contents of the textarea into the editor
            editor.load();

          }

        }

      }
      
    };
    
    if (xformsHandleResponse) {
      xformsHandleResponse = newXformsHandleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponse) {
      ORBEON.xforms.Server.handleResponse = newXformsHandleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponseDom) {
      ORBEON.xforms.Server.handleResponseDom = newXformsHandleResponse;
    } else if (ORBEON.xforms.server && ORBEON.xforms.server.AjaxServer && ORBEON.xforms.server.AjaxServer.handleResponseDom) {
      ORBEON.xforms.server.AjaxServer.handleResponseDom = newXformsHandleResponse;
    } 

  }

});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/Palettes.js");

$main(function(){
  org.mathdox.formulaeditor.Palettes = {
    /**
     * The palettestring
     */
    defaultPalette: ""+
"<OMOBJ version='2.0' xmlns='http://www.openmath.org/OpenMath'>\n"+
"  <OMA>\n"+
"    <OMS cd='editor1' name='palette'/>\n"+
"    <OMA>\n"+
"      <OMS cd='editor1' name='palette_tab'/>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMS cd='arith1' name='plus'/>\n"+
"        <OMS cd='arith1' name='minus'/>\n"+
"        <OMS cd='arith1' name='times'/>\n"+
"        <OMS cd='logic1' name='and'/>\n"+
"        <OMS cd='logic1' name='or'/>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='cos'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='root'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMI>2</OMI>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"calculus1\" name=\"int\"/>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"x\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"calculus1\" name=\"defint\"/>\n"+
"          <OMA>\n"+
"            <OMS cd=\"interval1\" name=\"interval\"/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"x\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMS cd='editor1' name='palette_whitespace'/>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_cc'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMS cd='relation1' name='lt'/>\n"+
"        <OMS cd='relation1' name='leq'/>\n"+
"        <OMS cd='relation1' name='eq'/>\n"+
"        <OMS cd='relation1' name='geq'/>\n"+
"        <OMS cd='relation1' name='gt'/>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='sin'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='root'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"arith1\" name=\"product\"/>\n"+
"          <OMA>\n"+
"            <OMS cd=\"interval1\" name=\"integer_interval\"/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"n\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"arith1\" name=\"sum\"/>\n"+
"            <OMA>\n"+
"              <OMS cd=\"interval1\" name=\"integer_interval\"/>\n"+
"              <OMS cd='editor1' name='input_box'/>\n"+
"              <OMS cd='editor1' name='input_box'/>\n"+
"            </OMA>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"n\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg1' name='determinant'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_co'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMS cd='nums1' name='pi'/>\n"+
"        <OMS cd='nums1' name='e'/>\n"+
"        <OMS cd='nums1' name='i'/>\n"+
"        <OMS cd='nums1' name='infinity'/>\n"+
"        <OMS cd='editor1' name='palette_whitespace'/>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='tan'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='list1' name='list'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='vector'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_oc'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='divide'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='power'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='abs'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='integer1' name='factorial'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='power'/>\n"+
"          <OMS cd='nums1' name='e'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='ln'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='log'/>\n"+
"          <OMI>10</OMI>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='vector'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_oo'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"    </OMA>\n"+
"  </OMA>\n"+
"</OMOBJ>\n"+
  ""};
});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/Services.js");

// load XMLHttpRequest methods
$require("com/oreilly/javascript/tdg/XML.js");
$require("com/oreilly/javascript/tdg/XMLHttp.js");

$main(function(){

  /**
   * Class that represents calls to services
   */
  org.mathdox.formulaeditor.Services = {
    url : "/phrasebook/",

    perform : function (service, action, data, callback) {
      var HTTP = com.oreilly.javascript.tdg.XMLHttp;
      var xmlValueOf = this.xmlValueOf;
      var onreturn = function(result) {
        /* 
          check if the result was ok 
          if it was call the callback function with the data
          otherwise show an alert window with the error message
        */
	var xmlData = com.oreilly.javascript.tdg.XML.parse(result);
	
        var statusNodeList = xmlData.documentElement.getElementsByTagName(
	  "status");
        if (statusNodeList.length === 0) {
          alert("Error: no status element found in service response");
          return;
        }
        var statusText = xmlValueOf(statusNodeList.item(0));

        if (statusText != "ok") { /* error */
          var errorNodeList = xmlData.documentElement.getElementsByTagName(
	    "error");
          var errorText = xmlValueOf(errorNodeList.item(0));
        
          alert("ERROR (while using service " + service + "/" + action + 
            "): " + errorText);
          return;
        } 
        
        /* everything went ok */
        var resultNodeList = xmlData.documentElement.getElementsByTagName(
	  "data");

        callback(xmlValueOf(resultNodeList.item(0)));
      };
      var values = {
        output: "xml",
        service: service,
        action: action,
        data: data
      };
      HTTP.post(this.url, values, onreturn); 
    },

    openmath2gap : function(openmath, callback) {
      return this.perform("gap", "translate_openmath_native", openmath, 
        callback);
    },

    /* 
      function like xsl:value-of, converts an XML element to the contained 
      text 
    */
    xmlValueOf : function(node) {
      var i;
      var buffer = []; // use a buffer for efficiency
     
      switch (node.nodeType) {
        case 1: // ELEMENT_NODE
          for (i=0; i<node.childNodes.length; i++) {
            buffer.push(arguments.callee(node.childNodes[i]));
          }
          return buffer.join("");
        case 2: // ATTRIBUTE_NODE
        case 3: // TEXT_NODE
        case 4: // CDATA_SECTION_NODE
          return node.nodeValue;
        case 7: // PROCESSING_INSTRUCTION_NODE
          return "";
        case 8: // COMMENT_NODE
          return "";
        case 9: // DOCUMENT_NODE
          return arguments.callee(node.Element);
        case 10: // DOCUMENT_TYPE_NODE
          return "";
        case 11: // DOCUMENT_FRAGMENT_NODE
          return "";
      }
      return "";
    }
  };
});


  
$identify("org/mathdox/formulaeditor/modules/arith1/minus.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "-",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>-</mo>"
  };

  /**
   * Define a semantic tree node that represents arith1.minus.
   */
  org.mathdox.formulaeditor.semantics.Arith1Minus =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='arith1' name='minus'/>",
        mathml   : symbol.mathml

      },

      associative : false,
      precedence : 120

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for arith1.minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleArith1Minus : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Arith1Minus();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__minus"] = new org.mathdox.formulaeditor.semantics.Keyword("arith1", "minus", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "-" == "-" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression120 = minus | super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1minus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1minus = 
      //    expression120 "-" expression130
      arith1minus : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression120"),
              pG.literal("-"),
              pG.rule("expression130")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Arith1Minus(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression120 = arith1minus | 
      //   super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1minus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1minus = 
      //    expression120 ("-"|"-") expression130
      arith1minus : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression120"),
  	    pG.alternation(
  	      pG.literal("-"),
  	      pG.literal("-")
  	    ),
              pG.rule("expression130")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Arith1Minus(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/arith1/plus.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "+",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>+</mo>",
    mathml_invisible : ( "⁤" != "" ? "<mo>⁤</mo>" : null )
  };

  /**
   * Define a semantic tree node that represents arith1.plus.
   */
  org.mathdox.formulaeditor.semantics.Arith1Plus =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='arith1' name='plus'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 120

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for arith1.plus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleArith1Plus : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Arith1Plus();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__plus"] = new org.mathdox.formulaeditor.semantics.Keyword("arith1", "plus", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "+" == "+" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression120 = plus | super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1plus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1plus = 
      //    expression120 "+" expression130
      arith1plus :
        pG.transform(
          pG.concatenation(
            pG.rule("expression120"),
            pG.literal("+"),
            pG.rule("expression130"),
            pG.repetition(
              pG.concatenation(
                pG.literal("+"),
                pG.rule("expression130")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Arith1Plus();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Arith1Plus && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression120 = arith1plus | 
      //   arith1plusalt | super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1plus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1plus = 
      //    expression120 "+" expression130
      arith1plus :
        pG.transform(
          pG.concatenation(
            pG.rule("expression120"),
	    pG.alternation(
	      pG.literal("+"),
	      pG.literal("+")
	    ),
            pG.rule("expression130"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("+"),
	          pG.literal("+")
	        ),
                pG.rule("expression130")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Arith1Plus();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Arith1Plus) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/abs.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.Abs =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        mathml   : ["<mo>|</mo>","","<mo>|</mo>"],
        onscreen : ["|","","|"],
        openmath : "<OMS cd='arith1' name='abs'/>"

      },

      precedence : 0

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.abs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns an absolute value object based on the OpenMath node.
      */
      handleArith1Abs : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Abs(operand);

      }

    });

  /**
   * Add parsing code for absolute values.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression160 = abs | super.expression160
        expression160 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("abs"),
            parent.expression160).apply(this, arguments);
        },

        // abs = "|" expression "|"
        abs :
          pG.transform(
            pG.concatenation(
              pG.literal("|"),
              pG.rule("expression"),
              pG.literal("|")
            ),
            function(result) {
              return new semantics.Abs(result[1]);
            }
          )
        };
      });

});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/divide.js");

$require("org/mathdox/formulaeditor/modules/arith1/plus.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Fraction.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a division.
   */
  org.mathdox.formulaeditor.semantics.Divide =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {
        openmath : "<OMS cd='arith1' name='divide'/>"
      },

      style: "mfrac",

      //precedence : 160,
      precedence : 170,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        return new presentation.Fraction(
          new presentation.Row(this.operands[0].getPresentation(context)),
          new presentation.Row(this.operands[1].getPresentation(context))
        );

      },

      getSymbolOpenMath : function() {
        var options = new org.mathdox.formulaeditor.Options();
        var result;
        if (options.getVerboseStyleOption() == "true") {
          var arr = this.symbol.openmath.split("/");
          result = arr.join(" style='" + this.style  + "'/");
        } else {
          result = this.symbol.openmath;
        }
        return result;
      },

      getMathML : function() {
        return "<mfrac>" +
          this.operands[0].getMathML() +
          this.operands[1].getMathML() +
          "</mfrac>";
      }

  });
  
  org.mathdox.formulaeditor.semantics.DivideInline =
    $extend(org.mathdox.formulaeditor.semantics.Divide, {
      //precedence : 130,
      precedence : 140,

      style: "colon",
      
      symbol : {
        mathml: "<mo>:</mo>",
	onscreen: ":",
        openmath : "<OMS cd='arith1' name='divide'/>"
      },

      getMathML : function() {
	// parent = Divide, parent.parent is MultaryOperation
	// use the default MultaryOperation method
        return arguments.callee.parent.getMathML.parent.getMathML.call(this);
      },

      getPresentation : function() {
	// parent = Divide, parent.parent is MultaryOperation
	// use the default MultaryOperation method
        return arguments.callee.parent.getPresentation.parent.getPresentation.call(this, arguments);
      }

  });


  /**
  * Extend the OpenMathParser object with parsing code for arith1.divide.
  */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Divide object based on the OpenMath node.
      */
      handleArith1Divide : function(node) {

        // parse the left and right operands
        var children = node.childNodes;
        var left  = this.handle(children.item(1));
        var right = this.handle(children.item(2));

        // construct a divide object
	var result;

	if (node.getAttribute("style") == "colon") {
          result = new org.mathdox.formulaeditor.semantics.DivideInline(left, right);
	} else {
          result = new org.mathdox.formulaeditor.semantics.Divide(left, right);
	}

        return result;
      }
  });

  /**
   * Add the parsing code for division.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( function(context) { 
    return {

      // expression130 = divide_inline | super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("divide_inline"),
          parent.expression130).apply(this, arguments);
      },

      // expression160 = divide | divide_silent_addition | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("divide"),
          pG.rule("divide_silent_addition"),
          parent.expression160).apply(this, arguments);
      },

      // divide = never
      divide : pG.never,

      // divide_inline = expression130 ":" expression140
      divide_inline :
        pG.transform(
          pG.concatenation(
            pG.rule("expression130"),
            pG.literal(':'),
            pG.rule("expression140")
          ),
          function(result) {
            return new semantics.DivideInline(result[0], result[2]);
          }
        ),

      divide_silent_addition : 
        pG.transform(
          pG.concatenation(
            pG.rule("integer"),
            pG.rule("divide")),
          function(result) {
            var semantics = org.mathdox.formulaeditor.semantics; 
            var plus = new semantics.Arith1Plus(result[0],result[1]);
            plus.style="invisible";
            return plus;
          }
        ),

      // parseNumber = divide | divide_silent_addition | parseNumber
      parseNumber : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("divide"),
          pG.rule("divide_silent_addition"),
          parent.parseNumber).apply(this, arguments);
      }
    };
  });


  /**
   * Add a key handler for the '/' and '%' keys.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the '/' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the '/' key has been pressed
          if (String.fromCharCode(event.charCode) == "/") {

            var Fraction = org.mathdox.formulaeditor.presentation.Fraction;
            var index    = editor.cursor.position.index;
            var length   = this.children.length;

	    // search for an expression of precedence level 130 (or 150 if
	    // restricted) to the left of the cursor, and of level 150 to the
	    // right of the cursor
	    var leftexpr;

	    if (editor.getExpressionParsingContext().optionArith1DivideMode == 'restricted') {
	      leftexpr = "expression150";
	    } else { // 'normal'
	      leftexpr = "expression130";
	    }
	    var parsedleft = this.getSemantics(editor.getExpressionParsingContext(), 0, index, leftexpr, true);
            var parsedright = this.getSemantics(editor.getExpressionParsingContext(), index, length, "expression150");

            // create the left and right operands of the fraction
            var right = this.remove(index, parsedright.index);
            var left  = this.remove(parsedleft.index,  index);

            // insert the fraction into the row
            this.insert(parsedleft.index, new Fraction(left, right));
            editor.cursor.position = right.getFollowingCursorPosition();

            // update the editor state
            editor.redraw();
            editor.save();
            return false;

          } else if (String.fromCharCode(event.charCode) == "%") {
            var presentation = org.mathdox.formulaeditor.presentation;
            var index    = editor.cursor.position.index;

            // create the fraction
            var fraction = new presentation.Fraction(
              new presentation.Row(new presentation.BlockSymbol()),
              new presentation.Row(new presentation.BlockSymbol()));

            // insert the fraction into the row
            this.insert(index, fraction);

            // move the cursor into the fraction
            editor.cursor.moveRight();
            
            // update the editor state
            editor.redraw();
            editor.save();
            return false;
          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });
    
});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/power.js");

$require("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/semantics/FunctionApplication.js");
$require("org/mathdox/formulaeditor/semantics/Integer.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a power function.
   */
  org.mathdox.formulaeditor.semantics.Power =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        openmath : "<OMS cd='arith1' name='power'/>"

      },

      precedence : 150,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        
        // add braces to base, if necessary

        var base = this.operands[0].getPresentation(context);

        if (this.useBrackets(this.operands[0], base) === true) {
          base = new presentation.Row(new presentation.Symbol("("), base, 
            new presentation.Symbol(")"));
        }
        return new presentation.Row(
          base,
          new presentation.Superscript(
            this.operands[1].getPresentation(context))
        );
      },

      getMathML : function() {
	var Options = new org.mathdox.formulaeditor.Options();

        // add braces to base, if necessary
	// use same method as for presentation (unfortunately this means getting the presentation)

        var basePres = this.operands[0].getPresentation(Options.getPresentationContext());
        var base = this.operands[0].getMathML();

        if (this.useBrackets(this.operands[0], basePres) === true) {
	  // NOTE: nicer would be to add an option bracketed to getMathML of base
	  // no double mrow then
          base = "<mrow><mo>(</mo>" + base + "<mo>)</mo></mrow>";
        }

        return "<msup>" + base +
          this.operands[1].getMathML() +
          "</msup>";
      },

      useBrackets : function(sem, pres) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var semantics = org.mathdox.formulaeditor.semantics;

	var positiveint = (sem instanceof semantics.Integer && sem.value >=0 );

	var brackets = false;

	if (positiveint === true) {
          brackets = false;
	} else if (pres instanceof presentation.Row && pres.children.length > 1) {
          brackets = true;
        } else if (pres instanceof presentation.Root) {
          brackets = true;
        } else if (pres instanceof presentation.Fraction) {
          brackets = true;
        }

        return brackets;
      }
    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.power.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Power object based on the OpenMath node.
      */
      handleArith1Power : function(node) {

        // parse the base and exponent
        var children = node.childNodes;
        var base     = this.handle(children.item(1));
        var exponent = this.handle(children.item(2));

        // construct a Power object
        return new org.mathdox.formulaeditor.semantics.Power(base, exponent);

      }

    });

  /**
   * Add the parsing code for power operations.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { 
      var func_powCheck = function(oper) {
        return false;
      };

      var func_powUpdate = function(oper) {
        return oper;
      };

      var func_powInvCheck = function(oper) {
        return false;
      };

      var func_powInvUpdate = function(oper) {
        return oper;
      };

      var names = [
        "arccos", "arccosh", "arccot", "arccoth", "arccsc", "arccsch",
        "arcsec", "arcsech", "arcsin", "arcsinh", "arctan", "arctanh", "cos",
        "cosh", "cot", "coth", "csc", "csch", /* "exp", "ln", "log", */ "sec",
        "sech", "sin", "sinh", "tan", "tanh"
      ];

      if (context.optionArith1PowerInversePrefix === "true") {
        func_powInvCheck = function(operInput) {
            var oper;
  
            oper = operInput;
            // oper should be a function application
            if (! (oper instanceof semantics.FunctionApplication) ) {
              return false;
            }
  
            // symbol should exist
            if (oper.symbol === undefined || oper.symbol === null) {
              return false;
            } 
  
            oper = oper.symbol;
  
            if (! (oper instanceof semantics.Power) ) {
              return false;
            }
            
            if (!((oper.operands[0] instanceof semantics.Keyword) && oper.operands[0].cd == "transc1")) {
              // base of power is not a transc1 function
              return false;
            }
  
            if (names.indexOf(oper.operands[0].name) === -1 ) {
              return false;
            }

            // exponent should be negative
            if (oper.operands[1] instanceof semantics.Arith1Unary_minus) {
              return true;
            }
  
            return false;
          };
          func_powInvUpdate = function(oper) {
  
            if (func_powInvCheck(oper)) {
              var oldsymbol = oper.symbol.operands[0];
              var oldname = oldsymbol.name;
              var newname;

              if (oldname.substring(0,3) == "arc") {
                newname = oldname.substring(3);
              } else {
                newname = "arc" + oldname;
              }

              var basename = oldsymbol.cd + "__" + newname;
              var base = org.mathdox.formulaeditor.parsing.openmath.KeywordList[basename];

              var negativeExponent = oper.symbol.operands[1]; 
              var exponent = negativeExponent.operands[0]; 

              var power;

              if (exponent instanceof semantics.Integer && exponent.value == 1) {
                power = base;
              } else {
                power = new semantics.Power(base, exponent);
              }

              return new semantics.FunctionApplication(power, oper.operands, oper.style);
            } else {
              return oper;
            }
          };
        } 

      if (context.optionArith1PowerPrefix === "true") {
        func_powCheck = function(operInput) {
          var oper;

          oper = operInput;
          // oper should be a function application
          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          oper = oper.symbol;

          if (! (oper instanceof semantics.Power) ) {
            return false;
          }
          
          if (!((oper.operands[0] instanceof semantics.Keyword) && oper.operands[0].cd == "transc1")) {
            // base of power is not a transc1 function
            return false;
          }

          if (names.indexOf(oper.operands[0].name) === -1 ) {
            return false;
          }

          // exponent should be variable: sin^n (x) or an integer: sin^2(x)
          if ((oper.operands[1] instanceof semantics.Variable) ) {
            return true;
          }

          if ((oper.operands[1] instanceof semantics.Integer) && oper.operands[1].value > 0 ) {
            return true;
          }

          return false;
        };
        func_powUpdate = function(oper) {

          if (func_powCheck(oper)) {
            var symbol = oper.symbol.operands[0];

            var base = new semantics.FunctionApplication(symbol, oper.operands);

            var exponent = oper.symbol.operands[1]; 

            return new semantics.Power(base, exponent);
          } else {
            return oper;
          }
        };
      } 

      return {

      // expression150 = power | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("power"),
          parent.expression150).apply(this, arguments);
      },

      // power = expression160 superscript
      power :
        pG.transform(
          pG.concatenation(
            pG.rule("expression160"),
            pG.rule("superscript")
          ),
          function(result) {
            return new semantics.Power(result[0], result[1]);
          }
        ),
      // note copy from ExpressionParser
      func_Update: function(oper) {
        var parent = arguments.callee.parent;
        return parent.func_Update( func_powUpdate( func_powInvUpdate( oper ) ) );
      },

      
      func_symbol: function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("restrictedpower"),
          parent.func_symbol).apply(this, arguments);
      },

      // useful for invisible multiplication (should not start with a number)
      // restrictedpower = restrictedexpression160 superscript
      restrictedpower :
        pG.transform(
          pG.concatenation(
            pG.rule("restrictedexpression160"),
            pG.rule("superscript")
          ),
          function(result) {
            return new semantics.Power(result[0], result[1]);
          }
        ),

      // superscript = 0
      superscript : pG.never
      };
    });

  /**
   * Add a key handler for the '^' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the '^' key.
       */
      onkeypress : function(event, editor) {
        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the '^' key has been pressed
          if (String.fromCharCode(event.charCode) == "^") {

            var Superscript =
              org.mathdox.formulaeditor.presentation.Superscript;

            var index  = editor.cursor.position.index;
            var length = this.children.length;

            // search for an expression of precedence level 130 to the right of
            // the cursor
            var parsed = this.getSemantics(editor.getExpressionParsingContext(), index, length, "expression130");

            // create the operand of the superscript operation
            var operand = this.remove(index, parsed.index);

            // insert the fraction into the row
            this.insert(index, new Superscript(operand));
            editor.cursor.position = operand.getFollowingCursorPosition();

            // update the editor state
            editor.redraw();
            editor.save();
            return false;

          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });

});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/product.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a product.
   */
  org.mathdox.formulaeditor.semantics.Product =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : integer_interval
      // operand 1 : lambda expression
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        
        return new presentation.Row(
          new presentation.Product(
            new presentation.Row(this.operands[0].operands[1].getPresentation(
              context)),
            new presentation.Row(
              this.operands[1].variables[0].getPresentation(context),
              new presentation.Symbol("="),
              this.operands[0].operands[0].getPresentation(context)
            )
          ),
          new presentation.Symbol("("),
          this.operands[1].expression.getPresentation(context),
          new presentation.Symbol(")")
        );
      
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='arith1' name='product'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
        "</OMA>";
      
      },

      getMathML : function() {
        return "<mrow>"+
	  "<munderover>" +
	  "<mrow>"+
          this.operands[1].variables[0].getMathML() +
          "<mo>=</mo>"+
          this.operands[0].operands[0].getMathML() +
	  "</mrow>"+
          // U+03A0 greek capital letter pi
	  "<mo>Π</mo>"+
          this.operands[0].operands[1].getMathML() +
          "</munderover>"+
          this.operands[1].expression.getMathML() +
	  "</mrow>";
      }
    
    });

  /**
   * Defines an on-screen product.
   */
  org.mathdox.formulaeditor.presentation.Product =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

      /**
       * top and bottom rows are smaller
       */
      fontSizeModifierArray : [-1,0,-1],

      initialize : function(above, below) {

        var parent = arguments.callee.parent;
        // U+03A0 greek capital letter pi
        var pi  = new org.mathdox.formulaeditor.presentation.Symbol("Π");
        return parent.initialize.call(this, above, pi, below);

      },

      copy : function() {
        return this.clone(this.children[0].copy(), this.children[2].copy());
      },

      getSemantics : function(context) {

        var semantics = org.mathdox.formulaeditor.semantics;

        var above = this.children[0].getSemantics(context).value;
        var below = this.children[2].getSemantics(context).value;

        if (below instanceof semantics.Relation1Eq) {

          return {
            value : [below.operands[1], above, below.operands[0]],
            rule  : "product"
          };

        }
        else {

          return null;

        }

      }

  });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.product.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Product object based on the OpenMath node.
       */
      handleArith1Product : function(node) {

        var children = node.childNodes;
        var integer_interval = this.handle(children.item(1));
        var lambda   = this.handle(children.item(2));

	if (lambda.variables.length === 0) {
	  alert("arith1.product needs a nonempty OMBVAR");
	  return null;
	}

        return new org.mathdox.formulaeditor.semantics.Product(integer_interval, lambda);

      }

    });


  /**
   * Add the parsing code for products.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression150 = product expression150 | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.transform(
            pG.concatenation(
              pG.rule("product"),
              pG.rule("expression150")
            ),
            function(result) {

              return new semantics.Product(
                new semantics.Integer_interval(result[0][0], result[0][1]),
                new semantics.Lambda([result[0][2]], result[1])
              );

            }
          ),
          parent.expression150).apply(this, arguments);
      },

      // product = never
      product : pG.never
    };
  });

});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/root.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/presentation/Root.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

$main(function(){

  var semantics = org.mathdox.formulaeditor.semantics;

  /**
   * Defines a semantic tree node that represents a root.
   */
  semantics.Arith1Root =
    $extend(semantics.MultaryOperation, {

      argcount : 2,

      symbol : {

        openmath : "<OMS cd='arith1' name='root'/>"

      },

      precedence : 160,

      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        return new presentation.Root(
          this.operands[0].getPresentation(context),
          this.operands[1].getPresentation(context)
        );
      },

      getMathML : function() {
	var base = this.operands[0];
	var index = this.operands[1];

	// TODO: also generate msqrt if index is integer, value 2
	if (index instanceof semantics.Integer && index && index.value == 2) {
	  // note: inferred mrow, but we might produce one
          return "<msqrt>" + base.getMathML() + "</msqrt>";
	} else {
          return "<mroot>" + base.getMathML() + index.getMathML() + "</mroot>";
	}
      }

  });

  /**
  * Extend the OpenMathParser object with parsing code for arith1.divide.
  */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Root object based on the OpenMath node.
      */
      handleArith1Root : function(node) {

        // parse the left and right operands
        var children = node.childNodes;
        var middle  = this.handle(children.item(1));
        var base  = this.handle(children.item(2));

        // construct a root object
        return new semantics.Arith1Root(middle, base);

      }

  });

  /**
   * Add the parsing code for division.
   */
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression160 = root | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("root"),
          parent.expression160).apply(this, arguments);
      },

      // root = never
      root : pG.never
    };
  });

  org.mathdox.formulaeditor.parsing.expression.KeywordList.rt = {
    parseResultFun : function(oper, array) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var root = new semantics.Arith1Root();
      root.initialize.apply(root, array);

      return root;
    }
  };

  org.mathdox.formulaeditor.parsing.expression.KeywordList.sqrt = {
    parseResultFun : function(oper, array) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var root = new semantics.Arith1Root();
      array.push(new semantics.Integer(2));

      root.initialize.apply(root, array);

      return root;
    }
  };

    org.mathdox.formulaeditor.parsing.expression.KeywordList.rt;


});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/sum.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a sum.
   */
  org.mathdox.formulaeditor.semantics.Sum =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : integer_interval
      // operand 1 : lambda expression
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        
        return new presentation.Row(
          new presentation.Sum(
            new presentation.Row(
              this.operands[0].operands[1].getPresentation(context)),
            new presentation.Row(
              this.operands[1].variables[0].getPresentation(context),
              new presentation.Symbol("="),
              this.operands[0].operands[0].getPresentation(context)
            )
          ),
          new presentation.Symbol("("),
          this.operands[1].expression.getPresentation(context),
          new presentation.Symbol(")")
        );
      
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='arith1' name='sum'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
        "</OMA>";
      
      },

      getMathML : function() {
        return "<mrow>"+
	  "<munderover>" +
	  "<mrow>"+
          this.operands[1].variables[0].getMathML() +
          "<mo>=</mo>"+
          this.operands[0].operands[0].getMathML() +
	  "</mrow>"+
          // U+03A3 greek capital letter sigma
	  "<mo>Σ</mo>"+
          this.operands[0].operands[1].getMathML() +
          "</munderover>"+
          this.operands[1].expression.getMathML() +
	  "</mrow>";
      }
    
    });

  /**
   * Defines an on-screen sum.
   */
  org.mathdox.formulaeditor.presentation.Sum =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

    /**
     * top and bottom rows are smaller
     */
    fontSizeModifierArray : [-1,0,-1],

    initialize : function(above, below) {

      var parent = arguments.callee.parent;
      // U+03A3 greek capital letter sigma
      var sigma  = new org.mathdox.formulaeditor.presentation.Symbol("Σ");
      return parent.initialize.call(this, above, sigma, below);

    },

    copy : function() {
      return this.clone(this.children[0].copy(), this.children[2].copy());
    },

    getSemantics : function(context) {

      var semantics = org.mathdox.formulaeditor.semantics;

        var above = this.children[0].getSemantics(context).value;
        var below = this.children[2].getSemantics(context).value;

        if (below instanceof semantics.Relation1Eq) {

          return {
            value : [below.operands[1], above, below.operands[0]],
            rule  : "sum"
          };

        }
        else {

          return null;

        }

      }

  });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.sum.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Sum object based on the OpenMath node.
       */
      handleArith1Sum : function(node) {

        var children = node.childNodes;
        var integer_interval = this.handle(children.item(1));
        var lambda   = this.handle(children.item(2));

	if (lambda.variables.length === 0) {
	  alert("arith1.sum needs a nonempty OMBVAR");
	  return null;
	}

        return new org.mathdox.formulaeditor.semantics.Sum(integer_interval, lambda);

      }

    });


  /**
   * Add the parsing code for sums.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression150 = sum expression150 | super.expression150
        expression150 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.concatenation(
                pG.rule("sum"),
                pG.rule("expression150")
              ),
              function(result) {

                return new semantics.Sum(
                  new semantics.Integer_interval(result[0][0], result[0][1]),
                  new semantics.Lambda([result[0][2]], result[1])
                );

              }
            ),
            parent.expression150).apply(this, arguments);
        },

        // sum = never
        sum : pG.never
      };
    });

});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/times.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/power.js");

$main(function(){
  /** 
   * describe how this symbol should be presented
   */
  var symbol = {
    // U+00B7 middle dot
    onscreen         : "·",
    openmath         : null,
    // U+00B7 middle dot
    mathml           : "<mo>·</mo>",
    // U+2062 invisible times
    mathml_invisible : "<mo>⁢</mo>"
  };

  /**
   * Defines a semantic tree node that represents a multiplication.
   */
  org.mathdox.formulaeditor.semantics.KeywordTimes =
    $extend(org.mathdox.formulaeditor.semantics.Keyword, {

      getSymbolOnscreen : function(context) {
        return context.symbolArith1Times;
      }

    });

  /**
   * Defines a semantic tree node that represents a multiplication.
   */
  org.mathdox.formulaeditor.semantics.Times =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='arith1' name='times'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible
      },

      getSymbolOnscreen : function(context) {
        return context.symbolArith1Times;
      },

      getSymbolMathML : function() {
        options = new org.mathdox.formulaeditor.Options();
        return "<mo>"+ options.getArith1TimesSymbol() +"</mo>";
      },

      getSymbolOpenMath : function() {
        var options = new org.mathdox.formulaeditor.Options();
	var result;
	if (options.getVerboseStyleOption() == "true") {
	  var arr = this.symbol.openmath.split("/");
          result = arr.join(" style='" + options.getArith1TimesStyle()  + "'/");
	} else {
	  result = this.symbol.openmath;
	}
        return result;
      },

      precedence : 130,
      precedence : 140

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.times.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Times object based on the OpenMath node.
       */
      handleArith1Times : function(node, style) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Times object
        var result = new org.mathdox.formulaeditor.semantics.Times();
        result.initialize.apply(result, operands);
	if (style == "invisible") {
          result.style = style;
        }
        return result;

      }

    });

  /**
   * Add the parsing code for multiplication.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression130 = times | super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("times"),
          parent.expression130).apply(this, arguments);
      },

      // expression150 = times | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("invisibletimes"),
          parent.expression150).apply(this, arguments);
      },

      // invisibletimes = number variable
      invisibletimes:
        pG.transform(
          pG.concatenation(
            pG.rule("parseNumber"),
            pG.alternation(
              pG.rule("restrictedexpression160"),
              pG.rule("restrictedpower")
            )
          ),
          function(result) {
            var times = new semantics.Times(result[0], result[1]);
            times.style = "invisible";
            return times;
          }
        ),

      // times = expression130 "·" expression140
      times :
        pG.transform(
          pG.concatenation(
            pG.rule("expression130"),
            pG.literal(context.symbolArith1Times),
            pG.rule("expression140")
          ),
          function(result) {
            return new semantics.Times(result[0], result[2]);
          }
        )
      };
    });

  /**
   * Add a key handler for the '*' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the '*' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the '*' key has been pressed
          if (String.fromCharCode(event.charCode) == "*") {

            // substitute the charCode of "·" for "*".
            var newEvent = {};
            for (var x in event) {
              newEvent[x] = event[x];
            }
            newEvent.charCode = editor.getPresentationContext().symbolArith1Times.charCodeAt(0);
            event = newEvent;

          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });
  
  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__times"] = new org.mathdox.formulaeditor.semantics.KeywordTimes("arith1", "times", symbol, "infix");

});

    $identify("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Arith1Unary_minus =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {

        onscreen : ["-","",""],
        openmath : "<OMS cd='arith1' name='unary_minus'/>",
        mathml   : [ "<mo>-</mo>", "", ""]

      },

      precedence : 140,

      getPrecedence: function(context) {
	var precedence;

        if (context.optionArith1UnaryMinusBrackets === 'true') {
          precedence = 120;
        } else {
          precedence = 140;
        }

	return precedence;
      },
      getInnerPrecedence: function(context) {
	var precedence;

        if (context.optionArith1UnaryMinusBrackets === 'true') {
          precedence = 130;
        } else {
          precedence = 130;
        }

	return precedence;
      },
      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var array = [];
        var symbolOnscreen = this.getSymbolOnscreen(context);
        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[0]!=="") {
            array.push(new presentation.Row(symbolOnscreen[0]));
          }
        }

        var operand = this.operands[0];

        if (operand.getPrecedence && operand.getPrecedence(context) != 0 &&
	    operand.getPrecedence(context) < this.getInnerPrecedence(context)) {
          array.push(new presentation.Symbol("("));
          array.push(operand.getPresentation(context));
          array.push(new presentation.Symbol(")"));
        } else {
          array.push(operand.getPresentation(context));
        }

        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[2]!=="") {
            array.push(new presentation.Row(symbolOnscreen[2]));
          }
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);
        return result;

      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary minus object based on the OpenMath node.
      */
      handleArith1Unary_minus : function(node) {

        var operand = this.handle(node.childNodes.item(1));
	var result = new org.mathdox.formulaeditor.semantics.Arith1Unary_minus(operand);

        return result;

      }

    });

  /**
   * Add the parsing code for unary symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { 
	var precedence;

        if (context.optionArith1UnaryMinusBrackets === 'true') {
          precedence = 120;
        } else {
          precedence = 140;
        }

        var rulesEnter = [];
        var positionEnter = 0;
    
        rulesEnter.push(pG.literal("-"));
        positionEnter++;
        rulesEnter.push(pG.rule("expression140"));
        var result = { arith1unary_minus :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Arith1Unary_minus(result[positionEnter]);
            }
          )
        };

        if (precedence == 120) {
          result.expression120 = function() {
            var parent = arguments.callee.parent;
            pG.alternation(
              pG.rule("arith1unary_minus"),
              parent.expression120).apply(this, arguments);
          };
        } else {
          result.expression140 = function() {
            var parent = arguments.callee.parent;
            pG.alternation(
              pG.rule("arith1unary_minus"),
              parent.expression140).apply(this, arguments);
          };
        }
      
      return result;
  });

});

  $package("org.mathdox.formulaeditor.modules.calculus1");

$identify("org/mathdox/formulaeditor/modules/calculus1/defint.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a definite integration.
   */
  org.mathdox.formulaeditor.semantics.Defint =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : interval
      // operand 1 : lambda expression
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        
        return new presentation.Row(
          new presentation.Defint(
            new presentation.Row(
              this.operands[0].operands[0].getPresentation(context)),
            new presentation.Row(
              this.operands[0].operands[1].getPresentation(context))
          ),
          this.operands[1].expression.getPresentation(context),
          // U+2146 Differential d
          new presentation.Symbol("ⅆ"),
          this.operands[1].variables[0].getPresentation(context)
        );
      
      },
      
      getMathML : function() {
      	// U+222B integral 
        return "<mrow><msubsup><mo>∫</mo>" +
          // below: lower boundry
          this.operands[0].operands[0].getMathML() +
          // above: higher boundry
          this.operands[0].operands[1].getMathML() +
          "</msubsup>"+
          this.operands[1].expression.getMathML() +
          "<mo>ⅆ</mo>"+
          this.operands[1].variables[0].getMathML() +
	  "</mrow>";
      },

      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='calculus1' name='defint'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
        "</OMA>";
      
      }
    
    });

  /**
   * Defines an on-screen (definite) integral.
   */
  org.mathdox.formulaeditor.presentation.Defint =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

      /**
       * top and bottom rows are smaller
       */
      fontSizeModifierArray : [-1,0,-1],

      initialize : function(below, above) {

        var parent = arguments.callee.parent;
        // U+222B integral
        var defint  = new org.mathdox.formulaeditor.presentation.Symbol("∫");
        return parent.initialize.call(this, above, defint, below);

      },

      copy : function() {
        var above = this.children[0];
        var below = this.children[2];
        return this.clone(below.copy(), above.copy());
      },

      getSemantics : function(context) {

        var above = this.children[0].getSemantics(context).value;
        var below = this.children[2].getSemantics(context).value;

        return {
          value : [below, above],
          rule  : "defint"
        };

      }

  });

  /**
   * Extend the OpenMathParser object with parsing code for calculus1.defint.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Sum object based on the OpenMath node.
       */
      handleCalculus1Defint : function(node) {

        var children = node.childNodes;
        var interval = this.handle(children.item(1));
        var lambda   = this.handle(children.item(2));

	if (lambda === null || lambda.variables.length === 0) {
	  alert("calculus1.defint needs a nonempty OMBVAR");
	  return null;
	}

        return new org.mathdox.formulaeditor.semantics.Defint(interval, lambda);

      }

    });


  /**
   * Add the parsing code for definite integrals.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression150 = defint expression 'd' variable | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.transform(
            pG.concatenation(
              pG.rule("defint"),
              pG.rule("expression"),
	      // U+2146 differential d
              pG.literal("ⅆ"),
              pG.rule("variable")
            ),
            function(result) {

              return new semantics.Defint(
                new semantics.Interval(result[0][0], result[0][1]),
                new semantics.Lambda(result[3], result[1])
              );

            }
          ),
          parent.expression150).apply(this, arguments);
      },

      // defint = never
      defint : pG.never,
      calculus1defint_partial: 
        pG.transform(
          pG.concatenation(
            pG.rule("defint"),
            pG.rule("expression")
          ),
          function(result) {
            // just return the expression
            // return value should probably not be used anyway
            return result[0];
          }
        )
    };
  });

  /**
   * Add a key handler for the 'd' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the 'd' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the 'd' key has been pressed
          if (String.fromCharCode(event.charCode) == "d") {

            // search for a partial integral expression to the left of
            // the cursor
            var index = editor.cursor.position.index;
            var parsedleft = this.getSemantics(editor.getExpressionParsingContext(), 0, index, 
              "calculus1defint_partial", true);

            if (parsedleft.value !== null || parsedleft.index > 0) {
              // found a partial calculus1int expression
              // U+2146 differential d
              var presentation = org.mathdox.formulaeditor.presentation;
              this.insert(index, new presentation.Symbol("ⅆ"));
              editor.cursor.moveRight();
            
              // update the editor state
              editor.redraw();
              editor.save();
              return false;
            }
          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });


});

    $identify("org/mathdox/formulaeditor/modules/calculus1/diff.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){
 
  var presentation = org.mathdox.formulaeditor.presentation;
  var semantics = org.mathdox.formulaeditor.semantics;

  // U+2032 [superscript] prime
  var mathmlSymbol= [ "", "", "<mo>′</mo>"];
  
  var symbol =  {
    // U+2032 [superscript] prime
    onscreen : ["","","′"],
    openmath : "<OMS cd='calculus1' name='diff'/>",
    mathml   : mathmlSymbol
  };

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Calculus1Diff =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {
        onscreen : symbol.onscreen,
        openmath : symbol.openmath,
        mathml   : mathmlSymbol
      },

      precedence : 150

    });

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Calculus1Nthdiff =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {
        onscreen : symbol.onscreen,
        openmath : "<OMS cd='calculus1' name='nthdiff'/>",
        mathml   : mathmlSymbol
      },

      precedence : 150,

      getSymbolMathML: function(context) {
        var symbol = ["",""];
        var primes=[];
        var i=0;

        for (i=0;i<this.operands[0].value;i++) {
          // U+2032 [superscript] prime
          primes.push("′");
        }
        symbol.push("<mo>"+primes.join("")+"</mo>");

        return symbol;
      },

      getSymbolOnscreen: function(context) {
        var symbol = ["", ""];
        var primes=[];
        var i=0;

        for (i=0;i<this.operands[0].value;i++) {
          // U+2032 [superscript] prime
          primes.push("′");
        }
        symbol.push(primes.join(""));

        return symbol;
      },

      getMathML: function(context) {
        var array = [];
        var operand = this.operands[1];
	
	array.push("<mrow>");

        if (operand.getPrecedence && operand.getPrecedence(context) != 0 && operand.getPrecedence(context)< this.getPrecedence(context)) {
          array.push("<mfenced>");
	  array.push(operand.getMathML(context));
          array.push("</mfenced>");
        } else {
	  array.push(operand.getMathML(context));
        }

        var symbol_mathml = this.getSymbolMathML();
        array.push(symbol_mathml[2]);
        
        // join row to result string
        var result = array.join("");

        return result;
      },

      getPresentation: function(context) {
        var array=[];
        var operand = this.operands[1];

        if (operand.getPrecedence && operand.getPrecedence(context) != 0 && operand.getPrecedence(context)< this.getPrecedence(context)) {
          array.push(new presentation.Symbol("("));
          array.push(operand.getPresentation(context));
          array.push(new presentation.Symbol(")"));
        } else {
          array.push(operand.getPresentation(context));
        }

        // symbolOnscreen is an array (defined above), removed check
        var symbol = this.getSymbolOnscreen(context);
        var row = new presentation.Row(symbol[2]);

        array.push(row);
        
        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);

        return result;
      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary object based on the OpenMath node.
      */
      handleCalculus1Diff : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Calculus1Diff(operand);

      },

      handleCalculus1Nthdiff : function(node) {
        var n = this.handle(node.childNodes.item(1));
        var func = this.handle(node.childNodes.item(2));
        var retval = new org.mathdox.formulaeditor.semantics.Calculus1Nthdiff(n, func);
        return retval;
      }
    });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["calculus1__diff"] = new org.mathdox.formulaeditor.semantics.Keyword("calculus", "diff", symbol, "unary");
  org.mathdox.formulaeditor.parsing.openmath.KeywordList["calculus1__nthdiff"] = new org.mathdox.formulaeditor.semantics.Keyword("calculus", "nthdiff", symbol, "binary");

  /**
   * Add the parsing code for unary symbol.
   */
  var pG = new org.mathdox.parsing.ParserGenerator();

  // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression150 = calculus1diff | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("calculus1diff"),
          parent.expression150).apply(this, arguments);
      },

      func_symbol : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("calculus1diff"),
          parent.func_symbol).apply(this, arguments);
      },

      // calculus1diff = expression160 "′*"
      calculus1diff :
        pG.transform(
          pG.concatenation(
            pG.rule("expression160"),
            pG.repetitionplus(
              pG.literal("′")
            )
          ),
          function(result) {
            var retval;
            var n = result.length - 1;

            if (n == 1) {
              retval = new semantics.Calculus1Diff(result[0]);
            } else {
              retval = new semantics.Calculus1Nthdiff(new semantics.Integer(n), result[0]);
            }
            return retval;
          }
        )
    };
  });

});

  $package("org.mathdox.formulaeditor.modules.calculus1");

$identify("org/mathdox/formulaeditor/modules/calculus1/int.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an integration.
   */
  org.mathdox.formulaeditor.semantics.Integration =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      // operand : lambda expression
      lambda: null,
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        var result = new presentation.Row();
        var row;

        row = [
          // U+222B integral
          new presentation.Symbol('∫'),
          this.lambda.expression.getPresentation(context),
          // U+2146 differential D
          new presentation.Symbol("ⅆ"),
          this.lambda.variables[0].getPresentation(context)
        ];

        result.initialize.apply(result, row);
        
        return result;
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='calculus1' name='int'/>" +
          this.lambda.getOpenMath() +
        "</OMA>";
      },

      getMathML : function() {
        // U+222B integral
        return "<mrow><mo>∫</mo>"+
          this.lambda.expression.getMathML() +
          // U+2146 differential D
          "<mo>ⅆ</mo>"+
          this.lambda.variables[0].getMathML()+
          "</mrow>";
      },

      initialize : function() {
        this.lambda = arguments[0];
      }
    
    });

  /**
   * Extend the OpenMathParser object with parsing code for calculus1.int.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Integration object based on the OpenMath node.
       */
      handleCalculus1Int : function(node) {

        var children = node.childNodes;
        var lambda   = this.handle(children.item(1));

        if (lambda === null || lambda.variables.length === 0) {
          alert("calculus1.int needs a nonempty OMBVAR");
          return null;
        }

        return new org.mathdox.formulaeditor.semantics.Integration(lambda);
      }

    });


  /**
   * Add the parsing code for integrals.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression150 = calculus1int | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("calculus1int"),
          parent.expression150).apply(this, arguments);
      },
      // U+222B integral
      // calculus1int '∫' expression 'd' variable 
      calculus1int: 
        pG.transform(
          pG.concatenation(
            // U+222B integral
            pG.literal("∫"),
            pG.rule("expression"),
            pG.literal("ⅆ"),
            pG.rule("variable")
          ),
          function(result) {
            var integration;

            integration =  new semantics.Integration(
              new semantics.Lambda(result[3], result[1])
            );

            return integration;
          }
        ),
      calculus1int_partial: 
        pG.transform(
          pG.concatenation(
            // U+222B integral
            pG.literal("∫"),
            pG.rule("expression")
          ),
          function(result) {
            // just return the expression
            // return value should probably not be used anyway
            return result[1];
          }
        )
    };
  });

  /**
   * Add a key handler for the 'd' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the 'd' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the 'd' key has been pressed
          if (String.fromCharCode(event.charCode) == "d") {

            // search for a partial integral expression to the left of
            // the cursor
            var index = editor.cursor.position.index;
            var parsedleft = this.getSemantics(editor.getExpressionParsingContext(), 0, index, 
              "calculus1int_partial", true);
	
            if (parsedleft.value !== null || parsedleft.index > 0) {
              // found a partial calculus1int expression
              // U+2146 differential d
              var presentation = org.mathdox.formulaeditor.presentation;
              this.insert(index, new presentation.Symbol("ⅆ"));
              editor.cursor.moveRight();
            
              // update the editor state
              editor.redraw();
              editor.save();
              return false;
            }
          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });


});

    $identify("org/mathdox/formulaeditor/modules/complex1/complex_cartesian.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/modules/arith1/plus.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/times.js");
$require("org/mathdox/formulaeditor/modules/keywords.js");

$main(function(){
  /**
   * Extend the OpenMathParser object with parsing code for arith1.times.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Times object based on the OpenMath node.
       */
      handleComplex1Complex_cartesian : function(node, style) {

        var semantics = org.mathdox.formulaeditor.semantics;
        // parse the children of the OMA
        var children = node.childNodes;

        var realpart = this.handle(children.item(1));

        var complexI = org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__i"];

        var imagpart = this.handle(children.item(2));
        var complexpart;

        // construct a Times object
        var result;

        if (imagpart instanceof semantics.Arith1Unary_minus) {
          complexpart = new semantics.Times(imagpart.operands[0], complexI);
          result = new semantics.Arith1Minus(realpart, complexpart);
        } else if (imagpart instanceof semantics.Integer || imagpart.getValueAsString().charAt(0)=='-') {
          var posInt = new semantics.Integer(imagpart.value.slice(1));
          complexpart = new semantics.Times(posInt, complexI);
          result = new semantics.Arith1Minus(realpart, complexpart);
        } else {
          complexpart = new semantics.Times(imagpart, complexI);
          result = new semantics.Arith1Plus(realpart, complexpart);
        }

        return result;
      }

    });

});

    $identify("org/mathdox/formulaeditor/modules/editor1/palette.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/modules/keywords.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");
$require("org/mathdox/formulaeditor/presentation/PTabContainer.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){
  /**
   * Define a semantic tree node that represents the editor1.palette
   */
  org.mathdox.formulaeditor.semantics.Editor1Palette =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

    symbol : {
      mathml   : ["<mtr><mtd>","</mtd><mtd>","</mtd></mtr>"],
      onscreen : ["[", ",", "]"],
      openmath : "<OMS cd='editor1' name='palette_row'/>"
    },
    
    precedence : 0,

    getPresentation : function(context) {
      var tabs=[];
      var i;

      for (i=0;i<this.operands.length;i++) {
        tabs.push(this.operands[i].getPresentation(context));
      }

      var result = new org.mathdox.formulaeditor.presentation.PTabContainer();

      result.initialize.apply(result,tabs);

      return result;
    }
  });

  /**
   * Define a semantic tree node that represents the editor1.palette_row
   */
  org.mathdox.formulaeditor.semantics.Editor1Palette_row =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
    
    symbol : {
      mathml   : ["<mtr><mtd>","</mtd><mtd>","</mtd></mtr>"],
      onscreen : ["[", ",", "]"],
      openmath : "<OMS cd='editor1' name='palette_row'/>"
    },
    
    precedence : 0

  });

  /**
   * Define a semantic tree node that represents the editor1.palette_tab
   */
  org.mathdox.formulaeditor.semantics.Editor1Palette_tab =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
  
    symbol : {
      mathml   : ["<mtable>","","</mtable>"],
      onscreen : ["[", ",", "]"],
      openmath : "<OMS cd='editor1' name='palette'/>"
    },
    
    precedence : 0,

    title : null,

    getPaletteEntry : function(context,semanticEntry) {
      var modifiedContext = {};
      for (var name in context) {
        modifiedContext[name] = context[name];
      }
      modifiedContext.inPalette = true;

      if (semanticEntry === null || semanticEntry === undefined) {
        semanticEntry = org.mathdox.formulaeditor.parsing.openmath.KeywordList["editor1__palette_whitespace"];
      }
      
      // presentation for the palette
      var entry = semanticEntry.getPresentation(modifiedContext);
      entry.semanticEntry = semanticEntry;
      // add presentation to insert
      entry.insertablePresentation = function() { 
        return this.semanticEntry.getPresentation(context);
      };
      // add function to insert, XXX possibly add library function to
      // presentation node ?
      entry.insertCopy = function(position) {

        if (this.insertablePresentation === null || 
            this.insertablePresentation === undefined ) {
          return; // nothing to insert
        }

        var toInsert = this.insertablePresentation();

        for (var i=0;i<toInsert.children.length;i++) {
          //alert("inserting: "+i+" : "+toInsert.children[i]);

          var moveright = position.row.insert(position.index, 
            toInsert.children[i], (i === 0));
          if (moveright) {
            position.index++;
          }
        }
      };
      return entry;

    },

    getPresentation : function(context) {
      var rows = [];
      var row; // counter
      var col; // counter
      for (row=0;row<this.operands.length;row++) {
        var cols = [];
        for (col=0;col<this.operands[row].operands.length;col++) {
          // semantic version of the entry
          var semanticEntry = this.operands[row].operands[col];
          
          // presentation for the palette
          var entry = this.getPaletteEntry(context,semanticEntry);

          cols.push(entry);
        }
        rows.push(cols);  
      }
      // calculate the (maximum) number of columns
      var numcols = 0;
      for (row=0;row<rows.length;row++){
        if (numcols < rows[row].length) {
          numcols = rows[row].length;
        }
      }
      for (row=0;row<rows.length;row++) {
        if (rows[row].length<numcols) {
          cols = rows[row];
          for (col = cols.length; col<numcols; col++) {
            cols.push(this.getPaletteEntry(context));
          }
        }
      }
      
      var pArray = new org.mathdox.formulaeditor.presentation.PArray();
      pArray.margin = 10.0;
      pArray.initialize.apply(pArray,rows);

      return pArray;
    }, 

    initialize : function() {
      if (arguments[0] instanceof org.mathdox.formulaeditor.semantics.Editor1Palette_tabname) {
        this.title = arguments[0];
	/* arguments is not really an array, arguments.slice(1) has to be done in a different way */
        this.operands = Array.prototype.slice.call(arguments,[1]);
      } else {
        this.title = null;
        this.operands = arguments;
      }
    }
  });

  org.mathdox.formulaeditor.semantics.Editor1Palette_tabname =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

    symbol : {
      mathml   : ["<mtr><mtd>","","</mtd></mtr>"],
      onscreen : ["", "" , ""],
      openmath : "<OMS cd='editor1' name='palette_tabname'/>"
    },
    
    precedence : 0,
  });

  // XXX todo parse parsing palette/palette_row in OM
  /**
   * Extend the OpenMathParser object with parsing code for editor1.palette
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns a Editor1Palette object based on the OpenMath node.
     */
    handleEditor1Palette : function(node) {

      // parse the operands of the OMA
      var children = node.childNodes;
      var operands = [];
      var child;
      for (var i=1; i<children.length; i++) {
        child = this.handle(children.item(i));
        if (child !== null) {
          // not a comment
          operands.push(child);
        }
      }

      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette();
      /* check if the first child is a palette tab */
      child = children.item(1);
      if ((child !==null) && (child !== undefined) &&
        (child.localName=="OMA")) {
        child = child.childNodes.item(0);
      }
      if ((child !==null) && (child !== undefined) &&
        (child.localName=="OMS") &&
        (child.getAttribute("cd") == "editor1") &&
        (child.getAttribute("name") == "palette_tab")) {

        // first child is a tab
        // construct a Editor1Palette object
        result.initialize.apply(result,operands);
      } else {
        // first child is not a tab : construct a Editor1Palette object with a
        // single tab
        var tab = new org.mathdox.formulaeditor.semantics.Editor1Palette_tab();

        tab.initialize.apply(tab,operands);

        result.initialize.apply(result,[tab]);
      }

      return result;
    },

    /**
     * Returns a Editor1Palette_row object based on the OpenMath node.
     */
    handleEditor1Palette_row : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct a Editor1Palette_row object
      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette_row();
      result.initialize.apply(result,operands);
      return result;

    },

    /**
     * Returns a Editor1Palette_tab object based on the OpenMath node.
     */
    handleEditor1Palette_tab : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct a Editor1Palette_row object
      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette_tab();
      result.initialize.apply(result,operands);
      return result;

    },

    /**
     * Returns a Editor1Palette_tabname object based on the OpenMath node.
     */
    handleEditor1Palette_tabname : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct a Editor1Palette_tabname object
      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette_tabname();
      result.initialize.apply(result,operands);
      return result;
    }
  });
});

    $identify("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$require("org/mathdox/formulaeditor/semantics/Lambda.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");

$main(function(){

  /**
   * Extend the OpenMathParser object with parsing code for fns1.lambda.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns an absolute value object based on the OpenMath node.
      */
      handleFns1Lambda : function(node) {

        // parse the children of the OMBIND
        var children = node.childNodes;

        // children.item(0) is OMS: fns1.lambda
        // children.item(1) is OMBVAR
        // children.item(2) is the expression

        if (children.length < 3) {
          // not enough arguments
          alert("parsing OpenMath fns1.lambda: not enough arguments");
          return null; 
        }
        var ombvarNode = children.item(1);
        if (ombvarNode.nodeType != 1) { // ELEMENT node
          alert("parsing OpenMath fns1.lambda: could not find OMBVAR node ");
          return null;
        }
        var ombvarChildren = ombvarNode.childNodes;
        var variables = [];
        var i; // counter
        for (i=0; i<ombvarChildren.length; i++) {
          variables.push(this.handle(ombvarChildren.item(i)));
        }

        var expressionNode = children.item(2);
        if (children.item(2).nodeType != 1) { // ELEMENT node
          alert("parsing OpenMath fns1.lambda: could not find expression node");
          return null;
        }
        var expression = this.handle(expressionNode);

        // construct a List1List object
        var semantics = org.mathdox.formulaeditor.semantics;
        var lambda = new semantics.Lambda(variables, expression);

        return lambda;
      }

    });


  /**
   * Add the parsing code for lambda functions.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( function(context) {
    return {

      // expression160 = list | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("fns1lambda"),
          parent.expression160).apply(this, arguments);
      },

      // U+03BB greek small letter lamda
      // lambda = "λ" ( variable | "(" variable ( "," variable )* ")" ) "."
      // ( variable | "(" expression ")" )
      fns1lambda :
        pG.transform(
          pG.concatenation(
            // U+03BB greek small letter lamda
            pG.literal("λ"),
            pG.alternation(
              pG.rule("variable"),
              pG.concatenation(
                pG.literal("("),
                pG.rule("variable"),
                pG.repetition(
                  pG.concatenation(
                    pG.literal(","),
                    pG.rule("variable")
                  )
                ),
                pG.literal(")")
              )
            ),
            pG.literal("."),
            pG.alternation(
              pG.rule("variable"),
              pG.concatenation(
                pG.literal("("),
                pG.rule("expression"),
                pG.literal(")")
              )
            )
          ),
          function(result) {
            var semantics = org.mathdox.formulaeditor.semantics;

            // result[0] = lambda

            // parse variables
            var variables = [];

            var i = 1;

            if (i<result.length && result[i] != "(") {
              // only one variable
              variables.push(result[i]);
              
              i++;
              // result[i] = "."
            } else {
              // multiple variables, result[i] == "("
              i++;
              // result[i] = ")" or result[i] = variable
              while (i<result.length && result[i] != ")") {
                variables.push(result[i]);
                i++;
                // result[i] = "," or result[i] = ")"
                if (i<result.length && result[i] == ",") {
                  // skip comma
                  i++;
                }
                // result[i] = variable or result[i] = ")"
              }
              // result[i] = ")"
              i++;
              // result[i] = '.'
            }
            // result[i] = '.'
            i++;
            // result[i] = variable or result[i] = "("
            if (i<result.length && result[i] != "(") {
              // only one variable
              expression = result[i];
              i++;
            } else {
              // result[i] = "("
              i++;
              expression = result[i];
              i++;
              // result[i] = ")"
              i++;
            }
            return new semantics.Lambda(variables,expression);
          }
        )
      };
    });

  org.mathdox.formulaeditor.parsing.expression.KeywordList.lambda = {
    parseResultFun : function(oper, array) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var lambda = new semantics.Lambda();
      lambda.initialize.apply(lambda, array);

      return lambda;
    }
  };
});

  
$identify("org/mathdox/formulaeditor/modules/integer1/factorial.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var mathmlSymbol= [ "", "", ""];
  
  if ("" !== "") {
    mathmlSymbol[0] = "<mo></mo>";
  }
  if ("!" !== "") {
    mathmlSymbol[2] = "<mo>!</mo>";
  }

  var symbol =  {
    onscreen : ["","","!"],
    openmath : "<OMS cd='integer1' name='factorial'/>",
    mathml   : mathmlSymbol
  };

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Integer1Factorial =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {
        onscreen : symbol.onscreen,
        openmath : symbol.openmath,
        mathml   : mathmlSymbol
      },

      precedence : 140

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary minus object based on the OpenMath node.
      */
      handleInteger1Factorial : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Integer1Factorial(operand);

      }

    });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["integer1__factorial"] = new org.mathdox.formulaeditor.semantics.Keyword("integer1", "factorial", symbol, "unary");

  /**
   * Add the parsing code for unary symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  var rulesEnter = [];
  var positionEnter = 0;
  if ("" !== "") {
    rulesEnter.push(pG.literal(""));
    positionEnter++;
  }
  rulesEnter.push(pG.rule("expression150"));
  if ("!" !== "") {
    rulesEnter.push(pG.literal("!"));
  }

  if (( ""  === ""  ) &&
      ( "!" === "!" )) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = integer1factorial | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("integer1factorial"),
            parent.expression140).apply(this, arguments);
        },

        // integer1factorial = "" expression150 "!"
        integer1factorial :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Integer1Factorial(result[positionEnter]);
            }
          )
      };
    });
  } else { // allow alternative as displayed on the screen
    var rulesScreen = [];
    var positionScreen = 0;
    if ("" !== "") {
      rulesScreen.push(pG.literal(""));
      positionScreen++;
    }
    rulesScreen.push(pG.rule("expression150"));
    if ("!" !== "") {
      rulesScreen.push(pG.literal("!"));
    }
  
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = integer1factorial | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("integer1factorial"),
            pG.rule("integer1factorialalt"),
            parent.expression140).apply(this, arguments);
        },

        // integer1factorial = "" expression150 "!"
        integer1factorial :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Integer1Factorial(result[positionEnter]);
            }
          ),

        // integer1factorialalt = "" expression150 "!"
        integer1factorialalt :
          pG.transform(
            pG.concatenation.apply(pG, rulesScreen),
            function(result) {
              return new semantics.Integer1Factorial(result[positionScreen]);
            }
          )
       };
     });
   }

});

    $identify("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Integer_interval =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 is lower bound
      // operand 1 is upper bound

      symbol : {

        onscreen : ["[",",","]"],
        openmath : "<OMS cd='interval1' name='integer_interval'/>"

      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.integer_interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Integer_interval : function(node) {

        var children = node.childNodes;
        var lower = this.handle(children.item(1));
        var upper = this.handle(children.item(2));

        return new org.mathdox.formulaeditor.semantics.Integer_interval(lower, upper);

      }

    });
  

});

    $identify("org/mathdox/formulaeditor/modules/interval1/interval.js");

$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      // operand 0 is lower bound
      // operand 1 is upper bound

      symbol : {

        onscreen : ["[",",","]"],
        openmath : "<OMS cd='interval1' name='interval'/>"

      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval : function(node) {

        var children = node.childNodes;
        var lower = this.handle(children.item(1));
        var upper = this.handle(children.item(2));

        return new org.mathdox.formulaeditor.semantics.Interval(lower, upper);

      }

    });
  

});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_cc.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_cc =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_cc'/>"

      },

      leftOpen: false,
      rightOpen: false,
      className: "Interval1Interval_cc"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_cc : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_cc();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_co.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_co =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_co'/>"

      },

      leftOpen: false,
      rightOpen: true,
      className: "Interval1Interval_co"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_co : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_co();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

    $identify("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/presentation/Boxed.js");
$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/PseudoRow.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_multi =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      /* to be filled in by extending classes */
      symbol : null,
      leftOpen: null,
      rightOpen: null,
      className: null,

      getPresentation: function (context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var semantics = org.mathdox.formulaeditor.semantics;

	var contents = [];
	var children = [];
	var child;

	var option = context.optionInterval1Brackets;

	var bracket;

	if (this.leftOpen) {
	  bracket = option.lo;
	} else {
	  bracket = option.lc;
	}

	var left = new presentation.Bracket(bracket);

	child = new presentation.Row(this.operands[0].getPresentation(context));
	children.push(child);
	contents.push(child);

	/* use the fixed list separator string from the context */
	var listSep = context.listSeparatorFixed;

	var i;
	for (i = 0; i<listSep.length; i++) {
	  contents.push(new presentation.Symbol(listSep.charAt(i)));
	}

	child = new presentation.Row(this.operands[1].getPresentation(context));
	children.push(child);
	contents.push(child);

	if (this.rightOpen) {
	  bracket = option.ro;
	} else {
	  bracket = option.rc;
	}

        var right = new presentation.Bracket(bracket);
	var prow = new presentation.PseudoRow();
	prow.initialize.apply(prow, contents);

	var row = new presentation.Row(new presentation.Bracketed(left, prow, right));

	return new presentation.Boxed(semantics[this.className], children, row);
      }

    });
});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_oc.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_oc =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_oc'/>"

      },

      leftOpen: true,
      rightOpen: false,
      className: "Interval1Interval_oc"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_oc : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_oc();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_oo.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_oo =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_oo'/>"

      },

      leftOpen: true,
      rightOpen: true,
      className: "Interval1Interval_oo"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_oo : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_oo();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  
$identify("org/mathdox/formulaeditor/modules/keywords.js");

$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  var semantics = org.mathdox.formulaeditor.semantics;
  var cd;
  var name;
  var symbol;
  var newvars = [];
  var regex = /^[A-Za-z]*$/;

  var hasOnlyLetters = function(s) {
    return regex.test(s);
  };

  
  /**
   * Define the arith1.gcd keyword.
   */
  cd = "arith1";
  name = "gcd";
  symbol = { 
    onscreen: "gcd", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>gcd</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["gcd"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( "gcd" !== "gcd" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["gcd"] = new semantics.Keyword(cd, name, symbol, "function", null);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__gcd"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( ! hasOnlyLetters("gcd") ) {
    newvars.push( "gcd" );
  }
  
  /**
   * Define the arith1.lcm keyword.
   */
  cd = "arith1";
  name = "lcm";
  symbol = { 
    onscreen: "lcm", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>lcm</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["lcm"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( "lcm" !== "lcm" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["lcm"] = new semantics.Keyword(cd, name, symbol, "function", null);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__lcm"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( ! hasOnlyLetters("lcm") ) {
    newvars.push( "lcm" );
  }
  
  /**
   * Define the editor1.input_box keyword.
   */
  cd = "editor1";
  name = "input_box";
  symbol = { 
    onscreen: "□", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>□</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["□"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "□" !== "□" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["□"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["editor1__input_box"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("□") ) {
    newvars.push( "□" );
  }
  
  /**
   * Define the editor1.palette_whitespace keyword.
   */
  cd = "editor1";
  name = "palette_whitespace";
  symbol = { 
    onscreen: " ", 
    openmath : null, // use default with model:cd and model:name
    mathml : ""
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList[""] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "" !== " " ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList[" "] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["editor1__palette_whitespace"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters(" ") ) {
    newvars.push( " " );
  }
  
  /**
   * Define the linalg1.determinant keyword.
   */
  cd = "linalg1";
  name = "determinant";
  symbol = { 
    onscreen: "det", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>det</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["det"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "det" !== "det" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["det"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["linalg1__determinant"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("det") ) {
    newvars.push( "det" );
  }
  
  /**
   * Define the logic1.false keyword.
   */
  cd = "logic1";
  name = "false";
  symbol = { 
    onscreen: "false", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>false</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["false"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "false" !== "false" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["false"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__false"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("false") ) {
    newvars.push( "false" );
  }
  
  /**
   * Define the logic1.true keyword.
   */
  cd = "logic1";
  name = "true";
  symbol = { 
    onscreen: "true", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>true</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["true"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "true" !== "true" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["true"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__true"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("true") ) {
    newvars.push( "true" );
  }
  
  /**
   * Define the nums1.e keyword.
   */
  cd = "nums1";
  name = "e";
  symbol = { 
    onscreen: "e", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>e</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["e"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "e" !== "e" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["e"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__e"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("e") ) {
    newvars.push( "e" );
  }
  
  /**
   * Define the nums1.i keyword.
   */
  cd = "nums1";
  name = "i";
  symbol = { 
    onscreen: "i", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>i</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["i"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "i" !== "i" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["i"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__i"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("i") ) {
    newvars.push( "i" );
  }
  
  /**
   * Define the nums1.infinity keyword.
   */
  cd = "nums1";
  name = "infinity";
  symbol = { 
    onscreen: "∞", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>∞</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["infinity"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "infinity" !== "∞" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["∞"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__infinity"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("∞") ) {
    newvars.push( "∞" );
  }
  
  /**
   * Define the nums1.pi keyword.
   */
  cd = "nums1";
  name = "pi";
  symbol = { 
    onscreen: "π", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>π</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["pi"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "pi" !== "π" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["π"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__pi"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("π") ) {
    newvars.push( "π" );
  }
  
  /**
   * Define the permutation1.sign keyword.
   */
  cd = "permutation1";
  name = "sign";
  symbol = { 
    onscreen: "sgn", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sgn</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sgn"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sgn" !== "sgn" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sgn"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["permutation1__sign"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sgn") ) {
    newvars.push( "sgn" );
  }
  
  /**
   * Define the plangeo7.triangle keyword.
   */
  cd = "plangeo7";
  name = "triangle";
  symbol = { 
    onscreen: "△", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mo>△</mo>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["triangle"] = new semantics.Keyword(cd, name, symbol, "function", 3);

  if ( "triangle" !== "△" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["△"] = new semantics.Keyword(cd, name, symbol, "function", 3);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["plangeo7__triangle"] = new semantics.Keyword(cd, name, symbol, "function", 3);

  if ( ! hasOnlyLetters("△") ) {
    newvars.push( "△" );
  }
  
  /**
   * Define the setname1.C keyword.
   */
  cd = "setname1";
  name = "C";
  symbol = { 
    onscreen: "ℂ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℂ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["CC"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "CC" !== "ℂ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℂ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__C"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℂ") ) {
    newvars.push( "ℂ" );
  }
  
  /**
   * Define the setname1.N keyword.
   */
  cd = "setname1";
  name = "N";
  symbol = { 
    onscreen: "ℕ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℕ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["NN"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "NN" !== "ℕ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℕ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__N"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℕ") ) {
    newvars.push( "ℕ" );
  }
  
  /**
   * Define the setname1.P keyword.
   */
  cd = "setname1";
  name = "P";
  symbol = { 
    onscreen: "ℙ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℙ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["PP"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "PP" !== "ℙ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℙ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__P"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℙ") ) {
    newvars.push( "ℙ" );
  }
  
  /**
   * Define the setname1.Q keyword.
   */
  cd = "setname1";
  name = "Q";
  symbol = { 
    onscreen: "ℚ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℚ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["QQ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "QQ" !== "ℚ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℚ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__Q"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℚ") ) {
    newvars.push( "ℚ" );
  }
  
  /**
   * Define the setname1.R keyword.
   */
  cd = "setname1";
  name = "R";
  symbol = { 
    onscreen: "ℝ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℝ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["RR"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "RR" !== "ℝ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℝ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__R"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℝ") ) {
    newvars.push( "ℝ" );
  }
  
  /**
   * Define the setname1.Z keyword.
   */
  cd = "setname1";
  name = "Z";
  symbol = { 
    onscreen: "ℤ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℤ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["ZZ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "ZZ" !== "ℤ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℤ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__Z"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℤ") ) {
    newvars.push( "ℤ" );
  }
  
  /**
   * Define the set1.emptyset keyword.
   */
  cd = "set1";
  name = "emptyset";
  symbol = { 
    onscreen: "∅", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>∅</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["emptyset"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "emptyset" !== "∅" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["∅"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["set1__emptyset"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("∅") ) {
    newvars.push( "∅" );
  }
  
  /**
   * Define the transc1.arccos keyword.
   */
  cd = "transc1";
  name = "arccos";
  symbol = { 
    onscreen: "arccos", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccos</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccos" !== "arccos" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccos"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccos") ) {
    newvars.push( "arccos" );
  }
  
  /**
   * Define the transc1.arccosh keyword.
   */
  cd = "transc1";
  name = "arccosh";
  symbol = { 
    onscreen: "arccosh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccosh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccosh" !== "arccosh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccosh") ) {
    newvars.push( "arccosh" );
  }
  
  /**
   * Define the transc1.arccot keyword.
   */
  cd = "transc1";
  name = "arccot";
  symbol = { 
    onscreen: "arccot", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccot</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccot" !== "arccot" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccot"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccot") ) {
    newvars.push( "arccot" );
  }
  
  /**
   * Define the transc1.arccoth keyword.
   */
  cd = "transc1";
  name = "arccoth";
  symbol = { 
    onscreen: "arccoth", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccoth</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccoth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccoth" !== "arccoth" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccoth"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccoth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccoth") ) {
    newvars.push( "arccoth" );
  }
  
  /**
   * Define the transc1.arccsc keyword.
   */
  cd = "transc1";
  name = "arccsc";
  symbol = { 
    onscreen: "arccsc", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccsc</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccsc" !== "arccsc" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsc"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccsc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccsc") ) {
    newvars.push( "arccsc" );
  }
  
  /**
   * Define the transc1.arccsch keyword.
   */
  cd = "transc1";
  name = "arccsch";
  symbol = { 
    onscreen: "arccsch", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccsch</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccsch" !== "arccsch" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsch"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccsch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccsch") ) {
    newvars.push( "arccsch" );
  }
  
  /**
   * Define the transc1.arcsec keyword.
   */
  cd = "transc1";
  name = "arcsec";
  symbol = { 
    onscreen: "arcsec", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsec</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsec" !== "arcsec" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsec"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsec") ) {
    newvars.push( "arcsec" );
  }
  
  /**
   * Define the transc1.arcsech keyword.
   */
  cd = "transc1";
  name = "arcsech";
  symbol = { 
    onscreen: "arcsech", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsech</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsech" !== "arcsech" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsech"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsech") ) {
    newvars.push( "arcsech" );
  }
  
  /**
   * Define the transc1.arcsin keyword.
   */
  cd = "transc1";
  name = "arcsin";
  symbol = { 
    onscreen: "arcsin", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsin</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsin" !== "arcsin" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsin"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsin") ) {
    newvars.push( "arcsin" );
  }
  
  /**
   * Define the transc1.arcsinh keyword.
   */
  cd = "transc1";
  name = "arcsinh";
  symbol = { 
    onscreen: "arcsinh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsinh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsinh" !== "arcsinh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsinh") ) {
    newvars.push( "arcsinh" );
  }
  
  /**
   * Define the transc1.arctan keyword.
   */
  cd = "transc1";
  name = "arctan";
  symbol = { 
    onscreen: "arctan", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arctan</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arctan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arctan" !== "arctan" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arctan"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arctan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arctan") ) {
    newvars.push( "arctan" );
  }
  
  /**
   * Define the transc1.arctanh keyword.
   */
  cd = "transc1";
  name = "arctanh";
  symbol = { 
    onscreen: "arctanh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arctanh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arctanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arctanh" !== "arctanh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arctanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arctanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arctanh") ) {
    newvars.push( "arctanh" );
  }
  
  /**
   * Define the transc1.cos keyword.
   */
  cd = "transc1";
  name = "cos";
  symbol = { 
    onscreen: "cos", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>cos</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["cos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "cos" !== "cos" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["cos"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__cos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("cos") ) {
    newvars.push( "cos" );
  }
  
  /**
   * Define the transc1.cosh keyword.
   */
  cd = "transc1";
  name = "cosh";
  symbol = { 
    onscreen: "cosh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>cosh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["cosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "cosh" !== "cosh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["cosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__cosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("cosh") ) {
    newvars.push( "cosh" );
  }
  
  /**
   * Define the transc1.cot keyword.
   */
  cd = "transc1";
  name = "cot";
  symbol = { 
    onscreen: "cot", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>cot</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["cot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "cot" !== "cot" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["cot"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__cot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("cot") ) {
    newvars.push( "cot" );
  }
  
  /**
   * Define the transc1.coth keyword.
   */
  cd = "transc1";
  name = "coth";
  symbol = { 
    onscreen: "coth", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>coth</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["coth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "coth" !== "coth" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["coth"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__coth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("coth") ) {
    newvars.push( "coth" );
  }
  
  /**
   * Define the transc1.csc keyword.
   */
  cd = "transc1";
  name = "csc";
  symbol = { 
    onscreen: "csc", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>csc</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["csc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "csc" !== "csc" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["csc"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__csc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("csc") ) {
    newvars.push( "csc" );
  }
  
  /**
   * Define the transc1.csch keyword.
   */
  cd = "transc1";
  name = "csch";
  symbol = { 
    onscreen: "csch", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>csch</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["csch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "csch" !== "csch" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["csch"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__csch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("csch") ) {
    newvars.push( "csch" );
  }
  
  /**
   * Define the transc1.exp keyword.
   */
  cd = "transc1";
  name = "exp";
  symbol = { 
    onscreen: "exp", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>exp</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["exp"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "exp" !== "exp" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["exp"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__exp"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("exp") ) {
    newvars.push( "exp" );
  }
  
  /**
   * Define the transc1.ln keyword.
   */
  cd = "transc1";
  name = "ln";
  symbol = { 
    onscreen: "ln", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ln</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["ln"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "ln" !== "ln" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ln"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__ln"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("ln") ) {
    newvars.push( "ln" );
  }
  
  /**
   * Define the transc1.log keyword.
   */
  cd = "transc1";
  name = "log";
  symbol = { 
    onscreen: "log", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>log</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["log"] = new semantics.Keyword(cd, name, symbol, "function", 2);

  if ( "log" !== "log" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["log"] = new semantics.Keyword(cd, name, symbol, "function", 2);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__log"] = new semantics.Keyword(cd, name, symbol, "function", 2);

  if ( ! hasOnlyLetters("log") ) {
    newvars.push( "log" );
  }
  
  /**
   * Define the transc1.sec keyword.
   */
  cd = "transc1";
  name = "sec";
  symbol = { 
    onscreen: "sec", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sec</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sec" !== "sec" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sec"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sec") ) {
    newvars.push( "sec" );
  }
  
  /**
   * Define the transc1.sech keyword.
   */
  cd = "transc1";
  name = "sech";
  symbol = { 
    onscreen: "sech", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sech</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sech" !== "sech" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sech"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sech") ) {
    newvars.push( "sech" );
  }
  
  /**
   * Define the transc1.sin keyword.
   */
  cd = "transc1";
  name = "sin";
  symbol = { 
    onscreen: "sin", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sin</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sin" !== "sin" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sin"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sin") ) {
    newvars.push( "sin" );
  }
  
  /**
   * Define the transc1.sinh keyword.
   */
  cd = "transc1";
  name = "sinh";
  symbol = { 
    onscreen: "sinh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sinh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sinh" !== "sinh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sinh") ) {
    newvars.push( "sinh" );
  }
  
  /**
   * Define the transc1.tan keyword.
   */
  cd = "transc1";
  name = "tan";
  symbol = { 
    onscreen: "tan", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>tan</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["tan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "tan" !== "tan" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["tan"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__tan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("tan") ) {
    newvars.push( "tan" );
  }
  
  /**
   * Define the transc1.tanh keyword.
   */
  cd = "transc1";
  name = "tanh";
  symbol = { 
    onscreen: "tanh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>tanh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["tanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "tanh" !== "tanh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["tanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__tanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("tanh") ) {
    newvars.push( "tanh" );
  }
  
  var pG = new org.mathdox.parsing.ParserGenerator();
  if(newvars.length > 0) {
    var args = [];
    for (var i=0;i < newvars.length; i++) {
      args.push(pG.literal(newvars[i]));
    }
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {
        variable : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.alternation.apply(this, args),
              function(result) {
                var result_joined = result.join("");

                // this should be in the keywordlist
                return org.mathdox.formulaeditor.parsing.expression.KeywordList[result_joined];
              }
            ),
            parent.variable).apply(this, arguments);
        }
      };
    });
  }
});

    $identify("org/mathdox/formulaeditor/modules/limit1/limit.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a sum.
   */
  org.mathdox.formulaeditor.semantics.Limit =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : limiting value
      // NOT USED YET operand 1 : method of approach
      // operand 2 : function
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
       
        return new presentation.Row(
          new presentation.Limit(
            new presentation.Row(
              this.operands[2].variables[0].getPresentation(context),
              // U+2192 rightwards arrow
              new presentation.Symbol("→"),
              this.operands[0].getPresentation(context)
            )
          ),
          new presentation.Symbol("("),
          this.operands[2].expression.getPresentation(context),
          new presentation.Symbol(")")
        );
      
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='limit1' name='limit'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
          this.operands[2].getOpenMath() +
        "</OMA>";
      
      },

      getMathML : function() {
        return "<mrow>"+
          "<munder>"+
            "<mo>lim</mo>"+
            "<mrow>"+
              this.operands[2].variables[0].getMathML() +
              // U+2192 rightwards arrow
              "<mo>→</mo>"+
              this.operands[0].getMathML() +
            "</mrow>" +
          "</munder>" +
          this.operands[2].expression.getMathML() +
        "</mrow>";
      }
    
    });

  /**
   * Defines an on-screen limit.
   */
  org.mathdox.formulaeditor.presentation.Limit =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

    /**
     * top and bottom rows are smaller
     */
    fontSizeModifierArray : [0,-1],

    /**
     * use top row as baseline
     */
    baselineIndex: 0,

    initialize : function(below) {

      var parent = arguments.callee.parent;
      // U+03A3 greek capital letter sigma
      
      var lim  = new org.mathdox.formulaeditor.semantics.Keyword("limit1","limit",{onscreen:"lim"},"function").getPresentation();
      return parent.initialize.call(this, lim, below);
    },

    getSemantics : function(context) {

      var semantics = org.mathdox.formulaeditor.semantics;

      var below = this.children[1].getSemantics(context, null, null, "approach").value;

      if (below !== null) {
        return {
          value : below,
          rule  : "limit"
        };

      }
      else {
        return null;
      }
    }
  });

  /**
   * Extend the OpenMathParser object with parsing code for limit1.limit.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Limit object based on the OpenMath node.
       */
      handleLimit1Limit : function(node) {


        var children = node.childNodes;
        var value = this.handle(children.item(1));
        var method = this.handle(children.item(2));
        var lambda   = this.handle(children.item(3));

        if (lambda.variables.length === 0) {
          alert("limit1.limit needs a nonempty OMBVAR");
          return null;
        }

        return new org.mathdox.formulaeditor.semantics.Limit(value, method, lambda);

      }

    });


  /**
   * Add the parsing code for limits.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression150 = limit expression150 | super.expression150
        expression150 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.concatenation(
                pG.rule("limit"),
                pG.rule("expression150")
              ),
              function(result) {

                return new semantics.Limit(
                  result[0][2], 
                  new semantics.Keyword("limit1", "null", null, "constant"),
                  new semantics.Lambda([result[0][0]], result[1])
                );

              }
            ),
            parent.expression150).apply(this, arguments);
        },

        approach : function() {
          var parent = arguments.callee.parent;
          pG.concatenation(
            pG.rule("variable"),
            pG.rule("rightarrow"),
            pG.rule("expression")
          ).apply(this, arguments);
        },
        
        rightarrow: function() {
          var parent = arguments.callee.parent;
          pG.transform(
            pG.alternation(
              pG.concatenation(pG.literal("-"), pG.literal(">")),
              // U+2192 rightwards arrow
              pG.literal("→")
            ),
            function(result){
              // U+2192 rightwards arrow
              return "→";
            }
          ).apply(this, arguments);
        },

        // limit = never
        limit : pG.never
      };
    });

});

    $identify("org/mathdox/formulaeditor/modules/linalg/matrix.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Matrix.js");
$require("org/mathdox/formulaeditor/presentation/Vector.js");
$require("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");
$require("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  /**
   * Define a semantic tree node that represents the linalg2.matrix
   */
  org.mathdox.formulaeditor.semantics.Linalg2Matrix =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mtable>","","</mtable>"],
        onscreen : ["[", ",", "]"],
        openmath : "<OMS cd='linalg2' name='matrix'/>"

      },

      precedence : 0,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        
        // add inMatrix to a copy of the context
        // XXX see if an extend like function can be used
        var modifiedContext = {};
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.inMatrix = true;

        var rows = [];

        for ( var row =0 ; row<this.operands.length ; row++) {
          var currentRow = [];
          for (var col = 0 ; col<this.operands[row].operands.length; col++) {
            var entry = this.operands[row].operands[col].getPresentation(
              modifiedContext);
            currentRow.push(entry);
          }
          rows[row] = currentRow;
        }

        var result = new presentation.Matrix();
        result.initialize.apply(result,rows);
       
        return result;
      }

    });

  /**
   * Define a semantic tree node that represents the linalg2.vector
   */
  org.mathdox.formulaeditor.semantics.Linalg2Vector =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        mathml   : ["<mo>[</mo>","<mo>,</mo>","<mo>]</mo>"],
        onscreen : ["[", ",", "]"],
        openmath : "<OMS cd='linalg2' name='vector'/>"

      },

      precedence : 0,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var entries = [];
        var vector = new presentation.Vector();

        // add inVector to a copy of the context
        // XXX see if an extend like function can be used
        var modifiedContext = {};
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.inVector = true;

        for (var i=0; i<this.operands.length; i++) {
          entries.push(this.operands[i].getPresentation(modifiedContext));
        }
       
        vector.initialize.apply(vector, entries);

        return vector;
      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for linalg2.matrixrow
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Linalg2Matrixrow object based on the OpenMath node.
       */
      handleLinalg2Matrix : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Linalg2Matrix object
        var result = new org.mathdox.formulaeditor.semantics.Linalg2Matrix();
        result.initialize.apply(result,operands);

        return result;
      },

      /**
       * Returns a Linalg2Matrixrow object based on the OpenMath node.
       */
      handleLinalg2Matrixrow : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Linalg2Matrixrow object
        var result = new org.mathdox.formulaeditor.semantics.Linalg2Matrixrow();
        result.initialize.apply(result,operands);
        return result;

      },

      /**
       * Returns a Linalg2Vector object based on the OpenMath node.
       */
      handleLinalg2Vector : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Linalg2Vector object
        var result = new org.mathdox.formulaeditor.semantics.Linalg2Vector();
        result.initialize.apply(result, operands);
        return result;

      }

    });

  /**
   * Add the parsing code for Matrixlike.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression160 = Linalg2Matrixlike | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("Linalg2Matrixlike"),
          parent.expression160).apply(this, arguments);
      },

      // Linalg2Matrixrow = "[" expression ("," expression)* "]"
      Linalg2Matrixlike :
        pG.transform(
          pG.concatenation(
            pG.literal("["),
            pG.rule("expression"),
            pG.repetition(
              pG.concatenation(
                pG.literal(context.listSeparator),
                pG.rule("expression")
              )
            ),
            pG.literal("]")
          ),
          function(result) {
            var array = [];
	    var i; // counter
            for (i=1; i+1<result.length; i=i+2) {
              array.push(result[i]);
            }
            var matrixLike;
            var allvector = true;
            for (i=0; i<array.length; i++) {
              allvector = allvector && 
                array[i] instanceof semantics.Linalg2Vector;
            }
            if (allvector) {
              /*
               * convert vectors in array to matrixrows
               */
              var matrixRows = [];
              for (i=0; i<array.length; i++) {
                var row = new semantics.Linalg2Matrixrow();
                row.initialize.apply(row, array[i].operands);
                matrixRows.push(row);
              }
              // create a new matrix
              matrixLike = new semantics.Linalg2Matrix();
              matrixLike.initialize.apply(matrixLike, matrixRows);
            } else {
              // create a vector 
              matrixLike = new semantics.Linalg2Vector();
              matrixLike.initialize.apply(matrixLike, array);
            }
            return matrixLike;
          }
        )
      };
    });

});

    $identify("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");

$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){
  /**
   * Define a semantic tree node that represents the linalg2.matrixrow
   */
  org.mathdox.formulaeditor.semantics.Linalg2Matrixrow =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mtr><mtd>","</mtd><mtd>","</mtd></mtr>"],
        onscreen : ["[", ",", "]"],
        openmath : "<OMS cd='linalg2' name='matrixrow'/>"

      },

      precedence : 0

    });
});

    $identify("org/mathdox/formulaeditor/modules/list1/list.js");

$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.List1List =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mo>{</mo>","<mo>,</mo>","<mo>}</mo>"],
        onscreen : ["{",",","}"],
        openmath : "<OMS cd='list1' name='list'/>"

      },

      precedence : 0

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.abs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns an absolute value object based on the OpenMath node.
      */
      handleList1List : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a List1List object
        var result = new org.mathdox.formulaeditor.semantics.List1List();
        result.initialize.apply(result, operands);
        return result;

      }

    });

  /**
   * Add the parsing code for lists.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression160 = list | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("list"),
          parent.expression160).apply(this, arguments);
      },

      // abs = "{" expression "}"
      list :
        pG.transform(
          pG.concatenation(
            pG.literal("{"),
            pG.rule("expression"),
            pG.repetition(
              pG.concatenation(
                pG.literal(context.listSeparator),
                pG.rule("expression")
              )
            ),
            pG.literal("}")
          ),
          function(result) {
            var array = [];
            for (var i=1; i+1<result.length; i=i+2) {
              array.push(result[i]);
            }
            var list = new semantics.List1List();
            list.initialize.apply(list, array);
            return list;
          }
        )
      };
    });

});

  
$identify("org/mathdox/formulaeditor/modules/logic1/and.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "∧",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>∧</mo>",
    mathml_invisible : ( "" != "" ? "<mo></mo>" : null )
  };

  /**
   * Define a semantic tree node that represents logic1.and.
   */
  org.mathdox.formulaeditor.semantics.Logic1And =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='logic1' name='and'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 100

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.and.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1And : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1And();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__and"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "and", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "&&" == "∧" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression100 = and | super.expression100
      expression100 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1and"),
          parent.expression100).apply(this, arguments);
      },

      // logic1and = 
      //    expression100 "&&" expression110
      logic1and :
        pG.transform(
          pG.concatenation(
            pG.rule("expression100"),
            pG.literal("&&"),
            pG.rule("expression110"),
            pG.repetition(
              pG.concatenation(
                pG.literal("&&"),
                pG.rule("expression110")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1And();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Logic1And && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression100 = logic1and | 
      //   logic1andalt | super.expression100
      expression100 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1and"),
          parent.expression100).apply(this, arguments);
      },

      // logic1and = 
      //    expression100 "&&" expression110
      logic1and :
        pG.transform(
          pG.concatenation(
            pG.rule("expression100"),
	    pG.alternation(
	      pG.literal("&&"),
	      pG.literal("∧")
	    ),
            pG.rule("expression110"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("&&"),
	          pG.literal("∧")
	        ),
                pG.rule("expression110")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1And();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Logic1And) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/logic1/equivalent.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "⇔",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>⇔</mo>",
    mathml_invisible : ( "" != "" ? "<mo></mo>" : null )
  };

  /**
   * Define a semantic tree node that represents logic1.equivalent.
   */
  org.mathdox.formulaeditor.semantics.Logic1Equivalent =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='logic1' name='equivalent'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 70

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.equivalent.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1Equivalent : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1Equivalent();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__equivalent"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "equivalent", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<=>" == "⇔" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression70 = equivalent | super.expression70
      expression70 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1equivalent"),
          parent.expression70).apply(this, arguments);
      },

      // logic1equivalent = 
      //    expression70 "<=>" expression80
      logic1equivalent :
        pG.transform(
          pG.concatenation(
            pG.rule("expression70"),
            pG.literal("<=>"),
            pG.rule("expression80"),
            pG.repetition(
              pG.concatenation(
                pG.literal("<=>"),
                pG.rule("expression80")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Equivalent();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Logic1Equivalent && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression70 = logic1equivalent | 
      //   logic1equivalentalt | super.expression70
      expression70 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1equivalent"),
          parent.expression70).apply(this, arguments);
      },

      // logic1equivalent = 
      //    expression70 "<=>" expression80
      logic1equivalent :
        pG.transform(
          pG.concatenation(
            pG.rule("expression70"),
	    pG.alternation(
	      pG.literal("<=>"),
	      pG.literal("⇔")
	    ),
            pG.rule("expression80"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("<=>"),
	          pG.literal("⇔")
	        ),
                pG.rule("expression80")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Equivalent();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Logic1Equivalent) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/logic1/implies.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "⇒",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>⇒</mo>"
  };

  /**
   * Define a semantic tree node that represents logic1.implies.
   */
  org.mathdox.formulaeditor.semantics.Logic1Implies =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='logic1' name='implies'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 80

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.implies.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1Implies : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1Implies();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__implies"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "implies", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "=>" == "⇒" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression80 = implies | super.expression80
      expression80 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1implies"),
          parent.expression80).apply(this, arguments);
      },

      // logic1implies = 
      //    expression80 "=>" expression90
      logic1implies : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression80"),
              pG.literal("=>"),
              pG.rule("expression90")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Logic1Implies(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression80 = logic1implies | 
      //   super.expression80
      expression80 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1implies"),
          parent.expression80).apply(this, arguments);
      },

      // logic1implies = 
      //    expression80 ("=>"|"⇒") expression90
      logic1implies : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression80"),
  	    pG.alternation(
  	      pG.literal("=>"),
  	      pG.literal("⇒")
  	    ),
              pG.rule("expression90")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Logic1Implies(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/logic1/not.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var mathmlSymbol= [ "", "", ""];
  
  if ("¬" !== "") {
    mathmlSymbol[0] = "<mo>¬</mo>";
  }
  if ("" !== "") {
    mathmlSymbol[2] = "<mo></mo>";
  }

  var symbol =  {
    onscreen : ["¬","",""],
    openmath : "<OMS cd='logic1' name='not'/>",
    mathml   : mathmlSymbol
  };

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Logic1Not =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {
        onscreen : symbol.onscreen,
        openmath : symbol.openmath,
        mathml   : mathmlSymbol
      },

      precedence : 140

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary minus object based on the OpenMath node.
      */
      handleLogic1Not : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Logic1Not(operand);

      }

    });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__not"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "not", symbol, "unary");

  /**
   * Add the parsing code for unary symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  var rulesEnter = [];
  var positionEnter = 0;
  if ("!" !== "") {
    rulesEnter.push(pG.literal("!"));
    positionEnter++;
  }
  rulesEnter.push(pG.rule("expression150"));
  if ("" !== "") {
    rulesEnter.push(pG.literal(""));
  }

  if (( "!"  === "¬"  ) &&
      ( "" === "" )) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = logic1not | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("logic1not"),
            parent.expression140).apply(this, arguments);
        },

        // logic1not = "!" expression150 ""
        logic1not :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Logic1Not(result[positionEnter]);
            }
          )
      };
    });
  } else { // allow alternative as displayed on the screen
    var rulesScreen = [];
    var positionScreen = 0;
    if ("¬" !== "") {
      rulesScreen.push(pG.literal("¬"));
      positionScreen++;
    }
    rulesScreen.push(pG.rule("expression150"));
    if ("" !== "") {
      rulesScreen.push(pG.literal(""));
    }
  
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = logic1not | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("logic1not"),
            pG.rule("logic1notalt"),
            parent.expression140).apply(this, arguments);
        },

        // logic1not = "!" expression150 ""
        logic1not :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Logic1Not(result[positionEnter]);
            }
          ),

        // logic1notalt = "¬" expression150 ""
        logic1notalt :
          pG.transform(
            pG.concatenation.apply(pG, rulesScreen),
            function(result) {
              return new semantics.Logic1Not(result[positionScreen]);
            }
          )
       };
     });
   }

});

  
$identify("org/mathdox/formulaeditor/modules/logic1/or.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "∨",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>∨</mo>",
    mathml_invisible : ( "" != "" ? "<mo></mo>" : null )
  };

  /**
   * Define a semantic tree node that represents logic1.or.
   */
  org.mathdox.formulaeditor.semantics.Logic1Or =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='logic1' name='or'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 90

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.or.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1Or : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1Or();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__or"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "or", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "||" == "∨" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression90 = or | super.expression90
      expression90 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1or"),
          parent.expression90).apply(this, arguments);
      },

      // logic1or = 
      //    expression90 "||" expression100
      logic1or :
        pG.transform(
          pG.concatenation(
            pG.rule("expression90"),
            pG.literal("||"),
            pG.rule("expression100"),
            pG.repetition(
              pG.concatenation(
                pG.literal("||"),
                pG.rule("expression100")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Or();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Logic1Or && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression90 = logic1or | 
      //   logic1oralt | super.expression90
      expression90 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1or"),
          parent.expression90).apply(this, arguments);
      },

      // logic1or = 
      //    expression90 "||" expression100
      logic1or :
        pG.transform(
          pG.concatenation(
            pG.rule("expression90"),
	    pG.alternation(
	      pG.literal("||"),
	      pG.literal("∨")
	    ),
            pG.rule("expression100"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("||"),
	          pG.literal("∨")
	        ),
                pG.rule("expression100")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Or();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Logic1Or) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

    $identify("org/mathdox/formulaeditor/modules/nums1/rational.js");

$require("org/mathdox/formulaeditor/modules/arithmetic/divide.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
  * Extend the OpenMathParser object with parsing code for arith1.divide.
  */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Divide object based on the OpenMath node.
      */
      handleNums1Rational : function(node) {
	return this.handleArith1Divide(node);
      }
  });

});

  
$identify("org/mathdox/formulaeditor/modules/permutation1/left_compose.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "∘",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>∘</mo>"
  };

  /**
   * Define a semantic tree node that represents permutation1.left_compose.
   */
  org.mathdox.formulaeditor.semantics.Permutation1Left_compose =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='permutation1' name='left_compose'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 130

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for permutation1.left_compose.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handlePermutation1Left_compose : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Permutation1Left_compose();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["permutation1__left_compose"] = new org.mathdox.formulaeditor.semantics.Keyword("permutation1", "left_compose", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "∘" == "∘" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression130 = left_compose | super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("permutation1left_compose"),
          parent.expression130).apply(this, arguments);
      },

      // permutation1left_compose = 
      //    expression130 "∘" expression140
      permutation1left_compose : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression130"),
              pG.literal("∘"),
              pG.rule("expression140")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Permutation1Left_compose(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression130 = permutation1left_compose | 
      //   super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("permutation1left_compose"),
          parent.expression130).apply(this, arguments);
      },

      // permutation1left_compose = 
      //    expression130 ("∘"|"∘") expression140
      permutation1left_compose : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression130"),
  	    pG.alternation(
  	      pG.literal("∘"),
  	      pG.literal("∘")
  	    ),
              pG.rule("expression140")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Permutation1Left_compose(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

    $identify("org/mathdox/formulaeditor/modules/permutation1/permutation.js");

$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.Cycle =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mo>(</mo>","<mo>,</mo>","<mo>)</mo>"],
        onscreen : ["(",",",")"],
        openmath : "<OMS cd='permutation1' name='cycle'/>"

      },

      precedence : 0

    });

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.Permutation =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        mathml   : ["","",""],
        onscreen : ["","",""],
        openmath : "<OMS cd='permutation1' name='permutation'/>"

      },

      precedence : 0

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.abs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a cycle object based on the OpenMath node.
      */
      handlePermutation1Cycle : function(node) {
        var operands = [];
        var result;
        var i;

        for (i=1; i<node.childNodes.length; i++) {
          operands.push(this.handle(node.childNodes.item(i)));
        }
        result = new org.mathdox.formulaeditor.semantics.Cycle();
        result.initialize.apply(result, operands);

        return result;
      }, 
      
      /**
      * Returns a permutation object based on the OpenMath node.
      */
      handlePermutation1Permutation : function(node) {
        var operands = [];
        var result;
        var i;

        for (i=1; i<node.childNodes.length; i++) {
          operands.push(this.handle(node.childNodes.item(i)));
        }
        result = new org.mathdox.formulaeditor.semantics.Permutation();
        result.initialize.apply(result, operands);

        return result;

      }

    });

  /**
   * Add the parsing code for permutations.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression160 = permutation | super.expression160
        expression160 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("permutation"),
            parent.expression160).apply(this, arguments);
        },

        // permutation = "(" (omString | integer) ("," (omString | integer))+ ")"
        permutation :
          pG.transform(
            pG.repetitionplus(
              pG.concatenation(
                pG.literal("("),
                pG.alternation(
                  pG.rule("integer"),
                  pG.rule("omString")
                ),
                pG.repetitionplus(
                  pG.concatenation(
                    pG.literal(context.listSeparator),
                    pG.alternation(
                      pG.rule("integer"),
                      pG.rule("omString")
                    )
                  )
                ),
                pG.literal(")")
              )
            ),
            function(result) {
              var cycles = [];
              var entries;
              var i=0;
              var perm;
              while (i<result.length) {
                // result[i] = '('
                i++;

                entries = [];
                while (i<result.length && result[i] != ')') {
                  entries.push(result[i]);
                  i++;
                  // result[i] = ')' or ','
                  if (i<result.length && result[i] == context.listSeparator) {
                    i++;
                  }
                  // result[i] = ')' or result[i] = <entry>
                }
                // result[i] == ')' 
                i++;
                
                var cycle = new semantics.Cycle();
                cycle.initialize.apply(cycle, entries);
                cycles.push(cycle);
              }

              perm = new semantics.Permutation();
              perm.initialize.apply(perm, cycles);
              return perm;
            }
          )
        };
      });

});

    $identify("org/mathdox/formulaeditor/modules/relation1/IntervalNotation.js");

$require("org/mathdox/formulaeditor/modules/logic1/and.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { 
      return {
	infix_Update: function(expr) {
	  var parent = arguments.callee.parent;
          var semantics = org.mathdox.formulaeditor.semantics;
          var result;
          var arg1, arg2;

          if ((expr instanceof semantics.Relation1Lt || expr instanceof semantics.Relation1Leq) &&
              (expr.operands[0] instanceof semantics.Relation1Lt || expr.operands[0] instanceof semantics.Relation1Leq)) {
            arg1 = expr.operands[0];
            console.log("1<x<2");

            if (expr instanceof semantics.Relation1Lt) {
              arg2 = new semantics.Relation1Lt(arg1.operands[1], expr.operands[1]);
            } else { //Leq
              arg2 = new semantics.Relation1Leq(arg1.operands[1], expr.operands[1]);
            }

            result = new semantics.Logic1And(arg1, arg2);
          } else if ((expr instanceof semantics.Relation1Gt || expr instanceof semantics.Relation1Geq) &&
              (expr.operands[0] instanceof semantics.Relation1Gt || expr.operands[0] instanceof semantics.Relation1Geq)) {
            arg1 = expr.operands[0];
            console.log("1>x>2");

            if (expr instanceof semantics.Relation1Gt) {
              arg2 = new semantics.Relation1Gt(arg1.operands[1], expr.operands[1]);
            } else { //Geq
              arg2 = new semantics.Relation1Geq(arg1.operands[1], expr.operands[1]);
            }

            result = new semantics.Logic1And(arg1, arg2);
          } else { // change nothing
            result = expr;
          }

          return parent.infix_Update(result);
	}
      };
    }
  );
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/approx.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≈",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≈</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.approx.
   */
  org.mathdox.formulaeditor.semantics.Relation1Approx =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='approx'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.approx.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Approx : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Approx();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__approx"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "approx", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "~~" == "≈" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = approx | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1approx"),
          parent.expression110).apply(this, arguments);
      },

      // relation1approx = 
      //    expression110 "~~" expression120
      relation1approx : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("~~"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Approx(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1approx | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1approx"),
          parent.expression110).apply(this, arguments);
      },

      // relation1approx = 
      //    expression110 ("~~"|"≈") expression120
      relation1approx : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("~~"),
  	      pG.literal("≈")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Approx(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/eq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen : "=",
    openmath : null, // use default with cd and name from model
    mathml   : "<mo>=</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.eq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Eq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='eq'/>",
        mathml   : symbol.mathml

      },

      precedence : 110

    });
 
  /**
   * Define a semantic tree node that represents relation2.eqs.
   */
  org.mathdox.formulaeditor.semantics.Relation2Eqs =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation2' name='eqs'/>",
        mathml   : symbol.mathml

      },

      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for 
   * relation1.eq and relation2.eqs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Eq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Eq();
      result.initialize.apply(result, operands);
      return result;

    },
    handleRelation2Eqs : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation2Eqs();
      result.initialize.apply(result, operands);
      return result;

    }


  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__eq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "eq", symbol, "infix");
  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation2__eqs"] = new org.mathdox.formulaeditor.semantics.Keyword("relation2", "eqs", symbol, "infix");

  /**
   * Add the parsing code for an infix-different symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "=" == "=" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression110 = relation1eqrelation2eqs | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1eqrelation2eqs"),
          parent.expression110).apply(this, arguments);
      },

      // relation1eqrelation2eqs = 
      //    expression110 "=" expression120
      relation1eqrelation2eqs :
        pG.transform(
          pG.concatenation(
            pG.rule("expression110"),
            pG.literal("="),
            pG.rule("expression120"),
            pG.repetition(
              pG.concatenation(
                pG.literal("="),
                pG.rule("expression120")
              )
            )
          ),
          function(result) {
	    var retval;
            var operands = [];
            var i;

            if ((result[0] instanceof semantics.Relation1Eq) ||
                (result[0] instanceof semantics.Relation1Eq)) {

              retval = new semantics.Relation2Eqs();
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
              retval = new semantics.Relation1Eq();
	      operands.push(result[0]);
            }

            for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression110 = relation1eqrelation2eqs | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1eqrelation2eqs"),
          parent.expression110).apply(this, arguments);
      },

      // relation1eqrelation2eqs = 
      //    expression110 "=" expression120
      relation1eqrelation2eqs :
        pG.transform(
          pG.concatenation(
            pG.rule("expression110"),
	    pG.alternation(
	      pG.literal("="),
	      pG.literal("=")
	    ),
            pG.rule("expression120"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("="),
	          pG.literal("=")
	        ),
                pG.rule("expression120")
              )
            )
          ),
          function(result) {
            var retval;
	    if (result.length < 3){
              retval = new semantics.Relation1Eq();
	    } else {
              retval = new semantics.Relation2Eqs();
	    }
            var operands = [];
            var i;

            for (i=0; 2*i<result.length; i++) {
              operands[i] = result[2*i];
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/geq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≥",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≥</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.geq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Geq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='geq'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.geq.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Geq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Geq();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__geq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "geq", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( ">=" == "≥" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = geq | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1geq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1geq = 
      //    expression110 ">=" expression120
      relation1geq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal(">="),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Geq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1geq | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1geq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1geq = 
      //    expression110 (">="|"≥") expression120
      relation1geq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal(">="),
  	      pG.literal("≥")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Geq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/gt.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : ">",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>&gt;</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.gt.
   */
  org.mathdox.formulaeditor.semantics.Relation1Gt =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='gt'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.gt.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Gt : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Gt();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__gt"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "gt", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( ">" == ">" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = gt | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1gt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1gt = 
      //    expression110 ">" expression120
      relation1gt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal(">"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Gt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1gt | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1gt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1gt = 
      //    expression110 (">"|">") expression120
      relation1gt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal(">"),
  	      pG.literal(">")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Gt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/leq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≤",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≤</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.leq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Leq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='leq'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.leq.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Leq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Leq();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__leq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "leq", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<=" == "≤" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = leq | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1leq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1leq = 
      //    expression110 "<=" expression120
      relation1leq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("<="),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Leq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1leq | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1leq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1leq = 
      //    expression110 ("<="|"≤") expression120
      relation1leq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("<="),
  	      pG.literal("≤")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Leq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/lt.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "<",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>&lt;</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.lt.
   */
  org.mathdox.formulaeditor.semantics.Relation1Lt =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='lt'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.lt.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Lt : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Lt();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__lt"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "lt", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<" == "<" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = lt | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1lt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1lt = 
      //    expression110 "<" expression120
      relation1lt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("<"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Lt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1lt | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1lt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1lt = 
      //    expression110 ("<"|"<") expression120
      relation1lt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("<"),
  	      pG.literal("<")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Lt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/neq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≠",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≠</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.neq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Neq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='neq'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.neq.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Neq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Neq();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__neq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "neq", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<>" == "≠" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = neq | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1neq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1neq = 
      //    expression110 "<>" expression120
      relation1neq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("<>"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Neq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1neq | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1neq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1neq = 
      //    expression110 ("<>"|"≠") expression120
      relation1neq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("<>"),
  	      pG.literal("≠")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Neq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/set1/in.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "∈",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>∈</mo>"
  };

  /**
   * Define a semantic tree node that represents set1.in.
   */
  org.mathdox.formulaeditor.semantics.Set1In =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='set1' name='in'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for set1.in.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleSet1In : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Set1In();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["set1__in"] = new org.mathdox.formulaeditor.semantics.Keyword("set1", "in", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "∈" == "∈" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = in | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("set1in"),
          parent.expression110).apply(this, arguments);
      },

      // set1in = 
      //    expression110 "∈" expression120
      set1in : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("∈"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Set1In(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = set1in | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("set1in"),
          parent.expression110).apply(this, arguments);
      },

      // set1in = 
      //    expression110 ("∈"|"∈") expression120
      set1in : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("∈"),
  	      pG.literal("∈")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Set1In(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/variables.js");

$require("org/mathdox/formulaeditor/semantics/Variable.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/VariableList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");
$require("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  var semantics = org.mathdox.formulaeditor.semantics;
  var name;
  var symbol;
  var newvars = [];
  var regex = /^[A-Za-z]*$/;

  var hasOnlyLetters = function(s) {
    return regex.test(s);
  };

  
  /**
   * Define the alpha variable.
   */
  name = "alpha";
  symbol = { 
    onscreen: "α", 
    mathml : "<mi>α</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["alpha"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["α"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["alpha"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("α") ) {
    newvars.push( "α" );
  }
  
  /**
   * Define the beta variable.
   */
  name = "beta";
  symbol = { 
    onscreen: "β", 
    mathml : "<mi>β</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["beta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["β"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["beta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("β") ) {
    newvars.push( "β" );
  }
  
  /**
   * Define the gamma variable.
   */
  name = "gamma";
  symbol = { 
    onscreen: "γ", 
    mathml : "<mi>γ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["gamma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["γ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["gamma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("γ") ) {
    newvars.push( "γ" );
  }
  
  /**
   * Define the delta variable.
   */
  name = "delta";
  symbol = { 
    onscreen: "δ", 
    mathml : "<mi>δ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["delta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["δ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["delta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("δ") ) {
    newvars.push( "δ" );
  }
  
  /**
   * Define the epsilon variable.
   */
  name = "epsilon";
  symbol = { 
    onscreen: "ϵ", 
    mathml : "<mi>ϵ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["epsilon"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϵ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["epsilon"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϵ") ) {
    newvars.push( "ϵ" );
  }
  
  /**
   * Define the varepsilon variable.
   */
  name = "varepsilon";
  symbol = { 
    onscreen: "φ", 
    mathml : "<mi>φ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varepsilon"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["φ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varepsilon"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("φ") ) {
    newvars.push( "φ" );
  }
  
  /**
   * Define the zeta variable.
   */
  name = "zeta";
  symbol = { 
    onscreen: "ζ", 
    mathml : "<mi>ζ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["zeta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ζ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["zeta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ζ") ) {
    newvars.push( "ζ" );
  }
  
  /**
   * Define the eta variable.
   */
  name = "eta";
  symbol = { 
    onscreen: "η", 
    mathml : "<mi>η</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["eta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["η"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["eta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("η") ) {
    newvars.push( "η" );
  }
  
  /**
   * Define the theta variable.
   */
  name = "theta";
  symbol = { 
    onscreen: "θ", 
    mathml : "<mi>θ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["theta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["θ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["theta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("θ") ) {
    newvars.push( "θ" );
  }
  
  /**
   * Define the vartheta variable.
   */
  name = "vartheta";
  symbol = { 
    onscreen: "ϑ", 
    mathml : "<mi>ϑ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["vartheta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϑ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["vartheta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϑ") ) {
    newvars.push( "ϑ" );
  }
  
  /**
   * Define the kappa variable.
   */
  name = "kappa";
  symbol = { 
    onscreen: "κ", 
    mathml : "<mi>κ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["kappa"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["κ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["kappa"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("κ") ) {
    newvars.push( "κ" );
  }
  
  /**
   * Define the mu variable.
   */
  name = "mu";
  symbol = { 
    onscreen: "μ", 
    mathml : "<mi>μ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["mu"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["μ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["mu"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("μ") ) {
    newvars.push( "μ" );
  }
  
  /**
   * Define the nu variable.
   */
  name = "nu";
  symbol = { 
    onscreen: "ν", 
    mathml : "<mi>ν</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["nu"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ν"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["nu"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ν") ) {
    newvars.push( "ν" );
  }
  
  /**
   * Define the xi variable.
   */
  name = "xi";
  symbol = { 
    onscreen: "ξ", 
    mathml : "<mi>ξ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["xi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ξ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["xi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ξ") ) {
    newvars.push( "ξ" );
  }
  
  /**
   * Define the varpi variable.
   */
  name = "varpi";
  symbol = { 
    onscreen: "ϖ", 
    mathml : "<mi>ϖ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varpi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϖ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varpi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϖ") ) {
    newvars.push( "ϖ" );
  }
  
  /**
   * Define the rho variable.
   */
  name = "rho";
  symbol = { 
    onscreen: "ρ", 
    mathml : "<mi>ρ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["rho"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ρ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["rho"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ρ") ) {
    newvars.push( "ρ" );
  }
  
  /**
   * Define the varrho variable.
   */
  name = "varrho";
  symbol = { 
    onscreen: "ϱ", 
    mathml : "<mi>ϱ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varrho"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϱ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varrho"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϱ") ) {
    newvars.push( "ϱ" );
  }
  
  /**
   * Define the sigma variable.
   */
  name = "sigma";
  symbol = { 
    onscreen: "σ", 
    mathml : "<mi>σ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["sigma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["σ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["sigma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("σ") ) {
    newvars.push( "σ" );
  }
  
  /**
   * Define the varsigma variable.
   */
  name = "varsigma";
  symbol = { 
    onscreen: "ς", 
    mathml : "<mi>ς</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varsigma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ς"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varsigma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ς") ) {
    newvars.push( "ς" );
  }
  
  /**
   * Define the tau variable.
   */
  name = "tau";
  symbol = { 
    onscreen: "τ", 
    mathml : "<mi>τ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["tau"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["τ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["tau"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("τ") ) {
    newvars.push( "τ" );
  }
  
  /**
   * Define the upsilon variable.
   */
  name = "upsilon";
  symbol = { 
    onscreen: "υ", 
    mathml : "<mi>υ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["upsilon"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["υ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["upsilon"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("υ") ) {
    newvars.push( "υ" );
  }
  
  /**
   * Define the phi variable.
   */
  name = "phi";
  symbol = { 
    onscreen: "ϕ", 
    mathml : "<mi>ϕ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["phi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϕ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["phi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϕ") ) {
    newvars.push( "ϕ" );
  }
  
  /**
   * Define the varphi variable.
   */
  name = "varphi";
  symbol = { 
    onscreen: "φ", 
    mathml : "<mi>φ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varphi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["φ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varphi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("φ") ) {
    newvars.push( "φ" );
  }
  
  /**
   * Define the chi variable.
   */
  name = "chi";
  symbol = { 
    onscreen: "χ", 
    mathml : "<mi>χ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["chi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["χ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["chi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("χ") ) {
    newvars.push( "χ" );
  }
  
  /**
   * Define the psi variable.
   */
  name = "psi";
  symbol = { 
    onscreen: "ψ", 
    mathml : "<mi>ψ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["psi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ψ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["psi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ψ") ) {
    newvars.push( "ψ" );
  }
  
  /**
   * Define the omega variable.
   */
  name = "omega";
  symbol = { 
    onscreen: "ω", 
    mathml : "<mi>ω</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["omega"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ω"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["omega"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ω") ) {
    newvars.push( "ω" );
  }
  
  /**
   * Define the Gamma variable.
   */
  name = "Gamma";
  symbol = { 
    onscreen: "Γ", 
    mathml : "<mi>Γ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Gamma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Γ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Gamma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Γ") ) {
    newvars.push( "Γ" );
  }
  
  /**
   * Define the Delta variable.
   */
  name = "Delta";
  symbol = { 
    onscreen: "Δ", 
    mathml : "<mi>Δ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Delta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Δ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Delta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Δ") ) {
    newvars.push( "Δ" );
  }
  
  /**
   * Define the Theta variable.
   */
  name = "Theta";
  symbol = { 
    onscreen: "Θ", 
    mathml : "<mi>Θ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Theta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Θ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Theta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Θ") ) {
    newvars.push( "Θ" );
  }
  
  /**
   * Define the Lamda variable.
   */
  name = "Lamda";
  symbol = { 
    onscreen: "Λ", 
    mathml : "<mi>Λ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Lamda"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Λ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Lamda"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Λ") ) {
    newvars.push( "Λ" );
  }
  
  /**
   * Define the Xi variable.
   */
  name = "Xi";
  symbol = { 
    onscreen: "Ξ", 
    mathml : "<mi>Ξ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Xi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Ξ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Xi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Ξ") ) {
    newvars.push( "Ξ" );
  }
  
  /**
   * Define the Phi variable.
   */
  name = "Phi";
  symbol = { 
    onscreen: "Φ", 
    mathml : "<mi>Φ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Phi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Φ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Phi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Φ") ) {
    newvars.push( "Φ" );
  }
  
  /**
   * Define the Psi variable.
   */
  name = "Psi";
  symbol = { 
    onscreen: "Ψ", 
    mathml : "<mi>Ψ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Psi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Ψ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Psi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Ψ") ) {
    newvars.push( "Ψ" );
  }
  
  /**
   * Define the Omega variable.
   */
  name = "Omega";
  symbol = { 
    onscreen: "Ω", 
    mathml : "<mi>Ω</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Omega"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Ω"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Omega"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Ω") ) {
    newvars.push( "Ω" );
  }
  
  var pG = new org.mathdox.parsing.ParserGenerator();
  if(newvars.length > 0) {
    var args = [];
    for (var i=0;i < newvars.length; i++) {
      args.push(pG.literal(newvars[i]));
    }
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {
        variable : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.alternation.apply(this, args),
              function(result) {
                var result_joined = result.join("");

                // this should be in the keywordlist
                return org.mathdox.formulaeditor.parsing.expression.VariableList[result_joined];
              }
            ),
            parent.variable).apply(this, arguments);
        }
      };
    });
  }
});

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$require("org/mathdox/parsing/Parser.js");
$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");

$main(function() {

    var ParsingParser = org.mathdox.parsing.Parser;
    var functions = new Array();

    var cachedContext = null;

    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser =
      $extend(Object, {
        getParser : function(context) {
          var i;

          if (context === null || context === undefined) {
	    context = this.getContext();
	  }

	  if (context.parser === undefined) {

            var parser = ParsingParser;

            for (i=0;i<functions.length;i++) {
              parser = $extend(parser, functions[i](context));
            }

	    context.parser = parser;
	  }

	  return context.parser;
        }
      });

    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction = function(fun) {
      functions.push(fun);
    };
    
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.clearCache = function() {
      cachedContext = null;
    }

    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.getContext = function() {
      if (cachedContext === null) {

        var Options = new org.mathdox.formulaeditor.Options();

        /* set context options based on options */
	/* XXX move this to options.getCachedContext() */

	cachedContext = Options.getExpressionParsingContext();
      }

      return cachedContext;
    };

    /* initialize with ExpressionParser rules */
    var ExpressionParser = new org.mathdox.formulaeditor.parsing.expression.ExpressionParser();

    functions.push(ExpressionParser.getRules);
}

);

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");

$require("org/mathdox/parsing/Parser.js");
$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/presentation/Subscript.js");
$require("org/mathdox/formulaeditor/semantics/FunctionApplication.js");
$require("org/mathdox/formulaeditor/semantics/Integer.js");
$require("org/mathdox/formulaeditor/semantics/SemanticFloat.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");

$main(function() {

  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionParser =
    $extend(Object, { getRules: function(context) { 
      var func_subCheck = function(oper) {
        return false;
      };
      
      var func_subUpdate = function(oper) {
        return oper;
      };

      // expression160 = braces | integer | variable
      var expression160 = pG.alternation(
        pG.rule("braces"),
        pG.rule("parseNumber"),
        pG.rule("func"),
        pG.rule("func_sub"),
        pG.rule("variable"),
        pG.rule("omSymbol"),
        pG.rule("omString")
      );

      if (context.styleTransc1Log === "postfix") {
        func_subCheck = function(operInput) {
         
          var oper;

          oper = operInput;
          // oper should be a function application
          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          oper = oper.symbol;

          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          // symbol should be a keyword
          if (!( oper.symbol instanceof semantics.Keyword)) {
            return false;
          }  
          
          if (oper.symbol.cd == "transc1" && oper.symbol.name == "log" ) {
            return true;
          }
          
          return false;
        };
        func_subUpdate = function(oper) {
          if (func_subCheck(oper)) {
            var symbol = oper.symbol.symbol;

            // use the operands from the subscript before the others
            var arr = oper.symbol.operands.concat(oper.operands);

            // and return the "flattened" function
            return new semantics.FunctionApplication(symbol, arr, "firstsub");
          } else {
            return oper;
          }
        };
      } else if (context.styleTransc1Log === "sangwin") {
        func_subCheck = function(operInput) {
         
          var oper;

          oper = operInput;
          // oper should be a function application
          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          oper = oper.symbol;

          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          // symbol should be a keyword
          if (!( oper.symbol instanceof semantics.Keyword)) {
            return false;
          }  
          
          if (oper.symbol.cd == "transc1" && oper.symbol.name == "log" ) {
            return true;
          }
          
          return false;
        };
        func_subUpdate = function(oper) {
          if (func_subCheck(oper)) {
            var symbol = oper.symbol.symbol;

            // use the operands from the subscript before the others
            var arr = oper.symbol.operands.concat(oper.operands);

            // and return the "flattened" function
            return new semantics.FunctionApplication(symbol, arr, "firstsub");
          } else {
            return oper;
          }
        };
 	
      }

      var rule_func_super;
      var rule_expression160;

      if (context.styleTransc1Log === "prefix") {
	rule_expression160 = pG.alternation(
          pG.rule("braces"),
          pG.rule("parseNumber"),
          pG.rule("func"),
          pG.rule("func_sub"),
          pG.rule("func_super"),
          pG.rule("variable"),
          pG.rule("omSymbol"),
          pG.rule("omString")
        );

	rule_func_super = 
          pG.transform(
            pG.concatenation(
	      pG.rule("superscript"),
              pG.alternation(
                pG.rule("variable"),
                pG.rule("omSymbol")
              ),
              pG.literal('('),
              pG.rule("expression"),
              pG.repetition(
                pG.concatenation(
                  pG.literal(context.listSeparator),
                  pG.rule("expression")
                )
              ),
              pG.literal(')')
	    ),
          function(result) {
            var array = [];
            var i,j; // counters
            var semantics = org.mathdox.formulaeditor.semantics;
           
	    array.push(result[0]);
	    var oper = result[1];
            var str;

	    // 2 : literal '('
            i=3;
            while (i < result.length) {
              array.push(result[i]);

              i=i+2;
            }
            return new semantics.FunctionApplication(oper, array);
          }
	);
      } else {
	rule_expression160 = pG.alternation(
          pG.rule("braces"),
          pG.rule("parseNumber"),
          pG.rule("func"),
          pG.rule("func_sub"),
          pG.rule("variable"),
          pG.rule("omSymbol"),
          pG.rule("omString")
        );
        rule_func_super = pG.never;
      }

      return {
        // TODO make this list alphabetical

        // start = expression
        start : pG.rule("expression"),

        // expression = expression70
        expression  : pG.rule("expression70"), 

        // expression70 = expression80
        expression70 : pG.rule("expression80"), // equivalence, ...

        // expression80 = expression90
        expression80 : pG.rule("expression90"), // implies, ...

        // expression90 = expression100
        expression90 : pG.rule("expression100"), // or, ...

        // expression100 = expression110
        expression100 : pG.rule("expression110"), // and, ...

        // expression110 = expression120
        expression110 : pG.rule("expression120"), // equals, lessthan,
                                                  // morethan, ...

        // expression120 = expression130
        expression120 : pG.rule("expression130"), // plus, minus 
        					  // forall

        // expression130 = expression140
        expression130 : pG.rule("expression140"), // times

        // expression140 = expression150
        expression140 : pG.rule("expression150"), // unary minus

        // expression150 = expression160
        expression150 : pG.rule("expression160"), // power

        // expression160 = braces | integer | variable
        expression160 : rule_expression160, // use version defined above

        // restrictedexpression160 = braces | variable | func
        // no number allowed, for silent multiplication
        restrictedexpression160 :
          pG.alternation(
            pG.rule("braces"),
            pG.rule("func"),
            pG.rule("func_sub"),
            pG.rule("variable"),
            pG.rule("omSymbol")
          ),

        biginteger : pG.never,

        // integer = [0..9]+
        integer :
          pG.transform(
            pG.repetitionplus(
              pG.range('0','9')
            ),
            function(result) {
              var numstr = result.join("");

              // remove starting 0s
              pos = 0;
              while (pos < numstr.length && numstr.charAt(pos) == '0') {
                pos++;
              }
              if (pos > 0) {
                if (pos == numstr.length) {
                  numstr = "0";
                } else {
                  numstr = numstr.substr(pos);
                }
              }

	      if (numstr.length <= 10) {
                return new semantics.Integer(Number(result.join("")));
              } else {
                return new semantics.Integer( {
                    value : numstr,
                    rule : "bigint"
                  }
                );
	      }
            }
          ),

        // float = [0..9]+ ++ context.decimalMark ++ [0-9]*
        parseFloat :
          pG.transform(
            pG.concatenation( 
              pG.repetitionplus(
                pG.range('0','9')
              ),
              pG.literal(context.decimalMark),
              pG.repetitionplus(
                pG.range('0','9')
              )
            ),
            function(result) {
              // replace decimalMark by a period
              var res=[];
	      var i;
              for (i=0; i<result.length; i++) {
		if (result[i] instanceof Object) {
                  res.push(result[i].value);
		} else {
                  res.push(result[i]);
		}
              }

              var string = res.join("");
              res=[];

              for (i=0; i<string.length; i++) {
		if (string.charAt(i)>='0' && string.charAt(i)<='9' ) {
                  res.push(string.charAt(i));
		} else {
                  res.push('.');
		}
              }

              return new semantics.SemanticFloat(res.join(""));
            }
          ),

        // number: float | integer
        parseNumber :
          pG.alternation(
            pG.rule("parseFloat"),
            pG.rule("biginteger"),
            pG.rule("integer")
          ),

        // variable = ([a..z]|[A..Z]) ([a..z]|[A..Z]|[0..9])*
        variable :
          pG.transform(
            pG.concatenation(
              pG.alternation(
                pG.range('a','z'),
                pG.range('A','Z')
              ),
              pG.repetition(
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9')
                )
              )
            ),
            function(result) {
              // store result.join(""); in a variable since it is used twice
              var result_joined=result.join("");

              if (org.mathdox.formulaeditor.parsing.expression.KeywordList[
                      result_joined] === undefined ||
                  org.mathdox.formulaeditor.parsing.expression.KeywordList[
                      result_joined] === null) {
                // not in the list of variables that are symbols
                return new semantics.Variable(result_joined);
              } else {
                // in the list of symbols, return the corresponding object
                // instead
                // TODO: check if we need to update the presentation tree
                return org.mathdox.formulaeditor.parsing.expression.KeywordList[result_joined];
              }
            }
          ),
        // omString = "([a..z]|[A..Z]|[0..9]|' _.-')*"
        // TODO: maybe add more symbols
        omString:
          pG.transform(
            pG.concatenation(
              pG.literal('"'),
              pG.repetitionplus( 
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9'),
                  pG.literal(' '),
                  pG.literal('_'),
                  pG.literal('.'),
                  pG.literal('-')
                )
              ),
              pG.literal('"')
            ),
            function(result) {
              return new semantics.SString(result.slice(1,result.length-1).join(""));
            }
          ),
        
        // omSymbol = ([a..z]|[A..Z]) ([a..z]|[A..Z]|[0..9]|'_')* '.' ([a..z]|[A..Z])([a..z]|[A..Z]|[0..9]|_)*
        omSymbol:
          pG.transform(
            pG.concatenation(
              pG.alternation(
                pG.range('a','z'),
                pG.range('A','Z')
              ),
              pG.repetition(
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9'),
                  pG.literal('_')
                )
              ),
              pG.literal('.'),
              pG.alternation(
                pG.range('a','z'),
                pG.range('A','Z')
              ),
              pG.repetition(
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9'),
                  pG.literal('_')
                )
              )
            ),

            /* 
             * XXX: hard to check whether something is a constant or a function
             */
            function(result) {
              var symbolinfo = result.join("").split('.');
              var cd=symbolinfo[0];
              var name=symbolinfo[1];

              var symbol = {
                onscreen: null,
                openmath: null,
                mathml: "&lt;mi&gt;"+cd+"."+name+"&lt;/mi&gt;"
              };
              return new semantics.Keyword(cd,name,symbol,"constant");
            }
          ),

        // braces = '(' expression ')'
        braces :
          pG.transform(
            pG.concatenation(
              pG.literal('('),
              pG.rule("expression"),
              pG.literal(')')
            ),
            function(result) {
              result[1].inside_braces = true;
              return result[1];
            }
          ),

        separatedArguments :
          pG.transform(
            pG.concatenation(
              pG.rule("expression"),
              pG.repetitionplus(
                pG.concatenation(
                  pG.literal(context.listSeparator),
                  pG.rule("expression")
                )
              )
            ),
            function(result) {
              var array = [];
              var i;
              for (i=0;i<result.length;i+=2) {
                array.push(result[i]);
              }
              return array;
            }
          ),
        // NOTE: produces an object for the first rule and an array for the second
        // for use with presentation/Bracketed.js parsing
	functionArguments : 
	  pG.alternation(
            pG.rule("expression"),
            pG.rule("separatedArguments")
          ),
        bracesWithSeparatedArguments :
	  pG.transform(
	    pG.concatenation(
              pG.literal('('),
	      pG.rule("separatedArguments"),
              pG.literal(')')
            ),
            function (result) {
              return result[1];
            }
          ),

        // function = variable '(' expr ( ',' expr ) * ')'
        func : function() {
	  var obj = this;

          pG.transform(
            pG.concatenation(
              pG.rule("func_symbol"),
              pG.repetitionplus(
		pG.alternation(
                  pG.rule("braces"),
                  pG.rule("bracesWithSeparatedArguments")
                )
              )
            ),
            function(result) {
              var array;
              var i; 
              
              var oper = result[0];
              
              for (i=1; i<result.length; i++) {
                if (result[i] instanceof Array) {
                  array = result[i];
                } else {
                  array = [];
                  array.push(result[i]);
                }

                if (oper.parseResultFun !== undefined) {
                  // special case: result function in operation
                  oper = oper.parseResultFun(oper, array);
                } else {
                  oper = new org.mathdox.formulaeditor.semantics.FunctionApplication(oper, array);
                }
              }

              // check for log_2(x) updates
              oper = obj.func_Update(oper);
              return oper;
            }
          ).apply(this, arguments);
	  },
        func_symbol: pG.alternation(
            pG.rule("variable"),
            pG.rule("omSymbol"),
            pG.rule("braces"),
            pG.rule("func_sub")
          ),
        func_sub:
          pG.transform(
            pG.concatenation(
              pG.alternation(
                pG.rule("variable"),
                pG.rule("omSymbol"),
                pG.rule("braces")
              ),
              pG.repetitionplus(
                pG.alternation(
                  pG.concatenation(
                    pG.literal('_'),
                    pG.alternation(
                      pG.rule("variable"),
                      pG.rule("omSymbol"),
                      pG.rule("integer"),
                      pG.concatenation(
                        pG.literal('{'),
                        pG.rule("expression"),
                        //repetition(
                        //  concatenation(
                        //    literal(","),
                        //    rule("expression")
                        //  )
                        //),
                        pG.literal('}')
                      )
                    )
                  ),
                  pG.rule("subscript")
                )
              )
            ),
            function(result) {
              var array;
              var i,j; // counters
              var semantics = org.mathdox.formulaeditor.semantics;
              
              var oper = result[0];
              var str;

              i=1;
              while (i < result.length) {
                // current position == '_' (or subscript)
                if (result[i]== "_") {
                  // current position == '_'
                  i++;
                }

                if (i<result.length && result[i] != '{') {
                  // simple argument
                  oper = new semantics.FunctionApplication(oper, [result[i]], 
                    "sub");
                  i++;
                  // current position == '_', subscript or end
                } else {
                  i++;
                  // current position: first argument
                  array = [];
                  // current position should be an argument
                  while (i<result.length && result[i] != '}') {
                    // function argument
                    array.push(result[i]);
                    i++;

                    if (i<result.length && result[i]==',') {
                      // comma -> skip
                      i++;
                    }
                  }
                  // current position should be '}'
                  oper = new semantics.FunctionApplication(oper, array, "sub");

                  i++;
                  // current position == '_', subscript or end
                }
              }

              return oper;
            }
          ),
        func_super: rule_func_super,
	func_Update: func_subUpdate,
	// update function for infix expression
	infix_Update : function(expr) {
	  return expr;
	},
          // subscript : rule only occurs from presentation
        subscript: pG.never,
          // superscript : rule only occurs from presentation
	superscript: pG.never
        };
      }

    });

  }

);

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.expression.KeywordList = {};
});

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/VariableList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.expression.VariableList = {};
});

  $package("org.mathdox.formulaeditor.parsing.mathml");

$identify("org/mathdox/formulaeditor/parsing/mathml/MathMLParser.js");

// NOTE: expression is on purpose, there is no keyword/variable list for mathml parsing yet
$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/expression/VariableList.js");
$require("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");
$require("org/mathdox/formulaeditor/presentation/Root.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

$main(function(){

  org.mathdox.formulaeditor.parsing.mathml.MathMLParser = 
      $extend(org.mathdox.formulaeditor.parsing.xml.XMLParser, {
    
    name: "MathMLParser",

    /* main handle function */
    handlemath: function(node, context) {
      return this.handlemrow(node, context);
    },

    /** 
     * artificial handle functions, not called by tags, 
     * but as helper functions 
     */
    handleTextNode: function(node, context, style) {
      // TODO:
      // - create symbols here
      // - ignore some symbols
      // - what to do with symbols that can't be shown
      var presentation = org.mathdox.formulaeditor.presentation;

      // use ""+... to force casting to string
      var value = ""+node.firstChild.nodeValue;

      var row;

      var arr = [];
      var i;

      for (i=0; i<value.length; i++) {
        var ch = value.charAt(i);
	if (org.mathdox.formulaeditor.presentation.SymbolAliases[ch] !== null) {
          if (style === null || style === undefined) {
	    arr.push(new presentation.Symbol(ch));
          } else {
	    arr.push(new presentation.Symbol(ch, style));
	  }
	}
      }
      row = new presentation.Row();
      row.initialize.apply(row, arr);

      return row;
    },

    /* 1 attribute is expected, if more are present an mrow is inferred, handle it as such.*/
    handleInferredMrow: function(node, context) {
      var children = node.childNodes;

      if (children.length != 1) {
        return this.handlemrow(node, context);
      } else {
        return this.handle(children.item(0));
      }
    },

    /** 
     * order based on mathml specs, in groups: token elements, general layout
     * schemata, script and limit schemata, tabular math, elementary math, enlivening expressions
     */
    /* 3.2 token elements */
    /* token math:mi */
    handlemi: function(node, context) {
      // TODO: check for layout information
      var result;
      var value = ""+node.firstChild.nodeValue;
      var parsing = org.mathdox.formulaeditor.parsing;
      var options = new org.mathdox.formulaeditor.Options();
      var presentation = org.mathdox.formulaeditor.presentation;

      if (parsing.expression.KeywordList[value] !== undefined) {
        result = new presentation.Row(
            parsing.expression.KeywordList[value].getPresentation(options.getPresentationContext()));
      } else if (parsing.expression.VariableList[value] !== undefined) {
        result = new presentation.Row(
	    parsing.expression.VariableList[value].getPresentation(options.getPresentationContext()));
      } else {
        result = this.handleTextNode(node, context, "math");
      }

      return result;
    },
    /* token math:mn */
    handlemn: function(node, context) {
      return this.handleTextNode(node, context);
    },
    /* token math:mo */
    handlemo: function(node, context) {
      return this.handleTextNode(node, context);
    },

    /* token math:ms */
    handlems: function(node, context) {
      var presentation = org.mathdox.formulaeditor.presentation;
      return new presentation.Row(new presentation.Symbol("\""), this.handleTextNode(node, context), 
	new presentation.Symbol("\""));
    },

    /* token math:mspace */
    handlemspace: function(node, context) {
      return null;
    },
    /* token math:mtext */
    handlemtext: function(node, context) {
      return this.handleTextNode(node, context);
    },
    /** 
     * general layout schemata
     *
     * supported elements:
     * mrow, mfrac, msqrt, mroot, mstyle(*), merror(*), mpadded(*),
     * mphantom(**), mfenced, menclose(*)
     *
     * notes: 
     *  * treated as mrow
     *  ** returns null
     */

    /* general layout : math:mrow */
    handlemrow: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        if (child !== null) { 
          // ignore comments
          entries.push(child);
        }
      }

      var row = new presentation.Row();
      row.initialize.apply(row, entries);
      return row;
    },

    /* general layout : math:mfrac */
    handlemfrac: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Fraction(entries[0], entries[1]);
    },    

    /* general layout : math:sqrt */
    handlemsqrt: function(node, context) {
      var presentation = org.mathdox.formulaeditor.presentation;
      
      var index = this.handleInferredMrow(node, context);
      var base = new presentation.Row("2");

      return new presentation.Row(new presentation.Root(index, base));
    },

    /* general layout : math:mroot */
    handlemroot: function(node, context) {
      var children = node.childNodes;

      var base = this.handle(children.item(0), context);
      var index = this.handle(children.item(1), context);

      var presentation = org.mathdox.formulaeditor.presentation;

      return new presentation.Root(index, base);
    },

    /*
     * general layout : math:mstyle 
     * currently : ignore, treat as row
     */
    handlemstyle: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:merror 
     * currently : ignore, treat as row
     */
    handlemerror: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:mpadded 
     * currently : ignore, treat as row
     */
    handlempadded: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:mphantom 
     * currently : return null
     */
    handlempadded: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:mphantom 
     */
    handlemfenced: function(node, context) {
      var opensymbol = node.getAttribute("open");
      var closesymbol = node.getAttribute("close");
      var separators = node.getAttribute("separators");
      var children = node.childNodes;

      var presentation = org.mathdox.formulaeditor.presentation;
      var entries = [];
      var i;

      if (opensymbol === null || opensymbol === undefined) {
	opensymbol = '(';
      } 
      entries.push(new presentation.Symbol(opensymbol));
      
      var separr;
      if (separators === null || separators === undefined) {
	separators = ',';
	separr = [ separators ];
      } else {
	separr = separators.split("\\s+");
	// check for empty parts
	if (separr[0] === "") {
	  // remove first element
	  separr = separr.slice(1);
	}

	if (separr.length>0) {
	  if (separr[separr.length] === "") {
	    // remove last element
	    separr.splice(separr.length-1);
          }
	}

	// check if length is 1, and if so update
	if (separr.length==1) {
	  var arr = [];

	  for (i=0;i<separr[0].length;i++) {
	    arr.push(separr[0].charAt(i));
	  }
	  separr = arr;
	}
      }

      // for each child : add child and possibly separator
      for (i = children.length - 1; i>=0; i--) {
        if (i>0) {
          // separator-attribute is not empty
	  var sep;
	  if (separr.length>0) { 
	    if (i<=separr.length) {
	      sep = separr[i];
	    } else {
	      sep = separr[0];
	    }
	  }
	  for (var j=0;j<sep.length;j++) {
            entries.push(new presentation.Symbol(sep.charAt[j]));
	  }
	}

	// add child
        var child = this.handle(children.item(i), context);

	entries.push(child);
      }

      if (closesymbol === null || closesymbol === undefined) {
	closesymbol = ')';
      } 
      entries.push(new presentation.Symbol(closesymbol));

      var row = new presentation.Row();
      row.initialize.apply(row, entries);
      return row;
    },

    /*
     * general layout : math:menclose 
     * currently : ignore, treat as row
     */
    handlemenclose: function(node, context) {
      return this.handlemrow(node, context);
    },

    /* 
     * script and limit schemata 
     *
     * supported elements:
     * msub, msup, msubsup
     *
     * not supported elements:
     * munder, mover, mmultiscripts
     */
     
    /* script and limit schemata : math:msub */
    handlemsub: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Row(entries[0], new presentation.Subscript(entries[1]));
    },

    /* script and limit schemata : math:msup */
    handlemsup: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Row(entries[0], new presentation.Superscript(entries[1]));
    },

    /* script and limit schemata : math:msubsup */
    handlemsubsup: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Row(entries[0], new presentation.Subscript(entries[1]), new presentation.Superscript(entries[2]));
    }
  });

});

  $package("org.mathdox.formulaeditor.parsing.openmath");

$identify("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.openmath.KeywordList = {};
});

  $package("org.mathdox.formulaeditor.parsing.openmath");

$identify("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");
$require("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");
$require("org/mathdox/formulaeditor/semantics/FunctionApplication.js");
$require("org/mathdox/formulaeditor/semantics/Integer.js");
$require("org/mathdox/formulaeditor/semantics/SemanticFloat.js");
$require("org/mathdox/formulaeditor/semantics/String.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");

$main(function(){

  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser = $extend(
        org.mathdox.formulaeditor.parsing.xml.XMLParser, {

    name: "OpenMathParser",

    /**
     * Handles an <OMOBJ> node by processing its child node.
     */
    handleOMOBJ: function(node) {

      var child = node.firstChild;

      if (child !== null) {
        return this.handle(child);
      }
      else {
        return null;
      }

    },

    /**
     * Handle an <OMA> node.
     */
    handleOMA: function(node) {
      var symbol;
      var semantics = org.mathdox.formulaeditor.semantics;

      var style = node.getAttribute("style");

      // handle <OMA>'s with as first argument an <OMS/>
      if ("OMS" == node.firstChild.localName) {

        // helper function that uppercases first character of provided string
        var uppercase = function(string) {
            return string.substring(0,1).toUpperCase() + string.substring(1);
        };

        // figure out which handler method to call; for instance, for handling 
        // an <OMA> with as first argument <OMS cd='arith1' name='plus'/>, the
        // handleArith1Plus method is called
        var symbolname= node.firstChild.getAttribute("cd") + "__" + node.firstChild.getAttribute("name");

        var handler = "handle";

        handler += uppercase(node.firstChild.getAttribute("cd"));
        handler += uppercase(node.firstChild.getAttribute("name"));

        // call the handler method
        if (handler in this) {
          return this[handler](node, style);
        } else if (org.mathdox.formulaeditor.parsing.openmath.KeywordList[symbolname] !== null && org.mathdox.formulaeditor.parsing.openmath.KeywordList[symbolname] !== undefined) {
          /* return a FunctionApplication at the end */
          symbol = this.handleOMS(node.firstChild);
        } else {
          var cd = node.firstChild.getAttribute("cd");
          var name = node.firstChild.getAttribute("name");
          var keywordsymbol = {
            onscreen : null,
            openmath : null,
            mathml: "<mi>"+cd+"."+name+"</mi>"
          };
          symbol = new semantics.Keyword(cd, name, keywordsymbol, "function");
        }

      } else if ("OMV" == node.firstChild.localName) {
        /* return a FunctionApplication at the end */
        symbol = this.handleOMV(node.firstChild);
      } else if ("OMA" == node.firstChild.localName) {
        symbol = this.handleOMA(node.firstChild);
      } else {
        throw new Error(
          "OpenMathParser doesn't know how to handle an <OMA> that does " +
          "not have an <OMS/> or <OMV/> as first argument");

      }

      if (symbol) {
        var children = node.childNodes;
        var operands = [];

        for (var i=1; i<children.length; i++) {
          var child = this.handle(children.item(i));

          if (child !== null) { 
            // ignore comments
            operands.push(child);
          }
        }
       
        if (style !== "" && style !== null) {
          return new semantics.FunctionApplication(symbol, operands, style);
        } else {
          return new semantics.FunctionApplication(symbol, operands);
        }
      }
    },

    /**
     * Handles an <OMBIND> node by pretending its an <OMA> node.
     */
    handleOMBIND: function(node) {

      return this.handleOMA(node);

    },

    /**
     * Ignores an <OMBVAR> node.
     */
    handleOMBVAR: function(node) {

      return this.handle(node.firstChild);

    },

    /**
     * Handles an <OMF> node.
     */
    handleOMF: function(node) {

      var semantics = org.mathdox.formulaeditor.semantics;
      if (node.getAttribute("dec")) {
        return new semantics.SemanticFloat(node.getAttribute("dec"));
      }

    },

    /**
     * Handles an <OMI> node.
     */
    handleOMI: function(node) {

      var semantics = org.mathdox.formulaeditor.semantics;
      return new semantics.Integer(parseInt(node.firstChild.nodeValue));

    },

    /**
     * Handles an <OMS> node that is translated to a symbol without arguments
     */
    handleOMS: function(node) {
      var symbolname= node.getAttribute("cd") + "__" + node.getAttribute("name");
      var keyword = org.mathdox.formulaeditor.parsing.openmath.KeywordList[symbolname];

      if (keyword !== null && keyword !== undefined) {
        if (keyword.type == "constant" || keyword.type == "function") {
          return keyword;
        } else if (keyword.type == "infix" || keyword.type == "unary") {
          //check if parent is palette_row
          var error = false; // set to true if an error is found
          var parentNode = node.parentNode;
          var omsNode = parentNode.firstChild;
          if (omsNode.localName!="OMS") {
            throw new Error(
              "OpenMathParser doesn't know how to handle this keyword of unknown type ("+keyword.type+"): " + node + " when it is not first in an <OMA>. First sibling is "+ omsNode.localName+".");
          }
          if (omsNode.getAttribute("cd")=="editor1" && 
            omsNode.getAttribute("name")=="palette_row") {
            // inside a palette_row -> return the found infix symbol
            return keyword;
          } else {
            throw new Error(
              "OpenMathParser doesn't know how to handle this keyword of unknown type ("+keyword.type+"): " + node + " when it is not first in an <OMA>. INFO: was expecting symbol reference 'editor1.palette_row' instead found '"+omsNode.getAttribute("cd")+"."+omsNode.getAttribute("name")+"'.");
          }

        } else {
          throw new Error(
            "OpenMathParser doesn't know how to handle this keyword of unknown type ("+keyword.type+"): " + node + " when it is not first in an <OMA>.");
        }
      } else {
        var semantics = org.mathdox.formulaeditor.semantics;
        var cd = node.getAttribute("cd");
        var name = node.getAttribute("name");
        var keywordsymbol = {
          onscreen : null,
          openmath : null,
          mathml: "<mi>"+cd+"."+name+"</mi>"
        };
        return new semantics.Keyword(cd, name, keywordsymbol, "constant");
      }
    },

    /**
     * Handles an <OMSTR> node.
     */
    handleOMSTR: function(node) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var children = [];
      var name="";
      var i;
      var child;
      for (i=0;i<node.childNodes.length; i++) {
	child = node.childNodes.item(i);
        if (child.nodeType == 3) { // Node.TEXT_NODE
	  children.push(child.nodeValue);
	}
      }
      return new semantics.SString(children.join(""));
    },
    /**
     * Handles an <OMV> node.
     */
    handleOMV: function(node) {

      var semantics = org.mathdox.formulaeditor.semantics;
      var varname= node.getAttribute("name");
      var variable = org.mathdox.formulaeditor.parsing.openmath.VariableList[varname];

      if (variable !== null && variable !== undefined) {
	return variable;
      } else {
      	return new semantics.Variable(varname);
      }

    }

  });

});

  $package("org.mathdox.formulaeditor.parsing.openmath");

$identify("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.openmath.VariableList = {};
});

  $package("org.mathdox.formulaeditor.parsing.xml");

$identify("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");

$main(function(){

  org.mathdox.formulaeditor.parsing.xml.XMLParser = $extend(Object, {

    name: "XMLParser",

    /**
     * Parses the supplied OpenMath xml, and returns a
     * org.mathdox.formulaeditor.semantics.Node.
     */
    parse: function(xml, context) {
      var rootnode;
      var xmlDoc;

      if (window.DOMParser)
      {
        parser=new DOMParser();
        xmlDoc=parser.parseFromString(xml,"text/xml");
      } else {
        // XXX: old Internet Explorer
        // test in IE 8 without this to see if we can remove legacy code

        xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async=false;
        xmlDoc.loadXML(xml); 
      } 
      rootnode = xmlDoc.documentElement;

      /* remove comment nodes, since we don't want to parse them */
      if (rootnode !== null) {
        this.removeComments(rootnode);
        this.removeWhitespace(rootnode);
      } else {
        return null;
      }
      
      /* do the actual parsing */
      if (rootnode !== null) {
        return this.handle(rootnode, context);
      } else {
        return null;
      }

    },

    /**
     * Extracts the local name of the node, and uses that to figure out which
     * method should be called to handle this node. For instance, when an
     * <OMI> node is encountered, the handleOMI method is called.
     */
    handle: function(node, context) {
      if (node.localName === null) {
        // XML comment or text
        return null;
      }

      var handler = "handle" + node.localName;

      if (handler in this) {
	if (context !== null && context!== undefined) {
          return this[handler](node, context);
	} else {
          return this[handler](node);
	}
      }
      else {
        throw new Error( this.name+" doesn't know how to handle this "+
            "node: " + node +". INFO: 1.");
      }

    },

    /**
     * Removes all comment nodes from a DOM XML tree
     */
    removeComments: function(node) {
      var children = node.childNodes;

      for (var i=children.length - 1; i>=0; i--) {
        var child = children.item(i);

        if (child) {
          if (child.nodeType == 8) { // 8: COMMENT_NODE
            node.removeChild(child);
          } else if (child.hasChildNodes()) {
            this.removeComments(child);
          }
        }
      }
    },

    /**
     * Removes all whitespace text nodes from a DOM XML tree
     */
    removeWhitespace: function(node) {
      var children = node.childNodes;

      for (var i=children.length - 1; i>=0; i--) {
        var child = children.item(i);

        if (child) {
          if (child.nodeType == 3) { // 3: TEXT_NODE
            var value = child.nodeValue.trim();
	    if (value === "") {
              node.removeChild(child);
	    }
          } else if (child.hasChildNodes()) {
            this.removeWhitespace(child);
          }
        }
      }
    }

  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/BlockSymbol.js");

$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){
  /**
   * Representation of an empty space in a row in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.BlockSymbol =
    $extend(org.mathdox.formulaeditor.presentation.Symbol, {

    initialize : function() {
      // U+25A1 white square
      this.value = '□';

      if (arguments.length == 1) {
        this.onscreen = arguments[0];
      } else {
        this.onscreen = "f";
      }
    },

    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone(this.onscreen);
    },
    draw : function(canvas, context, x, y, invisible) {
      var fontSizeModifier = 0;
      if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
        fontSizeModifier = context.fontSizeModifier;
      }

      this.dimensions = canvas.drawFBox(
        Math.round(x), Math.round(y), invisible, this.onscreen, this.typeface, fontSizeModifier);

      return this.dimensions;
    }
  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Boxed.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){
  org.mathdox.formulaeditor.presentation.Boxed =
    $extend(org.mathdox.formulaeditor.presentation.Node, {

    semanticClass : null,

    children : null,

    margin : 5,

    slowDelete: true,
    
    initialize : function(semanticClass, children, presentation) {
      this.semanticClass = semanticClass;
      this.children = children;
      this.presentation = presentation;
      this.updateChildren();
    },

    draw : function(canvas, context, x, y, invisible) { 
      var dim = this.presentation.draw(canvas, context, 0, 0, true);

      var height = this.presentation.dimensions.height;
      var width = this.presentation.dimensions.width;

      this.dimensions = {
        height : height + 2*this.margin,
        width : width + 2* this.margin,
        left : dim.left + x,
        top : dim.top + y - this.margin 
      }

      this.drawHighlight(canvas, invisible);

      if (!invisible) {
        canvas.drawBox(this.dimensions, "#7F7F7F");
        this.presentation.draw(canvas, context, x + this.margin, y, false);
      }

      return this.dimensions;
    },

    getFirstCursorPosition : function(index) {
      return this.getFollowingCursorPosition();
    },
    
    getLastCursorPosition : function(index) {
      return this.getPrecedingCursorPosition();
    },

    getFollowingCursorPosition : function(index) {
      var result = null;

      if (index === null||index === undefined ) {
	result = this.children[0].getFirstCursorPosition();
      } else if (index + 1 < this.children.length) {
	result = this.children[index+1].getFollowingCursorPosition();
      }

      if (((result === null)|| (result === undefined)) && (this.parent !== null)) {
        result = this.parent.getFollowingCursorPosition(this.index, false);
      }

      return result;
    },

    getPrecedingCursorPosition : function(index) {
      var result = null;

      if (index === null||index === undefined ) {
	result = this.children[this.children.length -1].getLastCursorPosition();
      } else if (index - 1 >= 0) {
	result = this.children[index-1].getPrecedingCursorPosition();
      }

      if (((result === null)|| (result === undefined)) && (this.parent !== null)) {
        return { row: this.parent, index: this.index };
      }

      return result;
    },

    getCursorPosition : function(x, y) {
      /* starting minimum is distance to closest side border */
      var dmin = Math.min(Math.abs(x- this.dimensions.left),Math.abs((this.dimensions.left+this.dimensions.width) - x));
      var dx;
      var idx = -1;
      
      for (var i = 0; i< this.children.length; i++) {
        var child = this.children[i];
        if (x < child.dimensions.left) {
          dx = child.dimensions.left - x;
        } else if (x <= child.dimensions.left + child.dimensions.width) {
          dx = 0;
        } else {
          dx = x - (child.dimensions.left + child.dimensions.width);
        }
        
	if (dx<dmin) {
          idx = i;
          dmin = dx;
        }
      }

      var pos;
      if (idx >=0) {
        pos = this.children[idx].getCursorPosition(x,y);
        if (pos !== null) {
          return pos;
        } else {
          if (x >= this.children[idx].dimensions.left + this.children[idx].dimensions.width) {
            return this.children[idx].getPrecedingCursorPosition();
          } else {
            return this.children[idx].getFollowingCursorPosition();
          }
        }
      } else { /* code from Node.js */
        if (this.parent !== null) {
          if (x < this.dimensions.left + this.dimensions.width / 2) {
            return this.parent.getPrecedingCursorPosition(this.index+1,false);
          }
          else {
            return this.parent.getFollowingCursorPosition(this.index,false);
          }
        } else {
          return null;
        }
      }
    },

    getSemantics : function(context) {
      var values = [];
      var i;
      for (i=0; i<this.children.length; i++) {
        values.push(this.children[i].getSemantics(context).value);
      }

      var value = null;

      if (this.semanticClass !== null) {
	value = new this.semanticClass();
	value.initialize.apply(value, values);
      }

      return {
        value : value,
        rule : "braces"
      }

    }
  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Bracket.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a mathematical bracket (with minimum height) in the
   * presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Bracket =
    $extend(org.mathdox.formulaeditor.presentation.Symbol, {

      /**
       * A string representation of the symbol.
       */
      value : null,
      /**
       * A string representation of the symbol for on the screen
       */
      onscreen : null,

      /*
       * Minimum desired height
       */
      minimumHeight : 1,

      /**
       * Initializes a Symbol node in the presentation tree using the specified
       * string representation of a symbol.
       */
      initialize : function() {

        if (arguments.length > 0) {
          this.value = arguments[0];
        }
        if (arguments.length > 1) {
          this.minimumHeight = arguments[1];
        }
        if (arguments.length > 2) {
          this.onscreen = arguments[2];
        }

      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        return this.clone(this.value, this.minimumHeight, this.onscreen);
      },

      /**
       * Draws the symbol to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var symbol = this.value;
        if (this.onscreen !== null) {
          symbol = this.onscreen;
        }

        this.dimensions = canvas.drawBracket(
          symbol, Math.round(x), Math.round(y), this.minimumHeight, invisible);

        return this.dimensions;

      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Bracketed.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Bracketed =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      // array
      middle : null,
      // left bracket
      leftBracket : null,
      // right bracket
      rightBracket : null,
      // should we draw boxes ?
      drawBox : false,
      // enable slow deleting
      slowDelete : true,

      /**
       * Draws the matrix to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var height;

        // invisible drawing of array to set dimensions
        
        this.middle.draw(canvas, context, 0, 0, true);

        // if the left and right symbols are brackets set the height
        // XXX check if they are brackets
        this.leftBracket.minimumHeight = 
          this.middle.dimensions.height;
        this.rightBracket.minimumHeight = 
          this.middle.dimensions.height;

        // invisible drawing of brackets to set dimensions
        this.leftBracket.draw(canvas, context, 0, 0, true);
        this.rightBracket.draw(canvas, context, 0, 0, true);

        height = Math.max(
            this.leftBracket.dimensions.height,
            this.middle.dimensions.height,
            this.rightBracket.dimensions.height);

        var yAdjust = 0;
        var yAdjustBrackets = 0;
        
        // brackets are higher than the array
        if (height>this.middle.dimensions.height) {
          yAdjust = (height - this.middle.dimensions.height)/2;
        }

        // brackets are smaller than the array
        // assuming right bracket has the same size as the left bracket
        if (this.leftBracket.dimensions.height<height) {
          yAdjustBrackets = (height - this.leftBracket.dimensions.height)/2;
        }

        this.dimensions = { 
          height : height,
          width : 
            this.leftBracket.dimensions.width +
            this.middle.dimensions.width +
            this.rightBracket.dimensions.width,
          left : x,
          top : y + this.middle.dimensions.top - yAdjust
        };
        
	this.drawHighlight(canvas, invisible);

        this.leftBracket.minimumHeight = this.middle.dimensions.height;
        this.leftBracket.draw(canvas, context,  
          x - this.leftBracket.dimensions.left, 
          this.dimensions.top + yAdjustBrackets - 
          this.leftBracket.dimensions.top, 
          invisible);

        this.middle.draw(canvas, context,  
          x + this.leftBracket.dimensions.width - this.middle.dimensions.left, 
          y, invisible);

        this.rightBracket.minimumHeight = this.middle.dimensions.height;
        this.rightBracket.draw(canvas, context, 
          x + this.rightBracket.dimensions.width + 
            this.middle.dimensions.width - this.rightBracket.dimensions.left,
          this.dimensions.top + yAdjustBrackets - 
          this.rightBracket.dimensions.top, 
          invisible);
        
        if ((!invisible) &&this.drawBox) {
          canvas.drawBox(this.middle.dimensions);
          canvas.drawBoxWithBaseline(this.leftBracket.dimensions, this.dimensions.top + this.dimensions.height - yAdjustBrackets);
          canvas.drawBoxWithBaseline(this.rightBracket.dimensions, this.dimensions.top + this.dimensions.height - yAdjustBrackets);
          canvas.drawBoxWithBaseline(this.dimensions,y);
        }

        return this.dimensions;
      },
      functionsFromRow : [ "getFirstCursorPosition",
        "getLastCursorPosition", "getLowerCursorPosition",
        "getHigherCursorPosition" ],
      getCursorPosition: function(x,y) {
        var dimensions;

        dimensions = this.leftBracket.dimensions;
        if (x < dimensions.left + dimensions.width) {
          if (this.parent !== null) {
            return { row: this.parent, index: this.index };
          } else {
            return null;
          }
          return this.getFollowingCursorPosition();
        }
        dimensions = this.middle.dimensions;
        if (x < dimensions.left + dimensions.width) {
          return this.middle.getCursorPosition(x,y);
        }
        if (this.parent !== null) {
          return { row: this.parent, index: this.index+1 };
        } else {
          return this.getPrecedingCursorPosition();
        }
      },
      getFollowingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          return this.middle.getFollowingCursorPosition();
        }
        
        var result = null;

        if (index === 0) {
          if (descend) {
            result = this.middle.getFollowingCursorPosition();
          }
        }

        if (result === null) {
          // when we're at the end of the matrix, ask the parent of the matrix
          // for the position following this matrix
          if (this.parent !== null) {
            return this.parent.getFollowingCursorPosition(this.index, false);
          }
        }
        
        return result;
      },
      getPrecedingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          return this.middle.getPrecedingCursorPosition();
        }
        
        var result = null;

        if (index == 1) {
          if (descend) {
            result = this.middle.getPrecedingCursorPosition();
          }
        }

        if (result === null) {
          // when we're at the beginning of the matrix, ask the parent of the
          // matrix for the position before this matrix
          if (this.parent !== null) {
            return this.parent.getPrecedingCursorPosition(this.index+1, false);
          }
        }
        
        return result;
      },
      initialize : function () {
        if (arguments.length>0) {
          this.leftBracket = arguments[0];
          this.middle = arguments[1];
          this.rightBracket = arguments[2];
          this.children = [];
          this.children.push(this.middle);
        } else {
          this.children = [];
        }

        var presentation = org.mathdox.formulaeditor.presentation;
        /* copy the cursor/position functions from Row */

        var row = new presentation.Row(); // only an instance has the functions

        for (var i=this.functionsFromRow.length - 1; i>=0; i--) {
          if (! this[this.functionsFromRow[i]] ) {
            this[this.functionsFromRow[i]] = 
              row[ this.functionsFromRow[i] ];
          }
        }
        this.updateChildren();
      },
      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also Presentation/Node.js
       */
      copy : function () {
        return this.clone(this.leftBracket.copy(), this.children[0].copy(), this.rightBracket.copy());
      },
      getSemantics: function(context) {
	var sem = this.middle.getSemantics(context, null, null, "functionArguments", null);
	var value = sem.value;

	if (!(value instanceof Array)) {
	  return {
            rule: "braces",
            value: value
          };
	} else if (value.length === 1) {
	  // NOTE: probably should not occur
	  return {
            rule: "braces",
            value: value[0]
          };
	} else {
          return {
	    rule: "bracesWithSeparatedArguments",
	    value: value
          };
        }
      }
    });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Column.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Column =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      slowDelete: true,
      /*
       * the margin between the entries
       */
      margin: 2.0,

      /**
       * should we draw a box around the column and all entries ?
       */
      drawBox : false,

      /**
       * To add a fontSizeModifier for each row; create a list with an entry for each row.
       * this is added to the fontSizeModifier of the context. 
       *
       * For example a column with three rows, where the top and lower row are smaller would have
       * fontSizeModifierArray = [ -1, 0, -1 ]
       *
       * Note the name Array: this is added because it is not a single value
       */
      fontSizeModifierArray : null,

      /**
       * To use a different baseline then the default set this variable.
       * The index here will be used to select the row which is placed on the baseline.
       * This is used for functions like logarithm.
       */
      baselineIndex: null,

      /**
       * Draws the column to the canvas.
       *
       * vertical align on middle column: Math.floor((this.children.length)/2)
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {

        // the amount of space between the column elements
        var margin = this.margin;
        var rowInfo = [];

        // determine the dimensions of the children, and the maximum width
        var maxWidth = 0;
        var totalHeight = 0;

        var childContextArray = [];

        for (var i=0; i<this.children.length; i++) {
          var height;
          var top;
          var baseline;

          var modifiedContext;
          
          if (this.fontSizeModifierArray !== null && 
            this.fontSizeModifierArray[i]!==undefined && this.fontSizeModifierArray[i]!== null) {

	    modifiedContext = { fontSizeModifier : 0 };
            for (var name in context) {
              modifiedContext[name] = context[name];
            }
            modifiedContext.fontSizeModifier = modifiedContext.fontSizeModifier + this.fontSizeModifierArray[i];
          } else {
            modifiedContext = context;
          }

          childContextArray.push(modifiedContext);

          var dimensions = this.children[i].draw(canvas, childContextArray[i], 0, 0, true);

          maxWidth = Math.max(maxWidth, dimensions.width);
          height = dimensions.height;
          if (i === 0) {
            baseline = 0;
            top = baseline + dimensions.top;
            totalHeight += height;
          } else {
            top = rowInfo[i-1].top + rowInfo[i-1].height + margin;
            baseline = top - dimensions.top;
            totalHeight += height + margin;
          }

          rowInfo[i] = {
            height: height,
            top: top,
            baseline: baseline
          };
        }

        // determine the baseline of the column (vertical aligned on middle
        // row, rounded down)
        
        var usedBaseline;
	if (this.baselineIndex === null) {
	  usedBaseline = rowInfo[Math.floor(this.children.length/2)].baseline;
        } else {
	  usedBaseline = rowInfo[this.baselineIndex].baseline;
        }

        var row; // counter
        for (row = 0; row < this.children.length; row++) {
          rowInfo[row].top -= usedBaseline;
          rowInfo[row].baseline -= usedBaseline;
        }

        this.dimensions = {
          top: y + rowInfo[0].top,
          left: x,
          width: maxWidth,
          height: totalHeight
        };

        this.drawHighlight(canvas, invisible);

        // center of the column
        var center = x + maxWidth/2;

        for (row = 0; row < this.children.length; row++) {
          var childLeft = center - this.children[row].dimensions.width/2;
          this.children[row].draw(canvas, childContextArray[row], childLeft, y + rowInfo[row].baseline, 
            invisible);
        }

        if ((!invisible) && this.drawBox) {
          canvas.drawBoxWithBaseline(this.dimensions,y);
        }

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        for (var i=0; i<this.children.length - 1; i++) {
          if (y < this.children[i+1].dimensions.top) {
            return this.children[i].getCursorPosition(x,y);
          }
        }
        return this.children[this.children.length - 1].getCursorPosition(x,y);

      },

      /**
       * See also Node.getFollowingCursorPosition(index).
       */
      getFollowingCursorPosition : function(index) {
        var result = null;

        if (index === null|| index === undefined) {
          var middle = Math.floor(this.children.length / 2);
          var i      = middle;
          while(result === null && 0<=i && i<this.children.length) {
            result = this.children[i].getFollowingCursorPosition();
            if (i>=middle) {
              i = 2*middle - i - 1;
            }
            else {
              i = 2*middle - i;
            }
          }
        }

        if ((result === null) && (this.parent !== null)) {
          result =  this.parent.getFollowingCursorPosition(this.index, false);
        }

        return result;

      },

      getPrecedingCursorPosition : function(index) {

        if (index === null || index === undefined) {
          var result = null;
          var middle = Math.floor(this.children.length / 2);
          var i      = middle;
          while(result === null && 0<=i && i<this.children.length) {
            result = this.children[i].getPrecedingCursorPosition();
            if (i>=middle) {
              i = 2*middle - i - 1;
            }
            else {
              i = 2*middle - i;
            }
          }
          return result;
        }

        if (this.parent !== null) {
          return this.parent.getPrecedingCursorPosition(this.index+1, false);
        }

        return null;

      },

      getLowerCursorPosition : function(index, x) {
        var last = this.children.length - 1;
        if (index === null || index === undefined) {
          return this.children[0].getLowerCursorPosition(null, x);
        }
        else {
          if (index < last) {
            return this.children[index + 1].getLowerCursorPosition(null, x);
          }
          else {
            return arguments.callee.parent.getLowerCursorPosition.call(this, index, x);
          }
        }
      },

      getHigherCursorPosition : function(index, x) {
        var last = this.children.length - 1;
        if (index === null || index === undefined) {
          return this.children[last].getHigherCursorPosition(null, x);
        }
        else {
          if (index > 0) {
            return this.children[index - 1].getHigherCursorPosition(null, x);
          }
          else {
            return arguments.callee.parent.getHigherCursorPosition.call(this, index, x);
          }
        }
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Editor.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of the editor root element in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Editor =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      /**
       * margin around the edges
       */
      margin : 4.0,

      /**
       * width of the palette enable/disable bar
       */
      barwidth: 10.0,

      /**
       * colors of the bar, default for on : AAF,  off: DDF
       */
      barcolor: { on: "#AAF", off: "#DDF" },

      /**
       * status of the bar, one of the following
       * "this": palette for this editor
       * "none": no palette at all
       * "other": palette for another editor
       */
      barstatus: null,

      /**
       * The arguments to the constructor are the children of this node.
       */
      initialize : function(pres, paletteEnabled) {
        var Row = org.mathdox.formulaeditor.presentation.Row;
        var row;

        if (paletteEnabled !== undefined && paletteEnabled !== null) {
          this.paletteEnabled = paletteEnabled;
        }

        this.children = [];
        if (pres) {
          row = new Row(pres);
          row.flatten();
        } else {
          row = new Row();
        }
        this.children.push(row);
        this.updateChildren();
      },
      
      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        // NOTE: assuming children contains a single row, and taking the first
        // subchild
        //
        // should also work with one children[0] less (but that might create an
        // additional row which needs updating away)
        return this.clone(this.children[0].copy(), this.paletteEnabled);
      },
 
      /**
       * Draws the editor to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var dimensions = this.children[0].draw(canvas, context, 0, 0, true);

        if (! invisible) {
          this.children[0].draw(canvas, context, x + this.margin - dimensions.left, y + this.margin);
        }

        /* draw bar */
        var boxdimensions = {
          left:   x + dimensions.width + 2 * this.margin,
          top:    y + dimensions.top, 
          height: dimensions.height + 2 * this.margin,
          width:  this.barwidth
        };
        /* draw the box */
        if (! invisible) {
	  var color;
          if (this.paletteEnabled) {
	    color = this.barcolor.on;
          } else {
	    color = this.barcolor.off;
	  }
          canvas.drawBox(boxdimensions, color, color);
        }

        this.dimensions = {
          left: x,
          top: boxdimensions.top,
          height: boxdimensions.height,
          width: dimensions.width + 2* this.margin + this.barwidth
        };

        return this.dimensions;
      },

      getCursorPosition : function(x, y) {
        if (x<this.dimensions.width - this.barwidth) {
          return this.children[0].getCursorPosition(x, y);
        } else {
          return null;
        }
      },

      getFirstCursorPosition : function(index) {
        return this.children[0].getFollowingCursorPosition();
      },
      getFollowingCursorPosition : function(index, descend) {
        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        if (!descend) {
          return null;
        }
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        return null;
      },
      getPrecedingCursorPosition : function(index, descend) {
        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        if (!descend) {
          return null;
        }
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        return null;
      },
      getLastCursorPosition : function(index) {
        return this.children[0].getPrecedingCursorPosition();
      },
      onmousedown : function(event, editor, x, y) {
        if (x>=this.dimensions.width - this.barwidth) {
          /* toggle bar */
          editor.togglePalette();
          if (editor.palette) {
            this.paletteEnabled = true;
          } else {
            this.paletteEnabled = false;
          }
        }
      },
      getSemantics : function (context) {
	return this.children[0].getSemantics(context);
      }
      
    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Fraction.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a fraction in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Fraction =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      slowDelete : true,

      /**
       * Draws the fraction on the canvas.
       *
       * vertically aligned on middle of previous symbol if present or middle
       * of a letter x (on the baseline) otherwise
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {

        var dim0;
        var presentation = org.mathdox.formulaeditor.presentation;
        if (this.parent instanceof presentation.Row && this.index > 0) {
          dim0 = this.parent.children[this.index - 1].dimensions;
        }
        else {
          dim0 = new presentation.Symbol("x").draw(canvas,context, x,y,true);
        }

        y = dim0.top + (dim0.height/2);

        x = Math.round(x);
        y = Math.round(y);

        var upper = this.children[0];
        var lower = this.children[1];

        var margin = 4.0;
        var lineWidth = 1.0;

        var upperDimensions = upper.draw(canvas, context, 0, 0, true);
        var lowerDimensions = lower.draw(canvas, context, 0, 0, true);

        var left   = x + Math.min(upperDimensions.left, lowerDimensions.left);
        var top    = y - upperDimensions.height - margin;
        var width  = Math.max(upperDimensions.width, lowerDimensions.width) + 
	  2 * margin;
        var height = upperDimensions.height + lowerDimensions.height + 
	  2 * margin + lineWidth;

        this.dimensions = {
          left   : left,
          top    : top,
          width  : width,
          height : height
        };

        this.drawHighlight(canvas, invisible);

        // draw upper part
        upper.draw(
          canvas, context,
          x + (width/2) - (upperDimensions.width/2),
          top - upperDimensions.top,
          invisible);

        if (!invisible) {

          // draw line
          var canvasContext = canvas.getContext();
          canvasContext.save();
          canvasContext.lineWidth = lineWidth;
          canvasContext.beginPath();
          canvasContext.moveTo(x,y);
          canvasContext.lineTo(x+width,y);
          canvasContext.stroke();
          canvasContext.closePath();
          canvasContext.restore();

        }

        // draw lower part
        lower.draw(
          canvas, context,
          x + (width/2) - (lowerDimensions.width/2),
          y + margin - lowerDimensions.top + 1,
          invisible);

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        var upper = this.children[0].dimensions;
        var lower = this.children[1].dimensions;

        if (y < ((upper.top + upper.height) + lower.top) / 2) {
          return this.children[0].getCursorPosition(x, y);
        }
        else {
          return this.children[1].getCursorPosition(x, y);
        }

      },

      getFollowingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row: this.parent, index: this.index + 1 };
          }
          else {
            return null;
          }
        }
      },

      getPrecedingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row: this.parent, index: this.index };
          }
          else {
            return null;
          }
        }
      },

      // TODO: something fishy when moving through 2/3/4
      getLowerCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          return this.children[0].getLowerCursorPosition(null, x);
        }
        else {
          if (index === 0) {
            return this.children[1].getLowerCursorPosition(null, x);
          }
          else {
            if (this.parent !== null ) {
              return this.parent.getLowerCursorPosition(this.index, x);
            } else {
              return null;
            }
          }
        }
      },

      getHigherCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          return this.children[1].getHigherCursorPosition(null, x);
        }
        else {
          if (index == 1) {
            return this.children[0].getHigherCursorPosition(null, x);
          }
          else {
            if (this.parent !== null) {
              return this.parent.getHigherCursorPosition(this.index, x);
            }
            else {
              return null;
            }
          }
        }
      },

      getSemantics : function(context) {
        return {
          value : new org.mathdox.formulaeditor.semantics.Divide(
                    this.children[0].getSemantics(context).value,
                    this.children[1].getSemantics(context).value),
          rule  : "divide"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Matrix.js");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");
$require("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Matrix =
    $extend(org.mathdox.formulaeditor.presentation.Bracketed, {
      // variable to store the array to get the semantics
      pArray : null,

      initialize : function () {
        var presentation = org.mathdox.formulaeditor.presentation;
        var leftBracket = new presentation.Bracket('(');
        var rightBracket = new presentation.Bracket(')');

        this.pArray = new presentation.PArray();
          
        this.pArray.initialize.apply(this.pArray,arguments);
        this.pArray.margin = 10.0;

        arguments.callee.parent.initialize.call(this, leftBracket,
          this.pArray, rightBracket);
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        return this.clone.apply(this, this.copyArray(this.pArray.entries));
      },

      getSemantics : function(context) {
        var rows = this.pArray.entries; // this.middle is the pArray
        var semanticRows;
        var matrix;

        var semantics = org.mathdox.formulaeditor.semantics;
        semanticRows = [];
        for (var i=0;i<rows.length;i++) {
          var semanticRowEntries;

          semanticRowEntries = [];
          for (var j=0; j<rows[i].length;j++) {
            semanticRowEntries.push(rows[i][j].getSemantics(context).value);
          }
          var semanticRow = new semantics.Linalg2Matrixrow();
          semanticRow.initialize.apply(semanticRow, semanticRowEntries);
          semanticRows.push(semanticRow);
        }
        matrix = new semantics.Linalg2Matrix();
        matrix.initialize.apply(matrix, semanticRows);

        return {
          value : matrix,
          rule  : "braces"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a node in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Node = $extend(Object, {

    /**
     * The parent node of this node.
     */
    parent : null,

    /**
     * The amount of siblings preceding this node.
     */
    index : null,

    /**
     * The child nodes of this node.
     */
    children : [],

    /**
     * The position and dimensions of the node when it was last rendered to a
     * canvas.
     */
    dimensions : null,

    /**
     * Indicate if this should be drawn with a highlight. Note: not all items
     * might support highlights.
     */
    highlight: false,

    /**
     * Indicate if this should not be deleted directly. The item will be
     * highlighted instead.
     */
    slowDelete: false,

    /**
     * Indicate this is on the baseline (for superscript/subscript drawing)
     */
    onBaseline: true,

    /**
     * The arguments to the constructor are the children of this node.
     */
    initialize : function() {

      this.children = Array.prototype.slice.call(arguments);
      this.updateChildren();

    },

    /*
      if ( typeof Object.getPrototypeOf !== "function" ) {
        if ( typeof "test".__proto__ === "object" ) {
          Object.getPrototypeOf = function(object){
            return object.__proto__;
          };
        } else {
          Object.getPrototypeOf = function(object){
            // May break if the constructor has been tampered with
            return object.constructor.prototype;
          };
        }
      }
    */

    /**
     * Returns a copy of an object initialized with arguments args, which
     * should be an array.
     */
    clone: function() {
      var constructor = function(){};
      constructor.prototype = Object.getPrototypeOf(this);

      var result = new constructor();
      result.initialize.apply(result, arguments);
      
      return result;
    },

    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone.apply(this, this.copyArray(this.children));
    },

    /**
     * Returns a copy of an array of presentation objects, without index
     * information. To be used for copy/paste or undo.
     */
    copyArray: function(arr) {
      var result = [];

      for (var i=0;i<arr.length;i++) {
        if (arr[i] instanceof Array) {
          result.push(this.copyArray(arr[i]));
	} else {
          result.push(arr[i].copy());
        }
      }
      return result;
    },

    /**
     * Test to see if we can delete this item.
     *
     * Result: 
     *   Returns true if this can be deleted. Returns false if this should not
     *   be deleted yet. This allows highlighting an item before deleting it.
     */
    deleteItem: function() {
      if (this.slowDelete === true) {
        if (this.highlight === true) {
          return true;
        } else {
          this.setHighlight(true);

          return false;
        }
      } else {
        return true;
      }
    },

    /**
     * Draws the node on the specified canvas context. This is an abstract
     * method, so it is expected that subclasses will override this method.
     *
     * Parameter canvas: The 2d context of the canvas upon which this node is
     *   expected to draw itself
     * Parameter context: The draw context (subscript font is smaller; etc)
     * Parameters x,y: The (x,y) coordinate indicates where the left of the
     *   baseline of the node will appear.
     * Parameter invisible: This is an optional boolean parameter that indicates
     *   whether or not the node should be drawn to the canvas. It defaults to
     *  'false'. Setting this parameter to 'true' can be used to obtain
     *   information about the dimensions of the node, without actually
     *   drawing on the canvas.
     * Result : an object containing the values { left, top, width, height }
     *   that indicate the position and dimensions of the bounding rectangle
     *   of the node.
     */
    draw : function(canvas, context, x, y, invisible) {

      throw new Error("abstract method called");

    },

    /**
     * draws the background when highlighted
     *
     * Parameter dimensions: the size of the object
     */
    drawHighlight : function(canvas, invisible) {
      var dimensions = this.dimensions;
      if ( (invisible === undefined || invisible === null || invisible === false ) && this.highlight === true) {
        canvas.drawBox(dimensions, "#66C", "rgba(160,160,255,0.5)");
        //canvas.drawBox(dimensions, "#66C", "rgba(255,0,0,0.5)");
      }
    },

    /**
     * Returns the MathML presentation of the node. This is an abstract method,
     * so it is expected that subclasses will override this method.
     */
    getMathML : function(mrow) {
      throw new Error("abstract method called");
    },

    /**
     * Method which is called whenever this node changes. Calls the parent's
     * onchange method by default.
     */
    onchange : function(node) {

      if (this.parent !== null) {
        this.parent.onchange(this);
      }

    },

    /**
     * Called whenever a keypress has been detected when the cursor was at the
     * specified index. Does nothing by default, should be overridden to do
     * something usefull.
     */
    onkeypress : function(index, event) {

      // skip

    },

    /**
     * Called whenever a mouseclick has been detected at position (x,y), and no
     * new cursor position could be found. Put other actions here.
     * If the event is handled, return false.
     */
    onmousedown : function(event, editor, x, y) {
      // skip
      return true;

    },

    /**
     * Flattens the tree, meaning that all rows inside rows will be moved into
     * one row.
     */
    flatten : function() {

      // flatten the child nodes
      for (var i=0; i<this.children.length; i++) {
        if (! this.children[i]) {
          alert("no child at :"+i);
        } else if (! this.children[i].flatten) {
          alert("no flatten in : "+i+".");
        } else {
          this.children[i].flatten();
        }
      }

    },

    /**
     * Re-calculates each child's index value, and sets each child's parent
     * value. This method should be called after a change in the tree. When the
     * 'begin' argument is specified, only the children at index >= begin will
     * be updated.
     */
    updateChildren : function(begin) {

      if ((begin === null) || (begin === undefined)) {
        begin = 0;
      }
      for (var i=begin; i<this.children.length; i++) {
        if (! this.children[i]) {
          alert("empty child : "+i+".");
        } else {
          this.children[i].parent = this;
          this.children[i].index = i;
        }
      }

    },

    /**
     * Returns a keyboard cursor position closest to the specified screen
     * coordinates.
     */
    getCursorPosition : function(x, y) {

      if (this.parent !== null) {
        if (x < this.dimensions.left + this.dimensions.width / 2) {
          return this.parent.getPrecedingCursorPosition(this.index+1,false);
        }
        else {
          return this.parent.getFollowingCursorPosition(this.index,false);
        }
      }
      else {
        return null;
      }

    },

    getFirstCursorPosition : function(index) {
      if (this.parent !== null) {
        return this.parent.getFirstCursorPosition();
      }
      else {
        return null;
      }
    },

    getLastCursorPosition : function(index) {
      if (this.parent !== null) {
        return this.parent.getLastCursorPosition();
      }
      else {
        return null;
      }
    },

    /**
     * Returns the cursor position following the cursor position at the
     * specified index. When no cursor position can be provided, null is
     * returned. By default this method always returns null, override it to do
     * something useful.
     */
    getFollowingCursorPosition : function(index) {

      return null;

    },

    getPrecedingCursorPosition : function(index) {

      return null;

    },

    getLowerCursorPosition : function(index, x) {

      var presentation = org.mathdox.formulaeditor.presentation;

      if (this.parent !== null) {
        if ((index === null || index === undefined) && 
            this.parent instanceof presentation.Row) {
          return { row: this.parent, index: this.index };
        }
        else {
          return this.parent.getLowerCursorPosition(this.index, x);
        }
      }
      else {
        return null;
      }

    },

    getHigherCursorPosition : function(index, x) {

      var presentation = org.mathdox.formulaeditor.presentation;

      if (this.parent !== null) {
        if ((index === null || index === undefined) && 
            this.parent instanceof presentation.Row) {
          return { row: this.parent, index: this.index };
        } else {
          return this.parent.getHigherCursorPosition(this.index, x);
        }
      } else {
        return null;
      }

    },
    toString : function() {
      if (this.value) {
        return this.value;
      } else if (this.children) {
        var str = "[ ";
        for (var i=0; i<this.children.length; i++) {
          str+=this.children[i];
          if (i<this.children.length-1) {
            str +=", ";
          }
        }
        str+=" ]";
        return str;
      }
    },
    maxDimensions: function(x,y,arr) {
      var i;
      var maxdim={ top:y, left:x, width:0, height:0 };
      var top, bottom, left, right;

      for (i=0; i< arr.length;i++) {
        top = Math.min(maxdim.top,arr[i].top);
        bottom = Math.max(maxdim.top+maxdim.height, 
          arr[i].top+arr[i].height);
        left = Math.min(maxdim.left,arr[i].left);
        right = Math.max(maxdim.left+maxdim.width, 
          arr[i].left+arr[i].width);
        maxdim = { 
          top:top, 
          left:left, 
          width: right-left, 
          height: bottom - top
        };
      }
      return maxdim;
    },

    /**
     * Parameter highlight:
     *   true if this should be highlighted.
     */
    setHighlight: function(highlight) {
      if (highlight === true || highlight === false) {
        this.highlight = highlight;
      } else {
        console.log('presentation.Node.setHighlight: invalid argument '+highlight+', was expecting true or false.');
      }
      if (highlight === false && this.children.length>0) {
        var i;
        // NOTE: going through all children, could be done cheaper (but the
        // assumption is a redraw is done anyway, so this shouldn't matter)
        for (i=0;i<this.children.length;i++) {
          this.children[i].setHighlight(false);
        }
      }
    }

  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/PArray.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.PArray =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
    /* 
     * number of rows 
     */
    rows : 0,
    /*
     * number of columsn
     */
    columns: 0,

    /*
     * the heights of the rows
     */
    rowInfo : null,
    /*
     * the widths of the columns
     */
    colInfo : null,

    /*
     * the margin between the entries
     */
    margin : 2.0,

    /*
     * Should we draw a box around the PArray and all entries ?
     */
    drawBox : false,

    /*
     * Should we "highlight" a certain entry in the PArray ?
     */
    highlight: null,

    /*
     * Determine the maximum height of a row
     * usage getMaxHeight(row) : max height of a row
     */
    getMaxHeight : function(row) {
      var maxHeight = 0;
      var highTop = 0;
      var lowBottom = 0;
      for (var col=0; col<this.columns; col++) {
        highTop = Math.min(highTop, this.entries[row][col].dimensions.top);
        lowBottom = Math.max(lowBottom, 
          this.entries[row][col].dimensions.top + 
          this.entries[row][col].dimensions.height);
      }
      maxHeight = lowBottom - highTop;
      return { height: maxHeight, top: highTop, bottom: lowBottom };
    },

    /*
     * Determine the width of a column
     * usage getMaxWidth(column) : max width of a column
     */
    getMaxWidth : function(col) {
      var maxWidth = 0;
      for (var row=0; row<this.rows; row++) {
        maxWidth = Math.max(maxWidth, this.entries[row][col].dimensions.width);
      }
      return maxWidth;
    },

    /**
     * Draws the matrix to the canvas.
     *
     * See also: org.mathdox.formulaeditor.presentation.Node.draw
     */
    draw : function(canvas, context, x, y, invisible) {

      // total height
      var totalHeight = 0;
      
      // fake drawing of children to set sizes
      
      var row; // row counter
      var col; // column counter
      for (row = 0; row < this.rows; row++) {
        for (col = 0; col < this.columns; col++) {
            if (this.entries[row][col] && this.entries[row][col].draw) {
              this.entries[row][col].draw(canvas, context, 0, 0, true);
            } else {
              alert("PArray could not draw row:"+row+", col:"+col+".");
            }
        }
      }
 
      for (row = 0; row < this.rows; row++) {
        var heightInfo = this.getMaxHeight(row);
        var rowHeight = heightInfo.height;
        var rowTop;
        var rowCenter;
        var rowBaseline;
        if (row === 0 ) {
          rowBaseline = 0;
          rowTop = rowBaseline + heightInfo.top;
          totalHeight += rowHeight;
        } else {
          rowTop = this.rowInfo[row-1].top + this.rowInfo[row-1].height + 
            this.margin;
          rowBaseline = rowTop - heightInfo.top;
          totalHeight += rowHeight + this.margin;
        }
        this.rowInfo[row] = {
          height : rowHeight,
          top : rowTop,
          baseline : rowBaseline
        };
      }

      // align on middle row: Math.floor((this.rows)/2)
      var usedBaseline = this.rowInfo[Math.floor((this.rows)/2)].baseline;

      // adjust rows for total height
      for (row = 0; row < this.rows; row++) {
        this.rowInfo[row].top -= usedBaseline;
        this.rowInfo[row].baseline -= usedBaseline;
      }

      // the widths of the columns
      var columnwidth = [];
      // total width
      var totalWidth = 0;

      for (col = 0; col < this.columns; col++) {
        var colWidth = this.getMaxWidth(col);
        if (col === 0 ) {
          colCenter = colWidth/2;
          totalWidth += colWidth;
        } else {
          colCenter = this.colInfo[col-1].center +this.colInfo[col-1].width/2+ this.margin + colWidth/2;
          totalWidth += colWidth + this.margin;
        }
        this.colInfo[col] = {
          left   : colCenter - colWidth/2,
          width  : colWidth,
          center : colCenter
        };
      }

      // draw all entries
      if (! invisible) {
        for (row=0; row<this.rows; row++) {
          for (col=0; col<this.columns; col++) {
            var entry       = this.entries[row][col];
            var entryWidth  = entry.dimensions.width;
            var entryHeight = entry.dimensions.height;
            var entryTop    = entry.dimensions.top;
            var highlight;

            if (this.highlight != null && this.highlight.row == row && this.highlight.col == col) {
              highlight = true;
            } else {
              highlight =false;
            }
    
            if (!invisible) {
              if (this.drawBox) {
                canvas.drawBoxWithBaseline(entry.dimensions, y + 
                  this.rowInfo[row].baseline);
              } else if (highlight) {
                //calculate box dimensions
                var boxdimensions = {
                  top:    y+this.rowInfo[row].top,
                  left:   x+this.colInfo[col].left,
                  width:  this.colInfo[col].width,
                  height: this.rowInfo[row].height
                }

		if (col+1 <this.columns) {
		  boxdimensions.width+=this.margin/2;
		}
		if (col > 0) {
		  boxdimensions.left-=this.margin/2;
		  boxdimensions.width+=this.margin/2;
		}
		if (row+1 <this.rows) {
		  boxdimensions.height+=this.margin/2;
		}
		if (row > 0) {
		  boxdimensions.top-=this.margin/2;
		  boxdimensions.height+=this.margin/2;
		}
                canvas.drawBox(boxdimensions, "#00F", "#DDF");
              }
            }

            entry.draw(
              canvas, context,
              x + this.colInfo[col].center - (entryWidth/2), 
                    // horizontally centered in column
              y + this.rowInfo[row].baseline,
              invisible);
          }
        }
      }
      this.dimensions = {
        top    : y+this.rowInfo[0].top,
        left   : x,
        width  : totalWidth,
        height : totalHeight
      };
      if ((!invisible) && this.drawBox) {
        canvas.drawBoxWithBaseline(this.dimensions, y);
      }
      return this.dimensions;
    },

    getCoordinatesFromPosition : function(x, y) {
      var row,col;

      // find the row
      row = 0;
      /*
       * Here rowHeight   = this.rowInfo[row].height and 
       *      entryHeight = this.entries[row][0].dimensions.height
       *
       * this.entries[row][0].dimensions.top is the top of the entry
       * subtract (rowHeight-entryHeight)/2 to get the top of the row
       * add rowHeight to get the bottom of the row
       *
       * if the coordinate is below the bottom, increase the row number
       */
      //while ((row<this.rows-1) && (y>this.rowInfo[row].top + this.rowInfo[row].height)) {
      while ((row<this.rows-1) && (y>this.entries[row][0].dimensions.top - (this.rowInfo[row].height - this.entries[row][0].dimensions.height)/2 + this.rowInfo[row].height)) {
        // not in row "row"
        row++;
      }

      // find the column
      col = 0;
             /*
       * Here colWidth   = this.colInfo[row].width and 
       *      entryWidth = this.entries[row][col].dimensions.width
       *
       * this.entries[row][col].dimensions.left is the left of the entry
       * subtract (colWidth - entryWidth)/2 to get the left of the column
       * add colWidth to get the right of the column
       *
       * if the coordinate is past the right, increase the column number
       */
      while ((col<this.columns-1) && (x> this.dimensions.left + this.colInfo[col].left + this.colInfo[col].width)) {
        // not in column "col"
        col++;
      }
      return {row:row, col:col};
    },
    getEntryFromPosition : function(x, y) {
        var coords = this.getCoordinatesFromPosition(x,y);
      return this.entries[coords.row][coords.col];
    },
    getCursorPosition : function(x, y) {
      return this.getEntryFromPosition(x,y).getCursorPosition(x,y);
    },

    
                      
   /**
     * See also Node.getFollowingCursorPosition(index).
     */
    getFollowingCursorPosition : function(index) {
      var result = null;
      var row, col;

      if (index === null || index === undefined) {
        middle = Math.floor(this.rows / 2);
        row    = middle;
        while(result === null && 0<=row && row < this.rows) {
          result = this.entries[row][0].getFollowingCursorPosition();
          if (row>=middle) {
            row = 2*middle - row - 1;
          }
          else {
            row = 2*middle - row;
          }
        }
        return result;
      }

      row = Math.floor(index / this.columns);
      col = index % this.columns;
      if (col+1<this.columns) {
        result = this.entries[row][col+1].getFirstCursorPosition();
      }

      if (((result === null)|| (result === undefined)) && (this.parent !== null)) {
        result = this.parent.getFollowingCursorPosition(this.index, false);
      }
      return result;

    },

    getPrecedingCursorPosition : function(index) {
      var result=null;
      var row = null;
      var col = null;

      if (index === null || index === undefined) {
        var middle = Math.floor(this.rows / 2);
        row    = middle;
        while(result === null && 0<=row && row < this.rows) {
          col = this.entries[row].length - 1;
          result = this.entries[row][col].getPrecedingCursorPosition();
          if (row>=middle) {
            row = 2*middle - row - 1;
          }
          else {
            row = 2*middle - row;
          }
        }
        return result;
      }

      if (index>0) {
        row = Math.floor(index / this.columns);
        col = index % this.columns;
        if (col>0) {
          result = this.entries[row][col-1].getLastCursorPosition();
        } 
      }

      if (((result === null) || (result === undefined))&& (this.parent !== null)) {
        result = this.parent.getPrecedingCursorPosition(this.index, false);
      }
      return result;
    },

    getLowerCursorPosition : function(index, x) {
      if (index === null || index === undefined) {
        return this.entries[0][0].getLowerCursorPosition(null, x);
      }

      var row = Math.floor(index / this.columns);
      var col = index % this.columns;
      var result;
      if (row+1<this.rows) {
        result = this.entries[row+1][col].getLowerCursorPosition(null, x);
      } 
      if (((result === null) || (result === undefined)) && (this.parent !== null)) {
        result = this.parent.getLowerCursorPosition(this.index, x);
      }
      return result;
    },

    getHigherCursorPosition : function(index, x) {
      
      if (index === null || index === undefined) {
        return this.entries[0][this.rows-1].getHigherCursorPosition(null, x);
      }

      if (index<this.children.length) {
        var row = Math.floor(index / this.columns);
        var col = index % this.columns;
        var result;
        if (row>0) {
          result = this.entries[row-1][col].getHigherCursorPosition(null, x);
        } 
        if (((result === null)||(result === undefined)) && (this.parent !== null)) {
          result = this.parent.getHigherCursorPosition(this.index, x);
        }
        return result;
      }

      return null;
    },
    initialize : function() {
      this.rowInfo = [];
      this.colInfo = [];
      if (arguments.length >0) {
        this.entries = Array.prototype.slice.call(arguments);
        this.rows = this.entries.length;
        this.columns = this.entries[0].length;
      }
      this.children = [];

      for (var row = 0; row < this.rows; row++) {
        for (var col = 0; col < this.columns; col++) {
          this.children.push(this.entries[row][col]);
        }
      }
      this.updateChildren();
    },
    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone.apply(this, this.copyArray(this.entries));
    }
  });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/PTabContainer.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");

$main(function(){

  /**
   * Representation of several tabs, [including a method to switch between
   * them]
   */
  org.mathdox.formulaeditor.presentation.PTabContainer =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
    /*
     * index of the current tab
     */
    currenttab: null,

    tabBarSize : 20,

    margin: 2.0,

    /**
     * Draws the current tab to the canvas.
     *
     * See also: org.mathdox.formulaeditor.presentation.Node.draw
     */
    draw : function(canvas, context, x, y, invisible) {

      if (this.current === null) {
        this.dimensions = { top:y, left:x, width:0, height:0 };
        return this.dimensions;
      }

      if ((this.children[this.current] === undefined) || (this.children[this.current] === null)) {
        this.dimensions = { top:y, left:x, width:0, height:0 };
        return this.dimensions;
      }

      /* calculate maximum dimensions */
      var dimArray = [];
      var maxDim;
      var boxDim;
      var tabBoxDim;
      var i;

      if (this.showTabBar()) {
        for (i=0; i< this.children.length; i++) {
          dimArray.push(this.children[i].draw(canvas,context,x,y+this.tabBarSize+this.margin,true));
        }
        maxDim = this.maxDimensions(x,y+this.tabBarSize+this.margin,dimArray);

        boxDim = { 
          top: maxDim.top - this.tabBarSize - this.margin, 
          left: maxDim.left, 
          width: maxDim.width, 
          height: this.tabBarSize
        };


        for (i=0; i< this.children.length; i++) {
          tabBoxDim = {
            top: boxDim.top,
            left: boxDim.left + (i/this.children.length)*boxDim.width,
            width: boxDim.width/this.children.length,
            height: boxDim.height
          };

          if (i == this.current) {
            if (!invisible) { 
              canvas.drawBox(tabBoxDim, "#00F", "#AAF"); 
            }
          } else {
            if (!invisible) { 
              canvas.drawBox(tabBoxDim, "#00F", "#DDF");
            }
          }
        }
        
        if (!invisible) { 
          canvas.drawBox(boxDim, "#00F");
        }
  
        this.children[this.current].draw(canvas, context, x, y + this.tabBarSize + this.margin, 
          invisible);
    
        this.dimensions = {
          top: maxDim.top - this.tabBarSize - this.margin,
          left: maxDim.left, 
          width: maxDim.width, 
          height: maxDim.height+this.tabBarSize + this.margin
        };
      } else { /* only 1 child, don't draw a bar */
        this.dimensions = this.children[0].draw(canvas, context, x, y, invisible);
      }

      return this.dimensions;
    },

    handleMouseClick : function (x,y,redraw) {
      var palcoords ;
      var index;

      if (this.showTabBar()) {
        if (y < this.dimensions.top + this.tabBarSize) {
          /* inside tabbar, insert nothing */
          index = Math.floor((x - this.dimensions.left) / 
            (this.dimensions.width) * this.children.length);
          
          this.current = index;

          redraw();

          return null;
        }
      }

      palcoords = this.children[this.current].getCoordinatesFromPosition(x,y);

      return {
        tab: this.current,
        row: palcoords.row,
        col: palcoords.col
      };
    },

    handleMouseMove : function (x,y,redraw) {
      if(x==null || y==null) {
	if (this.children[this.current].highlight) {
          this.children[this.current].highlight = null;

	  redraw();
	}

	return;
      }

      if (this.showTabBar()) {
        if (y < this.dimensions.top + this.tabBarSize) {

          if(this.children[this.current].highlight) {
            this.children[this.current].highlight = null;

	    redraw();
          }

          return;
        }
      }

      var oldhighlight = this.children[this.current].highlight;
      this.children[this.current].highlight = 
          this.children[this.current].getCoordinatesFromPosition(x,y);

      if ((!oldhighlight || !this.children[this.current].highlight) ||  
        (oldhighlight.col != this.children[this.current].highlight.col ||
          oldhighlight.row != this.children[this.current].highlight.row)) {

	redraw();
      } 

    },

    initialize : function() {
      if (arguments.length >0) {
        this.children = Array.prototype.slice.call(arguments);
        this.current = 0;
      }
      this.updateChildren();
    },

    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone.apply(this, this.copyArray(this.children));
    },

    showTabBar : function() {
      return (this.children.length>1);
    }
  });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/PseudoRow.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){
  /**
   * Representation of a row, which will not be flattened
   */
  org.mathdox.formulaeditor.presentation.PseudoRow =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      
      // allow overwriting of abstract draw method
      draw: null,

      functionsFromRow : [ "getFirstCursorPosition", "getFollowingCursorPosition", "getPrecedingCursorPosition",
        "getLastCursorPosition", "getLowerCursorPosition",
        "getHigherCursorPosition", "draw", "isEmpty", "getMathML", "getSemantics", "insert", "replace", "remove" ],

      initialize : function () {
        this.children = Array.prototype.slice.call(arguments);

        var presentation = org.mathdox.formulaeditor.presentation;
        /* copy the cursor/position functions from Row */

        var row = new presentation.Row(); // only an instance has the functions
        
        for (var i=this.functionsFromRow.length - 1; i>=0; i--) {
          if (! this[this.functionsFromRow[i]] ) {
            this[this.functionsFromRow[i]] = 
              row[ this.functionsFromRow[i] ];
          }
        }

        this.updateChildren();
      },
    });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Root.js");

$require("org/mathdox/formulaeditor/modules/keywords.js");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$require("org/mathdox/formulaeditor/semantics/Integer.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Root =
    $extend(org.mathdox.formulaeditor.presentation.Bracketed, {
      // base of the root (especially if not 2)
      base : null,

      // width of the line
      lineWidth : 1.0,

      // margin between the line and the row
      margin : 2.0,

      // should we draw boxes ?
      drawBox : false,
      
      drawBase : false,

      drawBaseQ: function() {
        var context;
        context = org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.getContext();

        var baseSemantics = this.base.getSemantics(context);

        return (!baseSemantics || !baseSemantics.value || 
          !baseSemantics.value.value || (baseSemantics.value.value != 2));
      },

      /**
       * Draws the root to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var middleheight;
        var rootheight;
        var baseheight;
        var height;
        var vlheight;
        var drawBase;

        var fontSizeModifier = 0;
        if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
          fontSizeModifier = context.fontSizeModifier;
        }

        var baseContext = { fontSizeModifier : 0 };
        for (var name in context) {
          baseContext[name] = context[name];
        }
        baseContext.fontSizeModifier = baseContext.fontSizeModifier - 1;

        // invisible drawing of array to set dimensions
        
        this.middle.draw(canvas, context, 0, 0, true);

        middleheight = this.middle.dimensions.height + this.lineWidth + 
          this.margin*2;

        drawBase = this.drawBase;

        if (drawBase) {
          this.base.draw(canvas, baseContext, 0, 0, true);
          baseheight = this.base.dimensions.height;
          vlheight = canvas.drawSymbol("vl", 0, 0, true, null, fontSizeModifier).height;
        }

        // if the left and right symbols are brackets set the height
        // XXX check if they are brackets
        if (drawBase) {
          this.leftBracket.minimumHeight = Math.max(middleheight, 
            Math.min(2*baseheight+3*this.margin,
              baseheight+vlheight+3*this.margin ));
        } else {
          this.leftBracket.minimumHeight = middleheight;
        }

        // invisible drawing of brackets to set dimensions
        this.leftBracket.draw(canvas, context, 0, 0, true);

        rootheight = this.leftBracket.dimensions.height;

        height = rootheight;

        var yAdjust = 0;
        var yAdjustBrackets = 0;
        
        // bracket is higher than the array
        if (height>middleheight) {
          yAdjust = (height - middleheight)/2;
        }

        // baseXAdjust: negative number or 0 indicating how much the base sticks
        // out to the left
        var baseXAdjust = 0;
        if (drawBase) {
          baseXAdjust = Math.min(0, 
            this.leftBracket.dimensions.width/2 - this.base.dimensions.width);
        }
 
        var yAdjustMiddle = - (this.middle.dimensions.top+this.middle.dimensions.height) - 
          this.margin;

        this.dimensions = { 
          height : height,
          width : 
            this.leftBracket.dimensions.width +
            this.middle.dimensions.width - baseXAdjust + this.margin,
          left : x,
          //top : y - this.leftBracket.dimensions.height + yAdjust/2 
          top : y - this.leftBracket.dimensions.height + yAdjust/2 - yAdjustMiddle
        };
     
        this.drawHighlight(canvas, invisible);

        if (drawBase) {
          this.base.draw(canvas, baseContext,
            x - this.base.dimensions.left,
            y + yAdjust/2 - Math.min(rootheight/2, vlheight) - 
              (this.base.dimensions.top + this.base.dimensions.height) - 
              2*this.margin - yAdjustMiddle, 
            invisible);
        }

        this.leftBracket.draw(canvas, context,
          x - this.leftBracket.dimensions.left - baseXAdjust, 
          y - (this.leftBracket.dimensions.top +
            this.leftBracket.dimensions.height) + yAdjust/2 - yAdjustMiddle, 
          invisible);
        /* XXX adjust vertically */
        this.middle.draw(canvas, context,
          x - baseXAdjust + this.leftBracket.dimensions.width -
          this.middle.dimensions.left + this.margin , 
          y, invisible);

        if (!invisible) {
          // draw line
          var canvasContext = canvas.getContext();

          canvasContext.save();
          canvasContext.lineWidth = this.lineWidth;
          canvasContext.beginPath();
          canvasContext.moveTo(x-baseXAdjust+this.leftBracket.dimensions.width - 1,
            this.dimensions.top + this.lineWidth);
          canvasContext.lineTo(x+this.dimensions.width, 
            this.dimensions.top + this.lineWidth);
          canvasContext.stroke();
          canvasContext.closePath();
          canvasContext.restore();
        }

        /* XXX adjust */
        if ((!invisible) &&this.drawBox) {
          if (drawBase) {
            canvas.drawBox(this.base.dimensions);
          }
          canvas.drawBox(this.middle.dimensions);
          canvas.drawBox(this.leftBracket.dimensions);
          canvas.drawBoxWithBaseline(this.dimensions,y);
        }

        return this.dimensions;
      },

      getCursorPosition : function(x,y) {
        var dimensions;

        // check for base
        if (this.drawBase) {
          dimensions = this.base.dimensions;
          if (x < dimensions.left + dimensions.width) {
            return this.base.getCursorPosition(x,y);
          }
        } 

        // check for middle
        dimensions = this.middle.dimensions;
        if (! this.drawBase) {
          if (x < dimensions.left) {
            return { row: this.parent, index: this.index };
          }
        }
        if (x < dimensions.left + dimensions.width) {
          return this.middle.getCursorPosition(x,y);
        }
        return { row: this.parent, index: this.index };
      },

      getFollowingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          if (this.drawBase) {
            return this.base.getFollowingCursorPosition();
          } else {
            return this.middle.getFollowingCursorPosition();
          }
        }
        
        var result = null;

        if (index === 0) {
          if (descend) {
            if (this.drawBase) {
              result = this.base.getFollowingCursorPosition();
            } else {
              return this.middle.getFollowingCursorPosition();
            }
          }
          if (result === null) {
            result = this.middle.getFollowingCursorPosition();
          }
        }

        if (result === null) {
          // when we're at the end of the matrix, ask the parent of the matrix
          // for the position following this matrix
          if (this.parent !== null) {
            return this.parent.getFollowingCursorPosition(this.index, false);
          }
        }
        
        return result;
      },
      getPrecedingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          return this.middle.getPrecedingCursorPosition();
        }
        
        var result = null;

        if (index == 1) {
          if (descend) {
            result = this.middle.getPrecedingCursorPosition();
          }
          if (result === null) {
            if (this.drawBase) {
              result = this.base.getPrecedingCursorPosition();
            }
          }
        }

        if (result === null) {
          // when we're at the beginning of the matrix, ask the parent of the
          // matrix for the position before this matrix
          if (this.parent !== null) {
            return { row: this.parent, index: this.index };
          }
        }
        
        return result;
      },
      initialize : function () {
        if (arguments.length>0) {
          this.leftBracket = 
            new org.mathdox.formulaeditor.presentation.Bracket("v");
          this.middle = arguments[0];
          this.base = arguments[1];
          this.children = [];
          this.children.push(this.base);
          this.children.push(this.middle);
        } else {
          this.children = [];
        }

        var presentation = org.mathdox.formulaeditor.presentation;
        /* copy the cursor/position functions from Row */

        var row = new presentation.Row(); // only an instance has the functions

        for (var i=this.functionsFromRow.length - 1; i>=0; i--) {
          if (! this[this.functionsFromRow[i]] ) {
            this[this.functionsFromRow[i]] = 
              row[ this.functionsFromRow[i] ];
          }
        }

        /* check if the base should be displayed */
        this.drawBase = this.drawBaseQ();

        this.updateChildren();
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        var result;
        if (this.children.length == 2) {
          result = this.clone(this.children[1].copy(), this.children[0].copy());
        } else {
          result = this.clone();
        }
        return result;
      },

      getSemantics : function(context) {
        var root;

        var semantics = org.mathdox.formulaeditor.semantics;
        root = new semantics.Arith1Root(this.middle.getSemantics(context).value, 
          this.base.getSemantics(context).value);
        return {
          value : root,
          rule  : "braces"
        };
      }


    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Row.js");

//$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/BlockSymbol.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/SuperscriptSymbol.js");

$main(function(){

  /**
   * Representation of a row of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Node, {

      initialize : function() {

        var SuperscriptSymbol = org.mathdox.formulaeditor.presentation.SuperscriptSymbol;
        var Symbol = org.mathdox.formulaeditor.presentation.Symbol;
        var BlockSymbol = org.mathdox.formulaeditor.presentation.BlockSymbol;
        var i; // counter

        if (arguments.length == 1 && typeof(arguments[0]) == "string") {
          var string = arguments[0];
          var array = [];
          for (i=0; i<string.length; i++) {
            array.push(this.newSymbol(string.charAt(i)));
          }
          return arguments.callee.parent.initialize.apply(this, array);
        }
        else {
          var children = Array.prototype.slice.call(arguments);

          if (children.length === 0) {
            children = [];
            children.push(null);
          }

          for (i=0; i<children.length; i++) {
            // an "empty" box is a symbol with the empty string
            if ((children[i] === null) || (children[i] === undefined)) {
              children[i] = new BlockSymbol();
            }
          }
          return arguments.callee.parent.initialize.apply(this, children);
        }

      },

      /**
       * Draws the row to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {

        if (this.children.length > 0) {

          // use following variables to maintain track of the bounding rectangle
          var left   = x;
          var top    = y;
          var right  = x;
          var bottom = y;


          // go through all child nodes in the row
          for (var i=0; i<this.children.length; i++) {

            var child = this.children[i];

            // draw the current child node
            var dimensions = child.draw(canvas, context, right, y, invisible);

            // update the dimensions of the bounding rectangle
            left   = Math.min(left, dimensions.left);
            top    = Math.min(top, dimensions.top);
            right  = Math.max(right, dimensions.left + dimensions.width);
            bottom = Math.max(bottom, dimensions.top + dimensions.height);

          }

          // return information about the bounding rectangle
          this.dimensions = {
            left:   left,
            top:    top,
            width:  right - left,
            height: bottom - top
          };

          return this.dimensions;

        }
        else {
          var fontSizeModifier = 0;
          if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
            fontSizeModifier = context.fontSizeModifier;
          }

          this.dimensions = canvas.drawFBox(x, y, true, null, null, fontSizeModifier);

          if (!invisible && this.parent) {
            canvas.drawFBox(x, y, invisible);
          }

          return this.dimensions;

        }

      },

      /**
       * Returns the MathML presentation of the node.
       */
      getMathML: function(mrow) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var result = [];
        var mode = "none";
        var newmode = "none";
        var arg = [];

        /* for all children add the corresponding mathml */
        /* TODO: do tricks for mi/mo/mn */

        var i;

        for (i = 0; i < this.children.length; i++) {
          if (this.children[i] instanceof presentation.Symbol) {
            newmode = "symbol";
          } else {
            newmode = "none";
          }

          if (newmode != mode) {
            if (mode != "none") {
              // TODO: do magic stuff
              // add result to result var
              arg = [];
            }
            if (newmode != "none") {
              arg = [];
            }
          } 
          if (newmode == "none") {
            result.push(this.children[i].getMathML());
          } else { // mode = "symbol"
            arg.push(this.children[i].value);
          }

          mode = newmode;
        }

        /**
         * wrap in mrow when not implicit
         * if length is 1, then skip (already 1 term, no row needed)
         */
        if (mrow !== undefined && mrow !== null && mrow === true && result.length != 1) {
          result = "<mrow>" + result.join("") + "</mrow>";
        } else {
          result = result.join("");
        }
      },

      /**
       * Generates a symbol in the correct style
       */
      newSymbol: function(character) {
	var SuperscriptSymbol = org.mathdox.formulaeditor.presentation.SuperscriptSymbol;
	var Symbol = org.mathdox.formulaeditor.presentation.Symbol;

        if (character == " ") {
          // spaces do not have a value
          return new Symbol([""," "]);
        } else if (((character >= 'a') && (character <='z'))||
                   ((character >= 'A') && (character <='Z'))) {
          return new Symbol(character, "math");
        } else if (character == "'" || character =="′" ) {
          // quote or U+2032 prime
          return new SuperscriptSymbol(character);
        } else {
          return new Symbol(character);
        }
      },

      /**
       * Handles an onkeydown event from the browser. Returns false when the
       * event has been handled and should not be handled by the browser,
       * returns true otherwise.
       */
      onkeydown : function(event, editor) {

        // only handle keypresses where alt, ctrl and shift are not held
        if (!event.altKey && !event.ctrlKey && !event.shiftKey) {

          // handle backspace and delete
          switch(event.keyCode) {

            case  8: // backspace
              var position = editor.cursor.position;
              if (position.index > 0) {
                // test if we should delete
                var del = this.children[position.index - 1].deleteItem();

                if (del) {
                  this.remove(position.index - 1);
                  position.index--;
                  // after deleting the last character, add a new input box
                  if (this.isEmpty()) {
                    this.insert(0);
                  }
                }
                editor.redraw();
                editor.save();
              }
              return false;

            case 46: // delete
              var position = editor.cursor.position;
              if (position.index <this.children.length) {
                // test if we should delete
                var del = this.children[position.index].deleteItem();

                if (del) {
                  this.remove(position.index);
                  // after deleting the last character, add a new input box
                  if (this.isEmpty()) {
                    this.insert(0);
                  }
                }
                editor.redraw();
                editor.save();
              }
              return false;
          }
        }

        // pass the event back to the browser
        return true;

      },

      /**
       * Handles an onkeypress event from the browser. Returns false when the
       * event has been handled and should not be handled by the browser,
       * returns true otherwise.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          var canvas    = editor.canvas;
          var fontName  = canvas.fontName;
          var fontSize  = canvas.fontSize;
          var character = String.fromCharCode(event.charCode);

          // XXX enter, fire DOMActivate event in the future
          if (event.charCode == 13) {
            return false;
          }

          // see whether there is a character for pressed key in current font
          if (canvas.getSymbolData(character)) {

            var moveright;

            // insert the character into the row, and move the cursor
	    moveright = this.insert(editor.cursor.position.index,
	      this.newSymbol(character));

            if (moveright) {
              editor.cursor.moveRight();
            }

            editor.redraw();
            editor.save();
            return false;

          }

        }

        // pass the event back to the browser
        return true;

      },

      /**
       * Flattens this row, meaning that all child nodes that are rows
       * themselves will be embedded into this row.
       */
      flatten : function() {

        var Row = org.mathdox.formulaeditor.presentation.Row;

        // call flatten on the child nodes
        arguments.callee.parent.flatten.apply(this);

        // go through all children
        var children = this.children;
        for (var i=0; i<children.length; i++) {
          var child = children[i];

          // check whether the child is a row
          if (child instanceof Row) {
            // insert the child node's children into the list of children
            children.splice.apply(children, [i,1].concat(child.children));
          }

        }
        this.updateChildren();

      },

      getCursorPosition : function(x, y) {

        var count = this.children.length;
        for (var i=0; i<count; i++) {
          var dimensions = this.children[i].dimensions;
          if (x < dimensions.left + dimensions.width || i == count - 1) {
            return this.children[i].getCursorPosition(x,y);
          }
        }

        return { row: this, index: 0 };

      },

      getFirstCursorPosition : function(index) {
        if (index === null || index === undefined || index > 0) {
          return this.getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return this.parent.getFirstCursorPosition();
          }
          else {
            return null;
          }
        }
      },

      getLastCursorPosition : function(index) {
        if (index === null || index === undefined ||
            index < this.children.length) {
          return this.getPrecedingCursorPosition();
        }
        if (this.parent !== null) {
          return this.parent.getLastCursorPosition();
        }
        else {
          return null;
        }
      },

      /**
       * Returns the cursor position following the specified index.
       * See also Node.getFollowingCursorPosition(index).
       */
      getFollowingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in this row
        if (index === null || index === undefined) {
          return { row : this, index : 0 };
        }

        // ask the child at the specified index for the cursor position
        if (index < this.children.length) {
          var result = null;
          if (descend) {
            result = this.children[index].getFollowingCursorPosition();
          }
          if (result === null) {
            // when the child can not provide a cursor position, shift the
            // cursor one position in this row
            result = { row : this, index : index + 1 };
          }
          return result;
        }

        // when we're at the end of the row, ask the parent of the row for the
        // position following this row
        if (this.parent !== null) {
          return this.parent.getFollowingCursorPosition(this.index, false);
        }

        // no suitable cursor position could be found
        return null;

      },

      getPrecedingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the last position in this row
        if (index === null || index === undefined) {
          return { row : this, index : this.children.length };
        }

        // ask the child at the specified index for the cursor position
        if (index > 0) {
          var result = null;
          if (descend) {
            result = this.children[index-1].getPrecedingCursorPosition();
          }
          if (result === null) {
            // when the child can not provide a cursor position, shift the
            // cursor one position in this row
            result = { row : this, index : index - 1 };
          }
          return result;
        }

        // when we're at the beginning of the row, ask the parent of the row for
        // the position preceding this row
        if (this.parent !== null) {
          return this.parent.getPrecedingCursorPosition(this.index, false);
        }

        // no suitable cursor position could be found
        return null;

      },

      getLowerCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          var minimumDistance = null;
          var bestIndex = 0;
          for (var i=0; i<=this.children.length; i++) {
            var left;
            if (i<this.children.length) {
              left = this.children[i].dimensions.left;
            }
            else {
              if (this.children.length > 0) {
                var dimensions = this.children[this.children.length-1].dimensions;
                left = dimensions.left + dimensions.width;
              }
              else {
                left = this.dimensions.left;
              }
            }
            var distance = Math.abs(left-x);
            if (minimumDistance === null || distance < minimumDistance) {
              minimumDistance = distance;
              bestIndex = i;
            }
          }
          if (this.children[bestIndex] !== null &&
            this.children[bestIndex] !== undefined) {
            return this.children[bestIndex].getLowerCursorPosition(null, x);
          }
          else {
            return { row: this, index : bestIndex };
          }
        }
        else {
          return this.parent.getLowerCursorPosition(this.index, x);
        }
      },

      getHigherCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          var minimumDistance = null;
          var bestIndex = 0;
          for (var i=0; i<=this.children.length; i++) {
            var left;
            if (i<this.children.length) {
              left = this.children[i].dimensions.left;
            }
            else {
              if (this.children.length > 0) {
                var dimensions = this.children[this.children.length-1].dimensions;
                left = dimensions.left + dimensions.width;
              }
              else {
                left = this.dimensions.left;
              }
            }
            var distance = Math.abs(left-x);
            if (minimumDistance === null || distance < minimumDistance) {
              minimumDistance = distance;
              bestIndex = i;
            }
          }
          if (this.children[bestIndex] !== null &&
            this.children[bestIndex] !== undefined) {
            return this.children[bestIndex].getHigherCursorPosition(null, x);
          }
          else {
            return { row: this, index : bestIndex };
          }
        }
        else {
          return this.parent.getHigherCursorPosition(this.index, x);
        }
      },

      isEmpty : function() {
        return (this.children.length === 0);
      },

      insert : function(index, node, fillempty) {
        var BlockSymbol = org.mathdox.formulaeditor.presentation.BlockSymbol;
        var newindex = index;
        var moveright = true;

        if ((fillempty === null) || (fillempty === undefined)) {
          fillempty = true;
        }
        if ((node === null) || (node === undefined)) {
          node = new BlockSymbol();
        }

        if (fillempty && index<=this.children.length &&
          this.children[index] instanceof BlockSymbol) {
          this.children.splice(index, 1, node);
        } else if (fillempty && index-1>=0 &&
            this.children[index-1] instanceof BlockSymbol) {
          this.children.splice(index-1, 1, node);
          newindex = index - 1;
          moveright = false; // do not move right after inserting now
        } else {
          this.children.splice(newindex, 0, node);
        }
        this.updateChildren(newindex);

        //alert("index:"+index+" -> "+newindex+"\nmoveright: "+moveright);
        return moveright;
      },

      replace : function(index, node) {
        this.children.splice(index, 1, node);
        this.updateChildren(index);
      },

      remove : function(begin, end) {
        var result;
        if (end === null || end === undefined) {
          result = this.children[begin];
          this.children.splice(begin, 1);
          this.updateChildren(begin);
          return result;
        }
        else {
          result = new org.mathdox.formulaeditor.presentation.Row();
          result.initialize.apply(result, this.children.splice(begin, end-begin));
          this.updateChildren(begin);
          return result;
        }
      },

      getSemantics : function(context, begin, end, start, backward) {

        // assign default values to parameters
        if (begin    === null || begin    === undefined ) {
          begin    = 0;
        }
        if (end      === null || end      === undefined ) {
          end      = this.children.length;
        }
        if (start    === null || start    === undefined) {
          start    = "start";
        }
        if (backward === null || backward === undefined) {
          backward = false;
        }

        // use the expressionparser to parse the elements of the row
        var ContextParser;
        ContextParser = org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser;

        var Parser;
        Parser = new ContextParser().getParser(context); //for now use empty context

        // create the input for the parser by serializing the row elements
        var input = "";
        // array to adjust for spaces (which have no semantics)
        var originalIndex = new Array();
        // adjust the index for the begin (XXX: shouldn't be necessary)
        originalIndex[begin] = begin;
        // counting spaces so far
        var adjustIndex = 0;

        // go through the row elements
        var children = this.children;
        for (var i=begin; i<end; i++) {

          // start a new variable scope
          (function(){

            // act differently based on the type of the row element
            var child = children[i];
            if (child instanceof org.mathdox.formulaeditor.presentation.Symbol) {

              // if the row element is a symbol, add its value to input string
              input = input + child.value;

              if (child.value == "") {
                // special case: space, count it
                adjustIndex=adjustIndex+1;
              }
            }
            else {

              // record the index of this row element in the parser input string
              var inputindex = input.length;

              // add a dummy to the input string
              input = input + '#';

              // retrieve the semantic tree node that represents the row element
              var semantics = child.getSemantics(context);

              // extend the parser so that it will parse the dummy into the
              // correct semantic tree node
              var extension = {};
              extension[semantics.rule] =
                function(context, index, result, continuation) {

                  var parent = arguments.callee.parent;

                  if (!context.backward && index == inputindex) {
                    continuation(index+1, result.concat([semantics.value]));
                  }
                  else if(context.backward && index - 1 == inputindex) {
                    continuation(index-1, [semantics.value].concat(result));
                  }
                  else {
                    parent[semantics.rule](context, index, result, continuation);
                  }

                };

              Parser = $extend(Parser, extension);

            }

          })();

          // adjust the index for this position
          originalIndex[i] = i + adjustIndex;
        }
        // adjust the index for the end
        originalIndex[end] = end + adjustIndex;

        // use the constructed parser and input to parse the row
        var parsebegin = backward ? input.length : 0           ;
        var parseend   = backward ? 0            : input.length;
        var parsed = new Parser().parse(input, parsebegin, backward, start);

        // return the result of parsing
        return {
          value : parsed.index == parseend ? parsed.value : null,
          index : originalIndex[parsed.index + begin],
          rule  : "braces"
        };

      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Subscript.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Represents a subscript expression.
   */
  org.mathdox.formulaeditor.presentation.Subscript =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      onBaseline : false,

      draw : function(canvas, context, x, y, invisible) {

        var subscript = this.children[0];

        var dim0;
        var presentation = org.mathdox.formulaeditor.presentation;

        var modifiedContext = { fontSizeModifier : 0 };
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.fontSizeModifier = modifiedContext.fontSizeModifier - 1;

        if (this.parent instanceof presentation.Row && this.index > 0) {
          dim0 = this.parent.children[this.index - 1].dimensions;
        }
        else {
          dim0 = new presentation.Symbol("x").draw(canvas,modifiedContext,x,y,true);
          dim0.left = x - dim0.width;
        }

        var tmp = subscript.draw(canvas,modifiedContext,0,0,true);

        var dim1 = subscript.draw(
          canvas, modifiedContext,
          dim0.left + dim0.width,
          dim0.top + dim0.height - tmp.top,
          invisible);

        var left   = dim1.left;
        var top    = Math.min(dim0.top,  dim1.top );
        var right  = dim1.left + dim1.width;
        var bottom = Math.max(dim0.top  + dim0.height, dim1.top  + dim1.height);

        this.dimensions = {
          left   : left,
          top    : top,
          width  : right - left,
          height : bottom - top
        };

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        return this.children[0].getCursorPosition(x,y);

      },

      getFollowingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index + 1 };
          }
          else {
            return null;
          }
        }
      },

      getPrecedingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index };
          }
          else {
            return null;
          }
        }
      },

      getSemantics : function(context) {
        return {
          value : this.children[0].getSemantics(context).value,
          rule  : "subscript"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Superscript.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Represents a superscript expression.
   */
  org.mathdox.formulaeditor.presentation.Superscript =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      slowDelete : true,
      onBaseline : false,

      draw : function(canvas, context, x, y, invisible) {

        var superscript = this.children[0];

        var dim0;
        var presentation = org.mathdox.formulaeditor.presentation;

	var modifiedContext = { fontSizeModifier : 0 };
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.fontSizeModifier = modifiedContext.fontSizeModifier - 1;

	/*
	 * Find a character earlier in the row on the baseline
	 */
        var index = 0;
	var xdim0, ydim0;
        if (this.parent instanceof presentation.Row) {
          index = this.index -1;
	  if (index>=0) { 
            xdim0 = this.parent.children[index].dimensions;
	  }
          while (index>0 && this.parent.children[index].onBaseline !== true) {
            index--;
	  }
        }

        if (index >= 0) {
	  //console.log("on baseline: "+this.parent.children[index].onBaseline);
          ydim0 = this.parent.children[index].dimensions;
	  dim0 = {
            left: xdim0.left,
            top: ydim0.top,
            width: xdim0.width,
            height: ydim0.height
	  }
        }
        else {
          dim0 = new presentation.Symbol("x").draw(canvas,modifiedContext,x,y,true);
          dim0.left = x - dim0.width;
        }

        var tmp = superscript.draw(canvas,modifiedContext,0,0,true);

        // warning drawing twice, should be possible to combine first dim1 with tmp
        var dim1 = superscript.draw(
          canvas,modifiedContext,
          dim0.left + dim0.width,
          dim0.top - (tmp.height + tmp.top),
          true);

        var left   = dim1.left;
        var top    = Math.min(dim0.top,  dim1.top );
        var right  = dim1.left + dim1.width;
        var bottom = Math.max(dim0.top  + dim0.height, dim1.top  + dim1.height);

        this.dimensions = {
          left   : left,
          top    : top,
          width  : right - left,
          height : bottom - top
        };

        if (invisible === false || invisible === null || invisible === undefined) {
          this.drawHighlight(canvas, invisible);
          // warning drawing twice
          superscript.draw(
            canvas,modifiedContext,
            dim0.left + dim0.width,
            dim0.top - (tmp.height + tmp.top),
            invisible);
        }

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        return this.children[0].getCursorPosition(x,y);

      },

      getFollowingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index + 1 };
          }
          else {
            return null;
          }
        }
      },

      getPrecedingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index };
          }
          else {
            return null;
          }
        }
      },

      getSemantics : function(context) {
        return {
          value : this.children[0].getSemantics(context).value,
          rule  : "superscript"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/SuperscriptSymbol.js");

$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  var presentation = org.mathdox.formulaeditor.presentation;

  /**
   * Representation of a mathematical symbol that is always displayed as
   * superscript (like prime, U+2032, 
   */
  org.mathdox.formulaeditor.presentation.SuperscriptSymbol =
    $extend(org.mathdox.formulaeditor.presentation.Symbol, {
      onBaseline : false,

      children : null,

      initialize: function() {
        // call parent initilialization
        arguments.callee.parent.initialize.apply(this, arguments);

        // set this.children[0] for Superscript-draw
        if (this.value !== undefined && this.value !== null) {
          this.children = [];
          this.children.push(new presentation.Symbol(this.value));
        }
      },

      // use the draw function from Superscript
      draw: presentation.Superscript.prototype.draw
    });

});


  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Symbol.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

$main(function(){

  /**
   * Representation of a mathematical symbol (number, letter, operator) in the
   * presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Symbol =
    $extend(org.mathdox.formulaeditor.presentation.Node, {

      /**
       * A string representation of the symbol.
       */
      value : null,
      /**
       * A string representation of the symbol for on the screen
       */
      onscreen : null,
      /**
       * The typeface (currently supported: math, which means display as
       * slanted if possible)
       */
      typeface : null,

      /**
       * Initializes a Symbol node in the presentation tree using the specified
       * string representation of a symbol.
       */
      initialize : function() {
        
        if (arguments.length > 0) {
          if (arguments[0] instanceof Array) {
            this.value = arguments[0][0];
            if (arguments[0].length > 1) {
              this.onscreen = arguments[0][1];
            }
          } else {
            this.value = arguments[0];
          }
	  var aliases = org.mathdox.formulaeditor.presentation.SymbolAliases;

	  if (aliases[this.value] !== undefined && aliases[this.value] !== null) {
            this.value = aliases[this.value];
	  }
        }
        if (arguments.length > 1) {
          this.typeface = arguments[1];
        }
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        var result;
        var arg0;

        if (this.onscreen !== null) {
          arg0 = [ this.value, this.onscreen ];
        } else {
          arg0 = this.value;
        }

        if (this.typeface !== null) {
          result = this.clone(arg0, this.typeface);
        } else {
          result = this.clone(arg0);
        }
  
        return result;
      },

      /**
       * Draws the symbol to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var symbol = this.value;
        if (this.onscreen !== null) {
          symbol = this.onscreen;
        }
       
        var fontSizeModifier = 0;
        if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
          fontSizeModifier = context.fontSizeModifier;
        }

        this.dimensions = canvas.drawSymbol(
          symbol, Math.round(x), Math.round(y), invisible, this.typeface, 
          fontSizeModifier);

        return this.dimensions;

      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

$main(function(){
  org.mathdox.formulaeditor.presentation.SymbolAliases = {
    // U+2062 invisible times -> '' empty string
    '⁢': null,
    // U+2064 invisible plus -> '' empty string
    '⁤' : null,
    // U+2217 asterisk operator -> U+002A asterisk
    '∗' : '*',
    // U+22C5 dot operator -> U+00B7 middle dot
    '⋅' : '·',
    // quote -> U+2032 [superscript] prime
    "'" : '′'
  };
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Vector.js");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Vector =
    $extend(org.mathdox.formulaeditor.presentation.Bracketed, {
      // variable to store the array to get the semantics
      entries : null,

      initialize : function () {
        var presentation = org.mathdox.formulaeditor.presentation;
        var leftBracket = new presentation.Bracket('(');
        var rightBracket = new presentation.Bracket(')');

        this.middle = new presentation.Column();
        this.middle.initialize.apply(this.middle,arguments);
        this.middle.margin = 10.0;

        arguments.callee.parent.initialize.call(this, leftBracket, 
          this.middle, rightBracket);
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        return this.clone.apply(this, this.copyArray(this.middle.children));
      },

      getSemantics : function(context) {
        var semanticEntries;
        var vector;

        var semantics = org.mathdox.formulaeditor.semantics;
        semanticEntries = [];
        for (var i=0;i<this.middle.children.length;i++) {
          semanticEntries.push(this.middle.children[i].getSemantics(context).value);
        }
        vector = new semantics.Linalg2Vector();
        vector.initialize.apply(vector, semanticEntries);

        return {
          value : vector,
          rule  : "braces"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/FunctionApplication.js");

$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary function application.
   */
  org.mathdox.formulaeditor.semantics.FunctionApplication =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The operands of the operation.
       */
      operands: null,
      
      /**
       * Information about the style
       * style="sub" means presentation should be subscript
       */
      style: null,
      /**
       * Information about the symbol that is used to represent this operation.
       */
      symbol: null,

      /**
       * Initializes the operation using the specified arguments as operands.
       */
      initialize : function(symbol, operands, style) {
        this.symbol = symbol;
        this.operands = operands;
        if (style !== undefined) {
          this.style = style;
        }
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;
        var semantics = org.mathdox.formulaeditor.semantics;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var pres = {}
        pres.array = [];

        var bracketed;

        var style = this.style;

        if ( (context.styleTransc1Log == "postfix") && 
            (this.symbol instanceof semantics.Keyword) && 
            (this.symbol.cd == "transc1") && (this.symbol.name == "log") ) {
          style = "firstsub";
        } else if ( (context.styleTransc1Log == "prefix") && 
            (this.symbol instanceof semantics.Keyword) && 
            (this.symbol.cd == "transc1") && (this.symbol.name == "log") ) {
          style = "firstsuper";
        }

        if (this.symbol instanceof semantics.MultaryOperation) {
          this.addPresentationBracketOpen(context, pres, "(");
        }
        if (style != "firstsuper") {
          pres.array.push(this.symbol.getPresentation(context));
        }
        if (this.symbol instanceof semantics.MultaryOperation) {
          this.addPresentationBracketClose(context, pres, ")");
        }
        if (style != "sub" && style != "firstsub" && style != "firstsuper") {
          // no brackets in subscript style "sub" or if the first argument is
          // handled differently
          this.addPresentationBracketOpen(context, pres, "(");
        }
        for (var i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
	  var sym;
          if (i>0) {
            sym = new presentation.Symbol(context.listSeparator);
            if (style == "sub") {
              // subscript style
              pres.array.push(new presentation.Subscript(sym));
              // first subscript (after the symbol)
            } else if ((style == "firstsub" ||style == "firstsuper") && i==1) {
              this.addPresentationBracketOpen(context, pres, "(");
            } else if (style == "firstsuper" && i==0) {
              // first superscript (before the symbol); 
              // print nothing yet
            } else {
              // normal style
              pres.array.push(sym);
            }
          }
          
          if (!operand) {
            alert("symbol: "+this.symbol.symbol.onscreen);
            alert("operands.length: "+this.operands.length);
            alert("operands[0]: "+this.operands[0]);
            alert("operands[1]: "+this.operands[1]);
          }
          sym = operand.getPresentation(context);
          if (style == "sub") {
            // subscript style
            pres.array.push(new presentation.Subscript(sym));
          } else if (style == "firstsub" && i==0) {
            pres.array.push(new presentation.Subscript(sym));
          } else if (style == "firstsuper" && i==0) {
            pres.array.push(new presentation.Superscript(sym));
              pres.array.push(this.symbol.getPresentation(context));
          } else {
            // normal style
            pres.array.push(sym);
          }
        }
        
        if (style != "sub") {
          // no brackets in subscript style "sub"
          this.addPresentationBracketClose(context, pres, ")");
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, pres.array);

        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {
        var semantics = org.mathdox.formulaeditor.semantics;
        var result;

        /* check number of arguments */
        if (this.symbol instanceof semantics.Keyword) {
          var argtest = this.symbol.checkArguments(this.operands);

          if (typeof argtest === "string") {
            result = "<OME><OMS cd='moreerrors' name='encodingError'/>";
            result += "<OMSTR>invalid expression entered: "+ argtest+"</OMSTR>";
            result += "</OME>";
            return result;
          }
          /* otherwise: everything is fine; continue */
        }

        if (this.style !== null) {
          result = "<OMA style='"+this.style+"'>";
        } else {
          result = "<OMA>";
        }

        result += this.symbol.getOpenMath();
        for (var i=0; i<this.operands.length; i++) {
          result = result + this.operands[i].getOpenMath();
        }
        result = result + "</OMA>";

        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {

        var result = "<mrow>" + this.symbol.getMathML() + "<mo>(</mo>";

        for (var i=0; i<this.operands.length; i++) {
          if (i>0) {
            result = result + "<mo>,</mo>";
          }
          result = result + this.operands[i].getMathML();
        }
        result = result + "<mo>)</mo>" + "</mrow>";

        return result;

      }

    });

});

  $package("org/mathdox/formulaeditor/semantics");

$identify("org/mathdox/formulaeditor/semantics/Integer.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){

  /**
  * Representation of an integer in the semantic tree.
  */
  org.mathdox.formulaeditor.semantics.Integer =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The integer value.
       */
      value : null,

      /**
       * Initializes a semantic tree node to represent an integer with the
       * specified value.
       */
      initialize : function(value) {
	// check for allowed types
	// 1: integer
	if (value === undefined || value === null) {
          this.value = 0;
	} else {
	  if (! ((typeof value == "number") || (typeof value == "object" && value.rule == "bigint"))) {
            console.log("MFE WARNING: integer object created with unknown type "+(typeof value));
	  }
	  this.value = value;
	}

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var string = this.value.toString();
        var symbols = [];

        for (var i=0; i<string.length; i++) {
          symbols[i] = new presentation.Symbol(string.charAt(i));
        }

        var result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMI>" + this.getValueAsString() + "</OMI>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        return "<mn>" + this.getValueAsString() + "</mn>";
      },

      getValueAsString: function() {
	if (typeof this.value == "number") {
	  return this.value.toString();
	} else if (typeof this.value == "string") { 
          console.log("MFE WARNING: found integer with unexpected type: string");
	  return this.value;
	} else if (typeof this.value == "object" && this.value.rule == "bigint") {
	  // bigint encoding, value.value is the string representation
	  return this.value.value;
	} else { // unknown type
          console.log("MFE ERROR: integer of unknown type");
	  return this.value.toString();
	}
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/Keyword.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of a keyword.
   */
  org.mathdox.formulaeditor.semantics.Keyword =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * Information about the symbol that is used to represent this keyword.
       */
      symbol : {

        /**
         * The symbol(s) that is/are used for rendering the keyword to the
         * screen.
         */
        onscreen : null,

        /**
         * The OpenMath symbol that is associated with this operation.
         */
        openmath : null,

        /**
         * The MathML representation of this operation.
         */
        mathml   : null

      },

      getSymbolOnscreen : function(context) {
        if (this.symbol.onscreen !== undefined) {
          return this.symbol.onscreen;
        } else {
          return null;
        }
      },

      /**
       * Initializes the keyword using the specified arguments as operands.
       * type should be one of the following strings:
       *
       * "constant" : constant like nums1.pi which probably cannot have
       *    arguments 
       * "function" : function like transc1.sin which probably should have
       *    arguments
       * "infix"    : infix operator like arith1.plus which can only occur
       *    without arguments in special places like an editor1.palette_row
       * "unary"    : unary operator like logic.not which can only occur
       *    without arguments in special places like an editor1.palette_row
       * "type"     : function or symbol
       * "argcount": number of arguments for a function
       */
      initialize : function(cd,name,symbol,type,argcount) {
        this.cd = cd;
        this.name = name;
        this.type = type;

        if (argcount!==null && argcount!== undefined) {
          this.argcount = argcount;
        } else {
          this.argcount = null;
        }

        if (symbol) {
          this.symbol = {};
          if (symbol.onscreen) {
            this.symbol.onscreen = symbol.onscreen;
          }
          if (symbol.openmath) {
            this.symbol.openmath = symbol.openmath;
          }
          if (symbol.mathml) {
            this.symbol.mathml = symbol.mathml;
          }
        }
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var string;
        var symbolOnscreen = this.getSymbolOnscreen(context);
	var result;

        // XXX make case distinction for U+25A1 white square 
        // to become BlockSymbol
        if (symbolOnscreen !== null && symbolOnscreen !== undefined) {
          // U+25A1 white square
          if (symbolOnscreen == '□') {
            if (context.inPalette === true && 
              (context.inMatrix === true || context.inVector === true)
            ) {
              return new presentation.Row(new presentation.BlockSymbol(','));
            } else {
              return new presentation.Row(new presentation.BlockSymbol());
            }
          } else if (symbolOnscreen === '') {
            if (context.inPalette === true) {
              string=" ";
            } else {
              string=" ";
            }
          } else if (symbolOnscreen instanceof Array) {
            var arr = [];

            if (symbolOnscreen[0] != "") {
              arr.push(new presentation.Symbol(symbolOnscreen[0]));
            }
            if (symbolOnscreen[0] != "" && symbolOnscreen[2]!= "") {
              arr.push(new presentation.BlockSymbol());
            }
            if (symbolOnscreen[2] != "") {
              arr.push(new presentation.Symbol(symbolOnscreen[2]));
            }
            result = new presentation.Row();

            result.initialize.apply(result, arr);
            return result;
	  } else {
            string = symbolOnscreen.toString();
          }
        } else {
          string = (this.cd + "." + this.name).toString();
        }

        var symbols = [];

        for (var i=0; i<string.length; i++) {
          symbols[i] = new presentation.Symbol(string.charAt(i));
        }

        result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {
        var result;
        
        if (this.symbol.openmath !== null && this.symbol.openmath !== undefined) {
          result = this.symbol.openmath;
        } else {
          result = "<OMS cd='" + this.cd + "' name='" + this.name + "'/>";
        }
        return result;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {
        var result;
        
        if (this.symbol.mathml !== null) {
          result = this.symbol.mathml;
        } else if (this.symbol.onscreen !== null) {
          result = "<mi>" + this.symbol.onscreen + "</mi>";
        } else {
          result = "<mi>" + this.cd + "." + this.name + "</mi>";
        }

        return result;
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/Lambda.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary function application.
   */
  org.mathdox.formulaeditor.semantics.Lambda =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The expression 
       */
      expression: null,

      /**
       * The bound variables of the lambda expression
       */
      variables: [],

      /**
       * Initializes the operation using the specified arguments as operands.
       */
      initialize : function() {
        var variables;
        var expression;

        if (arguments.length === 0) {
          // no arguments 
          variables = [];
          expression = null;
        } else if (arguments.length == 1) {
          // one arguments -> only expression
          variables = [];
          expression = arguments[0];
        } else if (arguments.length == 2) {
          // two arguments -> variable [array] and expression
          if (arguments[0] instanceof Array) {
            variables = arguments[0];
          } else {
            variables = [];
            variables.push(arguments[0]);
          }
          expression = arguments[1];
        } else if (arguments.length > 2) {
          // more than two arguments -> variables and expression
          variables = argument.slice(0, arguments.length -2);
          expression = arguments[arguments.length - 1];
        }

        this.variables = variables;
        this.expression = expression;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // WITH Operator symbols
        var array = [];
        var pres;
        var i; // counter

        // U+03BB greek small letter lamda
        array.push(new presentation.Symbol("λ"));
        if (this.variables.length == 1) {
          array.push(this.variables[0].getPresentation(context));
        } else {
          array.push(new presentation.Symbol("("));
          for (i=0; i<this.variables.length; i++) {
            if (i>0) {
              array.push(new presentation.Symbol(","));
            }
            array.push(this.variables[i].getPresentation(context));
          }
          array.push(new presentation.Symbol(")"));
        }

        array.push(new presentation.Symbol("."));
        array.push(new presentation.Symbol("("));
        array.push(this.expression.getPresentation(context));
        array.push(new presentation.Symbol(")"));

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);

        return result;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {

        var result = [];
        var i; // counter
        
        result.push("<OMBIND>");
        result.push("<OMS cd='fns1' name='lambda'/>");
        
        // bound variables
        result.push("<OMBVAR>");

        for (i=0; i<this.variables.length; i++) {
          result.push(this.variables[i].getOpenMath());
        }

        result.push("</OMBVAR>");

        // expression
        result.push(this.expression.getOpenMath());

        result.push("</OMBIND>");

        return result.join("");
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {
        var result = [];
        result.push("<mrow>");
        // U+03BB greek small letter lamda
        result.push("<mo>λ</mo>");

        if (this.variables.length == 1) {
          result.push(this.variables[0].getMathML());
        } else {
          result.push("<mo>(</mo>");
          for (i=0; i<this.variables.length; i++) {
            if (i>0) {
              result.push("<mo>,</mo>");
            }
            result.push(this.variables[i].getMathML());
          }
          result.push("<mo>)</mo>");
        }
        result.push("</mrow>");

        return result.join("");

      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary infix operation.
   */
  org.mathdox.formulaeditor.semantics.MultaryListOperation =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var array = [];
        var i;
        if (this.style != "invisible" && this.symbol.onscreen instanceof Array) {
          if (this.symbol.onscreen[0]!=="") {
            array.push(new presentation.Row(this.symbol.onscreen[0]));
          }
        }
        for (i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
          if (i>0 && this.style != "invisible" ) {
            if (this.symbol.onscreen instanceof Array) {
              // NOTE: use listSeparator
              array.push(new presentation.Row(context.listSeparator));
            }
            else {
              array.push(new presentation.Row(this.symbol.onscreen));
            }
          }
          if (operand.getPrecedence && operand.getPrecedence(context) != 0 && operand.getPrecedence(context) < this.getPrecedence(context)) {
            array.push(new presentation.Symbol("("));
            array.push(operand.getPresentation(context));
            array.push(new presentation.Symbol(")"));
          }
          else {
            array.push(operand.getPresentation(context));
          }
        }
        if (this.style != "invisible" && this.symbol.onscreen instanceof Array) {
          if (this.symbol.onscreen[2]!=="") {
            array.push(new presentation.Row(this.symbol.onscreen[2]));
          }
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);
        return result;

      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary infix operation.
   */
  org.mathdox.formulaeditor.semantics.MultaryOperation =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The operands of the operation.
       */
      operands: null,

      /**
       * Information about the symbol that is used to represent this operation.
       */
      symbol : {

        /**
         * The symbol that is used for rendering the operation to the screen.
         */
        onscreen         : null,

        /**
         * The OpenMath symbol that is associated with this operation.
         */
        openmath         : null,

        /**
         * The MathML representation of this operation.
         */
        mathml           : null,

        /**
         * The MathML invisible representation of this operation (if any)
         */
        mathml_invisible : null

      },

      getSymbolMathML : function(context) {
        return this.symbol.mathml;
      },

      getSymbolOnscreen : function(context) {
        return this.symbol.onscreen;
      },

      getSymbolOpenMath : function(context) {
        return this.symbol.openmath;
      },

      /**
       * The precedence level of the operator.
       */
      precedence : 0,

      getPrecedence : function(context) {
	return this.precedence;
      },
      getInnerPrecedence : function(context) {
	return this.getPrecedence(context);
      },
 
      /**
       * Is the operator associative
       *
       * if false: put brackets around the second argument also if it has an
       * operator with the same precedence. Example: a-(b-c)
       */
      associative : true,

      /**
       * style if any (like "invisible")
       */ 
      style:null,

      /**
       * Initializes the operation using the specified arguments as operands.
       */
      initialize : function() {
        this.operands = arguments;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var array = [];
        var i;
        var symbolOnscreen = this.getSymbolOnscreen(context);
        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[0]!=="") {
            array.push(new presentation.Row(symbolOnscreen[0]));
          }
        }
        for (i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
          if (i>0 && this.style != "invisible" ) {
            if (symbolOnscreen instanceof Array) {
              if (symbolOnscreen[1]!=="") {
                array.push(new presentation.Row(symbolOnscreen[1]));
              }
            }
            else {
              array.push(new presentation.Row(symbolOnscreen));
            }
          }
          //if (operand.precedence && ((operand.precedence < this.precedence) || ((this.associative==false) && i>0 && operand.precedence <= this.precedence))) {
          if (operand.getPrecedence && operand.getPrecedence(context) != 0 && ((operand.getPrecedence(context) < this.getInnerPrecedence(context)) || 
	     (operand.getPrecedence(context) == this.getInnerPrecedence(context) && 
	       (i>0 || (this.associative==true && this.symbol.openmath == operand.symbol.openmath) ||
		(this.operands.length == 1)
		)) 
	     )) {
            array.push(new presentation.Symbol("("));
            array.push(operand.getPresentation(context));
            array.push(new presentation.Symbol(")"));
          }
          else {
            array.push(operand.getPresentation(context));
          }
        }
        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[2]!=="") {
            array.push(new presentation.Row(symbolOnscreen[2]));
          }
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {
        var semantics = org.mathdox.formulaeditor.semantics;
	var result;

        var argtest = this.checkArguments(this.operands);

        if (typeof argtest === "string") {
          result = "<OME><OMS cd='moreerrors' name='encodingError'/>";
          result += "<OMSTR>invalid expression entered: "+ argtest+"</OMSTR>";
          result += "</OME>";
          return result;
        }

        var result = "<OMA";

        // add style (like invisible) if present
        if (this.style) {
          result = result + " style='" + this.style + "'";
        }

        result = result + ">" + this.getSymbolOpenMath();
        for (var i=0; i<this.operands.length; i++) {
          result = result + this.operands[i].getOpenMath();
        }
        result = result + "</OMA>";
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {

        var result = "<mrow>";
        var symbol_mathml = this.getSymbolMathML();

	if (this.style == "invisible" && (this.symbol.mathml_invisible !== undefined && this.symbol.mathml_invisible !== null)) {
          symbol_mathml = this.symbol.mathml_invisible;
	}

        if (symbol_mathml instanceof Array) {
          result = result + symbol_mathml[0];
        }

        for (var i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
          if (i>0) {
            if (symbol_mathml instanceof Array) {
              result = result + symbol_mathml[1];
            } else {
              result = result + symbol_mathml;
            }
          }
          if (operand.precedence && ((operand.precedence < this.precedence) || ((this.associative==false) && i>0 && operand.precedence <= this.precedence))) {
            result = result + "<mfenced>";
            result = result + this.operands[i].getMathML();
            result = result + "</mfenced>";
          }
          else {
            result = result + this.operands[i].getMathML();
          }
        }

        if (symbol_mathml instanceof Array) {
          result = result + symbol_mathml[2];
        }

        result = result + "</mrow>";
        return result;

      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$identify("org/mathdox/formulaeditor/semantics/Node.js");


$main(function(){

  /**
   * Representation of a node in the semantic tree.
   */
  org.mathdox.formulaeditor.semantics.Node = $extend(Object, {

      /**
       * expected number of arguments
       * "null" means no information
       */
      argcount : null,

      /**
       * checkArguments: check the number of arguments, returns true or an error string
       */
      checkArguments : function(operands) {
        var argcount;
        
        if (operands === null || operands === undefined) {
          argcount = 0;
        } else {
          argcount = operands.length;
        }

        if (this.argcount === null) {
          return true;
        } else if (this.argcount == argcount) {
          return true;
        } else {
          return "expecting "+this.argcount+" argument(s), but found "+argcount+" argument(s) instead";
        }
      },

    /**
     * Returns the presentation tree node that is used to draw this semantic
     * tree node on a canvas. This is an abstract method, so it is expected that
     * subclasses will override this method.
     *
     * context: object that can contain information that might influence the
     * presentation of child objects. context cascades; it is either the same,
     * or copied and then extended or modified.
     */
    getPresentation : function(context) {
      throw new Error("abstract method called");
    },

    /**
     * Returns the OpenMath representation of the node. This is an abstract
     * method, so it is expected that subclasses will override this method.
     */
    getOpenMath : function() {
      throw new Error("abstract method called");
    },

    /**
     * Returns the MathML presentation of the node. This is an abstract method,
     * so it is expected that subclasses will override this method.
     */
    getMathML : function() {
      throw new Error("abstract method called");
    },

    /**
     * get the value as a string, useful when multiple internal representations are possible
     */
    getValueAsString : function() {
      return this.value.toString();
    },

    /**
     * Utility method to add a bracket to presentation array
     *
     * Note: pres structure should be:
     * pres.array: presentation items
     * pres.old: old presentation structure containing array and possibly leftBracket
     * pres.leftBracket: left Bracket
     * rightBracket: closing Bracket
     */
    addPresentationBracketOpen : function(context, pres, bracket) {
      var presentation = org.mathdox.formulaeditor.presentation;

      if (context.optionResizeBrackets === true) {
	var tmp = {
	  array: pres.array,
	  leftBracket: pres.leftBracket,
	  old: pres.old
	};
	pres.old = tmp;

        pres.leftBracket = new presentation.Bracket(bracket);
        pres.array = [];
      } else {
	pres.array.push(new presentation.Bracket(bracket));
      }
    },
    addPresentationBracketClose : function(context, pres, bracket) {
      var presentation = org.mathdox.formulaeditor.presentation;

      if (context.optionResizeBrackets === true) {
        var rightBracket = new presentation.Bracket(bracket);

	var row = new presentation.Row();
	row.initialize.apply(row, pres.array);

        var bracketed = new presentation.Bracketed(pres.leftBracket, row, rightBracket);

        pres.array = pres.old.array;
        pres.leftBracket = pres.old.leftBracket;
        pres.old = pres.old.old;

        pres.array.push(bracketed);
      } else {
        pres.array.push(new presentation.Bracket(bracket));
      }
    }
  });

});

  $package("org/mathdox/formulaeditor/semantics");

$identify("org/mathdox/formulaeditor/semantics/SemanticFloat.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){

  /**
  * Representation of a float in the semantic tree.
  * it is named SemanticFloat because float is a reserved keyword
  */
  org.mathdox.formulaeditor.semantics.SemanticFloat =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The float value.
       */
      value : null,

      /**
       * Initializes a semantic tree node to represent an float with the
       * specified value.
       */
      initialize : function(value) {
        this.value = value;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var string = this.getValueAsString(context); // getValueAsString returns a string with corrected decimal mark
        var symbols = [];

        for (var i=0; i<string.length; i++) {
          symbols[i] = new presentation.Symbol(string.charAt(i));
        }

        var result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;

      },

      /**
       * return the value with the correct decimal mark
       */
      getValueAsString : function(context) {
        var string = this.value.toString();

	if (context === null || context === undefined || context.decimalMark == '.') {
          return string;
	}

	// use context to change the decimalMark

        var result=[];

        for (var i=0; i<string.length; i++) {
          if (string.charAt(i) != '.') {
            result.push(string.charAt(i));
          } else {
            result.push(context.decimalMark);
          }
        }

        return result.join("");
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMF dec='" + this.value + "'/>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        var string = this.value.toString();
        var result=[];

	result.push("<mn>");

        for (var i=0; i<string.length; i++) {
          if (string.charAt(i)!='.') {
            result.push(string.charAt(i));
          } else {
            result.push((new org.mathdox.formulaeditor.Options).getDecimalMark());
          }
        }
	result.push("</mn>");

        return result.join("");
      },

      toString : function() {
        return this.value.toString();
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/String.js");

$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/Node.js");

$main(function(){

  /**
   * Representation of a variable in the semantic tree.
   */
  org.mathdox.formulaeditor.semantics.SString =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The variable name.
       */
      name : null,

      /**
       * Initializes a semantic tree node to represent the variable with the
       * specified name.
       */
      initialize : function(name) {
        this.name = name;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var str = this.name; // the string that is presented
        var symbols = []; // array for the symbols
	
	// opening "
	symbols.push(new presentation.Symbol("\""));

	// the actual string
        for (var i=0; i<str.length; i++) {
          symbols.push(new presentation.Symbol(str.charAt(i)));
        }

	// closing "
	symbols.push(new presentation.Symbol("\""));

	// now create a row and initialize it with the list of symbols
        var result = new presentation.Row();
        result.initialize.apply(result, symbols);

        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMSTR>" + this.name + "</OMSTR>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        return "<mtext>" + this.name + "</mtext>";
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/Variable.js");

$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/Node.js");

$main(function(){

  /**
   * Representation of a variable in the semantic tree.
   */
  org.mathdox.formulaeditor.semantics.Variable =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The variable name.
       */
      name : null,

     /**
       * Information about the variable that is used to represent it.
       */
      symbol : {

        /**
         * The symbol(s) that is/are used for rendering the variable to the
         * screen.
         */
        onscreen : null,

        /**
         * The MathML representation of this variable.
         */
        mathml   : null

      },


      /**
       * Initializes a semantic tree node to represent the variable with the
       * specified name.
       */
      initialize : function(name, symbol) {
        this.name = name;

        if (symbol) {
          this.symbol = {};
          if (symbol.onscreen) {
            this.symbol.onscreen = symbol.onscreen;
          }
          if (symbol.mathml) {
            this.symbol.mathml = symbol.mathml;
          }
        }
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var str;
        if (this.symbol.onscreen !== null) {
          str = this.symbol.onscreen.toString();
        } else { 
          str = this.name.toString();
        }
        var symbols = [];

        for (var i=0; i<str.length; i++) {
          symbols[i] = new presentation.Symbol(str.charAt(i), "math");
        }

        var result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMV name='" + this.name + "'/>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        if (this.symbol.mathml !== null) {
          return this.symbol.mathml.toString();
        } else {
          return "<mi>" + this.name + "</mi>";
        }
      }

    });

});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/version.js");

$main(function(){
  /**
  * Version object (static)
  */

  org.mathdox.formulaeditor.version = {
    /**
     * Show an "About" popup with version info
     */
    showAboutPopup: function() {
      alert("MathDox Formulaeditor\n"+
	    "version: "+this.toString()+"\n"+
	    "http://mathdox.org/formulaeditor/\n"+
	    "info@mathdox.org");
    },
    /**
     * Return the version as a string
     */
    toString : function() {
      return this.versionInfo;
    },
    /**
     * variable containing the version information
     */
    versionInfo: "1.1.31f"
  };
});

  $package("org.mathdox.parsing");

$identify("org/mathdox/parsing/Parser.js");

$main(function(){

  org.mathdox.parsing.Parser = $extend(Object, {

    start : null,

    parse : function(string, index, backward, start) {

      if (index === null || index === undefined) {
        index = 0;
      }
      if (backward === null || backward === undefined) {
        backward = false;
      }
      if (start === null || start === undefined) {
        start = "start";
      }

      var context = {
        input    : string,
        backward : backward,
        parser   : this,
        cache    : {}
      };

      var endIndex  = null;
      var endResult = null;

      var continuation = function(newIndex, newResult) {
        if (context.backward) {
          if (endIndex === null || newIndex < endIndex) {
            endIndex  = newIndex;
            endResult = newResult;
          }
        }
        else {
          if (endIndex === null || newIndex > endIndex) {
            endIndex  = newIndex;
            endResult = newResult;
          }
        }
      };

      this[start](context, index, [], continuation);

      if (endResult !== null && endResult.length == 1) {
        endResult = endResult[0];
      }

      return { index: endIndex, value : endResult };

    }

  });

});

  $package("org.mathdox.parsing");

$identify("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  /**
   * A recursive descent parser in continuation passing style. This parser allows
   * both forward (left-to-right) and backward (right-to-left) parsing.
   */
  org.mathdox.parsing.ParserGenerator = $extend(Object, {

    alternation : function() {

      var alternatives = arguments;

      return function(context, index, result, continuation) {
        for (var i=0; i<alternatives.length; i++) {
          alternatives[i](context, index, result, continuation);
        }
      };

    },

    begin : function(context, index, result, continuation) {

      if (index == 0) {
        this.empty(context, index, result, continuation);
      }

    },

    concatenation : function() {

      var elements = Array.prototype.slice.call(arguments);
      var generator = this;

      if (elements.length > 0) {

        var concatenation = arguments.callee;

        return function(context, index, result, continuation) {

          var tail = elements.slice();
          var head = context.backward ? tail.pop() : tail.shift();

          head(
            context,
            index,
            result,
            function(newindex, newresult) {
              var tailparser = concatenation.apply(generator, tail);
              tailparser(context, newindex, newresult, continuation);
            }
          );

        };

      }
      else {

        return generator.empty;

      }

    },

    empty : function(context, index, result, continuation) {

      continuation(index, result);

    },

    end : function(context, index, result, continuation) {

      if (index == context.input.length) {
        this.empty(context, index, result, continuation);
      }

    },

    literal : function(string) {

      return function(context, index, result, continuation) {

        var start = context.backward ? index - string.length : index;
        var end   = context.backward ? index : index + string.length;

        if (context.input.substring(start, end) == string) {
          if (context.backward) {
            continuation(start, [string].concat(result));
          }
          else {
            continuation(end, result.concat([string]));
          }
        }

      };

    },

    never : function(context, index, result, continuation) {

      //skip

    },

    range : function(lower, upper) {

      return function(context, index, result, continuation) {

        var character = context.input.charAt(context.backward ? index-1 : index);

        if (lower <= character && character <= upper) {
          if (context.backward) {
            continuation(index - 1, [character].concat(result));
          }
          else {
            continuation(index + 1, result.concat([character]));
          }
        }

      };

    },

    repetition : function(operand) {
      var pG = this;

      return pG.alternation(
        pG.empty,
        pG.repetitionplus(operand)
      );

    },

    repetitionplus : function(operand) {

      var pG = this;

      return function(context, index, result, continuation) {
	// note: repetition is the same forwards and backwards
	// alternative 1: only 1 
        operand(context, index, result, continuation); 

	/* alternative 2: 1 followed by repetitionplus */
        operand(
          context,
          index,
          result,
          function(newindex, newresult) {
            pG.repetitionplus(operand)(context, newindex, newresult, continuation);
          }
        );
      };
    },

    rule : function(name) {

      return function(context, index, result, continuation) {

        context.parser[name](context, index, result, continuation);

      };

    },

    transform : function(operand, transform) {

      return function(context, index, result, continuation) {

        operand(
          context,
          index,
          result,
          function(newindex, newresult) {
	    var sliced;
            if (context.backward) {
              sliced = newresult.slice(0, newresult.length - result.length);
              continuation(newindex,[transform(sliced)].concat(result));
            }
            else {
              sliced = newresult.slice(result.length);
              continuation(newindex, result.concat([transform(sliced)]));
            }
          }
        );

      };

    }
  });


  /**
   * Add string representation to the generated parser parts. This is needed for
   * the memoization algorithm below.
   */
  org.mathdox.parsing.ParserGenerator =
    $extend(org.mathdox.parsing.ParserGenerator, {

      initialize : function() {

        this.begin.asString = "^" ;
        this.empty.asString = "()";
        this.end.asString   = "$" ;
        this.never.asString = "0" ;

      },

      alternation : function() {

        var parent = arguments.callee.parent;
        var result = parent.alternation.apply(this, arguments);

        result.asString = "(";

        for (var i=0; i<arguments.length; i++) {

          if (i>0) {
            result.asString += "|";
          }

          result.asString += arguments[i].asString;

        }

        result.asString += ")";

        return result;

      },

      parentAlternation: function(newrule, oldrule, obj) {
        alert(obj);
        alert(obj[oldrule]);
        var result = function() {
          this.alternation(newrule, obj[oldrule]).apply(this, arguments);
        }
        result.asString = "(" + obj[oldrule].asString + "|" + 
	  newrule.asString + ")";

        return result;
      },

      concatenation : function() {

        var parent = arguments.callee.parent;
        var result = parent.concatenation.apply(this, arguments);

        result.asString = "(";

        for (var i=0; i<arguments.length; i++) {

          if (i>0) {
            result.asString += " ";
          }

          result.asString += arguments[i].asString;

        }

        result.asString += ")";

        return result;

      },

      literal : function(string) {

        var parent = arguments.callee.parent;
        var result = parent.literal.apply(this, arguments);
        result.asString = "\"" + string + "\"";
        return result;

      },

      range : function(lower, upper) {

        var parent = arguments.callee.parent;
        var result = parent.range.apply(this, arguments);
        result.asString = "[" + lower + ".." + upper + "]";
        return result;

      },

      repetition : function(operand) {

        var parent = arguments.callee.parent;
        var result = parent.repetition.apply(this, arguments);
        result.asString = operand.asString + "*";
        return result;

      },

      repetitionplus : function(operand) {

        var parent = arguments.callee.parent;
        var result = parent.repetitionplus.apply(this, arguments);
        result.asString = operand.asString + "+";
        return result;

      },

      rule : function(name) {

        var parent = arguments.callee.parent;
        var result = parent.rule.apply(this, arguments);
        result.asString = name;
        return result;

      },

      transform : function(operand, transform) {

        var parent = arguments.callee.parent;
        var result = parent.transform.apply(this, arguments);
        result.asString = "{" + operand.asString + "}";
        return result;

      }

  });


  /**
   * Add memoization to support left-recursion (and right recursion when parsing
   * backwards), and improve the time complexity from exponential to polynomial.
   */
  org.mathdox.parsing.ParserGenerator =
    $extend(org.mathdox.parsing.ParserGenerator, {

      memoize : function(f) {

        var result = function(context, index, result, continuation) {

          var key = f.asString + "," + index;

          var entry = context.cache[key];
          if (!entry) {

            entry = context.cache[key] = { results : [], continuations : [] };
            entry.continuations.push(continuation);
            f(context, index, result, function(index, result) {
              entry.results.push({index : index, value : result});
              for (var i=0; i<entry.continuations.length; i++) {
                entry.continuations[i](index, result);
              }
            });

          }
          else {

            entry.continuations.push(continuation);
            for (var i=0; i<entry.results.length; i++) {
              var result = entry.results[i];
              continuation(result.index, result.value);
            }

          }

        };

        result.asString = f.asString;

        return result;

      },

      rule : function(name) {

        var parent = arguments.callee.parent;
        return this.memoize(parent.rule.apply(this, arguments));

      },

      repetitionplus : function(name) {

        var parent = arguments.callee.parent;
        return this.memoize(parent.repetitionplus.apply(this,arguments));

      }

    });

});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/FormulaEditor.js");

// load make/maker functions
$require("com/oreilly/javascript/tdg/make.js");
// load XMLHttpRequest methods
$require("com/oreilly/javascript/tdg/XMLHttp.js");

var Drag;
$require("net/youngpup/dom-drag/dom-drag.js", function() { return Drag; });

$require("org/mathdox/debug/Debug.js");

$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/mathml/MathMLParser.js");
$require("org/mathdox/formulaeditor/Canvas.js");
$require("org/mathdox/formulaeditor/MathCanvasFill.js");
$require("org/mathdox/formulaeditor/Cursor.js");
$require("org/mathdox/formulaeditor/EventHandler.js");
$require("org/mathdox/formulaeditor/Services.js");

$require("org/mathdox/formulaeditor/version.js");

$require("org/mathdox/formulaeditor/Options.js");

$require("org/mathdox/formulaeditor/Palettes.js");

$require("org/mathdox/formulaeditor/modules/keywords.js");
$require("org/mathdox/formulaeditor/modules/variables.js");

$require("org/mathdox/formulaeditor/modules/arithmetic/abs.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/divide.js");
$require("org/mathdox/formulaeditor/modules/arith1/minus.js");
$require("org/mathdox/formulaeditor/modules/arith1/plus.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/power.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/product.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/root.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/sum.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/times.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");

$require("org/mathdox/formulaeditor/modules/calculus1/defint.js");
$require("org/mathdox/formulaeditor/modules/calculus1/diff.js");
$require("org/mathdox/formulaeditor/modules/calculus1/int.js");

$require("org/mathdox/formulaeditor/modules/complex1/complex_cartesian.js");

$require("org/mathdox/formulaeditor/modules/editor1/palette.js");

$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$require("org/mathdox/formulaeditor/modules/integer1/factorial.js");

$require("org/mathdox/formulaeditor/modules/interval1/interval_cc.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_co.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_oc.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_oo.js");

$require("org/mathdox/formulaeditor/modules/linalg/matrix.js");

$require("org/mathdox/formulaeditor/modules/limit1/limit.js");

$require("org/mathdox/formulaeditor/modules/list1/list.js");

$require("org/mathdox/formulaeditor/presentation/Editor.js");
$require("org/mathdox/formulaeditor/presentation/Root.js");

$require("org/mathdox/formulaeditor/modules/logic1/and.js");
$require("org/mathdox/formulaeditor/modules/logic1/equivalent.js");
$require("org/mathdox/formulaeditor/modules/logic1/implies.js");
$require("org/mathdox/formulaeditor/modules/logic1/not.js");
$require("org/mathdox/formulaeditor/modules/logic1/or.js");

$require("org/mathdox/formulaeditor/modules/nums1/rational.js");

$require("org/mathdox/formulaeditor/modules/permutation1/left_compose.js");
$require("org/mathdox/formulaeditor/modules/permutation1/permutation.js");

$require("org/mathdox/formulaeditor/modules/relation1/approx.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/relation1/geq.js");
$require("org/mathdox/formulaeditor/modules/relation1/gt.js");
$require("org/mathdox/formulaeditor/modules/relation1/leq.js");
$require("org/mathdox/formulaeditor/modules/relation1/lt.js");
$require("org/mathdox/formulaeditor/modules/relation1/neq.js");
// for rewriting 1<x<2
$require("org/mathdox/formulaeditor/modules/relation1/IntervalNotation.js");

$require("org/mathdox/formulaeditor/modules/set1/in.js");

$main(function(){

  /**
   * Maintain a list of all formula editors that are initialized.
   */
  var editors = [];

  var palettes;
 
  var debug = null;

  /**
   * Class that represents a formula editor.
   */
  org.mathdox.formulaeditor.FormulaEditor = $extend(Object, {

    /**
     * The textarea that is being replaced.
     */
    textarea : null,

    /**
     * The canvas that will be used for rendering formulae.
     */
    canvas : null,

    /**
     * The current presentation tree.
     */
    presentation : null,

    /**
     * The keyboard cursor.
     */
    cursor : null,

    /**
     * The palette (if any)
     */
    palette : null,

    /**
     * Boolean that indicates whether the palette should be shown
     */
    showPalette : true,

    /**
     * Indicates whether this formula editor has the focus.
     */
    hasFocus : false,

    addPalette : function() {
      //canvas.parentNode.insertBefore(palette, canvas);
      var palcanvas = document.createElement("canvas");

      if (! org.mathdox.formulaeditor.options.ignoreTextareaStyle) {
        // copy style attributes from the textarea to the canvas
        for (x in this.textarea.style) {
          try {
            palcanvas.style[x] = this.textarea.style[x];
          }
          catch(exception) {
            // skip
          }
        }
      }

      // fix for opera
      if ( G_vmlCanvasManager === undefined) {
        if (palcanvas.style.getPropertyValue("height") != "") {
          try {
            palcanvas.style.removeProperty("height");
          } catch(exception) {
            // skip
          }
        }
      }

      // set the style attributes that determine the look of the palette
      if (org.mathdox.formulaeditor.options.paletteStyle) {
        // use paletteStyle option if available
        palcanvas.setAttribute("style",
                org.mathdox.formulaeditor.options.paletteStyle);
      } else {
        // no paletteStyle option available -> set default style
        palcanvas.style.border          = "2px solid #99F";
        palcanvas.style.verticalAlign   = "middle";
        palcanvas.style.cursor          = "pointer";
        palcanvas.style.padding         = "0px";
        palcanvas.style.backgroundColor = "white";
      }

      // clear possible display none
      palcanvas.style.display = "";
      // set a classname so the user can extend the style
      palcanvas.className           = "formulaeditorpalette";

      if (!palettes) {
        palettes = [];
      }
      this.palette = new org.mathdox.formulaeditor.Palette();
      palettes.push(this.palette);

      // special case: draggable canvas TODO
      if (org.mathdox.formulaeditor.options.dragPalette !== undefined &&
          org.mathdox.formulaeditor.options.dragPalette === true) {
        // create root 
        var root = document.createElement("div");
        root.style.left = "150px";
        root.style.top = "0px";
        root.style.position = "relative";

        var subdiv = document.createElement("div");

        // float is a keyword, to change the css float style, use cssFloat
        subdiv.style.cssFloat="right";

        // create handle
        var handle = document.createElement("div");

        handle.style.width = "200px";
        handle.style.marginLeft = "50px";
        handle.style.height = "10px";
        handle.style.cursor = "move";

        subdiv.appendChild(handle);
        subdiv.appendChild(palcanvas);
        root.appendChild(subdiv);

        // add root, handle and palette to the document
        if (this.textarea.parentNode.tagName.toLowerCase() == "p") {
          // NOTE: should not be added inside a para
          var para = this.textarea.parentNode;
          var paraparent = this.textarea.parentNode.parentNode;
          // code to insert after the paragraph
          if (G_vmlCanvasManager) {
            paraparent.replaceChild(root, this.canvas.canvas);
            paraparent.insertBefore(this.canvas.canvas, root);
          } else {
            paraparent.replaceChild(root, para);
            paraparent.insertBefore(para, root);
          }
          // to insert before the paragraph use
          //paraparent.insertBefore(root, para);
        } else {
          this.textarea.parentNode.insertBefore(root, this.textarea);
        }

        // initialize dragging script
        Drag.init(handle, root);

        var borderTopColor = "";
        
        // getting computed style: see also page 380 of J:TDG 5th edition
        if (palcanvas.currentStyle) { // Try simple IE API first
          borderTopColor = palcanvas.currentStyle.borderTopColor;
        } else if (window.getComputedStyle) {  // Otherwise use W3C API
          borderTopColor = 
            window.getComputedStyle(palcanvas, null).borderTopColor;
        }

        if (borderTopColor !== "") {
          handle.style.backgroundColor = borderTopColor;
        } else {
          handle.style.backgroundColor = "red";
        }

          this.palette.htmlelement = root;
      } else {
        // insert palcanvas in the document before the textarea 
        // in case of G_vmlCanvasManager, check if the parent is a p
        // if it is then put the canvas after the paragraph
        if (G_vmlCanvasManager && this.textarea.parentNode.tagName.toLowerCase() == "p") {
          // NOTE: should not be added inside a para
          var para = this.textarea.parentNode;
          var paraparent = this.textarea.parentNode.parentNode;
          // code to insert after the paragraph
          paraparent.replaceChild(palcanvas, para);
          paraparent.insertBefore(para, palcanvas);
          // to insert before the paragraph use
          //paraparent.insertBefore(root, para);
        } else {
          this.textarea.parentNode.insertBefore(palcanvas, this.textarea);
        }
      }
      if (G_vmlCanvasManager) {
        /* reinitialize canvas */
        palcanvas = G_vmlCanvasManager.initElement(palcanvas);
      }

      // Initialize the canvas. This is only needed in Internet Explorer,
      // where Google's Explorer Canvas library handles canvases.
      // NOTE: this should be done after putting the canvas in the DOM tree
      
      this.palette.initialize(palcanvas);
    },
    /**
     * checkClass(classNames, className): function to help check if an HTML
     * element contains a certain class.
     */
    checkClass: function(classNames, className) {
      var words = classNames.split(" ");
      var i;

      for (i=0; i<words.length; i++) {
        if (words[i] == className) {
          return true;
        }
      }
      return false;
    },

    togglePalette:function () {
      if (this.palette) {
        // remove existing palette
        org.mathdox.formulaeditor.Palette.removePalette(this.palette);
      } else {
        // add new palette
        this.addPalette();
      }
    },
    /**
     * Hides the specified textarea and replaces it by a canvas that will be
     * used for rendering formulae.
     */
    initialize : function(textarea, canvas) {
      var x;

      if (textarea) {

        var Cursor    = org.mathdox.formulaeditor.Cursor;
        var MathCanvas = org.mathdox.formulaeditor.MathCanvas;

        // ensure that there isn't already an editor for this textarea
        for (var i=0; i<editors.length; i++) {
          if (editors[i].textarea == textarea) {
            return editors[i];
          }
        }

        // check whether a new canvas needs to be added.
        if (!canvas) {

          // create an HTML canvas
          canvas = document.createElement("canvas");

          // copy style attributes from the textarea to the canvas
          if (! org.mathdox.formulaeditor.options.ignoreTextareaStyle) {
            for (x in textarea.style) {
              try {
                canvas.style[x] = textarea.style[x];
              }
              catch(exception) {
                // skip
              }
            }
          }

          // fix for opera
          if ( G_vmlCanvasManager === undefined) {
  	    if (canvas.style.getPropertyValue("height") != "") {
                try {
                  canvas.style.removeProperty("height");
  	      } catch(exception) {
  	        // skip
  	      }
  	    }
  	  }

          canvas.className = "mathdoxformula";

          // set the style attributes that determine the look of the editor
          if (textarea.getAttribute("style") !== null && 
               textarea.getAttribute("style") !== undefined &&
               textarea.getAttribute("style").value !== undefined) {
            // same style as the textarea
            canvas.setAttribute("style", textarea.getAttribute("style"));
          } else if (org.mathdox.formulaeditor.options.inputStyle) {
            // textarea has no style use inputStyle option if available
            canvas.setAttribute("style",
                    org.mathdox.formulaeditor.options.inputStyle);
          } else {
            // textarea has no style and no inputStyle option available
            // set default style
            canvas.style.border        = "1px solid #99F";
            canvas.style.verticalAlign = "middle";
            canvas.style.cursor        = "text";
            canvas.style.padding       = "0px";
          }

          // insert canvas in the document before the textarea 
          // in case of G_vmlCanvasManager, check if the parent is a p
          // if it is then put the canvas after the paragraph
          
          if (G_vmlCanvasManager && textarea.parentNode.tagName.toLowerCase() == "p") {
            // NOTE: should not be added inside a para
            var para = textarea.parentNode;
            var paraparent = textarea.parentNode.parentNode;
            // code to insert after the paragraph
            paraparent.replaceChild(canvas, para);
            paraparent.insertBefore(para, canvas);
            // to insert before the paragraph use
            //paraparent.insertBefore(root, para);
          } else {
            textarea.parentNode.insertBefore(canvas, textarea);
          }

          // Initialize the canvas. This is only needed in Internet Explorer,
          // where Google's Explorer Canvas library handles canvases.
          if (G_vmlCanvasManager) {
            canvas = G_vmlCanvasManager.initElement(canvas);
          }

        }

        // register the textarea 
        this.textarea = textarea;

        // register a new mathcanvas
        this.canvas   = new MathCanvas(canvas);

        // check whether a palette needs to be added
        if (this.checkClass(textarea.className, "mathdoxpalette")) {
          /* specified: show a palette */
          this.showPalette = this.showPalette && true;
        } else if (this.checkClass(textarea.className, "mathdoxnopalette")) {
          /* specified: don't show a palette */
          this.showPalette = this.showPalette && false;
        } else if (org.mathdox.formulaeditor.options.paletteShow == "all") {
          /* when unspecified, always show a palette */
          this.showPalette = this.showPalette && true;
        } else if (org.mathdox.formulaeditor.options.paletteShow == "none") {
          /* when unspecified, never show a palette */
          this.showPalette = this.showPalette && false;
        } else if (org.mathdox.formulaeditor.options.paletteShow == "once") {
          /* only add a palette if no palette is present on the page yet */
          this.showPalette = this.showPalette && (!palettes);
        } else {
          /* default: show only one palette */
          /* only add a palette if no palette is present on the page yet */
          this.showPalette = this.showPalette && (!palettes);
        }

        this.showPalette = this.showPalette &&
          (this.checkClass(textarea.className, "mathdoxpalette") || 
          (!this.checkClass(textarea.className, "mathdoxnopalette") && 
            !palettes)
          );
        if (this.showPalette) { 
          this.addPalette();
        }

        // hide the textarea XXX
        if (!this.checkClass(textarea.className, "mathdoxvisibletextarea")) {
          textarea.style.display = "none";
        }

        this.load();

        // initialize the cursor, and draw the presentation tree
        this.cursor = new Cursor(this.presentation.getFollowingCursorPosition());
        this.draw();

        // register this editor in the list of editors.
        editors.push(this);

      }

    },

    load : function() {

      var Parser    = org.mathdox.formulaeditor.parsing.openmath.OpenMathParser;
      var Editor    = org.mathdox.formulaeditor.presentation.Editor;
      var Row       = org.mathdox.formulaeditor.presentation.Row;

      // read any OpenMath code that may be present in the textarea
      var paletteEnabled;
      try {
        var parsed = new Parser().parse(this.textarea.value);
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(parsed.getPresentation(this.getPresentationContext()), paletteEnabled);
        } else {
          this.presentation = new Row(parsed.getPresentation(this.getPresentationContext()));
          this.presentation.flatten();
        }
      }
      catch(exception) {
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(null, paletteEnabled);
        } else {
          this.presentation = new Row();
        }
      }

    },

    loadMathML: function(xmlString) {
      org.mathdox.formulaeditor.FormulaEditor.addDebug("loading MathML");
      var Parser    = org.mathdox.formulaeditor.parsing.mathml.MathMLParser;
      var Editor    = org.mathdox.formulaeditor.presentation.Editor;
      var Row       = org.mathdox.formulaeditor.presentation.Row;

      // read any OpenMath code that may be present in the textarea
      var paletteEnabled;
      //try {
        var parsed = new Parser().parse(xmlString, this.getPresentationContext());

        org.mathdox.formulaeditor.FormulaEditor.addDebug("parsed: "+parsed);
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(parsed, paletteEnabled);
        } else {
          this.presentation = new Row(parsed);
          this.presentation.flatten();
        }
      //}
/*      catch(exception) {
        if (org.mathdox.formulaeditor.options.useBar) {
          if (this.palette) {
            paletteEnabled = true;
          } else {
            paletteEnabled = false;
          }
          this.presentation = new Editor(null, paletteEnabled);
        } else {
          this.presentation = new Row();
        }
      }*/
    },

    // TODO : move this to an onchange handler
    save : function() {

      var textarea = this.textarea;
      var openmathInfo = this.getOpenMath(true);

      // update the textarea
      if (org.mathdox.formulaeditor.options.indentXML && 
        org.mathdox.formulaeditor.options.indentXML === true) {
        textarea.value = this.indentXML(openmathInfo.value);
      } else {
        textarea.value = openmathInfo.value;
      }

      return { 
        success: openmathInfo.success,
        errorString: openmathInfo.errorString
      };
    },

    redraw : function() {
      this.canvas.clear();
      this.draw();
    },

    draw : function() {

      // TODO: move this code to a separate presentation node
      //       (equivalent to the DOM Document node)
      var dimensions;
      var drawContext = {};

      if (org.mathdox.formulaeditor.options.useBar) {
        dimensions = this.presentation.draw(this.canvas, drawContext, 0, 0, true);
      } else {
        /* add margin */
        var margin = 4.0;
        var formula_dimensions = this.presentation.draw(this.canvas, drawContext, 0, 0, true);
        dimensions = {
          top:    formula_dimensions.top    - margin,
          left:          formula_dimensions.left   - margin,
          width:  formula_dimensions.width  + 2 * margin,
          height: formula_dimensions.height + 2 * margin
        };
      }
      // XXX
      if (G_vmlCanvasManager) {
        var computedStyle;
        if (this.canvas.canvas.currentStyle !== undefined && this.canvas.canvas.currentStyle!== null) {
          // IE method 
          computedStyle = this.canvas.canvas.currentStyle;
        } else {
          computedStyle = getComputedStyle(this.canvas.canvas, null);
        }
        var dim_extra = { width:0, height:0};

        // adjust size horizontally
        var tmp;
        tmp = [ computedStyle.borderLeftWidth, 
          computedStyle.borderRightWidth, 
          computedStyle.paddingLeft, 
          computedStyle.paddingRight ];

        var i;
        var parsed;
        for (i=0;i<tmp.length;i++) {
          parsed = parseInt(tmp[i]);
          if (isFinite(parsed)) {
            dim_extra.width+=parsed;
          }
        }

        // adjust size vertically
        tmp = [ computedStyle.borderTopWidth, 
          computedStyle.borderBottomWidth, 
          computedStyle.paddingTop, 
          computedStyle.paddingBottom ];

        for (i=0;i<tmp.length;i++) {
          parsed = parseInt(tmp[i]);
          if (isFinite(parsed)) {
            dim_extra.height+=parsed;
          }
        }
        this.canvas.canvas.setAttribute("width", dimensions.width+dim_extra.width);
        this.canvas.canvas.setAttribute("height", dimensions.height+dim_extra.height);
      } else {
        this.canvas.canvas.setAttribute("width", dimensions.width);
        this.canvas.canvas.setAttribute("height", dimensions.height);
      }
      this.presentation.draw(this.canvas, drawContext, - dimensions.left, - dimensions.top);
      this.cursor.draw(this.canvas, drawContext);
    },

    /**
     * Handles an onkeydown event from the browser. Returns false when the event
     * has been handled and should not be handled by the browser, returns true
     * otherwise.
     */
    onkeydown : function(event) {

      // forward the event to the cursor object when we have the focus
      if(this.hasFocus) {
        // handle some events here
        if (event.keyCode == 116) {
          var Cursor    = org.mathdox.formulaeditor.Cursor;

          var saveResult = this.save();
          if (saveResult.success) {
            // formula can be parsed and transformed to OpenMath
            this.load();
            this.cursor = new Cursor(this.presentation.getFollowingCursorPosition());
            this.focus(); // XXX is this necessary ?
            this.redraw();
          } else {
            // formula cannot be parsed and transformed to OpenMath
            alert("The formula could not be interpreted correctly. "+
              "The error message was:\n"+saveResult.errorString);
          }

          return false;
        }
        this.focus(); // TODO: only necessary for crappy blinker implementation
        return this.cursor.onkeydown(event, this);
      }

    }, 
    decreaseSizes : function() {
      var i;
      for (i =0;i<palettes.length;i++) {
        if(palettes[i].canvas) {
          palettes[i].canvas.decreaseSize();
          palettes[i].redraw();
        }
      }
      for (i =0;i<editors.length;i++) {
        if(editors[i].canvas) {
          editors[i].canvas.decreaseSize();
          editors[i].redraw();
        }
      }
      return true;
    },
  
    increaseSizes : function() {
      var i;
      for (i=0;i<editors.length;i++) {
        if(editors[i].canvas) {
          editors[i].canvas.increaseSize();
          editors[i].redraw();
        }
      }
      for (i=0;i<palettes.length;i++) {
        if(palettes[i].canvas) {
          palettes[i].canvas.increaseSize();
          palettes[i].redraw();
        }
      }
      return true;
    },

    /**
     * Handles an onkeypress event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onkeypress : function(event) {

      // forward the event to the cursor object when we have the focus
      if (this.hasFocus) {
        var result = true;
        if (event.ctrlKey) {
          switch(event.charCode) {
            case 43: // '+' larger
              this.increaseSizes();
              result = false;
              break;
            case 45: // '-' smaller
              this.decreaseSizes();
              result = false;
              break;
          }
        }
  
        this.focus(); // TODO: only necessary for crappy blinker implementation
        if (result) {
          result = this.cursor.onkeypress(event, this);
        }

        return result;
      }

    },

    /**
     * Returns info about the mouse event, returning {x, y}, where x and y are
     * the relative positions in the canvas. If the mouseclick was not in the
     * canvas null is returned instead.
     */
    mouseeventinfo : function(event) {  

      // retrieve the screen coordinates of the mouse click
      var mouseX = event.clientX;
      var mouseY = event.clientY;

      // retrieve the page offset, needed to convert screen coordinates to
      // document coordinates
      var pageXOffset = window.pageXOffset;
      var pageYOffset = window.pageYOffset;

      var element;
      // MSIE provides the page offset in a different way *sigh*
      if (pageXOffset === null || pageXOffset === undefined) {
        element = document.documentElement;
        if (!element || !element.scrollLeft) {
          element = document.body;
        }
        pageXOffset = element.scrollLeft;
        pageYOffset = element.scrollTop;
      }

      // calculate the document coordinates of the mouse click
      if (!event.mathdoxnoadjust) {
        mouseX += pageXOffset;
        mouseY += pageYOffset;
      }

      // calculate the document coordinates of the canvas element
      element = this.canvas.canvas;
      var x      = 0;
      var y      = 0;
      var width  = element.offsetWidth;
      var height = element.offsetHeight;

      // check for padding and border
        
      var computedStyle;
      if (element.currentStyle !== undefined && element.currentStyle!== null) {
        // IE method 
        computedStyle = element.currentStyle;
      } else {
        computedStyle = getComputedStyle(element, null);
      }

      var tmpp,tmpb;

      // only add maximum of tmpp, tmpb
      // if only 1 is finite, that is the maximum
      tmpb = parseInt(computedStyle.borderLeftWidth);
      tmpp = parseInt(computedStyle.paddingLeft);

      if ( isFinite(tmpp) && isFinite(tmpb)) {
        if (tmpp>tmpb) {
          x += tmpp;
        } else {
          x += tmpb;
        }
      } else if (isFinite(tmpp)) {
        x += tmpp;
      } else if (isFinite(tmpb)) {
        x += tmpb;
      }

      tmpb = parseInt(computedStyle.borderTopWidth);
      tmpp = parseInt(computedStyle.paddingTop);
      // only add maximum of tmpp, tmpb
      // if only 1 is finite, that is the maximum
      if ( isFinite(tmpp) && isFinite(tmpb)) {
        if (tmpp>tmpb) {
          y += tmpp;
        } else {
          y += tmpb;
        }
      } else if (isFinite(tmpp)) {
        y += tmpp;
      } else if (isFinite(tmpb)) {
        y += tmpb;
      }

      while (element) {
        x += element.offsetLeft;
        y += element.offsetTop;

        element = element.offsetParent;
      }

      // check whether the mouse click falls in the canvas element
      if (x<=mouseX && mouseX<=x+width && y<=mouseY && mouseY<=y+height) {
        // we have focus
        // forward the mouse click to the cursor object
        return { x:mouseX-x, y:mouseY-y };
      }
      else {
        // we do not have focus
        return null;
      }

    },
    /**
     * Handles an onmousedown event from the browser. Returns false when the
     * event has been handled and should not be handled by the browser, returns
     * true otherwise.
     */
    onmousedown : function(event) {
      // check whether the mouse click falls in the canvas element
      var mouseinfo = this.mouseeventinfo(event);


      if (mouseinfo) {
        // we have focus
        this.focus();
        // give focus to the window
        // XXX check if it is the right window
        window.focus();
        // forward the mouse click to the cursor object
        return this.cursor.onmousedown(event, this, mouseinfo.x, mouseinfo.y);
      }
      else {
        // we do not have focus
        this.blur();
        this.redraw();
      }

    },

    // TODO: only necessary for crappy blinker implementation
    blinker : 0,

    focus : function() {

      this.hasFocus = true;
      this.cursor.visible = true;

      // cursor blinking
      // TODO: move to cursor class
      var editor = this;
      var blinker = ++this.blinker;
      var blinkon;
      var blinkoff;
      blinkon = function() {
        if (editor.hasFocus && (blinker == editor.blinker)) {
          editor.cursor.visible = true;
          editor.redraw();
          window.setTimeout(blinkoff, 600);
        }
      };
      blinkoff = function() {
        if (editor.hasFocus && (blinker == editor.blinker)) {
          editor.cursor.visible = false;
          editor.redraw();
          window.setTimeout(blinkon, 400);
        }
      };
      blinkon();

    },

    blur : function() {
      if (this.hasFocus) {
        // on losing focus save changes to ORBEON if ORBEON is around
        if (ORBEON) {
          ORBEON.xforms.Document.setValue(this.textarea.id, 
            this.textarea.value);
        }
	org.mathdox.formulaeditor.FormulaEditor.lastFocused = this;
      }
      this.hasFocus = false;
      this.cursor.visible = false;
    },

    getMathML : function() {
      var mmlstring;
      try {
        mmlstring = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"+
          this.presentation.getSemantics(this.getExpressionParsingContext()).value.getMathML()+
          "</math>";
      }
      catch(exception) {
        mmlstring = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"+
          "<mtext>"+exception.toString()+"</mtext></math>";
      }

      return mmlstring;
    },

    /**
     * getOpenMath()
     *
     * function to get the OpenMath value of the formula in the formulaeditor
     * returns the contents of the formulaeditor as an OpenMath string.
     * 
     * extended with optional argument returnErrorInfo (boolean). If true
     * an array is returned instead with entries: 
     * - value (the OpenMath string);
     * - success (a boolean, true if no error has occurred);
     * - errorString (the exception converted to a string, which might be shown
     *   to the user).
     *
     * Usually an error occurs when there is an error in the entered formula.
     */
    getOpenMath : function(returnErrorInfo) {
      var omstring;
      var errorInfo;
      var success;

      if (returnErrorInfo === null || returnErrorInfo === undefined) {
        returnErrorInfo = false;
      }

      try {
        var semantics = this.presentation.getSemantics(this.getExpressionParsingContext());

        if (semantics === null || semantics.value === null) {
          omstring = "<OME>" +
	      "<OMS cd='moreerrors' name='encodingError'/>" +
                "<OMSTR>invalid expression entered. Presentation was: " +
                  this.presentation +
	        "</OMSTR>" +
	    "</OME>";

          success = false;
          errorString = null;
        } else {
          omstring = semantics.value.getOpenMath();
          success = true;
          errorString = null;
        }
      }
      catch(exception) {
        // IE doesn't provide a useful .toString for errors, use name and
        // message instead
        // old code: errorString = exception.toString();
        errorString = exception.name + " : "+exception.message;
        omstring =
            "<OME>" +
              "<OMS cd='moreerrors' name='encodingError'/>" +
              "<OMSTR>invalid expression entered" +
                errorString + 
	        ". "+
	        " Presentation was: "+
                this.presentation +
	      "</OMSTR>" +
            "</OME>";
        success = false;
      }

      omstring = "<OMOBJ xmlns='http://www.openmath.org/OpenMath' version='2.0' " + 
        "cdbase='http://www.openmath.org/cd'>" + omstring + "</OMOBJ>";
      
      if (returnErrorInfo) {
        /* return information about whether an error did occur */
        return { 
          errorString : errorString,
          success: success,
          value: omstring
        };
      } else {
        return omstring;
      }
    },
    indentXML : function(str) {
      var buffer=[];     // buffer to prevent slow string concatenation
      var oldpos;        // old position in string (written up till here)
      var pos;                 // current position in string
      var l;                 // length
      var indent=0;         // current indenting
      var indentstr="  ";// indenting done for each step
      var child;         // true if a child tag exists inside this one
                               // set to true if a tag is closed
                         // set to false if a tag is opened

      // help function that does the indenting
      var doIndent = function() {
        var i;

        if (buffer.length>0) {
          buffer.push("\n");
        }
        for (i=indent;i>0;i--) {
          buffer.push(indentstr);
        }
      };

      l=str.length; // store the length in l;

      oldpos=0; // written up to 0

      while ((pos = str.indexOf('<',oldpos))>=0) {
        if (pos>oldpos) {
          /* 
            indenting is not desired for text inside tags, unless after a child
          */
          if (child === true) {
            doIndent();
          }
          buffer.push(str.substr(oldpos,pos-oldpos));
          oldpos=pos;
        }

        pos++;
        c = str.charAt(pos);
        switch(c) {
          case '/': // closing tag
            indent -= 1;
            if (indent<0) {
              // shouldn't happen
              indent=0;
            }
            /*
             * don't indent if the tag only contains text (so no other tags, no
             * comments and no CDATA)
             */
            if (child === true) {
              doIndent();
            }
            pos = str.indexOf('>',pos);
            if (pos<0) {
              //alert("couldn't find closing >");
              return buffer.join("")+str.substr(oldpos);
            }
            pos+=1;
            child = true;
            break;
          case '!': // comment or CDATA
            pos++;
            c = str.charAt(pos);
            switch(c) {
              case '[' : // CDATA 
                child = true;
                pos = str.indexOf(']]>',pos);
                if (pos<0) {
                  //alert("couldn't find closing ]]>");
                  return buffer.join("")+str.substr(oldpos);
                }
                pos+=3;

                doIndent();

                break;
              case '-' : // XML Comment
                child = true;
                pos = str.indexOf('-->',pos);
                if (pos<0) {
                  //alert("couldn't find closing -->");
                  return buffer.join("")+str.substr(oldpos);
                }
                pos+=3;

                doIndent();

                break;
              default: // failure to parse the string
                //alert("couldn't parse");
                return buffer.join("")+str.substr(oldpos);
            }
            break;

          default: // opening tag or directly closed tag
            pos = str.indexOf('>',pos);
            if (pos<0) {
              //alert("couldn't find >, was expecting one though");
              return buffer.join("")+str.substr(oldpos);
            }

            doIndent();
            
            // in case of an opening tag, increase indenting
            if (str.charAt(pos-1) !='/') {
              child = false;
              indent += 1;
            } else {
              child = true;
            }
            pos+=1;
            break;
        }
        buffer.push(str.substr(oldpos,pos-oldpos));
        oldpos = pos;
        
      }
      if (oldpos<str.length) {
        buffer.push(str.substr(oldpos));
      }
      
      return buffer.join("");
    },
    /**
     * get the context for the expression parser
     * in the future this might be dependant on the editor
     * for now it is just an additional layer
     */
    getExpressionParsingContext: function() {
      return org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.getContext();
    },
    /**
     * get the context for the expression parser
     * in the future this might be dependant on the editor
     * for now it is just an additional layer
     */
    getPresentationContext: function() {
      Options = new org.mathdox.formulaeditor.Options();

      return Options.getPresentationContext();
    }
  });

  /**
   * Write debug info if debug option is on
   */
  org.mathdox.formulaeditor.FormulaEditor.addDebug= function(str) {
    if (debug !== undefined && debug!== null) {
      debug.addDebug(str);
    }
    return debug;
  },

  /**
   * Perform several cleanup operations
   * 
   * - Check all Formula Editor objects in editors
   *   + check if the textarea and canvas still exist (and are visible)
   *   + if the canvas doesn't exist anymore; remove the Formula Editor (and
   *     textarea)
   *   + if the textarea doesn't exist anymore, it should be reconstructed (?)
   * - Check all *mathdoxformula* canvases and remove those without Editor
   * - Check all *mathdoxformula* textareas and remove those without Editor
   * - Make sure for all editors that the textarea is placed directly after the
   *   canvas.
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanup = function() {
    this.cleanupEditors();
    this.cleanupCanvases();
    this.cleanupTextareas();
    this.cleanupGroup();
  };

  /**
   * Perform some cleanup operations
   * 
   * - Check all *mathdoxformula* canvases and remove those without Editor
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupCanvases = function() {
    var canvases = document.getElementsByTagName("canvas");

    for (i=0; i<canvases.length; i++) {
      var canvas = canvases[i];

      // retrieve the class attribute of the textarea
      classattribute = canvas.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = canvas.getAttribute("className");
      }

      // check whether this canvas is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {
        if (!this.getEditorByCanvas(canvas)) {
          /* delete canvas */
          canvas.parentNode.removeChild(canvas);
        }
      }
    }
  };

  /**
   * Perform some cleanup operations
   * 
   * - Check all Formula Editor objects in editors
   *   + check if the textarea and canvas still exist (and are visible)
   *   + if the canvas doesn't exist anymore; remove the Formula Editor (and
   *     textarea)
   *   + if the textarea doesn't exist anymore, remove the Formula Editor (and
   *     canvas) 
   *     in the future : maybe reconstructed it ?
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupEditors = function() {
    /* check all editors and remove those that cannot be repaired */
    for (var i=editors.length; i>0; i--) {
      var nodeCanvas = editors[i-1].canvas.canvas;
      var nodeTextarea = editors[i-1].textarea;

      // check editor for canvas and textarea
      if (!nodeCanvas || !nodeTextarea) {
        if (nodeCanvas &&nodeCanvas.parentNode) {
          nodeCanvas.parentNode.removeChild(nodeCanvas);
        }

        if (nodeTextarea && nodeTextarea.parentNode) {
          nodeTextarea.parentNode.removeChild(nodeTextarea);
        }

        delete editors[i-1];
        editors.splice(i-1, 1);
        // editor removed
      }
    }
  };

  /**
   * Perform some cleanup operations
   * 
   * - Make sure for all editors that the textarea is placed directly after the
   *   canvas.
   * 
   * returns true if all editors have a textarea and canvas and false otherwise
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupGroup = function() {
    // check again all editors and place textareas directly after the canvas
    var i;
    var structureCorrect = true;

    for (i=0;i<editors.length;i++) {
      var nodeCanvas = editors[i].canvas.canvas;
      var nodeTextarea = editors[i].textarea;

      // check if editor has a canvas and textarea
      if (nodeCanvas && nodeCanvas.parentNode && nodeTextarea && nodeTextarea.parentNode) {
        if (nodeCanvas.nextSibling && (nodeCanvas.nextSibling==nodeTextarea)) {
          // text area was positioned correctly
        } else {
          // text area is not positioned correctly: fix it
          // create a clone of the textarea 
          var tmpTextarea = nodeTextarea.cloneNode(true);

          // put the clone directly after the canvas
          if (nodeCanvas.nextSibling) {
            nodeCanvas.parentNode.insertBefore(tmpTextarea, nodeCanvas.nextSibling);
          } else {
            nodeCanvas.parentNode.appendChild(tmpTextarea);
          }

          // update the textarea in the editor 
          editors[i].textarea = tmpTextarea;

          // remove original textarea
          textarea.parentNode.removeChild(textarea);
        }
      } else {
        // no canvas or no textarea found
        structureCorrect = false;
      }
    }

    return structureCorrect;
  };

  /**
   * Perform some cleanup operations
   * 
   * - Check all *mathdoxformula* textareas and remove those without Editor
   */
  org.mathdox.formulaeditor.FormulaEditor.cleanupTextareas = function() {
    var textareas = document.getElementsByTagName("textarea");

    for (i=0; i<textareas.length; i++) {
      var textarea = textareas[i];

      // retrieve the class attribute of the textarea
      classattribute = textarea.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = textarea.getAttribute("className");
      }

      // check whether this textarea is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {
        var textareaObject = this.getEditorByTextArea(textarea);
        if (!textareaObject) {
          /* delete textarea */
          textarea.parentNode.removeChild(textarea);
        } else {
          // dirty... but works (forces page to render in some cases)
          // workaround for some bug
          // TODO : is this still necessary
          textarea.innerHTML = textareaObject.textarea.value;
        }
      }
    }  
  };

  /**
   * Add the static deleteEditor(editor) method, that deletes a formula editor
   * object. This can be useful when cleaning, for example after changes in the
   * HTML, like when a textarea has been removed.
   * 
   * editor - an index in the editors array or a FormulaEditor object
   *
   * It returns true if the editor was found and of the right type and false
   * otherwise.
   */
  org.mathdox.formulaeditor.FormulaEditor.deleteEditor = function(editor) {
    var i;

    if (typeof editor == "number") {
      /* editor is an index; check if it is valid */
      i=editor;
      if (i<0 || i>=editors.length) {
        /* wrong index */
        return false;
      }
    } else if (editor instanceof org.mathdox.formuleditor.FormulaEditor) {
      /* editor is a FormulaEditor object; look it up editor in editors array */
      i=0;
      while (i<editors.length && editors[i]!=editor) {
        i++;
      }

      /* if the editor is not found, return false */
      if (i==editors.length) {
        return false;
      }
    } else {
      /* not a number, and not a Formula Editor */
      return false;
    }

    var nodeCanvas = editors[i].canvas.canvas;
    var nodeTextarea = editors[i].textarea;
  
    // remove canvas (if exists)
    if (nodeCanvas &&nodeCanvas.parentNode) {
      nodeCanvas.parentNode.removeChild(nodeCanvas);
    }
    // remove textarea (if exists)
    if (nodeTextarea && nodeTextarea.parentNode) {
      nodeTextarea.parentNode.removeChild(nodeTextarea);
    }

    // remove editor object
    delete editors[i];
    editors.splice(i,1);

    return true;
  };

  /**
   * Add the static getEditorByCanvas(canvas) method, that returns the
   * formula editor corresponding to a certain canvas. 
   * 
   * canvas - a string or an HTMLElement
   *
   * NOTE: might not work in IE if canvas is not an HTMLElement (check)
   *
   * It returns null when none of the editors in the page corresponds to the 
   * canvas given as argument.
   */
  org.mathdox.formulaeditor.FormulaEditor.getEditorByCanvas = function(canvas) {
    var i;

    if (canvas === undefined || canvas === null) {
      /* no argument given, return null */
      return null;
    }
    /* if canvas is a string, it is an id */
    /* NOTE: testing with instanceof String does *not* work */
    if (typeof canvas == "string") {
      for (i=0; i<editors.length; i++) {
        if (canvas == editors[i].canvas.id) {
          return editors[i];
        }
      }
    /**
     * if textarea is an object in the HTML DOM tree, it is the textarea itself
     */
    } else if (canvas instanceof HTMLElement) {
      for (i=0; i<editors.length; i++) {
        if (editors[i].canvas.canvas == canvas) {
          return editors[i];
        }
      }
    }
    /* no editor found */
    return null;
  };

  /**
   * Add the static getEditorByTextArea(textarea) method, that returns the
   * formula editor corresponding to a certain textarea. 
   * 
   * textarea - a string or an HTMLTextAreaElement
   *
   * It returns null when none of the editors in the page corresponds to the 
   * textarea given as argument.
   */
  org.mathdox.formulaeditor.FormulaEditor.getEditorByTextArea = function(textarea) {
    var i;

    if (textarea === undefined || textarea === null) {
      /* no argument given, return null */
      return null;
    }
    /* if textarea is a string, it is an id */
    /* NOTE: testing with instanceof String does *not* work */
    if (typeof textarea == "string") {
      for (i=0; i<editors.length; i++) {
        if (textarea == editors[i].textarea.id) {
          return editors[i];
        }
      }
    /**
     * if textarea is an object in the HTML DOM tree, it is the textarea itself
     */
    } else if (textarea instanceof HTMLElement) {
      for (i=0; i<editors.length; i++) {
        if (editors[i].textarea == textarea) {
          return editors[i];
        }
      }
    }
    /* no editor found */
    return null;
  };

  /**
   * Add the static getFocusedEditor() method, that returns the formula editor
   * that currently has focus. Returns null when none of the editors in the page
   * have focus.
   */
  org.mathdox.formulaeditor.FormulaEditor.getFocusedEditor = function() {

    for (var i=0; i<editors.length; i++) {
      if (editors[i].hasFocus) {
        return editors[i];
      }
    }
    return null;

  };
  
  org.mathdox.formulaeditor.FormulaEditor.lastFocused = null;

  /**
   * Add the static getLastFocusedEditor() method, that returns the formula
   * editor that last had focus. Returns null when none of the editors in
   * the page have had focus.
   */
  org.mathdox.formulaeditor.FormulaEditor.getLastFocusedEditor = function() {
    var current = org.mathdox.formulaeditor.FormulaEditor.getFocusedEditor();

    if (current !== null) {
      return current;
    }
    
    return org.mathdox.formulaeditor.FormulaEditor.lastFocused;
  };
 
  /**
   * Update the editor list, based on the current tree, focusing on which
   * textareas are present.
   *
   * In effect, create a new editor for each *relevant* textarea that has no 
   * corresponding editor. Here relevant means having the class
   * mathdoxformulaeditor.
   * 
   * clean: boolean, if true also do the following:
   *   - remove all editors for which no textarea is present
   *   - remove all *relevant* canvases for which no editor is present
   *     (here relevant means having the class ???)
   */
  org.mathdox.formulaeditor.FormulaEditor.updateByTextAreas = function(clean) {
    /* let textareas be all the textareas in the document */

    var textareas = document.getElementsByTagName("textarea");

    var classattribute;

    /* do cleaning : TODO */
    var i,j;
    if (clean) {
      /* remove all editors for which no textarea is present */

      i=0;
      while (i<editors.length) {
        /* get the index of j, or textareas.length if not found */
        j=0;
        while (j<textareas.length && editors[i].textarea != textareas[j]) {
          j++;
        }
        
        if (j==textareas.length) {
          /* textarea not found, delete the editor */
          this.deleteEditor(i);
        } else {
          i=i+1;
        }
      }

      /* 
        remove all *relevant* canvases for which no editor is present 
        Here relevant means of the class: mathdoxformula
      */
      this.cleanupCanvases();
    }

    /* 
     * add new editors where needed: 
     * for each textarea:
     * - check if the class contains mathdoxformula
     * - check if no editor corresponds to it
     * - create a new editor and add it to the list of editors
     */

    for (i=0; i<textareas.length; i++) {
      var textarea = textareas[i];

      // retrieve the class attribute of the textarea
      classattribute = textarea.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = textarea.getAttribute("className");
      }

      // check whether this textarea is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {
        // create and initialize new editor
        // new should not be used as a statement: use a dummy variable
        var editor = new org.mathdox.formulaeditor.FormulaEditor(textarea);
      }
    }
  };


  /**
   * Class that represents a formula editor palette.
   */
  org.mathdox.formulaeditor.Palette = $extend(
    org.mathdox.formulaeditor.FormulaEditor, {

    // do nothing with a keydown
    onkeydown : function(event) {
      return true; 
    },
    // check for keypress (currently: zoom)
    onkeypress : function(event) {
      var result = true;

      if (event.ctrlKey) {
        switch(event.charCode) {
          case 43: // '+' larger
            this.increaseSizes();
            result = false;
            break;
          case 45: // '-' smaller
            this.decreaseSizes();
            result = false;
            break;
        }
      }

      return result; 
    },
    // handle a mouseclick
    onmousedown: function(event) {
      // check whether the mouse click falls in the canvas element
      var mouseinfo = this.mouseeventinfo(event);
      var noEditorNeeded;

      if (mouseinfo) {
        // we are clicked on
        var editor = org.mathdox.formulaeditor.FormulaEditor.getFocusedEditor();

        noEditorNeeded = 
          this.handleMouseClick(editor, mouseinfo.x, mouseinfo.y);

        if ((noEditorNeeded === false) && (editor === null)) {
          alert("No formulaeditor with focus. Please click on an editor\n"+
                "at the position where the symbol should be entered.");
        }

        return false;
      }
      else {
        // we are not clicked on 
        return true;
      }
    },
    // fake function, do not draw the cursor
    cursor : {
      draw: function() {
        return true;
      }
    },
    /**
     * containing HTMLElement if not the canvas
     * item that should be removed if this palette should be removed
     */
    htmlelement : null,
    // todo onmousedown : function(event) { }
    initialize : function(canvas) {
      if (!canvas) {
        /* first initalization, do nothing yet */
        return null;
      }
     
      var MathCanvas = org.mathdox.formulaeditor.MathCanvas;

      if (arguments.length > 0 ) { 
        this.canvas = new MathCanvas(canvas);
      }

      var highlight = true;
      if (org.mathdox.formulaeditor.options.paletteHighlight == false) {
        highlight = false;
      }

      if (highlight) {
        var palette = this;
        var redrawFunction = function() {
          palette.redraw();
        };
        var HandlerLocal = $extend(org.mathdox.formulaeditor.EventHandlerLocal, {
          // handler for onmousemove
          onmousemove: function(event) {
            var mouseinfo = palette.mouseeventinfo(event);
  
	    if (mouseinfo) {
              var pTabContainer = palette.presentation.children[0];
  
              /* mouse over update function */
              pTabContainer.handleMouseMove(mouseinfo.x,mouseinfo.y,redrawFunction);
 
	    }
            return true;
          },
          onmouseout: function(event) {
            var pTabContainer = palette.presentation.children[0];
  
            /* mouse out update function */
            pTabContainer.handleMouseMove(null,null,redrawFunction);

            return true;
          }
        });

        var handlerLocal = new HandlerLocal(canvas);
      }
 
      // default presentation: empty
      this.presentation = new org.mathdox.formulaeditor.presentation.Row();

      var url;
      if (org.mathdox.formulaeditor.options.paletteURL) {
        url = org.mathdox.formulaeditor.options.paletteURL;
      } else {
        org.mathdox.formulaeditor.Palette.description = 
          org.mathdox.formulaeditor.Palettes.defaultPalette;
        
        this.parseXMLPalette(org.mathdox.formulaeditor.Palette.description);
        this.draw();

        return;
      }

      if (!org.mathdox.formulaeditor.Palette.description) {
        org.mathdox.formulaeditor.Palette.description = "loading";
        var HTTP = com.oreilly.javascript.tdg.XMLHttp;

        var callback = function(responseText) {

          org.mathdox.formulaeditor.Palette.description = responseText;
            
          /* update palettes */
          for (var p=0; p<palettes.length; p++) {
            palettes[p].parseXMLPalette(org.mathdox.formulaeditor.Palette.description);
            palettes[p].draw();
          }
        };

        HTTP.getText(url, callback);
      } else if (org.mathdox.formulaeditor.Palette.description != "loading") {
        // set presentation and semantics
        this.parseXMLPalette(org.mathdox.formulaeditor.Palette.description);
        this.draw();
      }
    },
    handleMouseClick: function(editor,x,y) {
      var pTabContainer = this.presentation.children[0];
      /* wrapper function to be able to redraw after a tab switch */
      var palette = this;
      var redrawFunction = function() {
              palette.redraw();
      };
      var coords = pTabContainer.handleMouseClick(x,y,redrawFunction);

      if (editor === null) {
        if (coords === null) {
        /* nothing to enter, so no editor needed */
          return true; 
        } else {
          return false;
        }
      }

      var position = editor.cursor.position;

      if (coords === null) {
        return false;
      }
      var row = this.semantics.operands[coords.tab].operands[coords.row].operands[coords.col];

      var presentation = org.mathdox.formulaeditor.presentation;
      var rowPresentation = new presentation.Row(row.getPresentation(this.getPresentationContext()));
      rowPresentation.flatten();

      var moveright;
      if (rowPresentation.children) {
        for (var i=0;i<rowPresentation.children.length;i++) {
          //alert("inserting: "+i+" : "+toInsert.children[i]);

          moveright = position.row.insert(position.index, 
            rowPresentation.children[i], (i === 0));
          if (moveright) {
            position.index++;
          }
        }
      } else {
        moveright = position.row.insert(
          position.index, rowPresentation, true);

        if (moveright) {
          position.index++;
        }
      }
      editor.redraw();
      editor.save();
      return false;
    },
    parseXMLPalette : function(XMLstr) {
      var presentation;
      var Parser    = org.mathdox.formulaeditor.parsing.openmath.OpenMathParser;
      var Row       = org.mathdox.formulaeditor.presentation.Row;

      // read any OpenMath code that may be present in the textarea
      //try {
        this.semantics = new Parser().parse(XMLstr);
        presentation = new Row(this.semantics.getPresentation(this.getPresentationContext()));
        presentation.flatten();
        this.presentation = presentation;
        this.presentation.margin = 10.0;
      //}
      //catch(exception) {
      //  presentation = new Row();
      //}

      return presentation;
    }
  });

  /**
   * Remove this palette from the document
   * does three things:
   * - removes this palette from palettes
   * - removes it from the corresponding editor
   * - removes the canvas from the document
   */
  org.mathdox.formulaeditor.Palette.removePalette = function (palette) {
    /* palette should be defined */
    if (palette === null || palette === undefined) {
      return ;
    }

    var i;
    for (i=0; i<palettes.length; i++) {
      if (palettes[i] == palette) {
        // remove palette from the palettes array
        palettes.splice(i,1);
      }
    }
    // remove palette's canvas from the corresponding editor
    for (i=0; i<editors.length; i++) {
      if (editors[i].palette == palette) {
        editors[i].palette = null;
      }
    }

    // remove this palette's canvas from the page
    var palhtml;

    if (palette.htmlelement!== null && palette.htmlelement !== undefined) {
      palhtml = palette.htmlelement;
    } else {
      palhtml = palette.canvas.canvas;
    }

    palhtml.parentNode.removeChild(palhtml);
  };

  /**
   * When the document has finished loading, replace all textarea elements of
   * class 'mathdoxformula' with a formula editor.
   */

  // function that will be called upon loading
  var onload = function() {
    var options = new org.mathdox.formulaeditor.Options();
    if (options.getOption("debug") === true) {
      debug = new org.mathdox.debug.Debug();
      debug.createDebug();
    }


    // replace all textarea's of class 'mathdoxformula' with editors
    var textareas = document.getElementsByTagName("textarea");
    for (var i=0; i<textareas.length; i++) {
      var textarea = textareas[i];

      // retrieve the class attribute of the textarea
      var classattribute = textarea.getAttribute("class");

      // workaround bug in IE
      // see also http://www.doxdesk.com/personal/posts/wd/20020617-dom.html
      if (!classattribute) {
        classattribute = textarea.getAttribute("className");
      }

      // check whether this textarea is of class 'mathdoxformula'
      if (classattribute && classattribute.match(/(^| )mathdoxformula($| )/)) {

        // replace the textarea by a formula editor
        var editor = new org.mathdox.formulaeditor.FormulaEditor(textarea);

      }

    }

    // register key and mouse handlers that forward events to the editors
    var Handler = $extend(org.mathdox.formulaeditor.EventHandler, {

      onkeydown : function(event) {
        var result = true;
        for (var i=0; i<editors.length; i++) {
          var intermediate = editors[i].onkeydown(event);
          if (intermediate !== null && intermediate !== undefined &&
              intermediate === false) {
            result = false;
          }
        }
        return result;
      },

      onkeypress : function(event) {
        var result = true;

        for (var i=0; i<editors.length; i++) {
          var intermediate = editors[i].onkeypress(event);
          if (intermediate !== null && intermediate !== undefined && 
              intermediate === false) {
            result = false;
          }
        }
        return result;
      },

      onmousedown : function(event) {
        var result = true;
        var i; // counter
        if (palettes) {
          for (i=0;i<palettes.length;i++) {
            if (result) {
              result = result && palettes[i].onmousedown(event);
            }
          }
        }
        if (result) {
          // if not handled by palettes, then continue
          for (i=0; i<editors.length; i++) {
            var intermediate = editors[i].onmousedown(event);
            if (intermediate !== null && intermediate !== undefined &&
                intermediate === false) {
              result = false;
            }
          }
          return result;
        }
      }
    });
    var handler = new Handler();
    var Options = new org.mathdox.formulaeditor.Options();

    /* check for onload focus */
    var focus = Options.getOption("onloadFocus");
    if (typeof focus == "string") {
      var onloadTextArea = document.getElementById(focus);
      if (onloadTextArea) {
        var onloadEditor = org.mathdox.formulaeditor.FormulaEditor.getEditorByTextArea( onloadTextArea );
        if (onloadEditor) {
          onloadEditor.focus();
        }
      } 
    } else if (focus == true) {
      editors[0].focus();
    } 
  };

  // register the onload function as an event handler
  if (window.addEventListener) {

    // use the W3C standard way of registering event handlers
    // NOTE: Google Chrome indicates it's already finished loading, so no
    // eventlistener needs to be added.
    if (org.mathdox.formulaeditor.hasLoaded || 
      (document.readyState && document.readyState == "complete")) {
      onload();
    } else {
      window.addEventListener("load", onload, false);
    }
  } else {

    // document.body might not exist yet, if it doesn't call the check function
    // with a 50 ms delay (fixes a bug)
    
    var bodyChecker;

    bodyChecker = function() {
      if (!document.body) {
        setTimeout(bodyChecker,50);
      } else {
        if (document.body.attachEvent) {
          // use the MSIE-only way of registering event handlers
          if (document.readyState == "complete") {
            onload();
          } else {
            document.body.attachEvent("onload", onload);
          }
        } 
      }
    };
    bodyChecker();
  }

});

org.mathdox.formulaeditor.hasLoaded = false;

if (window.addEventListener) {
  var setLoaded = function() {
    org.mathdox.formulaeditor.hasLoaded = true;
  };

  // use the W3C standard way of registering event handlers
  window.addEventListener("load", setLoaded, false);
}

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/MathCanvas.js");

$require("org/mathdox/formulaeditor/Options.js");

$main(function(){

  /**
   * Adds mathematical symbol and string rendering to an HTML Canvas.
   */
  org.mathdox.formulaeditor.MathCanvas = $extend(Object, {

    /**
     * The HTML Canvas that is used for drawing mathematics.
     */
    canvas : null,

    /**
     * The name of the font that is used for drawing symbols and strings.
     */
    fontName : "cmr",

    /**
     * The font size that is used for drawing symbols and strings.
     */
    fontSizes : [ 50, 60, 70, 85, 100, 120, 144, 173, 207, 249, 298, 358, 430],
    fontSizeIdx : 7,

    /**
     * Contains previously loaded images.
     */
    imageCache : null,

    /**
     * Constructor which takes as parameter the HTML Canvas that will be used to
     * draw mathematics on. */ 
    initialize : function(canvas) {
      this.canvas = canvas;
      this.imageCache = {};
      if (org.mathdox.formulaeditor.options.fontSize) {
        var i = 0;
        while (i<this.fontSizes.length - 1 && 
          this.fontSizes[i]<org.mathdox.formulaeditor.options.fontSize) {
          i++;
        }
        this.fontSizeIdx = i;
      }
    },

    /**
     * Returns the CanvasRenderingContext2D object associated with the HTML
     * canvas.
     */
    getContext : function() {
      return this.canvas.getContext("2d");
    },

    /**
     * Draws the specified bracket (character) on the canvas, at the specified
     * position, using the current fontName and fontSize. The (x,y) coordinate
     * indicates where the left of the baseline of the symbol will appear.
     * The result of this method is one object containing the values
     * { left, top, width, height } that indicate the position and dimensions of
     * the bounding rectangle of the drawn symbol.
     * The optional parameter 'invisible' determines whether or not the symbol
     * should be drawn to the canvas. By default this parameter is 'false'.
     * Setting this parameter to 'true' can be used to obtain information about
     * the dimensions of the drawn symbol, without actually drawing on the
     * canvas.
     *
     * This function is like the drawSymbol function, except it has an extra
     * parameter minimumSize, which is used to determine the size of the
     * brackets. A bracket symbol will be used of at least that size. If no
     * symbol of that size is known it will be tried to construct it, if that
     * fails a smaller symbol will be used. See also drawSymbol.
     */
    drawBracket : function(bracket, x, y, minimumHeight, invisible, fontSizeModifier, center) {

      // retrieve font and symbol data
      var symbolData;
      var ex = this.getFontUnitEx(fontSizeModifier);

      // see if a standard symbol can be used
      for (var i=4 ; i>=1; i--) {
        var tmpData = this.getSymbolDataByPosition(bracket + i, fontSizeModifier);
        if (tmpData.height >= minimumHeight) {
          symbolData = tmpData;
        }
      }
 
      // variables used in both if and else clauses, declare them before the if
      var left, height, top, width, font, canvas, cache, drawImage, image;

      if (symbolData) {
        // draw a symbol 
        
        // calculate the position of the topleft corner, the width and the height
        if (symbolData.margin) {
          symbolData = this.extendObject(symbolData, {
            x: symbolData.x - symbolData.margin,
            width: symbolData.width + 2*symbolData.margin
          });
        }
        left   = x;
        top    = y - symbolData.height + symbolData.yadjust;
        width  = symbolData.width;
        height = symbolData.height;
        font = symbolData.font;
  
        // draw that part of the font image which contains the symbol
        if (!invisible) {
  
          canvas = this.canvas;
          cache  = this.imageCache;
  
          drawImage = function() {
            canvas.getContext("2d").drawImage(
              cache[font.image],
              symbolData.x, symbolData.y, symbolData.width, symbolData.height,
              left, top, width, height);
          };

          /* warning code used in both drawSymbol and drawBracket */
          if (cache[font.image] === null || cache[font.image] === undefined) {
            image = new Image();
            image.onload = function() {
              if (cache[font.image] instanceof Array) {
                var todo = cache[font.image];
  
                cache[font.image] = image;
  
                for (var i=0; i<todo.length; i++) {
                  todo[i](); // call stored drawImage functions
                }
              }
            };
            cache[font.image] = [];
  
            cache[font.image].push(drawImage);
  
            image.src = font.image;
          } else if (cache[font.image] instanceof Array) {
            cache[font.image].push(drawImage);
          } else {
            drawImage();
          }
 
        }
  
        // return the coordinates of the topleft corner, the width and height
        return {
          left:   left,
          top:    top,
          width:  width,
          height: height
        };
      } else {
        // construct a symbol
        var topSymbol = this.getSymbolDataByPosition(bracket+"u", fontSizeModifier);
        var bottomSymbol = this.getSymbolDataByPosition(bracket+"l", fontSizeModifier);
        var connection = this.getSymbolDataByPosition(bracket+"m", fontSizeModifier);

        if (!topSymbol.adjusted) {
          // get rid of aliased top/bottom
          // for top part
          topSymbol.adjusted = true;
          topSymbol.height -= 1;

          // for middle part
          if (connection.height > 2) {
            // get rid of aliased top/bottom
            connection.height -= 2;
            connection.y += 1;
          }

          // for bottom part
          bottomSymbol.height -= 1;
          bottomSymbol.y += 1;
        }

        left = x;
        height = Math.max(minimumHeight,
          topSymbol.height + bottomSymbol.height);
        top = y - height + bottomSymbol.yadjust;
        width = Math.max(topSymbol.width, connection.width,
          bottomSymbol.width);

        font = topSymbol.font;

        if (!invisible) {
  
          canvas = this.canvas;
          cache  = this.imageCache;
  
          drawImage = function() {
            var minXadjust = Math.min(topSymbol.xadjust,
              bottomSymbol.xadjust, connection.xadjust);
            var topPos = { 
              left: left + topSymbol.xadjust - minXadjust,
              top: top,
              width: topSymbol.width,
              height: topSymbol.height
            };
            var bottomPos = { 
              left: left + bottomSymbol.xadjust - minXadjust,
              top: top + height - bottomSymbol.height ,
              width: bottomSymbol.width,
              height: bottomSymbol.height
            };
            var connPos = { 
              left: left + connection.xadjust - minXadjust,
              top: topPos.top + topPos.height,
              width: connection.width,
              height: height - topPos.height - bottomPos.height
            };
            //alert("top: ("+topPos.left+", "+topPos.top+", "+topPos.width+", "+topPos.height+")\n"+"conn: ("+connPos.left+", "+connPos.top+", "+connPos.width+", "+connPos.height+")\n"+"bottom: ("+bottomPos.left+", "+bottomPos.top+", "+bottomPos.width+", "+bottomPos.height+")");
            //alert("font.image:"+font.image);
            canvas.getContext("2d").drawImage(
              cache[font.image],
              topSymbol.x, topSymbol.y, topSymbol.width, topSymbol.height,
              topPos.left, topPos.top, topPos.width, 
              topPos.height);
            if (connPos.height>0) {
              canvas.getContext("2d").drawImage(
                cache[font.image],
                connection.x, connection.y, connection.width, connection.height,
                connPos.left, connPos.top, 
                connPos.width, connPos.height);
            }
            canvas.getContext("2d").drawImage(
              cache[font.image],
              bottomSymbol.x, bottomSymbol.y, bottomSymbol.width, 
              bottomSymbol.height, bottomPos.left, 
              bottomPos.top, bottomPos.width, bottomPos.height);
          };
          
          /* warning code used in both drawSymbol and drawBracket */
          if (cache[font.image] === null || cache[font.image] === undefined) {
            image = new Image();
            image.onload = function() {
              if (cache[font.image] instanceof Array) {
                var todo = cache[font.image];
  
                cache[font.image] = image;
  
                for (var i=0; i<todo.length; i++) {
                  todo[i](); // call stored drawImage functions
                }
              }
            };
            cache[font.image] = [];
  
            cache[font.image].push(drawImage);
  
            image.src = font.image;
          } else if (cache[font.image] instanceof Array) {
            cache[font.image].push(drawImage);
          } else {
            drawImage();
          }
  
        }
        //alert("total: ("+left+", "+top+", "+width+", "+height+")");
         // return the coordinates of the topleft corner, the width and height
        return {
          left:   left,
          top:    top,
          width:  width,
          height: height
        };
      }
    },

    /**
     * Draws a grey/black box around on the edge of an element, depending on
     * the dimensions. It overwrites the character (that is stays inside its
     * dimensions). The box will be drawn around
     * (dimensions.left,dimensions.top) (upper left) and
     * (dimensions.left+dimensions.width - 1, dimensions.top+dimensions.height
     * - 1) (lower right). 
     *
     * if strokeStyle is defined, that style will be used to draw the
     * border of the box.
     *
     * if fillStyle is defined, the box is filled using that style
     * 
     * if both stokeStyle and fillStyle are defined, then a filled box is drawn
     * first, followed by a border.
     */
    drawBox: function(dimensions, strokeStyle, fillStyle) {
      var canvas = this.canvas;
      var context = this.getContext();

      context.save();
      
      // set styles
      if (fillStyle !== undefined) {
        context.fillStyle = fillStyle;
      }
      if (strokeStyle !== undefined) {
        context.strokeStyle = strokeStyle;
      }

      // draw a filled box
      if (fillStyle) {
        context.fillRect(dimensions.left, dimensions.top, dimensions.width, 
          dimensions.height);
      }

      // draw the box border
      if (!fillStyle || (fillStyle && strokeStyle)) {
        context.lineWidth = 1.0;
        context.strokeRect(dimensions.left, dimensions.top, 
          dimensions.width - 1 , dimensions.height - 1);
      } 

      context.restore();
    },
   
    /**
     * This function draws a box with based on dimensions, with border style
     * strokeStyle and fill style fillStyle.
     * 
     * if y is defined a baseline will be drawn as well (in the strokeStyle)
     * 
     * see also: drawBox
     */
    drawBoxWithBaseline: function(dimensions, y, strokeStyle, fillStyle) {
      this.drawBox(dimensions, fillStyle, strokeStyle);

      var canvas = this.canvas;
      var context = this.getContext();

      context.save();
      if (y) {
        if (strokeStyle !== undefined) {
          context.strokeStyle = strokeStyle;
        }
        context.beginPath();
        context.moveTo(dimensions.left, y);
        context.lineTo(dimensions.left + dimensions.width - 1, y);
        context.stroke();
        context.closePath();
      }
      context.restore();
    },

    // draw a box the size of the symbol of the letter 'f' 
    drawFBox : function(x, y, invisible, letter, typeface, fontSizeModifier) {
      var dim;
      if (letter === null || letter === undefined) {
        letter = "f";
      }
      var presentation = org.mathdox.formulaeditor.presentation;

      dim = this.drawSymbol(letter,x,y,true, typeface, fontSizeModifier);

      if (!invisible) {
        var context = this.getContext();
        context.save();
        context.fillStyle = "rgba(160,160,255,0.5)";
        context.fillRect(dim.left, dim.top, dim.width, dim.height);
        context.restore();
      }

      return dim;

    },


    /**
     * Draws the specified symbol (character) on the canvas, at the specified
     * position, using the current fontName and fontSize. The (x,y) coordinate
     * indicates where the left of the baseline of the symbol will appear.
     * The result of this method is one object containing the values
     * { left, top, width, height } that indicate the position and dimensions of
     * the bounding rectangle of the drawn symbol.
     * The optional parameter 'invisible' determines whether or not the symbol
     * should be drawn to the canvas. By default this parameter is 'false'.
     * Setting this parameter to 'true' can be used to obtain information about
     * the dimensions of the drawn symbol, without actually drawing on the
     * canvas.
     * If the typeface is "math" a slanted/italic symbol will be drawn if
     * possible.
     */
    drawSymbol : function(symbol, x, y, invisible, typeface, fontSizeModifier) {
      var mathCanvas = org.mathdox.formulaeditor.MathCanvas;
      if (mathCanvas.specialSymbols[symbol]!== undefined) {
        // special case combined symbol: 
        // draw all subsymbols and return maximum dimensions

        var dim = {
          top:    y,
          left:   x,
          width:  0,
          height: 0
        };
        var olddim;
        var i;
        var symbols = mathCanvas.specialSymbols[symbol];

        for (i=0; i< symbols.length; i++) {
          olddim = dim;
          dim = this.drawSymbol(symbols[i], x, y, invisible, typeface, fontSizeModifier);

          dim = {
            top: Math.min(olddim.top, dim.top),
            height: Math.max(olddim.top+olddim.height, dim.top+dim.height) - 
              Math.min(olddim.top, dim.top),
            left: Math.min(olddim.left, dim.left),
            width: Math.max(olddim.left+olddim.width, dim.left+dim.width) - 
              Math.min(olddim.left, dim.left)
          };
        }

        return dim;
      }

      // retrieve font and symbol data
      var symbolData = this.getSymbolData(symbol, typeface, fontSizeModifier);

      if (symbolData === null) {
	// draw an invisible box instead. Another option would be a red box
	var box =  this.drawFBox(x, y, true, null, typeface, fontSizeModifier);
	if (invisible !== true) {
	  this.drawBox(box, "rgba(255,0,0, 1.0)");
	}
	return box;
      }

      var font = symbolData.font;

      // calculate the position of the topleft corner, the width and the height
      var left   = x;
      var top    = y - symbolData.height + symbolData.yadjust;
      var width  = symbolData.width;
      var height = symbolData.height;

      // draw that part of the font image which contains the symbol
      if (!invisible) {

        var canvas = this.canvas;
        var cache  = this.imageCache;

        var drawImage = function() {
          canvas.getContext("2d").drawImage(
            cache[font.image],
            symbolData.x, symbolData.y, symbolData.width, symbolData.height,
            left, top, width, height);
        };

        /* warning code used in both drawSymbol and drawBracket */
        if (cache[font.image] === null || cache[font.image] === undefined) {
          var image = new Image();
          image.onload = function() {
            if (cache[font.image] instanceof Array) {
              var todo = cache[font.image];

              cache[font.image] = image;

              for (var i=0; i<todo.length; i++) {
                todo[i](); // call stored drawImage functions
              }
            }
          };
          cache[font.image] = [];

          cache[font.image].push(drawImage);

          image.src = font.image;
        } else if (cache[font.image] instanceof Array) {
          cache[font.image].push(drawImage);
        } else {
          drawImage();
        }
      }

      // return the coordinates of the topleft corner, the width and height
      return {
        left:   left,
        top:    top,
        width:  width,
        height: height
      };

    },

    /**
     * copy an old object, replacing only a few attributes
     */
    extendObject: function(oldObj, replace) {
      var newObj = {};
      var name; // index variable
      for (name in oldObj) {
        newObj[name] = oldObj[name];
      }
      for (name in replace) {
        newObj[name] = replace[name];
      }

      return newObj;
    },

    getSymbolData : function(symbol, typeface, fontSizeModifier) {
      // retrieve font and symbol data
      var symbolData;

      /* some special cases */
      if (symbol==' ') {
        symbolData = this.getSymbolDataByPosition(',', fontSizeModifier);
        if (symbolData) {
          symbolData = this.extendObject(symbolData, {
            x:symbolData.x+symbolData.width+1
          });
        }
      } else if (symbol == '_' ) { 
        symbolData = this.getSymbolDataByPosition('-', fontSizeModifier);
        if (symbolData) {
          symbolData = this.extendObject(symbolData, { 
            yadjust: 0 + symbolData.height 
          });
        }
      } else if (typeface == 'math') {
        symbolData = this.getSymbolDataByPosition("m"+ symbol, fontSizeModifier);
        if (! symbolData) {
          symbolData = this.getSymbolDataByPosition(symbol, fontSizeModifier);
        }
      } else {
        /* generic case */
        symbolData = this.getSymbolDataByPosition(symbol, fontSizeModifier);
      }

      /* some margins, '-', '+', middle dot */
      if (symbol == '-') {
        symbolData = this.extendObject(symbolData, { 
          margin: 2
        });
      } else if (symbol == '+') { 
        symbolData = this.extendObject(symbolData, { 
          margin: 2
        });
      } else if (symbol == '·') { // U+00B7 middle dot
        symbolData = this.extendObject(symbolData, { 
          margin: 2
        });
      }

      if (!symbolData) {
        if ((!symbol) || (symbol === '') || (symbol.charCodeAt(0) === 0)) {
          return null;
        }
      }

      if (symbolData) {
        if (symbolData.margin) {
          symbolData = this.extendObject(symbolData, {
            x: symbolData.x - symbolData.margin,
            width: symbolData.width + 2*symbolData.margin
          });
        }

        // return symboldata
        return symbolData;
      }
        
      if (!symbolData) {
        // should not happen any more
        console.log("ALERT: unsupported symbol '"+symbol+"' cannot be gotten by position");
      }

      // no symbol data found, return null
      return null;
    },

    getSymbolDataByPosition: function(symbol, fontSizeModifier) {
      var positionInfo = org.mathdox.formulaeditor.MathCanvas.symbolPositions[
        symbol];
      var fBP = org.mathdox.formulaeditor.MathCanvas.fontsByPosition;
      var fontSize = this.fontSizes[this.fontSizeIdx];
      var newFontSizeIndex;
      if (fontSizeModifier!== undefined && fontSizeModifier !== null) {
	newFontSizeIndex = this.fontSizeIdx + fontSizeModifier;
	if (0<=newFontSizeIndex && newFontSizeIndex < this.fontSizes.length) {
	  fontSize = this.fontSizes[newFontSizeIndex];
	} else if (newFontSizeIndex<0) {
	  fontSize = this.fontSizes[0];
	} else if (newFontSizeIndex>this.fontSizes.length) {
	  fontSize = this.fontSizes[this.fontSizes.length-1];
	}
      }

      if (!positionInfo) {
        //alert("no positioninfo : "+symbol);
        return null;
      }
      
      if (!fBP[positionInfo.font]) {
        alert("no metrics for this font");
        return null;
      }

      if (!fBP[positionInfo.font][fontSize]) {
        alert("no metrics for this fontsize: "+fontSize);
        return null;
      }
      
      if (positionInfo.row*16+positionInfo.col >=
        fBP[positionInfo.font][fontSize].length) {
        alert("positionInfo row: "+positionInfo.row+" col: "+positionInfo.col);
        alert("no metrics for this symbol: "+(positionInfo.row*16+positionInfo.col)+"/"+fBP[positionInfo.font][fontSize].length);
        return null;
      }

      return fBP[positionInfo.font][fontSize][ positionInfo.row * 16 +
        positionInfo.col ];
    },

    getFontUnitEm: function (fontSizeModifier) {
      var data = this.getSymbolDataByPosition("M", fontSizeModifier);

      return data.width;
    },

    getFontUnitEx: function (fontSizeModifier) {
      var data = this.getSymbolDataByPosition("x", fontSizeModifier);

      return data.height;
    },

    /**
     * Clears the canvas.
     */
    clear : function() {
      var canvas = this.canvas;
      var width  = canvas.getAttribute("width");
      var height = canvas.getAttribute("height");
      canvas.getContext("2d").clearRect(0, 0, width, height);
    },

    decreaseSize: function() {
      if ( this.fontSizeIdx>0) {
        this.fontSizeIdx = this.fontSizeIdx - 1;
      }
    },

    increaseSize: function() {
      if ( this.fontSizeIdx<this.fontSizes.length-1) {
        this.fontSizeIdx = this.fontSizeIdx + 1;
      }
    }

  });

  /**
   * Static function addFont to add fonts to the static MathCanvas in
   * fontsByPosition. Arguments are like jsMath.Img.AddFont:
   * - size: the size (in pt?) of the font
   * - data: a record with fontname: array
   *   where array contains 256 entries (relative width, relative height,
   *   yadjust, optional xadjust)
   *   followed by a list of horizontal positions, a list of vertical
   *   positions and the lower right coordinates of the picture
   */
  org.mathdox.formulaeditor.MathCanvas.addFont = function(size,data) {
    var fontSize = ""+size;

    if (!org.mathdox.formulaeditor.MathCanvas.fontsByPosition) {
      org.mathdox.formulaeditor.MathCanvas.fontsByPosition = {};
    }
    var fBP = org.mathdox.formulaeditor.MathCanvas.fontsByPosition;

    for (var fontName in data) {
      if (!fBP[fontName]) {
        fBP[fontName] = {};
      }
      var fBPN = fBP[fontName];
      var fontInput = data[fontName];
      var font = { image : $baseurl + "org/mathdox/formulaeditor/fonts/" +
          fontName + "/" + fontSize + ".png"};

      if (!fBPN[fontSize]) {
        fBPN[fontSize] = [];
      }
      var fontInfo = fBPN[fontSize];
      var length = fontInput.length;

      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 16; col ++) {
          var pos = row*16 + col;

          if (pos<length-3) {
            var xadjust = 0;
            var width = fontInput[pos][0];
            var height = fontInput[pos][1];
            var yadjust = fontInput[pos][2];
            
            if (fontInput[pos][3]) {
              xadjust = fontInput[pos][3];
            }
            var outputCharInfo = {
              x: fontInput[ length - 3 ][col] - xadjust,
              y: fontInput[ length - 2 ][row] - height + yadjust,
              width: width,
              height: height,
              xadjust: - xadjust,
              yadjust: yadjust, // XXX check the sign
              font:font
            };
          }
          
          fontInfo.push(outputCharInfo);
        }
      }
    }
  };

  // XXX: how to multiple alternatives for symbols (capital pi vs product,
  // emptyset vs o with stroke) ?
  // XXX: which symbols to choose for ',`,"
  org.mathdox.formulaeditor.MathCanvas.symbolsInFont = {
    bbold10: [
        // U+213E double-struck capital gamma
        // U+213F double-struck capital pi
        // U+2140 double-struck n-ary summation
      [  'ℾ', null, null, null, null,  'ℿ',  '⅀', null,
        // U+213D double-struck small gamma
        null, null, null, null, null,  'ℽ', null, null],
      [ null, null, null, null, null, null, null, null,
        // U+213C double-struck small pi
        null,  'ℼ', null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
        // U+2102 double-struck capital c
        // U+210D double-struck capital h
      [ null, null, null,  'ℂ', null, null, null,  'ℍ',
        // U+2115 double-struck capital n
        null, null, null, null, null, null,  'ℕ', null],
        // U+2119 double-struck capital p
        // U+211A double-struck capital q
        // U+211D double-struck capital r
      [  'ℙ',  'ℚ',  'ℝ', null, null, null, null, null,
        // U+2124 double-struck capital z
        null, null,  'ℤ', null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null]
    ],
    cmr10: [
      // U+0393 Greek capital letter gamma
      // U+0349 Greek capital letter delta
      // U+0398 Greek capital letter theta
      // U+039E Greek capital letter xi
      // U+039B Greek capital letter lamda
      // U+03A0 Greek capital letter pi
      // U+03A3 Greek capital letter sigma
      // U+03D2 Greek upsilon with hook symbol
      [  'Γ',  'Δ',  'Θ',  'Ξ',  'Λ',  'Π',  'Σ',  'ϒ',
      // U+03A6 Greek capital letter phi
      // U+03A8 Greek capital letter psi
      // U+03A9 Greek capital letter omega
         'Φ',  'Ψ',  'Ω', 'ff', 'fi', 'fl','ffi','ffl'],
      // U+00B4 Acute accent (spacing)
      // U+00B0 Degree sign
      [ null, null,  '`',  '´', null, null, null,  '°', 
      // U+00B8 Cedilla (spacing)
      // U+00DF Latin small letter sharp s
      // U+00E6 Latin small letter ae
      // U+0152 Latin small ligature oe
      // U+00F8 Latin small letter o with stroke
      // U+00C6 Latin capital ae
      // U+0152 Latin capital ligature oe
      // U+00D8 Latin capital letter o with stroke
         '¸',  'ß',  'æ',  'œ',  'ø',  'Æ',  'Œ',  'Ø'],
      [ null,  '!',  '"',  '#',  '$',  '%',  '&', '\'',
         '(',  ')',  '*',  '+',  ',', null,  '.',  '/'],
      [  '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
      // U+00A1 inverted exclamation mark
      // U+00BF inverted question mark
         '8',  '9',  ':',  ';',  '¡',  '=',  '¿',  '?'],
      [  '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',
         'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O'],
      [  'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
         'X',  'Y',  'Z',  '[', '``',  ']',  '^', '^.'],
      [ null,  'a',  'b',  'c',  'd',  'e',  'f',  'g',
         'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o'],
      [  'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
      // U+00A8 diaeresis (spacing)
         'x',  'y',  'z', null, null, null,  '~',  '¨']
    ],
    cmbx10: [
      // U+0393 Greek capital letter gamma
      // U+0349 Greek capital letter delta
      // U+0398 Greek capital letter theta
      // U+039B Greek capital letter lamda
      // U+039E Greek capital letter xi
      // U+03A0 Greek capital letter pi
      // U+03A3 Greek capital letter sigma
      // U+03D2 Greek upsilon with hook symbol
      [ 'bΓ', 'bΔ', 'bΘ', 'bΛ', 'bΞ', 'bΠ', 'bΣ', 'bϒ', 
      // U+03A6 Greek capital letter phi
      // U+03A8 Greek capital letter psi
      // U+03A9 Greek capital letter omega
        'bΦ', 'bΨ', 'bΩ','bff','bfi','bfl','bffi','bffl'],
      // U+00B4 Acute accent (spacing)
      // U+00B0 Degree sign
      [ null, null, 'b`', 'b´', null, null, null, 'b°',
      // U+00B8 Cedilla (spacing)
      // U+00DF Latin small letter sharp s
      // U+00E6 Latin small letter ae
      // U+0152 Latin small ligature oe
      // U+00F8 Latin small letter o with stroke
      // U+00C6 Latin capital ae
      // U+0152 Latin capital ligature oe
      // U+00D8 Latin capital letter o with stroke
        'b¸', 'bß', 'bæ', 'bœ', 'bø', 'bÆ', 'bŒ', 'bØ'],
      [ null, 'b!', 'b"', 'b#', 'b$', 'b%', 'b&','b\'',
        'b(', 'b)', 'b*', 'b+', 'b,', 'b-', 'b.', 'b/'],
      [ 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7',
      // U+00A1 inverted exclamation mark
      // U+00BF inverted question mark
        'b8', 'b9', 'b:', 'b;', 'b¡', 'b=', 'b¿', 'b?'],
      [ 'b@', 'bA', 'bB', 'bC', 'bD', 'bE', 'bF', 'bG',
        'bH', 'bI', 'bJ', 'bK', 'bL', 'bM', 'bN', 'bO'],
      [ 'bP', 'bQ', 'bR', 'bS', 'bT', 'bU', 'bV', 'bW',
        'bX', 'bY', 'bZ', 'b[','b``', 'b]', 'b^','b^.'],
      [ null, 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'bg',
        'bh', 'bi', 'bj', 'bk', 'bl', 'bm', 'bn', 'bo'],
      [ 'bp', 'bq', 'br', 'bs', 'bt', 'bu', 'bv', 'bw',
      // U+00A8 diaeresis (spacing)
        'bx', 'by', 'bz', null, null, null, 'b~', 'b¨']
    ],
    cmex10: [
      // U+230A left floor
      // U+230B right floor
      // U+2308 right ceiling
      // U+2309 right ceiling
      [ '(1', ')1', '[1', ']1', '⌊1', '⌋1', '⌈1', '⌉1',
        '{1', '}1', '<1', '>1', null, null, '/1','\\1'],
      [ '(2', ')2', '(3', ')3', '[3', ']3', '⌊3', '⌋3',
        '⌈3', '⌉3', '{3', '}3', '<3', '>3', '/3','\\3'],
      [ '(4', ')4', '[4', ']4', '⌊4', '⌋4', '⌈4', '⌉4',
        '{4', '}4', '<4', '>4', '/4','\\4', '/2','\\2'],
      [ '(u', ')u', '[u', ']u', '[l', ']l', '[m', ']m',
        '{u', '}u', '{l', '}l', '{m', '}m', null, null],
      [ '(l', ')l', '(m', ')m', '<2', '>2', null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null],
      [ null, null, null, null, null, null, null, null,
        '[2', ']2', '⌊2', '⌋2', '⌈2', '⌉2', '{2', '}2'],
      [ 'v1', 'v2', 'v3', 'v4', 'vl', 'vm', 'vu', null,
        null, null, null, null, null, null, null, null]
    ],
    cmmi10: [
      // U+0393 Greek capital letter gamma
      // U+0349 Greek capital letter delta
      // U+0398 Greek capital letter theta
      // U+039E Greek capital letter xi
      // U+039B Greek capital letter lamda
      // U+03A0 Greek capital letter pi
      // U+03A3 Greek capital letter sigma
      // U+03D2 Greek upsilon with hook symbol
      [ 'mΓ', 'mΔ', 'mΘ', 'mΛ', 'mΞ', 'mΠ', 'mΣ', 'mϒ',
      // U+03A6 Greek capital letter phi
      // U+03A8 Greek capital letter psi
      // U+03A9 Greek capital letter omega
      // U+03B1 Greek small letter alpha
      // U+03B2 Greek small letter beta
      // U+03B3 Greek small letter gamma
      // U+03B4 Greek small letter delta
      // U+03F5 Greek lunate epsilon symbol
        'mΦ', 'mΨ', 'mΩ', 'mα', 'mβ', 'mγ', 'mδ', 'mϵ'],
      // U+03B6 Greek small letter zeta
      // U+03B7 Greek small letter eta
      // U+03B8 Greek small letter theta
      // U+03B9 Greek small letter iota
      // U+03BA Greek small letter kappa
      // U+03BB Greek small letter lamda
      // U+03BC Greek small letter mu
      // U+03BD Greek small letter nu
      [ 'mζ', 'mη', 'mθ', 'mι', 'mκ', 'λ', 'mμ', 'mν',
      // U+03BE Greek small letter xi
      // U+03C0 Greek small letter pi
      // U+03C1 Greek small letter rho
      // U+03C3 Greek small letter sigma
      // U+03C4 Greek small letter tau
      // U+03C5 Greek small letter upsilon
      // U+03D5 Greek phi symbol
      // U+03C7 Greek small letter chi
        'mξ', 'π', 'mρ', 'mσ', 'mτ', 'mυ', 'mϕ', 'mχ'],
      // U+03C8 Greek small letter psi
      // U+03C9 Greek small letter omega
      // U+03B5 Greek small letter epsilon
      // U+03D1 Greek theta symbol
      // U+03D6 Greek pi symbol
      // U+03F1 Greek rho symbol
      // U+03C2 Greek small letter final sigma
      // U+03C6 Greek small letter phi
      [ 'mψ', 'mω', 'mε', 'mϑ', 'mϖ', 'mϱ', 'mς', 'mφ',
        null, null, null, null, null, null, null, null],
      [ 'm0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7',
        'm8', 'm9', 'm.', 'm,',  '<', 'm/',  '>', 'm*'],
      // U+2202 Partial differential
      [  '∂', 'mA', 'mB', 'mC', 'mD', 'mE', 'mF', 'mG',
        'mH', 'mI', 'mJ', 'mK', 'mL', 'mM', 'mN', 'mO'],
      [ 'mP', 'mQ', 'mR', 'mS', 'mT', 'mU', 'mV', 'mW',
        'mX', 'mY', 'mZ', null, null, null, null, null],
      [ null, 'ma', 'mb', 'mc', 'md', 'me', 'mf', 'mg',
        'mh', 'mi', 'mj', 'mk', 'ml', 'mm', 'mn', 'mo'],
      [ 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw',
        'mx', 'my', 'mz', null, null, null, null, null]
    ],
    cmsy10: [
      // U+00B7 middle dot
      // U+00D7 multiplication sign
      // U+204E low asterisk
      // U+00F7 division sign
      // U+22C4 diamond operator 
      // U+00B1 plus-minus sign
      // U+2213 minus-or-plus sign
      [  '-',  '·',  '×',  '⁎',  '÷',  '⋄',  '±',  '∓',
      // U+2295 circled plus
      // U+2296 circled minus
      // U+2297 circled times
      // U+2298 circled division slash
      // U+2299 circled dot operator
      // U+25CB white circle
      // U+2218 ring operator
      // U+2219 bullet operator
         '⊕',  '⊖',  '⊗',  '⊘',  '⊙',  '○',  '∘',  '∙' ],
      // U+224D equivalent to
      // U+2261 identical to
      // U+2286 subset of or equal to
      // U+2287 superset of or equal to
      // U+2264 less than or equal to
      // U+2265 greater than or equal to
      // U+227C precedes or equal to
      // U+227D succeeds or equal to
      [  '≍',  '≡',  '⊆',  '⊇',  '≤',  '≥',  '≼',  '≽',
      // U+223C tilde operator
      // U+2248 almost equal to
      // U+2282 subset of
      // U+2283 superset of
      // U+226A much less-than
      // U+226B much greater-than
      // U+227A precedes
      // U+227B succeeds
         '∼',  '≈',  '⊂',  '⊃',  '≪',  '≫',  '≺',  '≻' ],
      // U+2190 leftwards arrow
      // U+2192 rightwards arrow
      // U+2191 upwards arrow
      // U+2193 downwards arrow
      // U+2194 left right arrow
      // U+2197 north east arrow
      // U+2198 south east arrow
      // U+2243 asymptotically equal to
      [  '←',  '→',  '↑',  '↓',  '↔',  '↗',  '↘',  '≃',
      // U+21D0 leftwards double arrow
      // U+21D2 rightwards double arrow
      // U+21D1 upwards double arrow
      // U+21D3 downwards double arrow
      // U+21D4 left right double arrow
      // U+2196 north west arrow
      // U+2199 south west arrow
      // U+221D proportional to
         '⇐',  '⇒',  '⇑',  '⇓',  '⇔',  '↖',  '↙',  '∝' ],
      // U+2032 [superscript] prime
      // U+221E infinity
      // U+2208 element of
      // U+220B contains as member
      // U+25B3 white up-pointing triangle
      // U+25BD white down-pointing triangle
      // U+2215 division slash
      [  '′',  '∞',  '∈',  '∋',  '△',  '▽',  '∕', null,
      // U+2200 for all
      // U+2203 there exists
      // U+00AC not sign
      // U+2205 empty set
      // U+211C black-letter capital r
      // U+2111 black-letter capital i
      // U+22A4 down tack
      // U+22A5 up tack
         '∀',  '∃',  '¬',  '∅',  'ℜ',  'ℑ',  '⊤', '⊥' ],
      // U+2135 alef symbol
      [  'ℵ', null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null ],
      [ null, null, null, null, null, null, null, null,
      // U+222A union
      // U+2229 intersection
      // U+2227 logical and
      // U+2228 logical or
      // U+228E multiset union
        null, null, null,  '∪',  '∩',  '⊎',  '∧',  '∨' ],
      // U+22A2 right tack
      // U+22A3 left tack
      // U+230A left floor
      // U+230B right floor
      [  '⊢',  '⊣',  '⌊',  '⌋',  '⌈',  '⌉',  '{',  '}',
      // U+27E8 mathematical left angle bracket
      // U+27E9 mathematical right angle bracket
      // U+2225 parallel to
      // U+2195 up down arrow
      // U+21D5 up down double arrow
      // U+2240 wreath product
         '⟨',  '⟩',  '|',  '∥',  '↕',  '⇕', '\\',  '≀' ],
      // U+221A square root
      // U+2210 n-ary coproduct
      // U+2207 nabla
      // U+222B integral
      // U+2294 square cup
      // U+2293 square cap
      // U+2291 square image of or equal to
      // U+2292 square original of or equal to
      [  '√',  '∐',  '∇',  '∫',  '⊔',  '⊓',  '⊑',  '⊒',
      // U+00A7 section sign
      // U+2020 dagger
      // U+2021 double dagger
      // U+00B6 pilcrow sign
      // U+2663 black club suit
      // U+2662 white diamond suit
      // U+2661 white heart suit
      // U+2660 black spade suit
         '§',  '†',  '‡',  '¶',  '♣',  '♢',  '♡',  '♠' ]
    ]
  };

  org.mathdox.formulaeditor.MathCanvas.specialSymbols = {
    // U+2146 differential D
    'ⅆ': [ 'd' ],
    // U+2260 not equal to
    // U+2215 division slash
    '≠': [ '=', '∕' ]
  };

  org.mathdox.formulaeditor.MathCanvas.fillSymbolPositions = function() {
    var sp,sif;
    if (!org.mathdox.formulaeditor.MathCanvas.symbolPositions) {
      org.mathdox.formulaeditor.MathCanvas.symbolPositions = {};
    }
    sp = org.mathdox.formulaeditor.MathCanvas.symbolPositions;
    sif = org.mathdox.formulaeditor.MathCanvas.symbolsInFont;

    for (var font in sif) {
      var symbolsArray = sif[font];
      for (var row = 0; row<symbolsArray.length; row++) {
        for (var col = 0; col<symbolsArray[row].length; col++) {
          var symbol = symbolsArray[row][col];
          if (symbol !== null && symbol !== undefined) {
            if (symbol in sp) {
              alert("duplicate entry for \""+symbol+"\"\n"+sp[symbol].font+
                ": ("+sp[symbol].row+", "+sp[symbol].col+")\n"+
                font+": ("+row+", "+col+")\n");
            } else {
              sp[symbol] = {
                font: font,
                row: row,
                col: col
              };
            }
          }
        }
      }
    }
  };

  org.mathdox.formulaeditor.MathCanvas.fillSymbolPositions();

});

  $package("org.mathdox.formulaeditor");
$identify("org/mathdox/formulaeditor/MathCanvasFill.js");
$require("org/mathdox/formulaeditor/MathCanvas.js");

$main(function(){
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmbx10:[[5,5,0],[7,5,0],[6,5,0],[6,5,0],[5,5,0],[6,5,0],[6,5,0],[6,5,0],
  [6,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0],[5,5,0],[7,5,0],[7,5,0],
  [2,4,0],[3,6,2,1],[3,2,-3],[3,2,-3,-1],[2,2,-3,-1],[4,2,-3],[4,2,-3],[2,2,-3,-2],
  [2,2,2,-1],[4,5,0],[6,4,0],[6,4,0],[4,5,1],[7,5,0],[8,6,1],[6,6,1],
  [3,1,-2],[2,5,0],[4,3,-2],[7,7,2],[4,6,1],[7,7,1],[6,5,0],[2,3,-2],
  [3,8,2],[3,8,2],[4,4,-2],[6,6,1],[2,2,1],[3,1,-1],[2,1,0],[4,8,2],
  [4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],
  [4,5,0],[4,5,0],[2,3,0],[2,4,1],[2,6,2],[6,3,0],[4,6,2],[4,5,0],
  [6,5,0],[6,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0],[5,5,0],[6,5,0],
  [6,5,0],[3,5,0],[4,6,1],[6,5,0],[5,5,0],[8,5,0],[6,5,0],[6,5,0],
  [5,5,0],[6,7,2],[6,5,0],[4,5,0],[6,5,0],[6,5,0],[6,5,0],[8,5,0],
  [6,5,0],[6,5,0],[5,5,0],[2,8,2],[3,3,-2,-1],[2,8,2],[2,2,-3,-1],[2,2,-3],
  [2,3,-2],[4,4,0],[5,5,0],[4,4,0],[5,5,0],[4,4,0],[3,5,0],[4,6,2],
  [5,5,0],[2,5,0],[3,7,2,1],[4,5,0],[2,5,0],[7,4,0],[5,4,0],[4,4,0],
  [5,6,2],[5,6,2],[3,4,0],[3,4,0],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-1],[8,1,-1],[3,2,-3,-1],[4,1,-4],[4,2,-3],
  [3,13,23,33,42,52,62,72,
  82,92,102,111,121,131,141,151],[9,17,26,34,42,51,59,67],[162,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmbx10:[[5,6,0],[7,6,0],[7,7,1],[6,6,0],[6,6,0],[7,6,0],[6,6,0],[7,6,0],
  [7,6,0],[7,6,0],[7,6,0],[6,6,0],[5,6,0],[5,6,0],[8,6,0],[8,6,0],
  [3,4,0],[4,6,2,1],[2,2,-4,-1],[2,2,-4,-2],[3,2,-4,-1],[3,2,-4,-1],[4,1,-4],[3,2,-4,-2],
  [3,2,2,-1],[5,6,0],[7,4,0],[7,4,0],[5,6,1],[8,6,0],[9,7,1],[7,7,1],
  [3,2,-2],[2,6,0],[4,4,-2],[7,8,2],[4,7,1],[8,7,1],[7,7,1],[2,3,-3],
  [3,8,2],[3,8,2],[4,4,-2],[7,6,1],[2,4,2],[3,2,-1],[2,2,0],[4,8,2],
  [5,6,0],[4,6,0],[5,6,0],[5,7,1],[5,6,0],[5,6,0],[5,7,1],[5,6,0],
  [5,7,1],[5,6,0],[2,4,0],[2,6,2],[2,6,2],[7,4,0],[4,6,2],[4,6,0],
  [7,6,0],[7,6,0],[6,6,0],[7,7,1],[7,6,0],[6,6,0],[6,6,0],[7,7,1],
  [7,6,0],[4,6,0],[5,7,1],[7,6,0],[6,6,0],[9,6,0],[7,6,0],[7,7,1],
  [6,6,0],[7,8,2],[7,7,1],[5,7,1],[6,6,0],[7,7,1],[7,6,0],[10,6,0],
  [7,6,0],[7,6,0],[6,6,0],[2,8,2,-1],[4,4,-2,-1],[2,8,2],[3,2,-4,-1],[2,2,-4],
  [2,4,-2],[5,4,0],[5,6,0],[4,4,0],[5,6,0],[4,4,0],[4,6,0],[5,6,2],
  [5,6,0],[3,6,0],[4,8,2,1],[5,6,0],[3,6,0],[8,4,0],[5,4,0],[5,4,0],
  [5,6,2],[5,6,2],[4,4,0],[4,4,0],[3,5,0],[5,4,0],[5,4,0],[7,4,0],
  [5,4,0],[5,6,2],[4,4,0],[5,1,-2],[9,1,-2],[3,2,-4,-1],[3,2,-4,-1],[3,2,-4,-1],
  [3,15,27,39,51,63,75,86,
  98,110,122,134,146,157,169,181],[11,21,31,41,51,61,71,81],[194,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmbx10:[[7,7,0],[9,7,0],[9,8,1],[8,7,0],[8,7,0],[9,7,0],[8,7,0],[9,7,0],
  [8,7,0],[9,7,0],[8,7,0],[8,7,0],[6,7,0],[6,7,0],[10,7,0],[10,7,0],
  [3,5,0],[4,7,2,1],[3,2,-5,-1],[3,2,-5,-2],[4,2,-5,-1],[4,2,-5,-1],[5,2,-5],[3,2,-5,-3],
  [4,2,2,-1],[6,7,0],[8,5,0],[9,5,0],[6,7,1],[10,7,0],[11,8,1],[12,9,1,3],
  [4,2,-2],[2,7,0,-1],[5,4,-3],[9,9,2],[5,9,1],[9,9,1],[9,8,1],[3,4,-3],
  [3,10,2,-1],[4,10,2],[5,5,-3],[9,9,2],[3,4,2],[4,2,-1],[3,2,0],[5,10,2],
  [6,8,1],[5,7,0],[6,7,0],[6,8,1],[6,7,0],[6,8,1],[6,8,1],[6,7,0],
  [6,10,1],[6,10,1],[3,5,0],[3,7,2],[2,7,2,-1],[9,3,-1],[5,7,2],[5,9,0],
  [9,7,0],[9,7,0],[8,7,0],[8,8,1],[9,7,0],[8,7,0],[7,7,0],[9,8,1],
  [9,7,0],[4,7,0],[6,8,1],[9,7,0],[7,7,0],[11,7,0],[9,7,0],[8,8,1],
  [8,7,0],[8,9,2],[9,8,1],[6,8,1],[8,7,0],[9,8,1],[9,7,0],[12,7,0],
  [12,7,0,3],[9,7,0],[7,7,0],[2,10,2,-1],[5,4,-3,-1],[2,10,2],[4,2,-5,-1],[3,2,-5],
  [3,4,-3],[6,5,0],[6,7,0],[5,5,0],[6,7,0],[5,5,0],[5,7,0],[6,7,2],
  [7,7,0],[3,7,0],[4,9,2,1],[6,9,0],[3,7,0],[10,9,0],[7,5,0],[6,5,0],
  [6,7,2],[6,7,2],[5,5,0],[5,5,0],[4,7,0],[7,5,0],[6,5,0],[8,5,0],
  [6,5,0],[6,7,2],[5,5,0],[6,1,-2],[12,1,-2],[8,5,-2,3],[4,2,-5,-1],[4,2,-5,-1],
  [4,18,32,46,59,73,87,101,
  115,128,142,156,170,184,198,211],[13,24,36,47,59,71,82,94],[227,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmbx10:[[8,9,0],[11,9,0],[10,10,1],[10,9,0],[9,9,0],[11,9,0],[10,9,0],[10,9,0],
  [10,9,0],[10,9,0],[10,9,0],[9,9,0],[8,9,0],[8,9,0],[11,9,0],[11,9,0],
  [4,6,0],[5,9,3,1],[3,3,-6,-1],[3,3,-6,-3],[5,2,-6,-1],[5,3,-6,-1],[5,2,-6,-1],[4,3,-6,-3],
  [5,3,3,-1],[7,9,0],[10,7,1],[11,7,1],[7,9,2],[12,9,0],[13,10,1,-1],[10,10,1],
  [4,2,-3],[2,9,0,-1],[6,5,-4],[11,12,3],[7,10,1],[11,10,1],[10,10,1],[2,5,-4,-1],
  [4,12,3,-1],[4,12,3],[5,6,-3,-1],[10,10,2],[2,5,3,-1],[4,2,-2],[2,2,0,-1],[6,12,3],
  [7,9,1],[5,8,0,-1],[7,8,0],[7,9,1],[7,8,0],[7,9,1],[7,9,1],[7,9,0],
  [7,9,1],[7,9,1],[2,6,0,-1],[2,9,3,-1],[2,9,3,-1],[10,4,-1],[6,9,3],[6,9,0],
  [10,10,1],[10,9,0],[9,9,0],[10,10,1],[10,9,0],[9,9,0],[8,9,0],[10,10,1],
  [11,9,0],[5,9,0],[7,10,1],[11,9,0],[8,9,0],[13,9,0],[11,9,0],[10,10,1],
  [9,9,0],[10,12,3],[11,10,1],[7,10,1],[9,9,0],[10,10,1],[10,9,0],[14,9,0],
  [10,9,0],[11,9,0],[8,9,0],[3,12,3,-1],[6,5,-4,-1],[3,12,3],[5,3,-6,-1],[2,3,-6,-1],
  [3,5,-4],[7,7,1],[8,9,0],[6,6,0],[8,10,1],[6,7,1],[6,9,0],[7,9,3],
  [8,9,0],[4,9,0],[5,12,3,1],[7,9,0],[4,9,0],[12,6,0],[8,6,0],[7,7,1],
  [8,9,3],[8,9,3],[6,6,0],[5,7,1],[5,8,0],[8,7,1],[7,6,0],[10,6,0],
  [7,6,0],[7,9,3],[6,6,0],[7,1,-3],[14,1,-3],[5,3,-6,-1],[5,2,-7,-1],[5,3,-6,-1],
  [5,22,38,55,72,89,106,122,
  139,156,173,190,206,223,240,257],[16,30,45,59,73,87,101,115],[275,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmbx10:[[9,10,0],[13,10,0],[12,11,1],[11,10,0],[10,10,0],[12,10,0],[10,10,0,-1],[11,10,0,-1],
  [11,10,0],[11,10,0,-1],[11,10,0],[11,10,0],[9,10,0],[9,10,0],[13,10,0],[13,10,0],
  [4,7,0],[5,10,3,1],[4,3,-7,-1],[4,3,-7,-3],[4,2,-7,-2],[6,3,-7,-1],[6,2,-7,-1],[4,3,-7,-4],
  [6,3,3,-1],[8,10,0],[12,8,1],[12,8,1],[8,10,2],[14,10,0],[15,11,1,-1],[12,12,1],
  [5,2,-4],[3,10,0,-1],[7,6,-4],[12,13,3,-1],[8,12,1],[13,12,1],[12,11,1],[3,5,-5,-1],
  [5,15,4,-1],[4,15,4,-1],[6,7,-4,-1],[11,11,2,-1],[3,6,3,-1],[5,2,-2],[3,3,0,-1],[6,15,4,-1],
  [8,11,1],[6,10,0,-1],[8,10,0],[8,11,1],[8,10,0],[8,11,1],[8,11,1],[7,11,1,-1],
  [8,11,1],[8,11,1],[3,7,0,-1],[3,10,3,-1],[3,10,3,-1],[11,5,-1,-1],[6,10,3,-1],[6,10,0,-1],
  [12,11,1],[12,10,0],[11,10,0],[11,11,1],[12,10,0],[10,10,0],[10,10,0],[12,11,1],
  [12,10,0],[6,10,0],[8,11,1],[12,10,0],[9,10,0],[15,10,0],[12,10,0],[12,11,1],
  [10,10,0],[12,13,3],[12,11,1],[8,11,1],[11,10,0],[12,11,1],[12,10,0],[17,10,0],
  [12,10,0],[12,10,0],[8,10,0,-1],[3,15,4,-1],[6,6,-4,-2],[3,15,4],[4,3,-7,-2],[3,3,-7,-1],
  [4,6,-4],[8,7,0],[9,10,0],[7,7,0],[9,11,1],[7,7,0],[7,10,0],[8,10,3],
  [9,10,0],[4,10,0],[5,13,3,1],[9,10,0],[5,10,0],[14,7,0],[9,7,0],[8,7,0],
  [9,10,3],[9,10,3],[7,7,0],[6,8,1],[6,10,1],[9,7,0],[8,7,0],[12,7,0],
  [9,7,0],[8,10,3],[7,7,0],[8,2,-3],[16,2,-3],[5,3,-7,-2],[6,2,-8,-1],[6,3,-7,-1],
  [6,26,45,65,85,104,124,144,
  164,183,203,223,243,262,282,302],[19,36,52,69,85,102,119,135],[324,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmbx10:[[11,12,0],[15,12,0,-1],[14,13,1,-1],[13,12,0],[13,12,0],[15,12,0],[12,12,0,-1],[13,12,0,-1],
  [12,12,0,-1],[13,12,0,-1],[13,12,0,-1],[13,12,0],[11,12,0],[11,12,0],[16,12,0],[16,12,0],
  [5,8,0],[6,12,4,1],[4,4,-8,-2],[4,4,-8,-4],[6,2,-9,-2],[7,4,-8,-1],[8,2,-9,-1],[5,3,-9,-5],
  [6,4,4,-2],[10,13,1],[14,9,1],[15,9,1],[10,12,2],[18,12,0],[19,13,1,-1],[14,14,1,-1],
  [6,3,-4],[4,12,0,-1],[8,6,-6],[15,16,4,-1],[8,14,1,-1],[15,14,1,-1],[15,13,1],[4,6,-6,-1],
  [6,17,4,-1],[5,17,4,-1],[8,8,-5,-1],[13,14,3,-1],[4,7,4,-1],[6,2,-3],[3,3,0,-1],[8,17,4,-1],
  [9,13,1],[8,12,0,-1],[8,12,0,-1],[9,13,1],[10,12,0],[8,12,1,-1],[9,13,1],[9,13,1,-1],
  [9,13,1],[9,13,1],[3,8,0,-1],[4,12,4,-1],[4,13,4,-1],[13,6,-1,-1],[8,13,4,-1],[8,12,0,-1],
  [14,13,1,-1],[14,12,0],[13,12,0],[12,13,1,-1],[14,12,0],[13,12,0],[12,12,0],[14,13,1,-1],
  [15,12,0],[7,12,0],[9,13,1],[15,12,0],[11,12,0],[18,12,0],[15,12,0],[13,13,1,-1],
  [13,12,0],[13,16,4,-1],[15,13,1],[9,13,1,-1],[13,12,0],[15,13,1],[15,13,1],[20,13,1],
  [15,12,0],[15,12,0],[10,12,0,-1],[3,17,4,-2],[8,7,-5,-2],[4,17,4],[6,3,-9,-2],[3,3,-9,-1],
  [3,7,-5,-1],[10,9,1],[11,13,1],[8,9,1],[11,13,1],[9,9,1],[8,12,0],[10,12,4],
  [11,12,0],[5,12,0],[6,16,4,1],[10,12,0],[5,12,0],[16,8,0],[11,8,0],[10,9,1],
  [11,12,4],[11,12,4],[8,8,0],[7,9,1],[7,12,1],[11,9,1],[10,8,0],[14,8,0],
  [10,8,0],[10,12,4],[8,8,0],[10,1,-4],[20,1,-4],[7,4,-8,-2],[7,2,-10,-1],[7,3,-9,-1],
  [7,31,54,78,102,125,149,173,
  196,220,244,268,291,315,339,362],[22,42,61,81,101,121,141,161],[388,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmbx10:[[13,14,0],[17,14,0,-1],[16,15,1,-1],[16,14,0],[14,14,0,-1],[18,14,0],[15,14,0,-1],[16,14,0,-1],
  [15,14,0,-1],[16,14,0,-1],[15,14,0,-1],[15,14,0],[12,14,0],[12,14,0],[19,14,0],[19,14,0],
  [5,9,0,-1],[8,13,4,2],[5,4,-10,-2],[5,4,-10,-5],[7,3,-10,-2],[8,4,-10,-2],[9,2,-11,-1],[5,4,-10,-6],
  [7,4,4,-2],[12,15,1],[16,10,1],[18,10,1],[11,13,2],[21,14,0],[22,15,1,-1],[16,16,1,-1],
  [7,3,-5],[3,15,0,-2],[10,7,-7],[17,18,4,-1],[10,17,2,-1],[17,17,2,-1],[16,15,1,-1],[4,7,-7,-1],
  [6,20,5,-2],[6,20,5,-1],[9,9,-6,-1],[16,16,3,-1],[4,8,4,-1],[7,3,-3],[4,4,0,-1],[10,20,5,-1],
  [11,15,1],[9,13,0,-1],[10,14,0,-1],[10,15,1,-1],[11,14,0],[10,14,1,-1],[10,15,1,-1],[11,15,1,-1],
  [10,15,1,-1],[10,15,1,-1],[4,9,0,-1],[4,13,4,-1],[3,15,5,-2],[16,6,-2,-1],[9,14,4,-1],[9,14,0,-1],
  [16,15,1,-1],[17,14,0],[15,14,0],[15,15,1,-1],[17,14,0],[15,14,0],[14,14,0],[16,15,1,-1],
  [18,14,0],[8,14,0],[11,15,1],[17,14,0],[13,14,0],[21,14,0],[18,14,0],[15,15,1,-1],
  [15,14,0],[16,18,4,-1],[18,15,1],[11,15,1,-1],[16,14,0],[17,15,1],[17,15,1],[24,15,1],
  [17,14,0],[17,14,0],[12,14,0,-1],[4,20,5,-2],[10,8,-6,-2],[4,20,5],[7,4,-10,-2],[4,4,-10,-1],
  [4,8,-6,-1],[12,10,1],[12,15,1],[10,10,1],[12,15,1],[10,10,1],[9,14,0],[12,13,4],
  [13,14,0],[5,14,0,-1],[8,18,4,2],[12,14,0],[5,14,0,-1],[19,9,0],[13,9,0],[11,10,1],
  [12,13,4],[12,13,4],[9,9,0],[9,10,1],[8,14,1],[13,10,1],[12,9,0],[17,9,0],
  [12,9,0],[12,13,4],[10,9,0],[12,1,-5],[23,1,-5],[7,5,-10,-3],[8,3,-11,-2],[8,3,-11,-2],
  [8,37,65,94,122,150,179,207,
  236,264,293,321,349,378,406,435],[26,50,74,98,122,145,169,193],[466,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmbx10:[[16,17,0],[21,17,0,-1],[19,18,1,-1],[18,17,0,-1],[17,17,0,-1],[21,17,0],[18,17,0,-1],[19,17,0,-1],
  [18,17,0,-1],[19,17,0,-1],[18,17,0,-1],[18,17,0],[15,17,0],[15,17,0],[23,17,0],[23,17,0],
  [6,11,0,-1],[9,16,5,2],[6,5,-12,-2],[6,5,-12,-5],[8,4,-12,-3],[10,5,-12,-2],[10,2,-13,-2],[7,5,-12,-7],
  [8,5,5,-3],[14,18,1],[20,12,1],[21,12,1],[13,17,3],[24,17,0,-1],[26,18,1,-2],[19,20,2,-1],
  [8,4,-6],[4,17,0,-2],[11,9,-8,-1],[21,22,5,-1],[12,20,2,-1],[21,20,2,-1],[19,18,1,-1],[5,9,-8,-2],
  [8,24,6,-2],[8,24,6,-1],[11,11,-7,-1],[19,20,4,-1],[4,9,5,-2],[8,3,-4],[4,4,0,-2],[12,24,6,-1],
  [12,17,1,-1],[10,16,0,-2],[12,16,0,-1],[12,17,1,-1],[13,16,0],[12,17,1,-1],[12,17,1,-1],[13,18,1,-1],
  [12,17,1,-1],[12,17,1,-1],[4,11,0,-2],[4,16,5,-2],[4,17,5,-2],[19,8,-2,-1],[11,17,5,-1],[11,17,0,-1],
  [19,18,1,-1],[19,17,0,-1],[19,17,0],[18,18,1,-1],[20,17,0],[18,17,0],[17,17,0],[20,18,1,-1],
  [21,17,0],[10,17,0],[13,18,1],[21,17,0],[16,17,0],[25,17,0,-1],[21,17,0],[19,18,1,-1],
  [18,17,0],[19,22,5,-1],[21,18,1],[13,18,1,-1],[18,17,0,-1],[20,18,1,-1],[21,18,1],[28,18,1],
  [20,17,0],[21,17,0],[15,17,0,-1],[4,24,6,-3],[11,9,-8,-3],[5,24,6],[8,5,-12,-3],[4,4,-13,-2],
  [5,9,-8,-1],[14,12,1],[15,18,1],[12,12,1],[15,18,1],[12,12,1],[10,17,0,-1],[14,16,5],
  [14,17,0,-1],[6,17,0,-1],[9,22,5,2],[15,17,0],[6,17,0,-1],[22,11,0,-1],[14,11,0,-1],[13,12,1],
  [15,16,5],[15,16,5],[11,11,0],[10,12,1],[10,17,1],[14,12,1,-1],[14,12,1],[20,12,1],
  [14,11,0],[14,16,5],[11,11,0],[14,1,-6],[28,1,-6],[9,5,-12,-3],[10,3,-14,-2],[10,4,-13,-2],
  [10,44,78,112,147,181,215,249,
  283,317,352,386,420,454,488,522],[32,61,90,118,147,176,204,233],[560,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmbx10:[[18,20,0,-1],[25,21,0,-1],[23,22,1,-1],[22,21,0,-1],[20,20,0,-1],[24,20,0,-1],[22,20,0,-1],[23,21,0,-1],
  [22,20,0,-1],[23,20,0,-1],[22,21,0,-1],[22,21,0],[18,21,0],[18,21,0],[27,21,0],[27,21,0],
  [8,13,0,-1],[10,19,6,2],[7,7,-14,-3],[7,7,-14,-7],[9,4,-15,-4],[11,7,-14,-3],[13,2,-16,-2],[7,6,-15,-9],
  [10,6,6,-3],[16,22,1,-1],[23,15,1,-1],[24,15,1,-1],[16,19,3],[29,20,0,-1],[31,22,1,-2],[23,24,2,-1],
  [10,4,-8],[6,21,0,-2],[13,11,-10,-1],[25,27,6,-1],[14,24,2,-1],[25,24,2,-1],[24,22,1,-1],[6,11,-10,-2],
  [8,30,8,-3],[9,30,8,-1],[13,14,-8,-2],[23,23,4,-1],[6,11,6,-2],[10,3,-5],[5,5,0,-2],[14,30,8,-1],
  [15,20,1,-1],[13,19,0,-2],[14,19,0,-1],[15,20,1,-1],[16,19,0],[14,20,1,-1],[15,20,1,-1],[16,21,1,-1],
  [15,20,1,-1],[15,20,1,-1],[5,13,0,-2],[5,19,6,-2],[6,21,6,-2],[23,9,-3,-1],[13,21,6,-1],[13,21,0,-1],
  [23,22,1,-1],[23,21,0,-1],[21,20,0,-1],[22,22,1,-1],[23,20,0,-1],[20,20,0,-1],[19,20,0,-1],[24,22,1,-1],
  [24,20,0,-1],[11,20,0,-1],[16,21,1],[24,20,0,-1],[18,20,0,-1],[30,20,0,-1],[24,20,0,-1],[23,22,1,-1],
  [20,20,0,-1],[23,27,6,-1],[24,21,1,-1],[16,22,1,-1],[21,20,0,-1],[24,21,1,-1],[25,21,1],[34,21,1],
  [24,20,0,-1],[25,20,0],[18,20,0,-1],[6,30,8,-3],[13,10,-10,-4],[6,30,8],[10,5,-15,-3],[5,6,-15,-2],
  [6,10,-10,-1],[16,15,1,-1],[17,22,1,-1],[13,15,1,-1],[17,22,1,-1],[15,15,1],[12,21,0,-1],[16,20,6,-1],
  [17,21,0,-1],[8,21,0,-1],[10,27,6,2],[16,21,0,-1],[8,21,0,-1],[27,13,0,-1],[17,13,0,-1],[16,15,1],
  [17,19,6,-1],[17,19,6,-1],[12,13,0,-1],[11,15,1,-1],[12,20,1],[17,14,1,-1],[17,14,1],[24,14,1],
  [17,13,0],[17,19,6],[13,13,0,-1],[17,2,-7],[34,2,-7],[11,6,-15,-4],[11,4,-17,-3],[11,5,-16,-3],
  [12,53,94,135,175,216,257,298,
  339,380,421,462,502,543,584,625],[37,72,106,140,175,209,243,278],[670,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmbx10:[[21,24,0,-1],[29,24,0,-2],[27,25,1,-2],[25,24,0,-1],[24,23,0,-1],[29,24,0,-1],[24,24,0,-2],[27,24,0,-2],
  [24,24,0,-2],[27,24,0,-2],[26,24,0,-1],[25,24,0,-1],[20,24,0,-1],[20,24,0,-1],[31,24,0,-1],[31,24,0,-1],
  [9,16,0,-1],[12,23,7,2],[8,7,-17,-4],[8,7,-17,-8],[11,6,-17,-4],[13,7,-17,-3],[15,3,-18,-2],[9,6,-18,-10],
  [11,7,7,-4],[19,25,1,-1],[27,17,1,-1],[29,17,1,-1],[18,23,4,-1],[34,24,0,-1],[37,25,1,-2],[27,28,2,-2],
  [11,5,-9],[6,24,0,-3],[15,13,-11,-1],[29,31,7,-2],[16,28,2,-2],[29,28,2,-2],[28,25,1,-1],[7,13,-11,-2],
  [10,35,9,-3],[10,35,9,-2],[15,16,-10,-2],[27,27,5,-2],[7,13,7,-2],[11,5,-5],[6,6,0,-2],[16,35,9,-2],
  [17,24,1,-1],[15,23,0,-2],[17,23,0,-1],[17,24,1,-1],[18,23,0,-1],[16,24,1,-2],[17,24,1,-1],[17,24,1,-2],
  [17,24,1,-1],[17,24,1,-1],[6,16,0,-2],[7,23,7,-2],[6,24,7,-3],[27,11,-3,-2],[15,24,7,-2],[15,24,0,-2],
  [27,25,1,-2],[28,24,0,-1],[25,24,0,-1],[24,25,1,-2],[27,24,0,-1],[24,24,0,-1],[22,24,0,-1],[27,25,1,-2],
  [29,24,0,-1],[13,24,0,-1],[18,25,1],[28,24,0,-1],[21,24,0,-1],[35,24,0,-1],[29,24,0,-1],[26,25,1,-2],
  [24,24,0,-1],[26,31,7,-2],[29,25,1,-1],[18,25,1,-2],[25,23,0,-1],[28,25,1,-1],[29,25,1],[40,25,1],
  [28,24,0,-1],[29,24,0],[20,24,0,-2],[6,35,9,-4],[16,13,-11,-4],[7,35,9],[11,6,-18,-4],[6,6,-18,-2],
  [6,13,-11,-2],[18,17,1,-1],[20,25,1,-1],[16,17,1,-1],[20,25,1,-1],[16,17,1,-1],[14,24,0,-1],[18,23,7,-1],
  [20,24,0,-1],[9,24,0,-1],[12,31,7,2],[19,24,0,-1],[9,24,0,-1],[31,16,0,-1],[20,16,0,-1],[18,17,1,-1],
  [20,23,7,-1],[20,23,7,-1],[14,16,0,-1],[14,17,1,-1],[13,23,1],[20,17,1,-1],[20,17,1],[28,17,1],
  [20,16,0],[20,23,7],[15,16,0,-1],[20,2,-8],[39,2,-8],[13,8,-17,-4],[14,4,-20,-3],[13,6,-18,-3],
  [14,64,113,162,211,260,309,359,
  408,457,506,555,604,653,703,752],[46,87,128,170,211,253,294,335],[806,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmbx10:[[26,28,0,-1],[35,29,0,-2],[32,30,1,-2],[31,29,0,-1],[28,28,0,-2],[35,28,0,-1],[30,29,0,-2],[32,29,0,-2],
  [30,29,0,-2],[32,29,0,-2],[30,29,0,-2],[30,29,0,-1],[24,29,0,-1],[24,29,0,-1],[37,29,0,-1],[37,29,0,-1],
  [11,19,0,-1],[14,28,9,3],[10,8,-21,-4],[10,8,-21,-9],[13,6,-21,-5],[15,9,-20,-4],[18,3,-22,-3],[10,7,-22,-13],
  [13,9,9,-5],[23,30,1,-1],[32,20,1,-1],[35,20,1,-1],[22,28,5,-1],[41,29,0,-1],[44,30,1,-3],[32,34,3,-2],
  [14,6,-11],[7,29,0,-4],[18,15,-14,-1],[35,37,8,-2],[19,34,3,-2],[35,34,3,-2],[33,30,1,-2],[8,15,-14,-3],
  [12,42,11,-4],[12,42,11,-2],[18,19,-12,-3],[32,32,6,-2],[8,15,8,-3],[13,5,-7],[7,7,0,-3],[19,42,11,-2],
  [21,28,1,-1],[18,27,0,-3],[20,27,0,-2],[20,28,1,-2],[22,27,0,-1],[20,28,1,-2],[20,28,1,-2],[21,29,1,-2],
  [20,28,1,-2],[20,28,1,-2],[7,19,0,-3],[7,27,8,-3],[7,30,9,-4],[32,13,-4,-2],[18,30,9,-2],[18,29,0,-2],
  [32,30,1,-2],[33,29,0,-1],[30,29,0,-1],[30,30,1,-2],[33,29,0,-1],[29,28,0,-1],[27,28,0,-1],[33,30,1,-2],
  [35,29,0,-1],[16,29,0,-1],[21,30,1,-1],[34,29,0,-1],[26,29,0,-1],[43,29,0,-1],[35,29,0,-1],[31,30,1,-2],
  [29,29,0,-1],[31,37,8,-2],[35,30,1,-1],[22,30,1,-2],[30,28,0,-1],[34,30,1,-1],[34,30,1,-1],[47,30,1,-1],
  [34,29,0,-1],[35,29,0],[25,29,0,-2],[7,42,11,-5],[19,15,-14,-5],[7,42,11,-1],[13,8,-21,-5],[7,7,-22,-3],
  [8,15,-14,-2],[22,20,1,-1],[24,30,1,-1],[19,20,1,-1],[24,30,1,-1],[20,20,1,-1],[17,29,0,-1],[22,28,9,-1],
  [25,29,0,-1],[11,29,0,-1],[14,38,9,3],[24,29,0,-1],[11,29,0,-1],[38,19,0,-1],[25,19,0,-1],[22,20,1,-1],
  [24,27,8,-1],[24,27,8,-1],[18,19,0,-1],[16,20,1,-1],[16,27,1],[25,20,1,-1],[23,20,1,-1],[32,20,1,-1],
  [24,19,0],[24,28,9],[18,19,0,-1],[24,2,-10],[48,2,-10],[16,9,-21,-5],[16,5,-24,-4],[16,7,-22,-4],
  [17,76,135,194,253,311,370,429,
  488,547,606,664,723,782,841,900],[55,104,154,203,253,302,352,401],[964,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmbx10:[[31,34,0,-1],[42,35,0,-2],[38,36,1,-3],[36,35,0,-2],[34,34,0,-2],[42,34,0,-1],[35,34,0,-3],[38,35,0,-3],
  [35,34,0,-3],[38,34,0,-3],[37,35,0,-2],[36,35,0,-1],[29,35,0,-1],[29,35,0,-1],[45,35,0,-1],[45,35,0,-1],
  [12,22,0,-2],[17,32,10,3],[12,10,-25,-5],[12,10,-25,-11],[16,7,-25,-6],[18,10,-24,-5],[22,3,-27,-3],[13,9,-26,-15],
  [16,10,10,-6],[27,36,1,-1],[39,24,1,-1],[42,24,1,-1],[26,32,5,-1],[48,34,0,-2],[52,36,1,-4],[38,40,3,-3],
  [15,7,-13,-1],[9,35,0,-4],[22,18,-16,-1],[41,44,10,-3],[22,40,3,-3],[41,40,3,-3],[39,36,1,-2],[9,18,-16,-4],
  [14,50,13,-5],[14,50,13,-3],[22,22,-15,-3],[38,38,7,-3],[9,18,10,-4],[16,6,-8],[8,8,0,-4],[22,50,13,-3],
  [24,34,1,-2],[21,32,0,-4],[24,33,0,-2],[24,34,1,-2],[26,33,0,-1],[24,33,1,-2],[24,34,1,-2],[25,35,1,-3],
  [24,34,1,-2],[24,34,1,-2],[8,22,0,-4],[8,32,10,-4],[9,35,10,-4],[38,15,-5,-3],[21,35,10,-3],[21,35,0,-3],
  [38,36,1,-3],[39,35,0,-2],[36,34,0,-1],[35,36,1,-3],[39,34,0,-1],[35,34,0,-1],[32,34,0,-1],[39,36,1,-3],
  [42,34,0,-1],[19,34,0,-1],[25,35,1,-1],[41,34,0,-1],[31,34,0,-1],[50,34,0,-2],[42,34,0,-1],[37,36,1,-3],
  [35,34,0,-1],[37,45,10,-3],[41,35,1,-1],[26,36,1,-3],[35,34,0,-2],[41,35,1,-1],[41,35,1,-1],[56,35,1,-1],
  [40,34,0,-1],[42,34,0],[29,34,0,-3],[9,50,13,-6],[22,18,-16,-6],[9,50,13,-1],[16,8,-26,-6],[8,8,-26,-4],
  [9,18,-16,-3],[27,24,1,-1],[29,35,1,-1],[23,24,1,-1],[29,35,1,-1],[24,24,1,-1],[20,35,0,-2],[27,33,10,-1],
  [29,34,0,-2],[12,34,0,-2],[17,44,10,3],[28,34,0,-1],[13,34,0,-2],[44,22,0,-2],[29,22,0,-2],[26,24,1,-1],
  [29,32,10,-1],[29,32,10,-1],[21,22,0,-1],[20,24,1,-1],[18,33,1,-1],[29,23,1,-2],[28,23,1,-1],[39,23,1,-1],
  [28,22,0,-1],[28,32,10,-1],[22,22,0,-1],[29,3,-12],[57,3,-12],[17,10,-25,-7],[20,6,-28,-4],[19,7,-27,-5],
  [21,91,162,233,303,374,445,516,
  586,657,728,798,869,940,1010,1081],[64,124,183,243,302,362,421,481],[1158,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmbx10:[[36,41,0,-2],[50,42,0,-3],[46,43,1,-3],[44,42,0,-2],[41,40,0,-2],[49,41,0,-2],[43,41,0,-3],[46,42,0,-3],
  [43,41,0,-3],[46,41,0,-3],[43,42,0,-3],[43,42,0,-1],[35,42,0,-1],[35,42,0,-1],[54,42,0,-1],[54,42,0,-1],
  [15,27,0,-2],[20,39,12,4],[13,12,-30,-7],[13,12,-30,-14],[18,9,-30,-8],[22,12,-29,-6],[26,4,-32,-4],[15,11,-31,-18],
  [19,12,12,-7],[32,43,1,-2],[46,28,1,-2],[50,28,1,-1],[31,40,7,-1],[58,41,0,-2],[63,43,1,-4],[46,48,4,-3],
  [18,8,-16,-1],[10,42,0,-5],[26,21,-20,-2],[50,53,12,-3],[28,49,4,-3],[50,49,4,-3],[48,43,1,-2],[11,21,-20,-4],
  [17,60,15,-6],[17,60,15,-3],[26,27,-18,-4],[46,46,8,-3],[11,22,12,-4],[19,6,-10],[10,10,0,-4],[28,60,15,-3],
  [30,40,1,-2],[25,39,0,-5],[28,39,0,-3],[29,40,1,-2],[31,39,0,-1],[28,40,1,-3],[29,40,1,-2],[30,41,1,-3],
  [29,40,1,-2],[29,40,1,-2],[10,27,0,-4],[11,39,12,-4],[10,43,13,-5],[46,18,-6,-3],[26,42,12,-3],[26,42,0,-3],
  [46,43,1,-3],[47,42,0,-2],[43,41,0,-2],[43,43,1,-3],[47,41,0,-2],[41,41,0,-2],[38,41,0,-2],[47,43,1,-3],
  [49,41,0,-2],[22,41,0,-2],[31,42,1,-1],[49,41,0,-2],[36,41,0,-2],[60,41,0,-2],[49,41,0,-2],[45,43,1,-3],
  [41,41,0,-2],[45,54,12,-3],[49,42,1,-2],[31,43,1,-3],[43,40,0,-2],[48,42,1,-2],[49,42,1,-1],[68,42,1,-1],
  [48,41,0,-2],[50,41,0,-1],[35,41,0,-3],[11,60,15,-7],[26,21,-20,-8],[11,60,15,-1],[19,10,-31,-7],[10,10,-31,-4],
  [11,21,-20,-3],[32,28,1,-1],[34,42,1,-2],[27,28,1,-2],[34,42,1,-2],[29,28,1,-1],[24,42,0,-2],[32,39,12,-1],
  [35,41,0,-2],[15,41,0,-2],[20,53,12,4],[33,41,0,-2],[16,41,0,-2],[54,27,0,-2],[35,27,0,-2],[31,28,1,-1],
  [34,39,12,-2],[34,39,12,-2],[24,27,0,-2],[23,28,1,-2],[22,39,1,-1],[35,28,1,-2],[34,28,1,-1],[47,28,1,-1],
  [34,27,0,-1],[34,39,12,-1],[27,27,0,-1],[34,3,-15],[68,3,-15],[21,12,-30,-8],[23,7,-34,-5],[22,9,-32,-6],
  [25,110,195,280,364,449,534,619,
  704,789,874,959,1043,1128,1213,1298],[77,149,220,292,363,434,506,577],[1390,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmex10:[[6,9,8,3],[3,9,8],[2,10,9,-1],[2,10,9],[2,10,9,-1],[2,10,9],[2,9,8,-1],[2,9,8],
  [2,9,8,-1],[2,9,8,-1],[3,9,8],[3,9,8],[1,5,5,-1],[2,5,5,-1],[4,9,8],[4,9,8],
  [7,14,13,3],[3,14,13],[4,18,17,-1],[4,18,17],[3,18,17,-1],[2,18,17],[3,18,17,-1],[3,18,17],
  [3,18,17,-1],[3,18,17],[4,18,17,-1],[4,18,17,-1],[4,18,17,-1],[5,18,17],[7,18,17],[7,18,17],
  [9,22,21,3],[4,22,21],[3,22,21,-1],[3,22,21],[4,22,21,-1],[3,22,21],[4,22,21,-1],[3,22,21],
  [4,22,21,-1],[4,22,21,-1],[4,22,21,-1],[5,22,21],[9,22,21],[9,22,21],[6,14,13],[6,14,13],
  [9,14,13,3],[5,14,13],[3,14,13,-2],[3,14,13],[3,14,13,-2],[3,14,13],[1,5,5,-2],[2,5,5,-1],
  [3,7,7,-2],[3,7,7,-1],[3,7,7,-2],[3,7,7,-1],[3,13,13,-1],[3,13,13,-2],[2,3,3,-2],[1,5,5,-2],
  [9,14,13,3],[5,14,13],[1,5,5,-2],[2,5,5,-3],[4,14,13],[4,14,13],[6,7,7],[8,10,10],
  [5,8,8],[7,16,16],[8,7,7],[11,10,10],[11,7,7,3],[11,10,10],[11,7,7,3],[11,10,10],
  [10,8,7,3],[7,7,7],[5,8,8],[6,7,7],[6,7,7],[6,7,7],[6,7,7],[6,7,7],
  [10,10,10],[9,10,10],[7,16,16],[8,10,10],[8,10,10],[8,10,10],[8,10,10],[8,10,10],
  [10,8,7,3],[9,10,10],[4,1,-4],[7,2,-4],[10,2,-4],[4,1,-4],[7,2,-4],[10,2,-4],
  [6,19,13,3],[2,14,13],[3,14,13,-1],[3,14,13],[3,14,13,-1],[3,14,13],[3,14,13,-1],[3,14,13,-1],
  [10,9,8,3],[6,13,13,-1],[6,17,17,-1],[6,21,21,-1],[5,13,13,-1],[2,5,5,-4],[4,5,4,-4],[3,5,5,-1],
  [3,5,5,-1],[4,4,4],[5,3,2,1],[4,3,2],[4,3,0],[4,3,0],[5,5,5],[5,4,4],
  [3,16,28,41,53,66,78,91,
  103,116,129,141,154,166,179,191],[11,42,72,103,134,165,196,226],[205,256]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmex10:[[3,10,9,-1],[3,11,10],[2,11,10,-1],[2,11,10],[3,11,10,-1],[3,10,10],[3,11,10,-1],[3,10,9],
  [3,11,10,-1],[3,11,10,-1],[3,9,9],[3,11,10],[1,5,5,-1],[3,5,5,-1],[4,10,10],[4,10,9],
  [4,15,14,-1],[4,15,14],[5,20,19,-1],[5,20,19],[2,20,19,-2],[3,20,19],[3,20,19,-2],[3,20,19],
  [3,20,19,-2],[3,20,19],[4,20,19,-1],[4,20,19,-1],[5,20,19,-1],[5,20,19],[8,20,19],[8,20,19],
  [5,25,24,-1],[5,25,24],[3,25,24,-2],[3,25,24],[3,25,24,-2],[3,25,24],[3,25,24,-2],[3,25,24],
  [5,25,24,-1],[5,25,24,-1],[5,25,24,-1],[5,25,24,-1],[10,25,24],[10,25,24],[6,15,14],[6,15,14],
  [5,16,15,-2],[5,16,15],[4,15,14,-2],[3,15,14],[4,16,15,-2],[3,16,15],[2,5,5,-2],[1,5,5,-2],
  [3,8,8,-3],[3,8,8,-1],[3,9,8,-3],[3,9,8,-1],[3,16,15,-1],[3,16,15,-3],[1,4,3,-3],[1,5,5,-2],
  [5,15,14,-2],[5,15,14],[2,5,5,-2],[2,5,5,-3],[4,15,14,-1],[4,15,14],[7,8,8],[9,12,12],
  [5,9,9],[8,18,18],[9,8,8],[12,12,12],[9,8,8],[12,12,12],[9,8,8],[12,12,12],
  [8,8,8],[7,8,8],[5,9,9],[7,8,8],[7,8,8],[7,8,8],[7,8,8],[7,8,8],
  [11,12,12],[10,12,12],[8,18,18],[9,12,12],[9,12,12],[9,12,12],[9,12,12],[9,12,12],
  [7,8,8],[10,12,12],[5,2,-4],[8,2,-4],[12,3,-4],[5,1,-5],[8,1,-5],[12,1,-5],
  [3,16,15,-1],[2,16,15],[3,15,15,-1],[3,16,15],[3,15,14,-1],[3,15,14],[4,15,14,-1],[4,15,14,-1],
  [7,10,10,-1],[7,14,14,-1],[7,19,19,-1],[7,24,24,-1],[5,15,15,-1],[1,5,5,-5],[4,6,5,-5],[3,5,5,-2],
  [4,5,5,-1],[4,5,5,-1],[5,3,2,1],[5,3,2,1],[5,3,0,1],[5,3,0,1],[6,5,5],[6,5,5],
  [4,19,34,49,64,79,94,109,
  124,139,154,169,184,199,215,230],[13,50,87,124,161,198,235,272],[246,308]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmex10:[[3,13,12,-1],[3,13,12],[2,13,12,-2],[3,13,12],[3,13,12,-2],[3,13,12],[3,13,12,-2],[3,13,12],
  [4,13,12,-1],[4,13,12,-1],[3,13,12,-1],[4,13,12],[1,8,7,-1],[4,8,7,-1],[6,13,12],[6,13,12],
  [5,19,18,-1],[5,19,18],[5,25,24,-2],[6,25,24],[4,25,24,-2],[3,25,24],[4,25,24,-2],[4,25,24],
  [4,25,24,-2],[4,25,24],[6,25,24,-1],[6,25,24,-1],[6,25,24,-1],[6,25,24,-1],[10,25,24],[10,25,24],
  [6,31,30,-2],[6,31,30],[4,31,30,-2],[4,31,30],[5,31,30,-2],[4,31,30],[5,31,30,-2],[4,31,30],
  [6,31,30,-1],[6,31,30,-1],[6,31,30,-1],[6,31,30,-1],[13,31,30],[13,31,30],[8,19,18],[8,19,18],
  [7,19,18,-2],[6,19,18],[4,19,18,-3],[4,19,18],[4,19,18,-3],[4,19,18],[1,6,6,-3],[2,6,6,-2],
  [5,10,10,-3],[4,10,10,-1],[5,10,9,-3],[4,10,9,-1],[4,20,19,-1],[4,20,19,-3],[2,5,4,-3],[1,6,6,-3],
  [7,19,18,-2],[6,19,18],[2,8,7,-2],[2,8,7,-4],[5,19,18,-1],[4,19,18,-1],[8,10,10],[11,14,14],
  [6,12,12],[10,23,23],[11,10,10],[15,14,14],[14,10,10,3],[15,14,14],[14,10,10,3],[15,14,14],
  [10,10,10],[9,10,10],[6,12,12],[8,10,10],[8,10,10],[8,10,10],[8,10,10],[8,10,10],
  [14,14,14],[13,14,14],[10,23,23],[11,14,14],[11,14,14],[11,14,14],[11,14,14],[11,14,14],
  [9,10,10],[13,14,14],[6,3,-5],[10,3,-5],[15,3,-5],[9,3,-5,3],[10,2,-6],[15,2,-6],
  [3,19,18,-2],[3,19,18],[3,19,18,-2],[3,19,18],[3,19,18,-2],[3,19,18],[5,19,18,-1],[5,19,18,-1],
  [10,13,12,-1],[10,19,18,-1],[10,25,24,-1],[10,31,30,-1],[7,19,18,-1],[1,7,6,-7],[4,7,6,-7],[4,6,6,-2],
  [5,6,6,-1],[5,6,6,-1],[6,4,2,1],[6,5,3,1],[6,4,0,1],[6,4,0,1],[8,6,6],[8,6,6],
  [4,22,39,57,75,92,110,127,
  145,162,180,198,215,233,250,268],[15,58,101,145,188,231,274,317],[287,359]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmex10:[[4,15,14,-1],[4,15,14],[3,15,14,-2],[3,15,14],[4,15,14,-2],[4,15,14],[4,15,14,-2],[4,15,14],
  [5,15,14,-1],[5,15,14,-1],[4,15,14,-1],[4,15,14,-1],[2,8,8,-1],[4,9,8,-1],[7,15,14],[7,15,14],
  [5,22,21,-2],[5,22,21],[7,30,29,-2],[7,30,29],[4,30,29,-3],[4,30,29],[4,30,29,-3],[4,30,29],
  [4,30,29,-3],[4,30,29],[7,30,29,-1],[7,30,29,-1],[7,30,29,-1],[7,30,29,-1],[12,30,29],[12,30,29],
  [7,37,36,-2],[7,37,36],[4,37,36,-3],[4,37,36],[5,37,36,-3],[5,37,36],[5,37,36,-3],[5,37,36],
  [7,37,36,-1],[7,37,36,-1],[8,37,36,-1],[7,37,36,-1],[15,37,36],[15,37,36],[9,22,21],[9,22,21],
  [7,23,22,-3],[7,23,22],[5,23,22,-3],[5,23,22],[5,23,22,-3],[5,23,22],[2,8,8,-3],[2,8,8,-3],
  [5,11,11,-4],[4,11,11,-2],[5,12,11,-4],[4,12,11,-2],[4,23,22,-2],[5,23,22,-4],[2,5,4,-4],[2,7,7,-3],
  [7,22,21,-3],[7,22,21],[2,9,8,-3],[2,9,8,-5],[6,22,21,-1],[5,22,21,-1],[10,12,12],[13,17,17],
  [8,14,14],[12,27,27],[13,12,12],[18,17,17],[13,12,12],[18,17,17],[13,12,12],[18,17,17],
  [12,12,12],[11,12,12],[8,14,14],[10,12,12],[10,12,12],[10,12,12],[10,12,12],[10,12,12],
  [17,17,17],[15,17,17],[12,27,27],[13,17,17],[13,17,17],[13,17,17],[13,17,17],[13,17,17],
  [11,12,12],[15,17,17],[7,3,-6],[12,3,-7],[18,3,-7],[7,2,-7],[12,2,-7],[18,2,-7],
  [4,23,22,-2],[3,23,22],[4,23,22,-2],[4,23,22],[4,22,21,-2],[4,23,22],[6,22,21,-1],[6,22,21,-1],
  [12,15,14,-1],[12,22,21,-1],[12,30,29,-1],[12,37,36,-1],[8,23,22,-1],[1,9,8,-8],[5,8,7,-8],[4,8,8,-3],
  [6,7,7,-1],[6,7,7,-1],[7,5,3,1],[7,5,3,1],[7,4,0,1],[7,4,0,1],[9,8,8],[9,7,7],
  [5,27,48,69,91,112,133,155,
  176,197,219,240,261,283,304,325],[19,72,124,177,229,281,334,386],[349,437]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmex10:[[4,18,17,-2],[5,18,17],[4,18,17,-2],[3,18,17],[5,18,17,-2],[4,18,17],[5,18,17,-2],[4,18,17],
  [6,18,17,-1],[6,18,17,-1],[5,18,17,-1],[5,18,17,-1],[1,10,9,-2],[4,10,9,-2],[8,18,17],[8,17,16],
  [6,26,25,-2],[6,26,25],[8,34,33,-2],[8,34,33],[5,34,33,-3],[4,34,33],[5,34,33,-3],[5,34,33],
  [5,34,33,-3],[5,34,33],[8,34,33,-1],[8,34,33,-1],[8,34,33,-1],[8,34,33,-1],[14,34,33],[14,34,33],
  [8,43,42,-3],[8,43,42],[5,43,42,-3],[5,43,42],[6,43,42,-3],[6,43,42],[6,43,42,-3],[6,43,42],
  [8,43,42,-2],[8,43,42,-2],[8,43,42,-2],[9,43,42,-1],[17,43,42],[17,43,42],[11,26,25],[11,26,25],
  [8,26,25,-4],[9,26,25],[6,26,25,-4],[5,26,25],[6,26,25,-4],[5,26,25],[2,9,9,-4],[2,9,9,-3],
  [5,13,13,-5],[6,13,13,-2],[5,14,13,-5],[6,14,13,-2],[6,27,26,-2],[5,27,26,-5],[3,6,5,-5],[1,9,9,-4],
  [8,26,25,-4],[9,26,25],[2,10,9,-4],[3,10,9,-6],[7,26,25,-1],[6,26,25,-1],[11,14,14],[15,20,20],
  [9,16,16],[14,31,31],[15,14,14],[21,20,20],[15,14,14],[21,20,20],[15,14,14],[21,20,20],
  [14,14,14],[13,14,14],[9,16,16],[11,14,14],[11,14,14],[11,14,14],[11,14,14],[11,14,14],
  [20,20,20],[18,20,20],[14,31,31],[15,20,20],[15,20,20],[15,20,20],[15,20,20],[15,20,20],
  [13,14,14],[18,20,20],[8,3,-8],[14,3,-8],[21,3,-8],[8,3,-8],[14,3,-8],[20,3,-8],
  [4,26,25,-3],[4,26,25],[5,26,25,-3],[5,26,25],[5,26,25,-3],[5,26,25],[7,26,25,-1],[7,26,25,-1],
  [14,18,17,-1],[14,26,25,-1],[14,34,33,-1],[14,43,42,-1],[10,26,25,-1],[2,10,9,-9],[6,9,8,-9],[5,9,9,-3],
  [7,9,9,-1],[7,9,9,-1],[8,5,3,1],[8,5,3,1],[8,5,0,1],[8,5,0,1],[11,9,9],[11,9,9],
  [6,31,56,82,107,132,157,182,
  207,232,257,282,307,332,358,383],[23,84,146,208,269,331,392,454],[410,514]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmex10:[[5,21,20,-2],[6,21,20],[4,21,20,-3],[4,21,20],[5,21,20,-3],[5,21,20],[5,21,20,-3],[5,21,20],
  [6,21,20,-2],[6,21,20,-2],[6,21,20,-1],[6,21,20,-1],[2,12,11,-2],[5,12,11,-2],[8,21,20,-1],[8,21,20,-1],
  [7,31,30,-3],[8,31,30],[9,42,41,-3],[9,41,40],[5,42,41,-4],[5,42,41],[6,42,41,-4],[6,42,41],
  [6,42,41,-4],[6,42,41],[9,41,40,-2],[9,42,41,-2],[9,41,40,-2],[10,41,40,-1],[16,41,40,-1],[16,41,40,-1],
  [9,52,51,-4],[10,52,51],[6,52,51,-4],[6,52,51],[7,52,51,-4],[7,52,51],[7,52,51,-4],[7,52,51],
  [10,52,51,-2],[10,52,51,-2],[10,52,51,-2],[11,52,51,-1],[20,52,51,-1],[20,52,51,-1],[12,31,30,-1],[12,31,30,-1],
  [10,32,31,-5],[10,32,31],[7,31,30,-5],[6,31,30],[7,31,30,-5],[6,31,30],[2,11,11,-5],[2,11,11,-4],
  [7,16,16,-6],[7,16,16,-2],[7,17,16,-6],[6,17,16,-3],[7,32,31,-2],[7,32,31,-6],[3,7,6,-6],[1,11,11,-5],
  [10,31,30,-5],[10,31,30],[2,12,11,-5],[2,12,11,-8],[7,31,30,-2],[8,31,30,-1],[13,17,17,-1],[17,24,24,-1],
  [10,19,19,-1],[15,38,38,-1],[17,17,17,-1],[24,24,24,-1],[17,17,17,-1],[24,24,24,-1],[17,17,17,-1],[24,24,24,-1],
  [16,17,17,-1],[14,17,17,-1],[10,19,19,-1],[13,17,17,-1],[13,17,17,-1],[13,17,17,-1],[13,17,17,-1],[13,17,17,-1],
  [23,24,24,-1],[20,24,24,-1],[15,38,38,-1],[17,24,24,-1],[17,24,24,-1],[17,24,24,-1],[17,24,24,-1],[17,24,24,-1],
  [14,17,17,-1],[20,24,24,-1],[10,4,-9],[17,4,-9],[25,4,-9],[10,3,-10],[17,3,-10],[25,3,-10],
  [5,31,30,-3],[5,31,30],[6,31,30,-3],[6,31,30],[6,31,30,-3],[6,31,30],[8,31,30,-2],[8,31,30,-2],
  [16,21,20,-2],[16,31,30,-2],[16,42,41,-2],[16,52,51,-2],[11,32,31,-2],[2,12,11,-11],[8,11,10,-11],[5,11,11,-4],
  [9,11,11,-1],[8,10,10,-2],[9,6,4,1],[9,6,4,1],[9,6,0,1],[9,6,0,1],[12,11,11,-1],[12,10,10,-1],
  [7,38,68,98,128,158,188,218,
  248,278,309,339,369,399,429,459],[26,100,174,248,322,396,470,544],[492,616]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmex10:[[6,24,23,-3],[6,24,23,-1],[4,25,24,-4],[5,25,24],[5,25,24,-4],[6,25,24],[5,25,24,-4],[6,25,24],
  [8,25,24,-2],[8,25,24,-2],[6,25,24,-2],[7,24,23,-1],[2,14,13,-2],[7,14,13,-2],[10,25,24,-1],[10,24,23,-1],
  [9,37,36,-3],[9,37,36],[10,49,48,-4],[11,49,48],[6,49,48,-5],[6,49,48],[7,49,48,-5],[7,49,48],
  [7,49,48,-5],[7,49,48],[11,49,48,-2],[11,49,48,-2],[11,49,48,-2],[11,49,48,-2],[19,49,48,-1],[19,49,48,-1],
  [11,61,60,-4],[12,61,60],[7,61,60,-5],[7,61,60],[8,61,60,-5],[8,61,60],[8,61,60,-5],[8,61,60],
  [12,61,60,-2],[12,61,60,-2],[12,61,60,-2],[12,61,60,-2],[24,61,60,-1],[24,61,60,-1],[14,37,36,-1],[14,37,36,-1],
  [12,37,36,-5],[12,37,36],[8,37,36,-6],[7,37,36],[8,37,36,-6],[7,37,36],[2,12,12,-6],[2,12,12,-5],
  [8,19,19,-7],[8,19,19,-3],[8,19,18,-7],[8,19,18,-3],[8,38,37,-3],[8,38,37,-7],[4,8,7,-7],[2,12,12,-6],
  [12,37,36,-5],[12,37,36],[3,14,13,-5],[3,14,13,-9],[9,36,35,-2],[9,37,36,-1],[15,20,20,-1],[21,28,28,-1],
  [12,23,23,-1],[18,45,45,-1],[20,20,20,-1],[28,28,28,-1],[20,20,20,-1],[28,28,28,-1],[20,20,20,-1],[28,28,28,-1],
  [19,20,20,-1],[17,20,20,-1],[12,23,23,-1],[15,20,20,-1],[15,20,20,-1],[15,20,20,-1],[15,20,20,-1],[15,20,20,-1],
  [27,28,28,-1],[24,28,28,-1],[18,45,45,-1],[21,28,28,-1],[21,28,28,-1],[21,28,28,-1],[20,28,28,-1],[20,28,28,-1],
  [17,20,20,-1],[24,28,28,-1],[12,4,-11],[20,5,-11],[29,5,-11],[11,3,-12],[20,3,-12],[29,3,-12],
  [5,37,36,-4],[5,37,36],[7,37,36,-4],[6,37,36],[7,37,36,-4],[6,37,36],[9,37,36,-2],[9,37,36,-2],
  [19,25,24,-2],[19,37,36,-2],[19,49,48,-2],[19,61,60,-2],[13,37,36,-2],[1,14,13,-14],[8,13,12,-14],[6,12,12,-5],
  [9,12,12,-2],[9,12,12,-2],[11,8,5,1],[11,8,5,1],[11,7,0,1],[11,7,0,1],[14,12,12,-1],[14,12,12,-1],
  [9,45,81,117,154,190,226,262,
  298,334,370,406,443,479,515,551],[31,120,209,297,386,475,564,652],[591,739]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmex10:[[7,29,28,-3],[7,29,28,-1],[6,29,28,-4],[6,29,28],[7,29,28,-4],[7,29,28],[7,29,28,-4],[7,29,28],
  [10,29,28,-2],[10,29,28,-2],[8,29,28,-2],[8,29,28,-1],[2,16,15,-3],[7,16,15,-3],[12,29,28,-1],[12,29,28,-1],
  [10,44,43,-4],[9,44,43,-1],[12,58,57,-5],[12,58,57,-1],[7,58,57,-6],[7,58,57],[8,58,57,-6],[8,58,57],
  [8,58,57,-6],[8,58,57],[12,58,57,-3],[12,58,57,-3],[13,58,57,-3],[13,58,57,-2],[23,58,57,-1],[23,58,57,-1],
  [14,72,71,-5],[14,72,71],[8,72,71,-6],[8,72,71],[9,72,71,-6],[9,72,71],[9,72,71,-6],[9,72,71],
  [13,72,71,-3],[13,72,71,-3],[14,72,71,-3],[14,72,71,-2],[29,72,71,-1],[29,72,71,-1],[17,44,43,-1],[17,44,43,-1],
  [14,44,43,-7],[14,44,43],[9,44,43,-7],[9,44,43],[9,44,43,-7],[9,44,43],[3,15,15,-7],[3,15,15,-6],
  [9,22,22,-9],[9,22,22,-4],[9,23,22,-9],[9,23,22,-4],[9,45,44,-4],[9,45,44,-9],[4,9,8,-9],[2,15,15,-7],
  [13,45,43,-7],[14,45,43],[3,16,15,-7],[3,16,15,-11],[11,44,43,-2],[10,44,43,-2],[18,24,24,-1],[25,34,34,-1],
  [14,27,27,-1],[22,54,54,-1],[25,24,24,-1],[34,34,34,-1],[25,24,24,-1],[34,34,34,-1],[25,24,24,-1],[34,34,34,-1],
  [23,24,24,-1],[21,24,24,-1],[14,27,27,-1],[18,24,24,-1],[18,24,24,-1],[18,24,24,-1],[18,24,24,-1],[18,24,24,-1],
  [33,34,34,-1],[29,34,34,-1],[22,54,54,-1],[25,34,34,-1],[25,34,34,-1],[25,34,34,-1],[25,34,34,-1],[25,34,34,-1],
  [21,24,24,-1],[29,34,34,-1],[14,5,-13],[24,6,-13],[35,6,-13],[14,4,-14],[24,3,-15],[35,3,-15],
  [6,44,43,-5],[6,44,43],[8,44,43,-5],[8,44,43],[8,44,43,-5],[8,44,43],[12,44,43,-2],[12,44,43,-2],
  [23,29,28,-2],[23,44,43,-2],[23,58,57,-2],[23,72,71,-2],[16,45,44,-2],[2,16,15,-16],[10,15,14,-16],[7,15,15,-6],
  [12,15,15,-2],[12,15,15,-2],[12,9,6,1],[13,9,6,1],[12,8,0,1],[13,8,0,1],[17,15,15,-1],[17,15,15,-1],
  [11,54,98,141,184,228,271,315,
  358,401,445,488,532,575,619,662],[39,145,252,358,465,571,678,785],[709,888]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmex10:[[8,36,34,-4],[8,36,34,-1],[7,36,34,-5],[7,36,34],[8,36,34,-5],[8,36,34],[8,36,34,-5],[8,36,34],
  [11,36,34,-3],[11,36,34,-3],[10,36,34,-2],[9,36,34,-2],[2,19,18,-4],[8,19,18,-4],[14,36,34,-1],[14,36,34,-1],
  [12,53,51,-5],[11,53,51,-1],[15,71,69,-6],[15,71,69,-1],[8,71,69,-7],[8,71,69],[10,71,69,-7],[10,71,69],
  [10,71,69,-7],[10,71,69],[15,71,69,-3],[15,71,69,-3],[16,71,69,-3],[16,71,69,-2],[28,71,69,-1],[28,71,69,-1],
  [16,88,86,-6],[16,88,86,-1],[9,88,86,-8],[9,88,86],[11,88,86,-8],[11,88,86],[11,88,86,-8],[11,88,86],
  [16,88,86,-4],[16,88,86,-4],[17,88,86,-4],[17,88,86,-3],[35,88,86,-1],[35,88,86,-1],[21,53,51,-1],[21,53,51,-1],
  [17,54,52,-8],[16,54,52,-1],[11,53,51,-9],[10,53,51],[11,53,51,-9],[10,53,51],[3,18,18,-9],[3,18,18,-7],
  [10,27,27,-11],[10,27,27,-5],[10,27,26,-11],[10,28,27,-5],[10,54,53,-5],[10,54,53,-11],[4,10,9,-11],[2,18,18,-9],
  [17,53,51,-8],[16,53,51,-1],[4,19,18,-8],[4,19,18,-13],[13,53,51,-3],[13,53,51,-2],[22,29,29,-1],[30,41,41,-1],
  [17,33,33,-1],[27,65,65,-1],[30,29,29,-1],[42,41,41,-1],[30,29,29,-1],[42,41,41,-1],[30,29,29,-1],[42,41,41,-1],
  [28,29,29,-1],[25,29,29,-1],[17,33,33,-1],[22,29,29,-1],[22,29,29,-1],[22,29,29,-1],[22,29,29,-1],[22,29,29,-1],
  [40,41,41,-1],[35,41,41,-1],[27,65,65,-1],[30,41,41,-1],[30,41,41,-1],[30,41,41,-1],[30,41,41,-1],[30,41,41,-1],
  [25,29,29,-1],[35,41,41,-1],[17,6,-16],[29,7,-16],[42,7,-16],[16,4,-17],[29,4,-18],[42,4,-18],
  [8,53,51,-6],[8,53,51],[9,53,51,-6],[9,53,51],[9,53,51,-6],[9,53,51],[13,53,51,-3],[13,53,51,-3],
  [27,35,34,-3],[27,52,51,-3],[27,70,69,-3],[27,87,86,-3],[19,54,53,-3],[2,19,18,-20],[12,19,17,-20],[9,18,18,-7],
  [14,18,18,-3],[14,18,18,-3],[15,11,7,1],[15,11,7,1],[15,10,0,1],[15,10,0,1],[20,18,18,-1],[20,18,18,-1],
  [13,65,117,169,221,273,325,377,
  428,480,532,584,636,688,740,792],[45,173,300,428,555,683,810,938],[849,1062]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmex10:[[9,42,40,-5],[10,42,40,-1],[8,42,40,-6],[8,42,40],[10,42,40,-6],[10,42,40],[10,42,40,-6],[10,42,40],
  [12,42,40,-4],[12,42,40,-4],[11,42,40,-3],[11,42,40,-2],[3,22,21,-4],[10,22,21,-4],[16,42,40,-2],[16,42,40,-2],
  [13,62,60,-6],[14,62,60,-1],[17,83,81,-7],[17,83,81,-1],[10,83,81,-8],[10,83,81],[12,83,81,-8],[12,83,81],
  [12,83,81,-8],[12,83,81],[17,83,81,-4],[17,83,81,-4],[19,83,81,-4],[19,83,81,-3],[32,83,81,-2],[32,83,81,-2],
  [18,103,101,-8],[18,103,101,-1],[11,103,101,-9],[11,103,101],[13,103,101,-9],[13,103,101],[13,103,101,-9],[13,103,101],
  [19,103,101,-4],[19,103,101,-4],[20,103,101,-4],[20,103,101,-3],[40,103,101,-2],[40,103,101,-2],[24,62,60,-2],[24,62,60,-2],
  [20,63,61,-9],[19,63,61,-1],[12,62,60,-11],[12,62,60],[12,62,60,-11],[12,62,60],[3,21,21,-11],[3,21,21,-9],
  [12,31,31,-13],[13,31,31,-5],[12,32,31,-13],[13,32,31,-5],[13,63,62,-5],[12,63,62,-13],[5,12,11,-13],[3,21,21,-10],
  [20,62,60,-9],[19,62,60,-1],[5,22,21,-9],[4,22,21,-16],[15,62,60,-3],[14,62,60,-3],[26,34,34,-1],[35,48,48,-1],
  [19,38,38,-2],[31,76,76,-1],[35,34,34,-1],[49,48,48,-1],[35,34,34,-1],[49,48,48,-1],[35,34,34,-1],[49,48,48,-1],
  [33,34,34,-1],[30,34,34,-1],[19,38,38,-2],[26,34,34,-1],[26,34,34,-1],[26,34,34,-1],[25,34,34,-2],[25,34,34,-2],
  [46,48,48,-1],[41,48,48,-1],[31,76,76,-1],[35,48,48,-1],[35,48,48,-1],[35,48,48,-1],[34,48,48,-2],[35,48,48,-1],
  [30,34,34,-1],[41,48,48,-1],[19,7,-19],[34,8,-19],[49,8,-19],[19,5,-20],[34,5,-21],[49,5,-21],
  [9,62,60,-7],[9,62,60],[11,62,60,-7],[11,62,60],[11,62,60,-7],[11,62,60],[15,62,60,-4],[15,62,60,-4],
  [32,42,40,-3],[32,62,60,-3],[32,83,81,-3],[32,103,101,-3],[23,63,62,-3],[3,22,21,-23],[14,22,20,-23],[10,21,21,-8],
  [16,21,21,-3],[16,21,21,-3],[17,13,8,1],[18,13,8,1],[17,12,0,1],[18,12,0,1],[24,21,21,-1],[24,21,21,-1],
  [16,78,141,203,265,328,390,453,
  515,578,640,703,765,828,890,953],[55,209,362,515,669,822,976,1129],[1021,1278]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmex10:[[11,50,48,-6],[12,50,48,-1],[9,50,48,-8],[9,50,48],[11,50,48,-8],[11,50,48],[11,50,48,-8],[11,50,48],
  [16,50,48,-4],[16,50,48,-4],[12,50,48,-4],[13,50,48,-3],[3,27,26,-5],[12,27,26,-5],[20,50,48,-2],[20,50,48,-2],
  [16,75,73,-7],[17,75,73,-1],[21,99,97,-8],[21,99,97,-1],[11,99,97,-10],[12,99,97],[14,99,97,-10],[14,99,97],
  [14,99,97,-10],[14,99,97],[21,99,97,-5],[21,99,97,-5],[22,99,97,-5],[22,99,97,-4],[39,99,97,-2],[39,99,97,-2],
  [22,124,122,-9],[22,124,122,-1],[13,124,122,-11],[13,124,122],[15,124,122,-11],[15,124,122],[15,124,122,-11],[15,124,122],
  [23,124,122,-5],[23,124,122,-5],[24,124,122,-5],[24,124,122,-4],[48,124,122,-2],[48,124,122,-2],[29,75,73,-2],[29,74,72,-2],
  [24,75,73,-11],[23,75,73,-1],[14,75,73,-13],[14,75,73],[14,75,73,-13],[14,75,73],[4,25,25,-13],[3,25,25,-11],
  [15,38,38,-15],[14,38,38,-7],[15,38,37,-15],[14,38,37,-7],[14,76,75,-7],[15,76,75,-15],[6,14,13,-15],[3,25,25,-12],
  [24,75,73,-11],[23,75,73,-1],[6,26,25,-11],[5,26,25,-19],[18,75,73,-4],[18,75,73,-3],[30,41,41,-2],[42,58,58,-2],
  [23,46,46,-2],[37,92,92,-2],[42,41,41,-2],[58,58,58,-2],[42,41,41,-2],[58,58,58,-2],[42,41,41,-2],[58,58,58,-2],
  [39,41,41,-2],[35,41,41,-2],[23,46,46,-2],[30,41,41,-2],[30,41,41,-2],[30,41,41,-2],[30,41,41,-2],[30,41,41,-2],
  [55,58,58,-2],[49,58,58,-2],[37,92,92,-2],[42,58,58,-2],[42,58,58,-2],[42,58,58,-2],[42,58,58,-2],[42,58,58,-2],
  [35,41,41,-2],[49,58,58,-2],[23,8,-23],[41,9,-23],[60,9,-23],[23,6,-24],[41,6,-25],[59,6,-25],
  [10,75,73,-9],[10,75,73],[12,75,73,-9],[13,75,73],[12,75,73,-9],[13,75,73],[19,75,73,-4],[19,75,73,-4],
  [38,50,48,-4],[38,75,73,-4],[38,99,97,-4],[38,124,122,-4],[27,75,74,-4],[3,27,26,-28],[16,26,24,-28],[12,25,25,-10],
  [19,25,25,-4],[19,25,25,-4],[20,14,9,1],[21,14,9,1],[20,14,0,1],[21,14,0,1],[28,25,25,-2],[28,25,25,-2],
  [19,93,168,243,318,392,467,542,
  617,692,766,841,916,991,1066,1140],[66,249,433,617,800,984,1167,1351],[1222,1530]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmex10:[[14,59,57,-7],[13,59,57,-2],[11,59,57,-9],[10,59,57,-1],[13,59,57,-9],[13,59,57,-1],[13,59,57,-9],[13,59,57,-1],
  [18,59,57,-5],[18,59,57,-5],[16,59,57,-4],[16,59,57,-3],[3,32,31,-7],[14,32,31,-7],[24,59,57,-2],[24,59,57,-2],
  [20,89,87,-8],[20,89,87,-1],[25,118,116,-10],[25,118,116,-1],[14,118,116,-12],[14,118,116],[16,118,116,-12],[17,118,116],
  [16,118,116,-12],[17,118,116],[25,118,116,-6],[25,118,116,-6],[26,118,116,-6],[27,118,116,-4],[47,118,116,-2],[47,118,116,-2],
  [26,147,145,-11],[27,147,145,-1],[15,147,145,-13],[15,147,145],[18,147,145,-13],[18,147,145],[18,147,145,-13],[18,147,145],
  [26,147,145,-7],[26,147,145,-7],[29,147,145,-6],[28,147,145,-5],[58,147,145,-2],[58,147,145,-2],[35,89,87,-2],[35,89,87,-2],
  [28,89,87,-14],[28,89,87,-1],[17,89,87,-16],[17,89,87],[17,89,87,-16],[17,89,87],[4,30,30,-16],[4,30,30,-13],
  [18,45,45,-18],[17,45,45,-8],[18,45,44,-18],[17,45,44,-8],[17,90,89,-8],[18,90,89,-18],[7,17,16,-18],[3,30,30,-15],
  [28,90,87,-14],[28,90,87,-1],[6,31,30,-14],[6,31,30,-23],[21,89,87,-5],[21,89,87,-4],[36,49,49,-2],[50,69,69,-2],
  [28,55,55,-2],[45,109,109,-2],[50,49,49,-2],[70,69,69,-2],[50,49,49,-2],[70,69,69,-2],[50,49,49,-2],[70,69,69,-2],
  [47,49,49,-2],[42,49,49,-2],[28,55,55,-2],[36,49,49,-2],[36,49,49,-2],[36,49,49,-2],[36,49,49,-2],[36,49,49,-2],
  [66,69,69,-2],[58,69,69,-2],[45,109,109,-2],[50,69,69,-2],[50,69,69,-2],[50,69,69,-2],[50,69,69,-2],[50,69,69,-2],
  [42,49,49,-2],[58,69,69,-2],[29,10,-27,1],[49,10,-28],[71,10,-28],[27,7,-29],[49,7,-30],[71,7,-30],
  [12,89,87,-11],[12,89,87],[14,89,87,-11],[15,89,87],[14,89,87,-11],[15,89,87],[22,89,87,-5],[22,89,87,-5],
  [45,59,57,-5],[45,89,87,-5],[45,118,116,-5],[45,147,145,-5],[32,90,89,-5],[3,32,31,-34],[19,31,29,-34],[14,30,30,-12],
  [23,30,30,-5],[23,30,30,-5],[25,17,11,2],[25,17,11,1],[25,17,0,2],[25,17,0,1],[34,30,30,-2],[34,29,29,-2],
  [22,112,202,292,382,472,561,651,
  741,831,921,1011,1100,1190,1280,1370],[78,298,519,740,960,1181,1401,1622],[1468,1836]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmex10:[[16,72,69,-9],[16,72,69,-2],[13,72,69,-11],[12,72,69,-1],[16,72,69,-11],[15,72,69,-1],[16,72,69,-11],[15,72,69,-1],
  [22,72,69,-6],[22,72,69,-6],[19,72,69,-5],[18,72,69,-4],[4,39,37,-8],[17,39,37,-8],[28,72,69,-3],[28,72,69,-3],
  [23,107,104,-10],[23,107,104,-2],[30,143,140,-12],[30,143,140,-2],[17,143,140,-14],[17,143,140],[20,143,140,-14],[20,143,140],
  [20,143,140,-14],[20,143,140],[30,143,140,-7],[30,143,140,-7],[32,143,140,-7],[32,143,140,-5],[56,143,140,-3],[56,143,140,-3],
  [32,178,175,-13],[31,178,175,-2],[18,178,175,-16],[19,178,175],[21,178,175,-16],[22,178,175],[21,178,175,-16],[22,178,175],
  [31,178,175,-8],[31,178,175,-8],[34,178,175,-8],[34,178,175,-6],[69,178,175,-3],[69,178,175,-3],[42,107,104,-3],[42,107,104,-3],
  [33,108,105,-17],[33,108,105,-2],[20,107,104,-19],[21,107,104],[20,107,104,-19],[21,107,104],[5,37,36,-19],[5,37,36,-16],
  [21,54,54,-22],[20,54,54,-10],[21,54,53,-22],[20,54,53,-10],[20,108,107,-10],[21,108,107,-22],[8,20,19,-22],[3,37,36,-18],
  [33,107,104,-17],[33,107,104,-2],[7,37,36,-17],[8,37,36,-27],[25,107,104,-6],[25,107,104,-5],[43,59,59,-3],[60,83,83,-3],
  [33,66,66,-3],[53,132,132,-3],[60,59,59,-3],[83,83,83,-3],[60,59,59,-3],[83,83,83,-3],[60,59,59,-3],[83,83,83,-3],
  [56,59,59,-3],[50,59,59,-3],[33,66,66,-3],[43,59,59,-3],[43,59,59,-3],[43,59,59,-3],[43,59,59,-3],[43,59,59,-3],
  [79,83,83,-3],[69,83,83,-3],[53,132,132,-3],[60,83,83,-3],[60,83,83,-3],[60,83,83,-3],[60,83,83,-3],[60,83,83,-3],
  [50,59,59,-3],[69,83,83,-3],[34,11,-33,1],[60,12,-34,1],[86,12,-34],[33,8,-35],[59,9,-36],[85,9,-36],
  [14,107,104,-13],[14,107,104,-1],[17,107,104,-13],[17,107,104,-1],[17,107,104,-13],[17,107,104,-1],[26,107,104,-7],[26,107,104,-7],
  [55,72,69,-6],[55,107,104,-6],[55,143,140,-6],[55,178,175,-6],[38,109,107,-6],[3,39,37,-41],[23,38,35,-41],[16,37,36,-15],
  [27,36,36,-6],[27,36,36,-6],[30,21,13,2],[29,21,13,1],[30,20,0,2],[29,20,0,1],[40,36,36,-3],[40,35,35,-3],
  [27,135,243,350,458,566,674,782,
  890,998,1106,1213,1321,1429,1537,1645],[93,358,623,888,1153,1418,1683,1947],[1762,2205]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmmi10:[[5,5,0],[6,5,0],[6,6,1],[5,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0],
  [5,5,0],[5,5,0],[6,5,0],[5,3,0],[4,6,1],[4,5,2],[3,5,0],[3,3,0],
  [4,7,2],[4,5,2],[4,5,0],[3,3,0],[4,3,0],[4,5,0],[4,5,2],[4,3,0],
  [3,7,2],[4,3,0],[4,5,2],[4,3,0],[4,3,0],[4,3,0],[4,7,2],[4,5,2],
  [5,7,2],[5,3,0],[3,5,1],[4,5,0],[6,3,0],[4,5,2],[3,4,1],[5,5,2],
  [7,3,-1],[9,2,0,2],[7,3,-1],[9,2,0,2],[4,3,-1,2],[2,3,-1],[4,4,0],[4,4,0],
  [4,5,1],[3,3,0],[4,4,0],[4,6,2],[4,6,2],[3,5,2],[4,6,1],[4,5,2],
  [4,6,1],[4,6,2],[2,1,0],[2,2,1],[5,5,1],[3,7,2],[5,5,1],[4,4,0],
  [4,6,1],[5,5,0],[6,5,0],[6,6,1],[6,5,0],[6,5,0],[6,5,0],[6,6,1],
  [6,5,0],[4,5,0],[5,6,1],[6,5,0],[5,5,0],[7,5,0],[8,5,0,2],[6,6,1],
  [6,5,0],[6,7,2],[6,6,1],[5,6,1],[5,5,0],[6,6,1],[6,5,0],[7,5,0],
  [8,5,0,2],[6,5,0],[5,5,0],[3,5,0],[3,7,2],[3,7,2],[7,2,-1],[9,2,-1,2],
  [3,5,0],[4,3,0],[3,5,0],[3,3,0],[4,5,0],[3,3,0],[4,7,2],[4,5,2],
  [4,5,0],[2,5,0],[3,7,2],[4,5,0],[2,5,0],[6,3,0],[4,3,0],[4,3,0],
  [4,5,2],[3,5,2],[3,3,0],[3,3,0],[3,5,0],[4,3,0],[4,3,0],[5,3,0],
  [4,3,0],[4,5,2],[3,3,0],[2,3,0],[3,5,2],[5,5,2],[4,2,-3,-1],[3,1,-4,-2],
  [3,11,19,28,36,44,53,61,
  69,77,86,94,102,111,119,127],[9,17,26,34,42,51,59,67],[137,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmmi10:[[6,6,0],[7,6,0],[6,7,1],[6,6,0],[7,6,0],[7,6,0],[7,6,0],[6,6,0],
  [5,6,0],[6,6,0],[7,6,0],[5,5,1],[5,8,2],[5,6,2],[4,6,0],[3,4,0],
  [4,8,2],[4,6,2],[4,6,0],[3,4,0],[5,4,0],[5,6,0],[5,6,2],[5,4,0],
  [4,8,2],[5,4,0],[4,6,2],[5,5,1],[4,4,0],[5,4,0],[5,8,2],[5,6,2],
  [5,8,2],[5,4,0],[4,5,1],[5,6,0],[7,4,0],[4,6,2],[4,5,1],[5,6,2],
  [8,3,-1],[8,3,0],[8,3,-1],[8,3,0],[2,3,-1],[2,3,-1],[4,4,0],[4,4,0],
  [4,5,1],[3,4,0,-1],[4,4,0],[4,6,2],[4,6,2],[4,6,2],[4,7,1],[4,6,2],
  [4,7,1],[4,6,2],[2,1,0],[2,3,2],[6,6,1],[4,8,2],[6,6,1],[4,4,0],
  [5,7,1],[6,6,0],[6,6,0],[6,7,1],[7,6,0],[6,6,0],[6,6,0],[6,7,1],
  [7,6,0],[4,6,0],[5,7,1],[7,6,0],[5,6,0],[9,6,0],[9,6,0,2],[6,7,1],
  [6,6,0],[6,8,2],[6,7,1],[6,7,1],[6,6,0],[6,7,1],[6,6,0],[9,6,0],
  [9,6,0,2],[6,6,0],[6,6,0],[3,6,0],[3,8,2],[3,8,2],[8,2,-1],[8,2,-1],
  [4,6,0],[4,4,0],[4,6,0],[4,5,1],[4,6,0],[4,4,0],[5,8,2],[4,6,2],
  [5,6,0],[3,6,0],[3,8,2],[4,6,0],[2,6,0],[7,4,0],[5,4,0],[4,5,1],
  [4,6,2],[4,6,2],[4,4,0],[4,5,1],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [5,4,0],[4,6,2],[4,4,0],[3,4,0],[3,6,2],[5,6,2],[4,2,-4,-1],[4,2,-4,-2],
  [3,13,23,33,43,53,63,73,
  83,93,103,113,123,133,143,153],[11,21,31,41,51,61,71,81],[164,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmmi10:[[8,7,0],[8,7,0],[8,8,1],[7,7,0],[8,7,0],[9,7,0],[8,7,0],[7,7,0],
  [7,7,0],[7,7,0],[8,7,0],[6,6,1],[6,9,2],[6,7,2],[5,8,0],[4,6,1],
  [5,9,2],[5,7,2],[5,8,1],[4,6,1],[6,6,1],[6,7,0],[6,7,2],[6,5,0],
  [5,9,2],[6,5,0],[5,7,2],[6,5,0],[5,5,0],[6,6,1],[6,9,2],[6,7,2],
  [7,9,2],[6,6,1],[5,6,1],[6,8,1],[8,5,0],[5,7,2],[4,6,1],[7,7,2],
  [10,3,-2],[12,3,0,2],[10,3,-2],[10,3,0],[5,3,-2,2],[3,3,-2],[5,5,0],[5,5,0],
  [5,6,1],[3,5,0,-1],[5,5,0],[5,7,2],[5,7,2],[5,7,2],[5,8,1],[5,7,2],
  [5,8,1],[5,7,2],[2,1,0],[2,3,2],[6,7,1,-1],[5,10,2],[6,7,1,-1],[5,5,0],
  [6,9,1],[7,7,0],[8,7,0],[8,8,1],[8,7,0],[8,7,0],[8,7,0],[8,8,1],
  [9,7,0],[5,7,0],[7,8,1],[9,7,0],[7,7,0],[11,7,0],[11,7,0,2],[8,8,1],
  [8,7,0],[8,9,2],[8,8,1],[7,8,1],[7,7,0],[8,8,1],[8,8,1],[11,8,1],
  [11,7,0,2],[8,7,0],[8,7,0],[4,9,1],[4,9,2],[4,9,2],[10,3,-1],[12,3,-1,2],
  [4,7,0],[5,6,1],[5,8,1],[5,5,0],[6,8,1],[5,5,0],[6,9,2],[5,7,2],
  [6,7,0],[3,7,0],[4,9,2],[5,7,0],[3,7,0],[9,5,0],[6,6,1],[5,5,0],
  [6,7,2,1],[5,7,2],[5,5,0],[5,5,0],[4,8,1],[6,6,1],[5,6,1],[7,6,1],
  [6,6,1],[5,7,2],[5,5,0],[3,5,0],[5,7,2,1],[7,7,2],[5,2,-5,-2],[5,2,-5,-2],
  [4,15,27,39,50,62,74,85,
  97,108,120,132,143,155,167,178],[13,24,36,47,59,71,82,94],[191,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmmi10:[[9,9,0],[10,9,0],[9,10,1],[8,9,0],[10,9,0],[11,9,0],[10,9,0],[9,9,0],
  [8,9,0],[9,9,0],[9,9,0,-1],[8,7,1],[7,12,3],[7,9,3],[6,10,1],[5,7,1],
  [6,12,3],[6,9,3],[6,9,0],[4,7,1],[7,7,1],[7,10,1],[7,9,3],[7,6,0],
  [6,12,3],[7,6,0],[6,9,3],[7,7,1],[6,7,1],[7,7,1],[7,12,3],[7,9,3],
  [8,12,3],[8,7,1],[5,7,1],[7,10,1],[10,7,1],[6,9,3],[5,8,2],[8,9,3],
  [12,4,-2],[15,4,0,3],[15,4,-2,3],[15,4,0,3],[6,4,-2,3],[3,4,-2],[6,6,0],[6,6,0],
  [6,7,1],[4,6,0,-1],[6,6,0],[6,9,3],[6,9,3],[6,9,3],[6,9,1],[6,9,3],
  [6,9,1],[6,9,3],[2,2,0,-1],[2,5,3,-1],[8,8,1,-1],[6,12,3],[8,8,1,-1],[6,6,0],
  [7,10,1],[9,9,0],[9,9,0],[9,10,1],[10,9,0],[10,9,0],[9,9,0],[9,10,1],
  [11,9,0],[6,9,0],[8,10,1],[11,9,0],[8,9,0],[12,9,0],[14,9,0,3],[9,10,1],
  [9,9,0],[9,12,3],[9,10,1],[8,10,1],[9,9,0],[9,10,1],[8,10,1,-1],[12,10,1],
  [13,9,0,3],[9,9,0],[9,9,0],[4,10,1],[3,12,3,-1],[4,12,3],[12,4,-1],[15,4,-1,3],
  [5,10,1],[6,7,1],[5,10,1],[6,7,1],[6,10,1],[5,7,1],[7,12,3],[6,9,3],
  [7,9,0],[4,8,0],[6,11,3,1],[6,10,1],[3,10,1],[11,7,1],[7,7,1],[6,7,1],
  [7,9,3,1],[6,9,3],[6,6,0],[5,7,1],[4,9,1],[7,7,1],[6,7,1],[9,7,1],
  [7,7,1],[6,9,3],[6,7,1],[4,6,0],[6,9,3,1],[8,9,3],[6,3,-6,-2],[5,2,-6,-3],
  [5,19,33,47,61,75,89,104,
  118,132,146,160,174,188,202,216],[16,30,45,59,73,87,101,115],[232,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmmi10:[[10,10,0],[11,10,0],[11,11,1],[10,10,0],[11,10,0],[13,10,0],[11,10,0,-1],[10,10,0],
  [9,10,0],[10,10,0],[10,10,0,-1],[9,8,1],[9,13,3],[8,10,3],[7,11,1],[6,7,1],
  [7,13,3],[7,10,3],[7,11,1],[5,8,1],[8,8,1],[8,11,1],[8,9,3],[8,7,0],
  [7,13,3],[8,7,1],[7,10,3],[8,7,1],[8,7,1],[8,8,1],[8,13,3],[9,10,3],
  [9,13,3],[9,8,1],[6,8,1],[8,11,1],[12,7,1],[6,10,3,-1],[6,9,2],[9,10,3],
  [14,4,-3],[14,4,0],[14,4,-3],[17,4,0,3],[3,4,-3],[3,4,-3],[7,7,0],[7,7,0],
  [7,8,1],[5,7,0,-1],[7,7,0],[7,10,3],[7,10,3],[7,10,3],[7,11,1],[7,10,3],
  [7,11,1],[7,10,3],[2,2,0,-1],[2,5,3,-1],[9,9,1,-1],[7,15,4],[9,9,1,-1],[7,7,0],
  [8,11,1],[10,10,0],[11,10,0],[11,11,1],[12,10,0],[11,10,0],[11,10,0],[11,11,1],
  [13,10,0],[7,10,0],[8,11,1,-1],[13,10,0],[9,10,0],[15,10,0],[16,10,0,3],[11,11,1],
  [11,10,0],[11,13,3],[11,11,1],[9,11,1],[10,10,0],[10,11,1,-1],[11,11,1],[14,11,1],
  [15,10,0,3],[11,10,0],[10,10,0],[5,12,1],[4,13,3,-1],[5,13,3],[12,4,-1,-1],[12,4,-2,-1],
  [6,11,1],[7,8,1],[6,11,1],[6,8,1],[8,11,1],[6,8,1],[8,13,3],[7,10,3],
  [8,11,1],[4,11,1],[7,13,3,1],[7,11,1],[4,11,1],[12,8,1],[8,8,1],[7,8,1],
  [8,10,3,1],[7,10,3],[6,8,1],[6,8,1],[5,10,1],[8,8,1],[7,8,1],[10,8,1],
  [8,8,1],[7,10,3],[7,8,1],[4,8,1],[6,10,3,1],[8,10,3,-1],[7,3,-7,-2],[6,3,-7,-3],
  [6,22,39,55,72,89,105,122,
  138,155,172,188,205,221,238,255],[19,36,52,69,85,102,119,135],[273,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmmi10:[[13,12,0],[13,13,0,-1],[13,13,1],[12,12,0],[13,12,0,-1],[15,12,0],[13,12,0,-1],[12,12,0],
  [11,12,0],[12,12,0],[13,12,0,-1],[11,9,1],[10,16,4],[10,12,4],[8,14,1],[7,9,1],
  [8,16,4],[9,12,4],[8,13,1],[5,9,1,-1],[9,9,1,-1],[9,13,1,-1],[10,12,4],[8,8,0,-1],
  [8,16,4],[10,9,1],[9,12,4],[10,9,1],[9,9,1],[9,9,1],[10,16,4],[10,12,4],
  [11,16,4],[11,9,1],[8,9,1],[10,13,1],[14,9,1],[8,12,4,-1],[7,10,2],[11,12,4],
  [15,6,-3,-1],[15,6,1,-1],[15,6,-3,-1],[15,6,1,-1],[3,4,-4,-1],[3,5,-3,-1],[8,9,0],[8,9,0],
  [8,9,1],[6,8,0,-1],[8,8,0],[8,12,4],[8,12,4],[8,12,4],[8,13,1],[8,12,4,-1],
  [8,13,1],[8,12,4],[3,2,0,-1],[3,6,4,-1],[11,11,1,-1],[7,17,4,-1],[11,11,1,-1],[9,9,0],
  [10,14,1],[13,13,0],[13,12,0],[13,13,1],[14,12,0],[13,12,0],[13,12,0],[13,13,1],
  [15,12,0],[9,12,0],[10,13,1,-1],[15,12,0],[11,12,0],[18,12,0],[18,12,0,3],[13,13,1],
  [13,12,0],[13,16,4],[13,13,1],[10,13,1,-1],[12,12,0],[12,13,1,-1],[12,13,1,-1],[17,13,1,-1],
  [18,12,0,3],[13,12,0],[12,12,0,-1],[6,14,1],[5,17,4,-1],[5,16,4,-1],[15,5,-2,-1],[15,5,-2,-1],
  [7,13,1],[9,9,1],[7,13,1],[8,9,1],[9,13,1],[8,9,1],[9,16,4,-1],[8,12,4],
  [9,13,1,-1],[5,13,1],[8,16,4,1],[8,13,1,-1],[5,13,1],[15,9,1],[10,9,1],[8,9,1],
  [10,12,4,1],[8,12,4],[8,9,1],[7,9,1],[6,12,1],[10,9,1],[8,9,1],[12,9,1],
  [9,9,1],[9,12,4],[8,9,1],[5,9,1],[8,12,4,1],[10,12,4,-1],[8,4,-8,-3],[7,3,-9,-4],
  [7,27,46,66,86,106,126,146,
  166,186,206,226,246,266,286,306],[22,42,61,81,101,121,141,161],[328,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmmi10:[[15,14,0],[15,15,0,-1],[14,16,1,-1],[14,15,0],[15,14,0,-1],[18,14,0],[15,14,0,-1],[14,14,0],
  [13,14,0],[14,14,0],[15,15,0,-1],[12,10,1],[12,18,4],[11,14,5],[9,16,1],[7,10,1,-1],
  [10,19,5],[10,14,5],[10,15,1],[6,10,1,-1],[10,10,1,-1],[10,15,1,-1],[12,14,5],[10,9,0,-1],
  [9,19,5],[12,10,1],[10,14,5],[12,10,1],[11,10,1],[11,10,1],[11,18,4,-1],[12,14,5],
  [13,18,4],[13,10,1],[9,10,1],[12,16,1],[17,10,1],[9,13,4,-1],[9,12,3],[12,14,5,-1],
  [18,7,-4,-1],[18,7,1,-1],[18,7,-4,-1],[18,7,1,-1],[4,6,-4,-1],[4,6,-4,-1],[10,10,0],[10,10,0],
  [10,10,1],[7,9,0,-2],[8,9,0,-1],[10,14,5],[10,14,4],[8,14,5,-1],[10,15,1],[9,15,5,-1],
  [10,15,1],[10,14,5],[3,3,0,-1],[3,7,4,-1],[13,12,1,-1],[8,20,5,-1],[13,12,1,-1],[10,10,0],
  [12,16,1],[15,15,0],[16,14,0],[15,16,1,-1],[17,14,0],[16,14,0],[15,14,0],[15,16,1,-1],
  [18,14,0],[10,14,0],[12,15,1,-1],[18,14,0],[13,14,0],[21,14,0],[18,14,0],[14,16,1,-1],
  [15,14,0],[14,19,4,-1],[15,15,1],[12,16,1,-1],[14,14,0],[15,15,1,-1],[15,15,1,-1],[20,15,1,-1],
  [17,14,0],[16,14,0],[14,14,0,-1],[6,16,1,-1],[6,20,5,-1],[6,20,5,-1],[18,6,-2,-1],[18,6,-2,-1],
  [8,15,1],[10,10,1],[8,15,1,-1],[9,10,1],[11,15,1],[9,10,1],[10,19,4,-1],[10,14,5],
  [10,15,1,-1],[6,15,1],[9,19,5,1],[10,15,1,-1],[6,15,1],[17,10,1],[12,10,1],[10,10,1],
  [11,13,4,1],[9,13,4],[9,10,1],[8,10,1,-1],[7,14,1],[11,10,1],[10,10,1],[14,10,1],
  [11,10,1],[10,14,5],[9,10,1,-1],[6,10,1],[9,14,5,1],[12,14,5,-1],[10,5,-10,-3],[8,4,-10,-5],
  [8,32,56,80,104,128,151,175,
  199,223,247,271,295,319,343,367],[26,50,74,98,122,145,169,193],[393,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmmi10:[[17,17,0,-1],[18,18,0,-1],[17,18,1,-1],[16,18,0],[18,17,0,-1],[20,17,0,-1],[19,17,0,-1],[17,17,0],
  [16,17,0],[17,17,0],[18,17,0,-1],[14,12,1,-1],[15,22,5],[13,16,5],[10,18,1,-1],[8,12,1,-1],
  [11,22,5,-1],[12,17,6],[10,18,1,-1],[7,12,1,-1],[12,12,1,-1],[12,18,1,-1],[14,17,6],[12,11,0,-1],
  [11,22,5],[14,12,1],[12,17,6],[14,12,1],[13,12,1],[13,12,1],[13,22,5,-1],[15,16,5],
  [16,22,5],[15,12,1],[11,12,1],[14,18,1],[20,12,1],[11,16,5,-1],[10,14,3],[14,17,6,-1],
  [22,8,-5,-1],[22,8,1,-1],[22,8,-5,-1],[22,8,1,-1],[5,7,-5,-1],[5,7,-5,-1],[12,12,0],[12,12,0],
  [10,12,1,-1],[8,11,0,-2],[10,11,0,-1],[10,17,6,-1],[12,17,5],[10,17,6,-1],[10,17,1,-1],[11,17,6,-1],
  [10,17,1,-1],[10,17,6,-1],[3,3,0,-2],[3,8,5,-2],[15,14,1,-2],[10,24,6,-1],[15,14,1,-2],[12,12,0],
  [13,19,1,-1],[18,18,0],[18,17,0,-1],[18,18,1,-1],[19,17,0,-1],[18,17,0,-1],[17,17,0,-1],[18,18,1,-1],
  [20,17,0,-1],[12,17,0],[14,18,1,-1],[21,17,0,-1],[15,17,0,-1],[24,17,0,-1],[20,17,0,-1],[17,18,1,-1],
  [18,17,0,-1],[17,22,5,-1],[17,18,1,-1],[15,18,1,-1],[17,17,0],[18,18,1,-1],[18,18,1,-1],[24,18,1,-1],
  [25,17,0,4],[18,17,0,-1],[17,17,0,-1],[7,19,1,-1],[7,24,6,-1],[7,24,6,-1],[22,6,-3,-1],[22,7,-3,-1],
  [10,18,1],[11,12,1,-1],[9,18,1,-1],[10,12,1,-1],[12,18,1,-1],[10,12,1,-1],[13,22,5,-1],[12,16,5],
  [12,18,1,-1],[7,17,1],[11,21,5,1],[12,18,1,-1],[6,18,1,-1],[21,12,1],[14,12,1],[11,12,1,-1],
  [13,16,5,1],[10,16,5,-1],[11,12,1],[9,12,1,-1],[8,16,1],[13,12,1],[12,12,1],[17,12,1],
  [13,12,1],[12,16,5],[11,12,1,-1],[7,12,1],[10,16,5,1],[14,17,6,-1],[11,5,-12,-4],[10,3,-13,-6],
  [10,38,67,96,124,153,182,211,
  239,268,297,326,354,383,412,440],[32,61,90,118,147,176,204,233],[472,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmmi10:[[20,20,0,-1],[22,21,0,-1],[21,22,1,-1],[19,21,0,-1],[22,20,0,-1],[25,20,0,-1],[23,20,0,-1],[21,21,0],
  [19,20,0],[20,20,0],[21,21,0,-2],[17,14,1,-1],[18,27,6],[16,20,7],[13,22,1,-1],[10,14,1,-1],
  [13,27,6,-1],[15,20,7],[13,22,1,-1],[9,14,1,-1],[15,14,1,-1],[15,22,1,-1],[17,20,7],[15,13,0,-1],
  [13,27,6],[17,14,1],[15,20,7],[16,14,1,-1],[15,14,1],[16,14,1],[16,26,6,-1],[17,19,6,-1],
  [19,26,6],[18,14,1],[13,15,1],[17,22,1],[24,14,1],[13,19,6,-2],[12,17,4],[17,20,7,-1],
  [27,9,-6,-1],[27,9,1,-1],[27,9,-6,-1],[27,9,1,-1],[6,8,-6,-1],[6,8,-6,-1],[14,16,1],[14,16,1],
  [13,15,1,-1],[11,13,0,-2],[12,14,0,-1],[13,21,7,-1],[14,20,6],[12,20,7,-1],[13,21,1,-1],[13,21,7,-1],
  [13,21,1,-1],[13,21,7,-1],[4,3,0,-2],[4,9,6,-2],[18,18,2,-2],[12,30,8,-1],[18,17,1,-2],[15,14,0],
  [16,22,1,-1],[20,21,0,-1],[21,20,0,-1],[21,22,1,-1],[23,20,0,-1],[22,20,0,-1],[21,20,0,-1],[21,22,1,-1],
  [25,20,0,-1],[14,20,0,-1],[17,21,1,-2],[25,20,0,-1],[18,20,0,-1],[30,20,0,-1],[25,20,0,-1],[21,22,1,-1],
  [21,20,0,-1],[21,27,6,-1],[21,21,1,-1],[18,22,1,-1],[21,20,0],[20,21,1,-2],[22,21,1,-1],[30,21,1,-1],
  [29,20,0,4],[21,20,0,-1],[20,20,0,-1],[9,23,1,-1],[7,28,7,-2],[9,28,7,-1],[27,8,-3,-1],[27,8,-3,-1],
  [12,22,1],[14,14,1,-1],[11,22,1,-1],[12,14,1,-1],[14,22,1,-1],[12,14,1,-1],[15,27,6,-1],[14,19,6],
  [15,22,1,-1],[9,21,1],[13,26,6,1],[14,22,1,-1],[7,22,1,-1],[25,14,1],[17,14,1],[13,14,1,-1],
  [16,19,6,1],[12,19,6,-1],[13,14,1],[12,14,1,-1],[10,20,1],[16,14,1],[14,14,1],[20,14,1],
  [16,14,1],[15,19,6],[13,14,1,-1],[9,14,1],[12,19,6,1],[16,20,7,-2],[13,6,-15,-5],[12,5,-15,-7],
  [11,46,80,115,149,183,218,252,
  286,321,355,390,424,458,493,527],[37,72,106,140,175,209,243,278],[565,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmmi10:[[24,24,0,-1],[26,25,0,-1],[25,25,1,-1],[22,25,0,-1],[26,23,0,-1],[29,24,0,-1],[26,24,0,-2],[23,24,0,-1],
  [22,24,0],[23,24,0,-1],[25,24,0,-2],[20,16,1,-1],[20,31,7],[19,23,8],[15,26,1,-1],[12,16,1,-1],
  [15,31,7,-1],[16,23,8,-1],[15,25,1,-1],[10,16,1,-1],[18,16,1,-1],[18,25,1,-1],[19,23,8,-1],[17,15,0,-1],
  [16,31,7],[19,16,1,-1],[16,23,8,-1],[19,16,1,-1],[17,16,1,-1],[17,16,1,-1],[19,31,7,-1],[20,22,7,-1],
  [21,31,7,-1],[21,16,1],[15,17,1],[18,25,1,-1],[27,16,1,-1],[15,22,7,-2],[13,19,4,-1],[20,23,8,-1],
  [31,11,-7,-1],[31,11,1,-1],[31,11,-7,-1],[31,11,1,-1],[7,9,-7,-1],[7,9,-7,-1],[16,19,1],[16,19,1,-1],
  [15,17,1,-1],[12,16,0,-3],[15,16,0,-1],[15,24,8,-1],[15,23,7,-1],[15,24,8,-1],[15,24,1,-1],[16,24,8,-1],
  [15,24,1,-1],[15,24,8,-1],[4,4,0,-3],[4,11,7,-3],[22,21,2,-2],[13,35,9,-2],[22,21,2,-2],[17,17,0],
  [19,26,1,-1],[24,25,0,-1],[25,24,0,-1],[25,25,1,-1],[27,24,0,-1],[25,24,0,-1],[25,24,0,-1],[25,25,1,-1],
  [29,24,0,-1],[16,24,0,-1],[20,25,1,-2],[30,24,0,-1],[21,24,0,-1],[35,24,0,-1],[29,24,0,-1],[25,25,1,-1],
  [25,24,0,-1],[25,31,7,-1],[25,25,1,-1],[21,25,1,-1],[24,23,0],[24,25,1,-2],[25,25,1,-2],[35,25,1,-1],
  [28,24,0,-1],[25,24,0,-1],[23,24,0,-2],[11,27,1,-1],[9,33,8,-2],[11,33,8,-1],[30,9,-4,-2],[30,9,-4,-2],
  [14,25,1],[16,16,1,-1],[14,25,1,-1],[14,16,1,-1],[17,25,1,-1],[14,16,1,-1],[18,31,7,-1],[17,22,7],
  [18,25,1,-1],[9,24,1,-1],[15,30,7,1],[17,25,1,-1],[8,25,1,-1],[28,16,1,-1],[19,16,1,-1],[15,16,1,-1],
  [18,22,7,1],[15,22,7,-1],[14,16,1,-1],[14,16,1,-1],[12,23,1],[18,16,1,-1],[15,16,1,-1],[23,16,1,-1],
  [17,16,1,-1],[16,22,7,-1],[15,16,1,-1],[9,16,1,-1],[14,22,7,1],[19,24,8,-2],[16,8,-17,-6],[13,5,-18,-9],
  [14,55,96,138,179,221,262,303,
  345,386,427,469,510,551,593,634],[46,87,128,170,211,253,294,335],[679,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmmi10:[[29,28,0,-1],[31,30,0,-2],[29,30,1,-2],[27,30,0,-1],[30,28,0,-2],[35,28,0,-1],[31,28,0,-2],[28,29,0,-1],
  [26,28,0,-1],[28,28,0,-1],[30,29,0,-3],[24,20,1,-1],[24,37,8,-1],[23,28,9],[18,31,1,-1],[15,19,1,-1],
  [19,38,9,-1],[20,28,9,-1],[18,30,1,-1],[12,20,1,-2],[21,20,1,-2],[21,30,1,-2],[23,27,9,-1],[20,19,0,-2],
  [18,38,9,-1],[23,19,1,-1],[20,28,9,-1],[23,19,1,-1],[20,19,1,-1],[21,20,1,-1],[22,38,9,-2],[24,28,9,-1],
  [25,38,9,-1],[25,19,1],[17,20,1,-1],[22,30,1,-1],[33,19,1,-1],[18,27,8,-3],[16,24,5,-1],[24,28,9,-2],
  [37,12,-9,-2],[37,13,1,-2],[37,12,-9,-2],[37,13,1,-2],[7,10,-9,-2],[8,10,-9,-2],[19,22,1,-1],[19,22,1,-1],
  [18,20,1,-1],[15,19,0,-3],[18,19,0,-1],[18,28,9,-1],[19,27,8,-1],[17,28,9,-2],[18,29,1,-1],[18,28,9,-2],
  [18,29,1,-1],[18,28,9,-1],[5,5,0,-3],[6,13,8,-3],[26,25,2,-3],[17,42,11,-2],[26,25,2,-3],[21,20,0],
  [23,31,1,-1],[29,30,0,-1],[30,28,0,-1],[30,30,1,-2],[32,28,0,-1],[31,28,0,-1],[30,28,0,-1],[30,30,1,-2],
  [36,28,0,-1],[20,28,0,-1],[24,29,1,-2],[36,28,0,-1],[26,28,0,-1],[42,28,0,-1],[36,28,0,-1],[29,30,1,-2],
  [30,28,0,-1],[29,37,8,-2],[30,29,1,-1],[25,30,1,-2],[28,28,0,-1],[30,29,1,-2],[30,29,1,-2],[41,29,1,-2],
  [34,28,0,-1],[31,28,0,-1],[28,28,0,-2],[12,32,1,-2],[10,39,9,-3],[12,39,9,-2],[37,11,-5,-2],[37,11,-5,-2],
  [17,30,1],[20,20,1,-1],[16,30,1,-1],[17,20,1,-1],[20,30,1,-1],[17,20,1,-1],[21,38,9,-2],[20,28,9],
  [21,30,1,-2],[11,28,1,-1],[18,36,9,1],[19,30,1,-2],[10,30,1,-1],[34,20,1,-1],[23,20,1,-1],[19,20,1,-1],
  [23,27,8,2],[18,27,8,-1],[17,20,1,-1],[16,20,1,-2],[13,27,1,-1],[22,20,1,-1],[19,20,1,-1],[28,20,1,-1],
  [21,20,1,-1],[20,28,9,-1],[18,20,1,-1],[11,20,1,-1],[16,28,9,1],[23,28,9,-3],[19,9,-21,-7],[17,6,-22,-10],
  [16,66,115,165,214,264,313,363,
  412,462,511,561,610,660,709,759],[55,104,154,203,253,302,352,401],[813,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmmi10:[[34,34,0,-2],[37,35,0,-2],[35,37,2,-2],[32,35,0,-1],[36,34,0,-2],[42,34,0,-2],[38,34,0,-2],[34,35,0,-1],
  [31,34,0,-1],[33,34,0,-1],[36,35,0,-3],[28,23,1,-2],[28,45,10,-1],[27,33,11],[21,36,1,-2],[17,23,1,-2],
  [22,45,10,-2],[24,33,11,-1],[21,36,1,-2],[14,23,1,-2],[25,23,1,-2],[25,35,1,-2],[27,33,11,-1],[24,22,0,-2],
  [21,45,10,-1],[27,23,1,-1],[24,33,11,-1],[27,23,1,-1],[24,23,1,-1],[25,23,1,-1],[26,44,10,-2],[28,32,10,-1],
  [31,44,10,-1],[30,23,1],[20,25,2,-1],[27,36,1,-1],[39,23,1,-1],[22,32,10,-3],[19,28,6,-1],[29,33,11,-2],
  [45,14,-11,-2],[45,15,1,-2],[45,14,-11,-2],[45,15,1,-2],[9,12,-11,-2],[9,12,-11,-2],[23,26,1,-1],[23,26,1,-1],
  [21,25,2,-2],[17,23,0,-4],[20,23,0,-2],[21,34,11,-2],[22,33,10,-1],[20,34,11,-2],[21,35,2,-2],[22,34,11,-2],
  [21,35,2,-2],[21,34,11,-2],[6,6,0,-4],[6,16,10,-4],[30,29,2,-4],[20,50,13,-2],[30,29,2,-4],[25,24,0],
  [26,36,1,-2],[35,35,0,-1],[35,34,0,-2],[36,37,2,-2],[38,34,0,-2],[37,34,0,-1],[36,34,0,-1],[36,37,2,-2],
  [42,34,0,-2],[24,34,0,-1],[28,35,1,-3],[43,34,0,-1],[30,34,0,-2],[50,34,0,-2],[42,34,0,-2],[35,37,2,-2],
  [35,34,0,-2],[35,45,10,-2],[35,35,1,-2],[30,37,2,-2],[34,34,0,-1],[35,36,2,-3],[36,35,1,-2],[50,35,1,-2],
  [41,34,0,-1],[37,34,0,-1],[34,34,0,-2],[15,38,1,-2],[13,47,11,-3],[15,46,11,-2],[45,13,-6,-2],[45,13,-6,-2],
  [20,36,1],[23,23,1,-2],[19,35,1,-2],[19,23,1,-2],[24,35,1,-2],[19,23,1,-2],[25,45,10,-2],[24,32,10],
  [25,35,1,-2],[14,34,1,-1],[21,43,10,1],[23,35,1,-2],[11,35,1,-2],[41,23,1,-1],[27,23,1,-1],[21,23,1,-2],
  [26,32,10,2],[20,32,10,-2],[21,23,1,-1],[19,23,1,-2],[16,32,1,-1],[26,23,1,-1],[22,23,1,-1],[33,23,1,-1],
  [25,23,1,-1],[23,32,10,-1],[21,23,1,-2],[14,23,1,-1],[19,32,10,1],[28,34,11,-3],[22,10,-25,-9],[19,7,-26,-13],
  [20,79,139,198,258,317,377,436,
  495,555,614,674,733,793,852,912],[64,124,183,243,302,362,421,481],[977,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmmi10:[[41,41,0,-2],[44,43,0,-3],[42,44,2,-2],[38,43,0,-2],[43,40,0,-3],[50,41,0,-2],[45,41,0,-3],[41,42,0,-1],
  [37,41,0,-1],[40,41,0,-1],[43,42,0,-4],[34,28,1,-2],[34,54,12,-1],[31,40,13,-1],[25,43,1,-2],[21,27,1,-2],
  [26,55,13,-2],[29,40,13,-1],[25,43,1,-2],[17,27,1,-3],[30,27,1,-3],[30,42,1,-3],[33,39,13,-1],[28,26,0,-3],
  [26,54,13,-1],[33,27,1,-1],[29,40,13,-1],[32,27,1,-2],[30,27,1,-1],[30,27,1,-1],[32,53,12,-2],[34,39,13,-1],
  [37,53,12,-1],[36,27,1],[25,29,2,-1],[32,43,1,-1],[48,27,1,-1],[26,39,12,-4],[24,34,7,-1],[34,39,13,-3],
  [53,18,-13,-3],[53,17,1,-3],[53,18,-13,-3],[53,17,1,-3],[10,15,-13,-3],[11,15,-13,-3],[27,31,1,-1],[27,31,1,-1],
  [26,29,2,-2],[20,27,0,-5],[25,27,0,-2],[25,40,13,-2],[27,40,12,-1],[24,40,13,-3],[25,42,2,-2],[26,41,13,-3],
  [25,42,2,-2],[25,40,13,-2],[7,7,0,-5],[7,19,12,-5],[37,35,3,-4],[24,60,15,-3],[37,35,3,-4],[30,28,-1],
  [32,45,2,-2],[41,43,0,-2],[43,41,0,-2],[42,44,2,-3],[46,41,0,-2],[43,41,0,-2],[43,41,0,-2],[42,44,2,-3],
  [50,41,0,-2],[28,41,0,-2],[34,43,2,-4],[51,41,0,-2],[36,41,0,-2],[60,41,0,-2],[50,41,0,-2],[42,44,2,-2],
  [43,41,0,-2],[42,54,12,-2],[43,43,2,-2],[35,44,2,-3],[41,40,0,-1],[41,43,2,-4],[43,43,2,-3],[59,43,2,-3],
  [50,41,0,-1],[43,41,0,-2],[40,41,0,-3],[17,47,2,-3],[15,56,13,-4],[17,56,13,-3],[53,15,-7,-3],[53,16,-7,-3],
  [24,43,1],[28,28,1,-2],[23,42,1,-2],[24,28,1,-2],[29,42,1,-2],[24,28,1,-2],[30,54,12,-3],[28,40,13],
  [30,42,1,-3],[17,40,1,-1],[25,52,13,1],[27,42,1,-3],[14,42,1,-2],[49,28,1,-1],[33,28,1,-1],[26,28,1,-2],
  [31,38,12,2],[25,39,12,-2],[25,28,1,-1],[22,28,1,-3],[19,38,1,-1],[31,27,1,-1],[27,27,1,-1],[40,27,1,-1],
  [31,28,1,-1],[28,39,13,-1],[26,27,1,-2],[17,27,1,-1],[23,39,13,1],[33,40,13,-4],[27,13,-30,-10],[24,9,-31,-15],
  [24,95,167,238,309,381,452,524,
  595,666,738,809,880,952,1023,1095],[77,149,220,292,363,434,506,577],[1172,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmr10:[[4,5,0],[6,5,0],[5,6,1],[5,5,0],[5,5,0],[5,5,0],[5,5,0],[5,5,0],
  [5,5,0],[5,5,0],[5,5,0],[5,5,0],[4,5,0],[4,5,0],[6,5,0],[6,5,0],
  [2,3,0],[3,5,2,1],[2,2,-3],[2,2,-3,-1],[2,2,-3,-1],[3,2,-3],[3,2,-3],[2,2,-3,-2],
  [2,2,2,-1],[4,5,0],[5,4,0],[6,4,0],[4,5,1],[6,5,0],[7,6,1],[5,6,1],
  [2,1,-2],[2,5,0],[3,2,-3],[6,7,2],[4,6,1],[6,7,1],[5,6,1],[2,2,-3],
  [3,7,2],[2,7,2],[3,4,-2],[5,5,1],[2,2,1],[2,1,-1],[2,1,0],[3,7,2],
  [4,6,1],[3,5,0],[4,5,0],[4,6,1],[4,5,0],[4,6,1],[4,6,1],[4,6,1],
  [4,6,1],[4,6,1],[2,3,0],[2,4,1],[2,6,2],[5,3,0],[3,6,2],[3,5,0],
  [5,5,0],[5,5,0],[5,5,0],[5,6,1],[5,5,0],[5,5,0],[5,5,0],[5,6,1],
  [5,5,0],[3,5,0],[3,6,1],[5,5,0],[4,5,0],[6,5,0],[5,5,0],[5,6,1],
  [5,5,0],[5,7,2],[5,6,1],[4,6,1],[5,5,0],[5,6,1],[5,5,0],[7,5,0],
  [7,5,0,2],[5,5,0],[4,5,0],[2,8,2],[3,3,-2,-1],[2,8,2],[2,1,-4,-1],[2,1,-4],
  [2,3,-2],[4,4,0],[4,5,0],[3,4,0],[4,5,0],[3,4,0],[3,5,0],[4,5,2],
  [4,5,0],[2,5,0],[3,7,2,1],[4,5,0],[2,5,0],[6,3,0],[4,3,0],[4,4,0],
  [4,5,2],[4,5,2],[3,3,0],[3,4,0],[3,5,0],[4,3,0],[4,3,0],[5,3,0],
  [4,3,0],[4,5,2],[3,3,0],[4,1,-1],[7,1,-1],[2,2,-3,-1],[3,1,-4],[3,1,-4],
  [3,11,20,28,37,45,54,63,
  71,80,88,97,105,114,122,131],[9,17,26,34,42,51,59,67],[141,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmr10:[[5,6,0],[7,6,0],[6,7,1],[6,6,0],[5,6,0],[6,6,0],[6,6,0],[6,6,0],
  [6,6,0],[6,6,0],[6,6,0],[5,6,0],[4,6,0],[4,6,0],[7,6,0],[7,6,0],
  [2,4,0],[3,6,2,1],[2,2,-4,-1],[2,2,-4,-1],[2,1,-4,-1],[4,2,-4],[4,1,-4],[2,2,-4,-2],
  [2,2,2,-1],[4,6,0],[6,5,1],[6,4,0],[4,5,1],[7,6,0],[8,7,1],[6,7,1],
  [2,1,-2],[2,6,0],[3,3,-3],[6,8,2],[4,7,1],[7,7,1],[6,7,1],[2,3,-3],
  [3,8,2],[3,8,2],[4,4,-2],[6,6,1],[2,3,2],[3,1,-1],[2,1,0],[4,8,2],
  [4,7,1],[4,6,0],[4,6,0],[4,7,1],[4,6,0],[4,7,1],[4,7,1],[4,7,1],
  [4,7,1],[4,7,1],[2,4,0],[2,6,2],[2,6,2],[6,2,-1],[4,6,2],[4,6,0],
  [6,7,1],[6,6,0],[6,6,0],[6,7,1],[6,6,0],[6,6,0],[5,6,0],[6,7,1],
  [6,6,0],[3,6,0],[4,7,1],[6,6,0],[5,6,0],[7,6,0],[6,6,0],[6,7,1],
  [5,6,0],[6,8,2],[6,7,1],[4,7,1],[6,6,0],[6,7,1],[6,6,0],[8,6,0],
  [6,6,0],[6,6,0],[5,6,0],[2,8,2],[3,3,-3,-1],[2,8,2],[2,2,-4,-1],[2,2,-4],
  [2,3,-3],[4,5,1],[5,7,1],[4,4,0],[4,6,0],[4,4,0],[3,6,0],[4,6,2],
  [5,6,0],[2,6,0],[3,8,2,1],[4,6,0],[2,6,0],[7,4,0],[5,4,0],[4,4,0],
  [5,6,2],[4,6,2],[3,4,0],[3,5,1],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-2],[8,1,-2],[3,2,-4,-1],[4,2,-4],[2,2,-4,-1],
  [3,14,24,34,44,55,65,75,
  85,95,106,116,126,136,147,157],[11,21,31,41,51,61,71,81],[169,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmr10:[[6,7,0],[8,7,0],[8,8,1],[7,7,0],[7,7,0],[7,7,0],[7,7,0],[8,7,0],
  [7,7,0],[7,7,0],[7,7,0],[7,7,0],[6,7,0],[6,7,0],[8,7,0],[8,7,0],
  [3,5,0],[4,7,2,1],[2,2,-5,-1],[2,2,-5,-2],[3,2,-5,-1],[3,2,-5,-1],[5,1,-5],[3,3,-5,-2],
  [3,2,2,-1],[5,7,0],[7,6,1],[8,6,1],[5,7,1],[9,7,0],[10,8,1],[8,9,1],
  [3,2,-2],[2,8,0],[4,3,-4],[8,9,2],[5,9,1],[8,9,1],[8,9,1],[2,3,-4],
  [3,10,2,-1],[3,10,2],[5,5,-3],[8,7,1],[2,3,2],[3,2,-1],[2,1,0],[5,10,2],
  [5,8,1],[3,7,0,-1],[5,7,0],[5,8,1],[5,7,0],[5,8,1],[5,8,1],[5,8,1],
  [5,10,1],[5,10,1],[2,5,0],[2,7,2],[2,7,2],[8,3,-1],[5,7,2],[5,9,0],
  [8,8,1],[7,7,0],[7,7,0],[7,8,1],[7,7,0],[7,7,0],[6,7,0],[8,8,1],
  [7,7,0],[4,7,0],[5,8,1],[8,7,0],[6,7,0],[9,7,0],[7,7,0],[8,8,1],
  [7,7,0],[8,9,2],[8,8,1],[5,8,1],[7,7,0],[7,8,1],[8,8,1],[10,8,1],
  [10,7,0,2],[8,7,0],[6,7,0],[2,10,2,-1],[4,3,-4,-1],[2,10,2],[3,2,-5,-1],[2,2,-5],
  [2,3,-4],[5,5,0],[6,7,0],[4,6,1],[6,8,1],[5,6,1],[4,7,0],[5,7,2],
  [6,7,0],[3,7,0],[4,9,2,1],[5,9,0],[3,7,0],[8,9,0],[6,5,0],[5,6,1],
  [6,7,2],[6,7,2],[4,5,0],[4,5,0],[4,7,1],[6,6,1],[5,5,0],[7,5,0],
  [5,5,0],[5,7,2],[4,5,0],[5,1,-2],[10,1,-2],[4,2,-5,-1],[3,2,-5,-1],[3,2,-5,-1],
  [4,16,28,40,52,64,76,88,
  99,111,123,135,147,159,171,183],[13,24,36,47,59,71,82,94],[197,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmr10:[[7,9,0],[10,9,0],[9,10,1],[8,9,0],[8,9,0],[9,9,0],[8,9,0],[9,9,0],
  [8,9,0],[9,9,0],[8,9,0],[8,9,0],[7,9,0],[7,9,0],[10,9,0],[10,9,0],
  [3,6,0],[4,9,3,1],[3,3,-6,-1],[3,3,-6,-2],[4,2,-6,-1],[4,3,-6,-1],[4,2,-6,-1],[3,3,-6,-3],
  [4,3,3,-1],[6,10,1],[9,7,1],[9,7,1],[6,8,1],[11,9,0],[12,10,1],[12,10,1,3],
  [3,2,-3],[2,9,0,-1],[5,5,-4],[10,12,3],[6,10,1],[10,10,1],[9,10,1],[2,5,-4,-1],
  [3,12,3,-1],[4,12,3],[6,5,-4],[9,8,1],[2,5,3,-1],[4,1,-2],[2,2,0,-1],[6,12,3],
  [6,9,1],[4,8,0,-1],[6,8,0],[6,9,1],[6,8,0],[6,9,1],[6,9,1],[6,9,1],
  [6,9,1],[6,9,1],[2,6,0,-1],[2,9,3,-1],[2,9,3,-1],[9,4,-1],[5,9,3],[5,9,0],
  [9,10,1],[9,9,0],[8,9,0],[8,10,1],[9,9,0],[8,9,0],[8,9,0],[9,10,1],
  [9,9,0],[4,9,0],[6,10,1],[9,9,0],[7,9,0],[11,9,0],[9,9,0],[9,10,1],
  [8,9,0],[9,12,3],[9,10,1],[6,10,1],[9,9,0],[9,10,1],[9,10,1],[12,10,1],
  [9,9,0],[9,9,0],[7,9,0],[2,12,3,-1],[5,5,-4,-1],[2,12,3],[4,2,-6,-1],[2,2,-6,-1],
  [3,5,-4],[6,7,1],[7,10,1],[5,7,1],[7,10,1],[5,7,1],[5,9,0],[6,9,3],
  [7,9,0],[3,8,0],[4,11,3,1],[6,9,0],[3,9,0],[10,6,0],[7,6,0],[6,7,1],
  [7,9,3],[7,9,3],[5,6,0],[5,7,1],[4,9,1],[7,7,1],[6,6,0],[9,6,0],
  [7,6,0],[6,9,3],[5,6,0],[6,1,-3],[12,1,-3],[8,6,-3,3],[4,1,-7,-1],[4,2,-6,-1],
  [5,19,34,48,63,77,92,106,
  121,135,150,164,179,193,208,222],[16,30,45,59,73,87,101,115],[239,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmr10:[[9,10,0],[11,10,0],[11,11,1],[10,10,0],[9,10,0],[10,10,0],[10,10,0],[10,10,0],
  [10,10,0],[9,10,0,168],[10,10,0],[9,10,0],[8,10,0],[8,10,0],[12,10,0],[12,10,0],
  [4,7,0],[4,10,3,1],[3,3,-7,-1],[3,3,-7,-3],[5,2,-7,-1],[5,3,-7,-1],[5,2,-7,-1],[3,3,-7,-4],
  [4,3,3,-2],[7,11,1],[10,8,1],[11,8,1],[7,10,2],[13,10,0],[13,11,1,-1],[11,12,1],
  [4,2,-4],[2,10,0,-1],[5,5,-5],[11,13,3],[7,12,1],[11,12,1],[11,11,1],[2,5,-5,-1],
  [4,15,4,-1],[3,15,4,-1],[5,7,-4,-1],[10,9,1],[2,5,3,-1],[4,2,-2],[2,2,0,-1],[7,15,4],
  [7,11,1],[5,10,0,-1],[7,10,0],[7,11,1],[7,10,0],[7,11,1],[7,11,1],[7,11,1],
  [7,11,1],[7,11,1],[2,6,0,-1],[2,9,3,-1],[2,10,3,-1],[10,5,-1],[6,10,3],[6,10,0],
  [11,11,1],[10,10,0],[10,10,0],[10,11,1],[10,10,0],[9,10,0],[9,10,0],[11,11,1],
  [10,10,0],[5,10,0],[7,11,1],[11,10,0],[9,10,0],[13,10,0],[10,10,0],[11,11,1],
  [9,10,0],[11,13,3],[11,11,1],[7,11,1],[10,10,0],[10,11,1],[11,11,1],[14,11,1],
  [11,10,0],[11,10,0],[8,10,0],[3,15,4,-1],[5,5,-5,-2],[3,15,4],[5,3,-7,-1],[2,2,-8,-1],
  [2,5,-5,-1],[7,8,1],[8,11,1],[6,8,1],[8,11,1],[6,8,1],[5,10,0],[7,10,3],
  [8,10,0],[4,10,0],[4,13,3,1],[8,10,0],[4,10,0],[12,7,0],[8,7,0],[7,8,1],
  [8,10,3],[8,10,3],[5,7,0],[5,8,1],[5,10,1],[8,8,1],[7,6,0],[10,6,0],
  [8,6,0],[7,9,3],[6,6,0],[7,1,-3],[14,1,-3],[5,3,-7,-1],[5,2,-8,-1],[5,2,-8,-1],
  [6,23,40,57,74,91,108,125,
  142,159,176,193,210,227,244,262],[19,36,52,69,85,102,119,135],[281,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmr10:[[10,12,0],[14,12,0],[12,13,1,-1],[12,13,0],[11,12,0],[13,12,0],[11,12,0,-1],[12,12,0,-1],
  [11,12,0,-1],[12,12,0,-1],[12,12,0],[11,12,0],[9,12,0],[9,12,0],[14,12,0],[14,12,0],
  [5,8,0],[5,12,4,1],[4,4,-8,-1],[4,4,-8,-3],[5,3,-8,-2],[6,4,-8,-1],[7,1,-9,-1],[4,4,-9,-4],
  [5,4,4,-2],[8,13,1],[12,9,1],[13,9,1],[8,11,2],[15,12,0],[16,13,1,-1],[12,14,1,-1],
  [5,3,-4],[3,13,0,-1],[6,6,-6],[13,16,4,-1],[7,14,1,-1],[13,14,1,-1],[13,14,1],[3,6,-6,-1],
  [5,17,4,-1],[4,17,4,-1],[7,8,-5,-1],[12,12,2,-1],[3,6,4,-1],[5,2,-3],[3,2,0,-1],[7,17,4,-1],
  [8,13,1],[7,12,0,-1],[8,12,0],[8,13,1],[8,12,0],[8,13,1],[8,13,1],[8,13,1,-1],
  [8,13,1],[8,13,1],[3,8,0,-1],[3,12,4,-1],[3,13,4,-1],[12,5,-2,-1],[6,13,4,-1],[6,12,0,-1],
  [12,13,1,-1],[13,13,0],[11,12,0],[11,13,1,-1],[12,12,0],[11,12,0],[11,12,0],[12,13,1,-1],
  [13,12,0],[6,12,0],[8,13,1],[13,12,0],[10,12,0],[15,12,0],[13,12,0],[12,13,1,-1],
  [11,12,0],[12,16,4,-1],[13,13,1],[8,13,1,-1],[12,12,0],[13,13,1],[13,13,1],[18,13,1],
  [13,12,0],[13,12,0],[9,12,0,-1],[3,17,4,-2],[6,6,-6,-2],[3,17,4],[5,3,-9,-2],[3,3,-9,-1],
  [3,6,-6,-1],[9,9,1],[9,13,1],[7,9,1],[9,13,1],[7,9,1],[6,12,0],[9,12,4],
  [9,12,0],[5,12,0],[5,16,4,1],[9,12,0],[5,12,0],[14,8,0],[9,8,0],[8,9,1],
  [9,12,4],[9,12,4],[7,8,0],[7,9,1],[6,12,1],[9,9,1],[9,9,1],[12,9,1],
  [9,8,0],[9,12,4],[7,8,0],[9,1,-4],[17,1,-4],[6,4,-8,-2],[6,3,-9,-1],[6,3,-9,-1],
  [7,27,48,68,89,109,130,150,
  171,191,211,232,252,273,293,314],[22,42,61,81,101,121,141,161],[337,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmr10:[[12,14,0],[15,15,0,-1],[14,16,1,-1],[14,15,0],[13,14,0],[15,14,0],[13,14,0,-1],[14,15,0,-1],
  [13,14,0,-1],[14,14,0,-1],[13,15,0,-1],[13,15,0],[11,15,0],[11,15,0],[16,15,0],[16,15,0],
  [5,9,0],[6,14,5,1],[4,4,-10,-2],[4,4,-10,-4],[6,3,-10,-2],[6,4,-10,-2],[8,1,-11,-1],[5,5,-10,-5],
  [6,5,5,-2],[10,16,1],[13,10,1,-1],[15,10,1],[10,13,2],[18,14,0],[19,15,1,-1],[14,16,1,-1],
  [6,3,-5],[3,15,0,-1],[7,6,-8],[15,18,4,-1],[8,16,1,-1],[15,17,2,-1],[15,16,1],[4,6,-8,-1],
  [5,20,5,-2],[5,20,5,-1],[8,9,-6,-1],[14,14,2,-1],[3,7,4,-1],[6,2,-3],[3,3,0,-1],[8,20,5,-1],
  [10,15,1],[8,14,0,-1],[8,14,0,-1],[10,15,1],[10,14,0],[8,15,1,-1],[10,15,1],[9,15,1,-1],
  [10,15,1],[10,15,1],[3,9,0,-1],[3,13,4,-1],[3,15,5,-1],[14,6,-2,-1],[8,15,5,-1],[8,15,0,-1],
  [14,16,1,-1],[15,15,0],[13,14,0],[13,16,1,-1],[15,14,0],[13,14,0],[13,14,0],[14,16,1,-1],
  [15,14,0],[7,14,0],[10,15,1],[15,14,0],[12,14,0],[18,14,0],[15,14,0],[14,16,1,-1],
  [13,14,0],[14,19,4,-1],[15,15,1],[9,16,1,-1],[14,14,0],[15,15,1],[15,15,1],[21,15,1],
  [15,14,0],[15,14,0],[11,14,0,-1],[4,20,5,-2],[7,7,-7,-3],[4,20,5],[6,3,-11,-2],[3,3,-11,-1],
  [3,7,-7,-1],[10,10,1],[11,15,1],[9,10,1],[11,15,1],[9,10,1],[8,15,0],[10,14,5],
  [11,14,0],[5,14,0],[6,19,5,1],[11,14,0],[5,14,0],[17,9,0],[11,9,0],[10,10,1],
  [11,13,4],[11,13,4],[8,9,0],[8,10,1],[7,14,1],[11,10,1],[11,10,1],[14,10,1],
  [11,9,0],[11,13,4],[8,9,0],[10,1,-5],[20,1,-5],[7,4,-10,-2],[8,3,-11,-1],[6,3,-11,-2],
  [8,33,57,82,106,131,155,180,
  205,229,254,278,303,327,352,377],[26,50,74,98,122,145,169,193],[404,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmr10:[[14,17,0],[18,18,0,-1],[17,18,1,-1],[16,18,0],[14,17,0,-1],[18,17,0],[15,17,0,-1],[17,17,0,-1],
  [15,17,0,-1],[17,17,0,-1],[16,17,0,-1],[15,17,0],[13,17,0],[13,17,0],[20,17,0],[20,17,0],
  [6,11,0],[6,16,5,1],[5,5,-12,-2],[5,5,-12,-5],[6,4,-12,-3],[8,5,-12,-2],[10,2,-13,-1],[6,5,-13,-6],
  [6,5,5,-3],[12,18,1],[16,12,1,-1],[18,12,1],[12,16,3],[21,17,0],[23,18,1,-1],[17,20,2,-1],
  [7,4,-6],[3,18,0,-2],[9,8,-9],[18,22,5,-1],[10,20,2,-1],[18,20,2,-1],[17,19,1,-1],[3,8,-9,-2],
  [6,24,6,-2],[6,24,6,-1],[10,11,-7,-1],[17,16,2,-1],[3,8,5,-2],[7,2,-4],[3,3,0,-2],[10,24,6,-1],
  [11,17,1],[8,16,0,-2],[10,16,0,-1],[10,17,1,-1],[12,17,0],[10,17,1,-1],[10,17,1,-1],[11,18,1,-1],
  [10,17,1,-1],[10,17,1,-1],[3,11,0,-2],[3,16,5,-2],[3,18,6,-2],[17,6,-3,-1],[9,17,5,-1],[9,17,0,-1],
  [17,18,1,-1],[18,18,0],[16,17,0],[15,18,1,-1],[17,17,0],[16,17,0],[15,17,0],[17,18,1,-1],
  [18,17,0],[8,17,0],[11,18,1,-1],[18,17,0],[14,17,0],[22,17,0],[18,17,0],[17,18,1,-1],
  [15,17,0],[17,22,5,-1],[18,18,1],[11,18,1,-1],[17,17,0],[18,18,1],[18,18,1],[25,18,1],
  [18,17,0],[18,17,0],[13,17,0,-1],[5,24,6,-2],[9,8,-9,-3],[4,24,6],[6,4,-13,-3],[3,3,-13,-2],
  [4,8,-9,-1],[11,12,1,-1],[13,18,1],[10,12,1],[13,18,1],[10,12,1],[9,17,0],[12,16,5],
  [13,17,0],[6,16,0],[6,21,5,1],[13,17,0],[7,17,0],[20,11,0],[13,11,0],[12,12,1],
  [13,16,5],[13,16,5],[9,11,0],[9,12,1],[8,16,1],[13,12,1],[13,12,1],[17,12,1],
  [13,11,0],[13,16,5],[10,11,0],[12,1,-6],[24,1,-6],[7,5,-12,-3],[8,3,-13,-2],[8,3,-13,-2],
  [10,39,69,98,128,157,187,216,
  246,275,305,334,364,393,423,453],[32,61,90,118,147,176,204,233],[485,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmr10:[[16,20,0,-1],[22,21,0,-1],[20,22,1,-1],[20,21,0],[18,20,0,-1],[20,20,0,-1],[19,20,0,-1],[20,21,0,-1],
  [19,20,0,-1],[20,20,0,-1],[19,21,0,-1],[19,21,0],[16,21,0],[16,21,0],[24,21,0],[24,21,0],
  [7,13,0,-1],[9,19,6,2],[6,6,-15,-3],[6,6,-15,-6],[8,4,-15,-3],[9,6,-15,-3],[11,2,-16,-2],[6,6,-15,-8],
  [8,6,6,-3],[14,22,1],[20,14,1,-1],[22,14,1],[13,19,3,-1],[26,20,0],[27,22,1,-2],[20,24,2,-1],
  [8,4,-8],[4,21,0,-2],[9,10,-11,-1],[22,27,6,-1],[12,24,2,-1],[22,24,2,-1],[20,22,1,-1],[4,9,-11,-2],
  [8,30,8,-2],[8,30,8,-1],[11,13,-9,-2],[20,20,3,-1],[4,9,6,-2],[8,3,-5],[4,3,0,-2],[12,30,8,-1],
  [13,21,1,-1],[11,20,0,-2],[12,20,0,-1],[13,21,1,-1],[14,20,0],[12,21,1,-1],[13,21,1,-1],[13,21,1,-1],
  [13,21,1,-1],[13,21,1,-1],[4,13,0,-2],[4,19,6,-2],[4,22,7,-2],[20,8,-3,-1],[11,21,6,-1],[11,21,0,-1],
  [20,22,1,-1],[21,21,0],[18,20,0,-1],[19,22,1,-1],[20,20,0,-1],[18,20,0,-1],[17,20,0,-1],[21,22,1,-1],
  [20,20,0,-1],[10,20,0],[13,21,1,-1],[21,20,0,-1],[16,20,0,-1],[25,20,0,-1],[20,20,0,-1],[20,22,1,-1],
  [18,20,0,-1],[21,27,6,-1],[21,21,1,-1],[14,22,1,-1],[19,20,0,-1],[20,21,1,-1],[22,21,1],[30,21,1],
  [21,20,0],[22,20,0],[16,20,0,-1],[5,30,8,-3],[10,9,-11,-4],[5,30,8],[8,5,-15,-3],[4,4,-16,-2],
  [4,9,-11,-2],[14,14,1,-1],[16,22,1],[11,14,1,-1],[15,22,1,-1],[12,14,1],[10,21,0,-1],[14,20,6],
  [16,21,0],[7,20,0,-1],[9,26,6,2],[15,21,0],[7,21,0,-1],[24,13,0],[16,13,0],[14,14,1],
  [16,19,6],[15,19,6,-1],[11,13,0],[10,14,1,-1],[10,19,1],[15,14,1,-1],[15,14,1],[21,14,1],
  [15,13,0],[15,19,6],[12,13,0],[15,1,-7],[29,1,-7],[10,6,-15,-3],[10,4,-16,-2],[9,4,-16,-3],
  [12,47,82,118,153,188,223,259,
  294,329,365,400,435,471,506,541],[37,72,106,140,175,209,243,278],[580,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmr10:[[19,24,0,-1],[26,25,0,-1],[24,25,1,-1],[22,25,0,-1],[21,23,0,-1],[24,24,0,-1],[21,24,0,-2],[23,24,0,-2],
  [22,24,0,-1],[23,24,0,-2],[22,24,0,-1],[21,24,0,-1],[17,24,0,-1],[17,24,0,-1],[27,24,0,-1],[27,24,0,-1],
  [8,15,0,-1],[10,22,7,2],[7,7,-17,-3],[7,7,-17,-7],[9,5,-17,-4],[11,7,-17,-3],[13,2,-19,-2],[7,7,-18,-9],
  [9,7,7,-4],[15,25,1,-1],[23,17,1,-1],[25,17,1,-1],[15,22,4,-1],[29,24,0,-1],[32,25,1,-2],[24,27,2,-1],
  [8,5,-9,-1],[4,25,0,-3],[11,11,-13,-1],[25,31,7,-2],[14,28,2,-1],[26,28,2,-1],[24,26,1,-1],[4,11,-13,-3],
  [9,35,9,-3],[8,35,9,-2],[13,16,-10,-2],[23,23,3,-2],[4,11,7,-3],[10,3,-6],[4,4,0,-3],[13,35,9,-2],
  [15,24,1,-1],[12,23,0,-3],[15,23,0,-1],[15,24,1,-1],[15,23,0,-1],[15,24,1,-1],[15,24,1,-1],[15,24,1,-2],
  [15,24,1,-1],[15,24,1,-1],[4,15,0,-3],[4,22,7,-3],[4,25,8,-3],[23,9,-4,-2],[14,24,7,-1],[14,24,0,-1],
  [24,25,1,-1],[24,25,0,-1],[22,24,0,-1],[22,25,1,-1],[23,24,0,-1],[22,24,0,-1],[20,24,0,-1],[24,25,1,-1],
  [24,24,0,-1],[11,24,0,-1],[15,25,1,-1],[24,24,0,-1],[19,24,0,-1],[29,24,0,-1],[24,24,0,-1],[24,25,1,-1],
  [21,24,0,-1],[24,31,7,-1],[24,25,1,-1],[16,25,1,-1],[23,23,0,-1],[24,25,1,-1],[25,25,1],[35,25,1],
  [25,24,0],[26,24,0],[18,24,0,-1],[5,35,9,-4],[11,11,-13,-5],[6,35,9],[9,6,-18,-4],[4,4,-19,-3],
  [5,11,-13,-2],[16,17,1,-1],[17,25,1,-1],[13,17,1,-1],[17,25,1,-1],[14,17,1,-1],[12,24,0,-1],[16,23,7,-1],
  [18,24,0,-1],[8,23,0,-1],[10,30,7,2],[17,24,0,-1],[8,24,0,-1],[27,15,0,-1],[18,15,0,-1],[15,17,1,-1],
  [17,22,7,-1],[17,22,7,-1],[12,15,0,-1],[12,17,1,-1],[12,22,1],[18,16,1,-1],[18,16,1],[24,16,1],
  [18,15,0],[18,22,7],[13,15,0,-1],[17,2,-8],[34,2,-8],[11,7,-17,-4],[11,4,-19,-3],[11,4,-19,-3],
  [14,56,99,141,184,226,269,311,
  354,396,439,481,524,566,609,651],[46,87,128,170,211,253,294,335],[698,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmr10:[[23,28,0,-1],[31,30,0,-2],[28,30,1,-2],[27,30,0,-1],[25,28,0,-1],[29,28,0,-1],[26,28,0,-2],[28,29,0,-2],
  [26,28,0,-2],[28,28,0,-2],[27,29,0,-1],[25,29,0,-1],[21,29,0,-1],[21,29,0,-1],[32,29,0,-1],[32,29,0,-1],
  [10,19,0,-1],[11,28,9,2],[8,8,-21,-4],[8,8,-21,-8],[11,5,-21,-5],[13,8,-21,-4],[16,3,-22,-2],[9,8,-22,-11],
  [10,9,9,-5],[19,30,1,-1],[28,20,1,-1],[30,20,1,-1],[18,26,4,-1],[35,28,0,-1],[39,30,1,-2],[28,34,3,-2],
  [10,5,-11,-1],[5,30,0,-3],[14,13,-16,-1],[30,37,8,-2],[17,34,3,-2],[30,34,3,-2],[29,31,1,-1],[6,13,-16,-3],
  [10,42,11,-4],[10,42,11,-2],[16,18,-13,-2],[28,28,4,-2],[6,13,8,-3],[12,3,-7],[5,5,0,-3],[17,42,11,-2],
  [18,29,1,-1],[15,28,0,-3],[17,28,0,-2],[18,29,1,-1],[19,28,0,-1],[17,29,1,-2],[18,29,1,-1],[18,29,1,-2],
  [18,29,1,-1],[18,29,1,-1],[5,18,0,-3],[5,26,8,-3],[5,30,9,-3],[28,10,-5,-2],[15,30,9,-2],[15,29,0,-2],
  [28,30,1,-2],[29,30,0,-1],[26,28,0,-1],[26,30,1,-2],[28,28,0,-1],[26,28,0,-1],[24,28,0,-1],[29,30,1,-2],
  [29,28,0,-1],[13,28,0,-1],[19,29,1,-1],[30,28,0,-1],[23,28,0,-1],[35,28,0,-1],[29,28,0,-1],[28,30,1,-2],
  [25,28,0,-1],[28,37,8,-2],[29,29,1,-1],[19,30,1,-2],[27,28,0,-1],[29,29,1,-1],[30,29,1],[42,29,1],
  [29,28,0,-1],[31,28,0],[21,28,0,-2],[7,42,11,-4],[14,13,-16,-6],[7,42,11],[11,7,-22,-5],[5,5,-23,-3],
  [5,13,-16,-3],[20,20,1,-1],[21,30,1,-1],[16,20,1,-1],[21,30,1,-1],[16,20,1,-1],[14,29,0,-1],[19,28,9,-1],
  [21,29,0,-1],[10,28,0,-1],[11,37,9,2],[20,29,0,-1],[10,29,0,-1],[33,19,0,-1],[21,19,0,-1],[19,20,1,-1],
  [21,27,8,-1],[21,27,8,-1],[14,19,0,-1],[14,20,1,-1],[14,27,1],[21,20,1,-1],[21,19,1],[29,19,1],
  [22,18,0],[21,27,9],[16,18,0,-1],[21,2,-10],[41,2,-10],[13,8,-21,-5],[14,5,-23,-3],[13,5,-23,-4],
  [17,67,118,169,220,271,322,373,
  423,474,525,576,627,678,729,780],[55,104,154,203,253,302,352,401],[835,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmr10:[[28,34,0,-1],[37,35,0,-2],[34,36,1,-2],[32,35,0,-1],[29,34,0,-2],[35,34,0,-1],[31,34,0,-2],[34,35,0,-2],
  [31,34,0,-2],[34,34,0,-2],[32,35,0,-2],[30,35,0,-1],[25,35,0,-1],[25,35,0,-1],[39,35,0,-1],[39,35,0,-1],
  [12,22,0,-1],[13,32,10,2],[10,10,-25,-5],[10,10,-25,-10],[13,7,-25,-6],[16,9,-25,-4],[18,2,-27,-3],[10,10,-26,-13],
  [12,9,10,-6],[23,36,1,-1],[32,23,1,-2],[36,23,1,-1],[22,31,5,-1],[42,34,0,-1],[46,37,2,-3],[34,39,3,-2],
  [12,6,-13,-1],[6,35,0,-4],[16,15,-19,-1],[36,44,10,-2],[20,40,3,-2],[36,40,3,-2],[34,38,2,-2],[7,15,-19,-4],
  [13,50,13,-4],[13,50,13,-2],[19,22,-15,-3],[34,33,4,-2],[6,16,10,-4],[14,3,-9],[6,6,0,-4],[20,50,13,-2],
  [22,35,2,-1],[17,33,0,-4],[20,33,0,-2],[21,35,2,-2],[23,34,0,-1],[20,35,2,-2],[21,35,2,-2],[22,35,1,-2],
  [21,35,2,-2],[21,34,1,-2],[6,22,0,-4],[6,32,10,-4],[6,36,11,-4],[34,12,-6,-2],[19,35,10,-2],[19,35,0,-2],
  [34,36,1,-2],[35,35,0,-1],[31,34,0,-1],[31,37,2,-2],[34,34,0,-1],[31,34,0,-1],[29,34,0,-1],[34,37,2,-2],
  [35,34,0,-1],[16,34,0,-1],[21,35,1,-2],[36,34,0,-1],[28,34,0,-1],[43,34,0,-1],[35,34,0,-1],[34,36,1,-2],
  [30,34,0,-1],[34,45,10,-2],[35,35,1,-1],[23,37,2,-2],[33,34,0,-1],[35,35,1,-1],[36,35,1],[50,35,1],
  [35,34,0,-1],[37,34,0],[26,34,0,-2],[8,50,13,-5],[16,15,-19,-7],[7,50,13,-1],[14,8,-26,-5],[6,6,-27,-4],
  [7,15,-19,-3],[23,23,1,-2],[25,35,1,-1],[20,23,1,-1],[25,35,1,-1],[20,23,1,-1],[17,35,0,-1],[23,34,11,-1],
  [26,34,0,-1],[12,33,0,-1],[13,43,10,2],[24,34,0,-1],[12,34,0,-1],[39,22,0,-1],[26,22,0,-1],[23,23,1,-1],
  [25,32,10,-1],[25,32,10,-1],[17,22,0,-1],[17,23,1,-1],[16,32,1,-1],[26,23,1,-1],[25,23,1],[35,23,1],
  [26,22,0],[25,32,10],[19,22,0,-1],[25,2,-12],[49,2,-12],[15,10,-25,-6],[17,5,-28,-4],[15,6,-27,-5],
  [20,81,142,203,264,325,387,448,
  509,570,631,692,753,814,875,937],[64,124,183,243,302,362,421,481],[1003,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmr10:[[33,41,0,-2],[45,43,0,-2],[40,44,2,-3],[38,43,0,-1],[35,40,0,-2],[41,41,0,-2],[37,41,0,-3],[40,42,0,-3],
  [37,41,0,-3],[40,41,0,-3],[38,42,0,-2],[36,42,0,-1],[31,42,0,-1],[31,42,0,-1],[47,42,0,-1],[47,42,0,-1],
  [13,26,0,-2],[16,39,13,3],[12,12,-30,-6],[11,12,-30,-12],[16,8,-30,-7],[19,11,-30,-5],[22,2,-33,-4],[12,11,-32,-16],
  [15,11,12,-7],[27,43,1,-1],[39,28,1,-2],[44,28,1,-1],[26,38,6,-2],[51,41,0,-1],[54,44,2,-4],[40,48,4,-3],
  [15,7,-16,-1],[7,43,0,-5],[19,18,-23,-2],[43,53,12,-3],[24,49,4,-3],[43,49,4,-3],[41,45,2,-2],[8,18,-23,-5],
  [15,60,15,-5],[14,60,15,-3],[23,27,-18,-3],[40,40,5,-3],[7,19,12,-5],[17,4,-11],[7,7,0,-5],[24,60,15,-3],
  [26,42,2,-2],[20,40,0,-5],[24,40,0,-3],[25,42,2,-2],[27,40,0,-1],[24,42,2,-3],[25,42,2,-2],[26,42,2,-3],
  [25,42,2,-2],[25,42,2,-2],[7,26,0,-5],[7,38,12,-5],[7,43,13,-5],[40,15,-7,-3],[22,43,13,-3],[22,42,0,-3],
  [40,43,1,-3],[42,43,0,-1],[37,41,0,-2],[37,44,2,-3],[40,41,0,-2],[37,41,0,-2],[34,41,0,-2],[41,44,2,-3],
  [41,41,0,-2],[19,41,0,-1],[26,43,2,-2],[42,41,0,-2],[33,41,0,-2],[50,41,0,-2],[41,41,0,-2],[40,44,2,-3],
  [35,41,0,-2],[40,54,12,-3],[42,43,2,-2],[27,44,2,-3],[39,40,0,-2],[41,43,2,-2],[43,43,2,-1],[59,43,2,-1],
  [42,41,0,-1],[44,41,0],[30,41,0,-3],[8,60,15,-7],[19,18,-23,-9],[9,60,15,-1],[16,9,-32,-7],[7,7,-33,-5],
  [8,18,-23,-4],[28,28,1,-2],[30,42,1,-1],[23,28,1,-2],[30,42,1,-2],[24,28,1,-1],[19,42,0,-2],[28,40,13,-1],
  [31,41,0,-1],[13,40,0,-2],[16,53,13,3],[30,41,0,-1],[13,41,0,-2],[47,27,0,-1],[31,27,0,-1],[27,28,1,-1],
  [30,39,12,-1],[30,39,12,-2],[21,26,0,-1],[20,28,1,-2],[19,38,1,-1],[31,27,1,-1],[29,27,1,-1],[41,27,1,-1],
  [31,26,0],[29,39,13,-1],[23,26,0,-1],[30,2,-15],[59,2,-15],[18,12,-30,-7],[20,7,-33,-5],[18,7,-33,-6],
  [24,97,171,244,317,391,464,538,
  611,684,758,831,904,978,1051,1125],[77,149,220,292,363,434,506,577],[1205,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmsy10:[[5,1,-1],[2,1,-1],[4,4,0,-1],[3,4,0],[5,5,1],[4,4,0],[5,5,0],[5,5,1],
  [5,5,1],[5,5,1],[5,5,1],[5,5,1],[5,5,1],[7,7,2],[3,4,0],[3,4,0],
  [5,4,0],[5,4,0],[5,6,1],[5,6,1],[5,6,1],[5,6,1],[5,6,1],[5,6,1],
  [5,2,-1],[5,4,0],[5,5,1],[5,5,1],[7,5,1],[7,5,1],[5,5,1],[5,5,1],
  [7,3,0],[7,3,0],[3,7,2],[3,7,2],[7,3,0],[7,7,2],[7,7,2],[5,4,0],
  [7,4,0],[7,4,0],[4,7,2],[4,7,2],[7,4,0],[7,7,2],[7,7,2],[5,3,0],
  [2,4,0],[7,3,0],[4,5,1],[4,5,1],[6,5,0],[6,6,2],[4,7,2,-1],[1,3,0],
  [4,5,0],[4,5,0],[5,3,0],[4,7,1],[5,6,1],[5,5,0],[5,5,0],[5,5,0],
  [4,5,0],[6,6,1],[5,6,1],[4,6,1],[6,5,0],[4,6,1],[6,6,1],[5,6,1],
  [6,6,1],[5,5,0],[6,6,1],[5,6,1],[5,6,1],[8,6,1],[9,7,1,2],[6,6,1],
  [6,6,1],[6,6,1],[6,6,1],[5,6,1],[6,5,0],[6,6,1,1],[5,6,1],[8,6,1],
  [6,5,0],[5,6,1],[6,5,0],[5,5,1],[5,5,0],[5,5,1],[5,4,0],[5,4,0],
  [4,5,0],[4,5,0],[2,8,2,-1],[2,8,2],[2,8,2,-1],[2,8,2],[3,8,2],[3,8,2],
  [3,8,2],[2,8,2],[2,7,2],[3,8,2],[3,8,2],[4,8,2],[3,8,2],[2,5,1],
  [6,8,7],[5,5,0],[6,6,1],[4,7,2],[5,4,0],[5,5,0],[5,6,1],[5,6,1],
  [3,7,2],[3,7,2],[3,7,2],[4,7,2],[6,6,1],[5,6,1],[5,6,1],[5,6,1],
  [3,13,23,33,43,53,63,73,
  83,93,103,113,123,133,142,152],[9,24,38,52,66,80,95,109],[164,121]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmsy10:[[5,2,-1,-1],[2,2,-1],[4,4,0,-1],[4,4,0],[6,6,1],[4,4,0],[6,6,0],[6,6,2],
  [6,6,1],[6,6,1],[6,6,1],[6,6,1],[6,6,1],[8,8,2],[4,4,0],[4,4,0],
  [6,4,0],[6,4,0],[6,8,2],[6,8,2],[6,7,2],[6,7,2],[6,7,2],[6,7,2],
  [6,2,-1],[6,4,0],[6,6,1],[6,6,1],[8,6,1],[8,6,1],[5,6,1,-1],[6,6,1],
  [8,4,0],[8,4,0],[4,8,2],[4,8,2],[8,4,0],[8,8,2],[8,8,2],[6,4,0],
  [8,6,1],[8,6,1],[5,8,2],[5,8,2],[8,6,1],[8,8,2],[8,8,2],[6,4,0],
  [2,5,0],[8,4,0],[5,6,1],[5,6,1],[7,6,0],[7,6,2],[4,8,2,-1],[1,4,0],
  [5,6,0],[4,6,0],[5,3,0],[4,7,1],[6,7,1],[6,7,1],[6,6,0],[6,6,0],
  [5,6,0],[7,7,1],[6,7,1],[5,7,1],[7,6,0],[5,7,1],[7,7,1],[5,7,1],
  [7,7,1],[5,6,0],[7,7,1],[6,7,1],[5,7,1],[9,7,1],[9,8,1,1],[7,7,1],
  [6,7,1],[6,7,1,-1],[7,7,1],[6,7,1],[7,6,0],[7,7,1,1],[6,7,1],[9,7,1],
  [7,6,0],[6,7,1],[6,6,0],[5,6,1],[5,5,0],[5,6,1],[5,5,0],[5,5,0],
  [5,6,0],[5,6,0],[3,8,2,-1],[3,8,2],[3,8,2,-1],[3,8,2],[3,8,2,-1],[3,8,2],
  [2,8,2,-1],[3,8,2],[1,8,2,-1],[2,8,2,-1],[4,8,2],[5,8,2],[4,8,2],[2,6,1],
  [7,9,8],[6,6,0],[7,7,1],[4,8,2],[5,5,0],[5,5,0],[6,8,2],[6,8,2],
  [3,8,2],[3,8,2],[3,8,2],[5,8,2],[6,7,1],[6,8,2],[6,7,1],[6,7,1],
  [3,15,27,39,51,63,75,87,
  99,111,123,135,147,159,171,183],[11,28,45,62,80,97,114,131],[196,145]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmsy10:[[6,1,-2,-1],[2,1,-2],[6,5,0,-1],[5,5,0],[8,7,1],[5,5,0],[8,7,0],[8,7,2],
  [8,7,1],[8,7,1],[8,7,1],[8,7,1],[8,7,1],[10,11,3],[5,5,0],[5,5,0],
  [8,5,0],[8,5,0],[7,9,2],[6,9,2,-1],[6,9,2,-1],[6,9,2,-1],[6,9,2,-1],[7,9,2],
  [8,3,-1],[8,5,0],[7,7,1],[6,7,1,-1],[10,7,1],[10,7,1],[6,7,1,-1],[6,7,1,-1],
  [10,5,0],[10,5,0],[5,9,2],[5,9,2],[10,5,0],[10,9,2],[10,9,2],[8,5,0],
  [10,5,0],[10,5,0],[6,9,2],[6,9,2],[10,7,1],[10,9,2],[10,9,2],[8,6,1],
  [3,6,0],[10,6,1],[6,7,1],[5,7,1,-1],[9,7,0],[9,7,2],[6,9,2,-1],[2,5,0],
  [6,8,1],[5,7,0],[7,3,-1],[5,9,1],[7,9,1],[7,8,1],[8,7,0],[8,7,0],
  [6,7,0],[8,9,1],[7,8,1],[6,8,1],[8,7,0],[6,8,1],[9,8,1],[6,9,2],
  [8,8,1],[7,7,0],[9,9,2],[8,8,1],[7,8,1],[11,8,1],[13,9,1,3],[8,8,1],
  [8,8,1],[7,9,2,-1],[9,8,1],[7,8,1],[8,8,0],[8,8,1,1],[7,8,1],[11,8,1],
  [8,7,0],[8,9,2],[8,7,0],[7,7,1],[7,7,1],[7,7,1],[6,7,1],[6,7,1],
  [6,7,0],[6,7,0],[4,11,3,-1],[3,11,3],[4,11,3,-1],[3,11,3],[3,11,3,-1],[3,11,3,-1],
  [3,11,3,-1],[3,11,3],[1,11,3,-1],[3,11,3,-1],[3,11,3,-1],[6,11,3],[5,11,3],[3,7,1],
  [9,11,10],[7,7,0],[8,8,1],[5,11,3],[6,6,0],[6,6,0],[7,9,2],[7,9,2],
  [4,9,2],[4,9,2],[4,9,2],[6,9,2],[8,10,2],[8,10,2],[8,9,1],[8,10,2],
  [4,18,32,46,60,74,88,102,
  116,130,144,158,172,186,199,213],[13,33,53,73,93,113,133,152],[229,169]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmsy10:[[8,2,-2,-1],[2,2,-2,-1],[7,6,0,-1],[6,6,0],[9,8,1],[6,6,0],[9,8,0],[9,8,2],
  [9,8,1],[9,8,1],[9,8,1],[9,8,1],[9,8,1],[12,12,3],[6,6,0],[6,6,0],
  [9,6,0],[9,6,0],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],[8,10,2,-1],
  [9,4,-1],[9,6,0],[8,8,1,-1],[8,8,1,-1],[12,8,1],[12,8,1],[8,8,1,-1],[8,8,1,-1],
  [11,4,-1,-1],[11,4,-1],[4,11,3,-1],[4,11,2,-1],[10,4,-1,-1],[12,12,3],[12,12,3],[9,6,0],
  [11,8,1,-1],[11,8,1],[7,12,3],[7,12,3],[12,8,1],[12,12,3],[12,12,3],[9,7,1],
  [3,7,0],[12,7,1],[6,8,1,-1],[6,8,1,-1],[10,9,0],[10,9,3],[7,12,3,-1],[2,6,0],
  [7,10,1],[6,9,0],[8,4,-1],[6,11,1],[9,10,1],[9,10,1],[9,8,0],[9,8,0],
  [7,9,0],[10,10,1],[8,10,1],[7,10,1],[10,9,0],[7,10,1],[10,10,1],[8,11,2],
  [10,10,1],[9,9,0,1],[10,11,2],[9,10,1],[8,10,1],[14,10,1],[13,11,1,1],[10,10,1],
  [9,10,1],[9,11,2,-1],[10,10,1],[8,10,1],[10,9,0],[10,10,1,1],[8,10,1],[13,10,1],
  [10,9,0],[9,11,2],[9,9,0],[8,8,1],[8,9,1],[8,8,1],[8,8,1],[8,7,0],
  [7,9,0],[7,9,0],[3,12,3,-2],[4,12,3],[3,12,3,-2],[4,12,3],[4,12,3,-1],[4,12,3,-1],
  [3,12,3,-1],[4,12,3],[1,12,3,-1],[4,12,3,-1],[4,12,3,-1],[7,14,4],[6,12,3],[3,8,1],
  [10,13,12,-1],[9,9,0],[10,10,1],[6,12,3],[8,7,0],[8,8,0],[8,10,2,-1],[9,10,2],
  [5,12,3],[5,12,3],[5,12,3],[7,12,3],[9,11,2],[9,11,2],[9,10,1],[9,11,2],
  [5,22,39,56,73,90,107,124,
  141,157,174,191,208,225,242,259],[17,41,65,90,114,138,162,186],[278,206]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmsy10:[[9,1,-3,-1],[2,3,-2,-1],[7,7,0,-2],[5,7,0,-1],[10,9,1],[7,7,0],[10,10,0],[10,10,3],
  [11,11,2],[11,11,2],[11,11,2],[11,11,2],[11,11,2],[14,13,3],[7,7,0],[7,7,0],
  [10,7,0],[10,7,0],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],[9,11,2,-1],
  [11,5,-1],[10,7,0],[9,9,1,-1],[9,9,1,-1],[14,9,1],[14,9,1],[9,9,1,-1],[9,9,1,-1],
  [13,5,-1,-1],[13,5,-1],[5,13,3,-1],[5,13,3,-1],[12,5,-1,-1],[14,13,3],[14,13,3],[10,7,0],
  [13,9,1,-1],[13,9,1],[8,13,3],[8,13,3],[14,9,1],[14,13,3],[14,13,3],[10,8,1],
  [4,8,0],[14,8,1],[7,9,1,-1],[8,9,1,-1],[12,10,0],[12,10,3],[7,13,3,-2],[2,5,-1],
  [8,11,1],[7,10,0],[9,4,-1],[7,12,1],[10,11,1],[10,11,1],[9,10,0,-1],[10,10,0],
  [8,10,0],[11,11,1],[10,11,1],[8,11,1],[11,10,0],[8,11,1],[12,11,1],[9,12,2],
  [12,11,1],[10,10,0,1],[12,12,2],[11,11,1],[9,11,1],[16,11,1],[15,12,1,1],[11,11,1],
  [11,11,1],[10,12,2,-1],[12,11,1],[9,11,1],[11,10,0],[11,11,1,1],[10,11,1],[15,11,1],
  [12,10,0],[10,12,2],[11,10,0],[9,10,1],[9,10,1],[9,10,1],[8,10,1,-1],[9,10,1],
  [8,10,0],[8,10,0],[4,15,4,-2],[4,15,4],[4,15,4,-2],[4,15,4],[5,15,4,-1],[5,15,4,-1],
  [4,15,4,-1],[4,15,4],[2,15,4,-1],[5,15,4,-1],[5,15,4,-1],[8,15,4],[7,15,4],[4,11,2],
  [11,15,14,-1],[10,10,0],[11,11,1],[7,13,3],[9,9,0],[9,9,0],[9,11,2,-1],[9,11,2,-1],
  [5,13,3,-1],[6,13,3],[6,13,3],[8,13,3],[11,13,2],[10,14,3],[11,11,1],[11,13,2],
  [6,26,46,66,86,106,125,145,
  165,185,205,225,245,265,285,305],[20,48,77,105,134,162,190,219],[327,243]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmsy10:[[11,2,-3,-1],[3,3,-3,-1],[9,9,0,-2],[7,8,0,-1],[12,10,1,-1],[9,9,0],[12,12,0,-1],[12,12,3,-1],
  [12,12,2,-1],[12,12,2,-1],[12,12,2,-1],[12,12,2,-1],[12,12,2,-1],[15,17,4,-1],[7,7,-1,-1],[7,7,-1,-1],
  [12,9,0,-1],[12,8,0,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],[11,14,3,-1],
  [12,5,-2,-1],[12,8,-1,-1],[11,11,1,-1],[11,11,1,-1],[15,11,1,-1],[15,11,1,-1],[11,11,1,-1],[11,11,1,-1],
  [15,7,-1,-1],[15,7,-1,-1],[7,16,4,-1],[7,16,4,-1],[15,7,-1,-1],[15,16,4,-1],[15,16,4,-1],[12,8,0,-1],
  [15,10,1,-1],[15,10,1,-1],[10,16,4],[10,16,4],[17,10,1],[15,16,4,-1],[15,16,4,-1],[12,9,1,-1],
  [5,10,0],[15,9,1,-1],[9,11,1,-1],[9,11,1,-1],[13,13,0,-1],[13,13,4,-1],[9,17,4,-2],[1,7,-1,-1],
  [10,13,1],[8,12,0,-1],[10,5,-1,-1],[8,15,2],[12,14,1],[11,13,1,-1],[12,12,0,-1],[12,12,0,-1],
  [9,12,0,-1],[14,14,1],[12,13,1],[9,13,1],[13,12,0],[10,13,1],[14,13,1],[11,14,2],
  [14,13,1],[12,12,0,1],[15,14,2],[13,13,1],[11,13,1],[19,13,1],[18,15,1,1],[13,13,1,-1],
  [13,13,1],[12,15,3,-2],[14,13,1],[11,13,1],[14,13,0],[13,13,1,1],[12,13,1],[18,13,1],
  [14,12,0],[13,15,3],[13,12,0],[10,12,1,-1],[10,12,1,-1],[10,12,1,-1],[10,12,1,-1],[10,12,1,-1],
  [9,12,0,-1],[9,12,0,-1],[4,18,5,-3],[5,18,5],[5,18,5,-3],[5,18,5],[7,18,5,-1],[7,18,5,-1],
  [5,18,5,-1],[4,18,5,-1],[1,18,5,-2],[5,18,5,-2],[7,18,5,-1],[10,18,5],[7,18,5,-1],[3,12,2,-1],
  [14,18,17,-1],[12,12,0],[14,13,1],[7,17,4,-1],[10,11,0,-1],[10,11,0,-1],[11,14,3,-1],[11,14,3,-1],
  [6,16,4,-1],[6,16,4,-1],[6,16,4,-1],[9,16,4,-1],[13,16,3],[12,16,3,-1],[12,14,1,-1],[12,16,3,-1],
  [7,31,55,79,103,127,151,174,
  198,222,246,270,294,318,342,366],[23,57,91,125,159,193,227,261],[392,290]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmsy10:[[13,2,-4,-1],[3,2,-4,-1],[10,10,0,-3],[8,10,0,-1],[14,12,1,-1],[10,10,0],[14,14,0,-1],[14,14,4,-1],
  [14,14,2,-1],[14,14,2,-1],[14,14,2,-1],[14,14,2,-1],[14,14,2,-1],[18,20,5,-1],[8,8,-1,-1],[8,8,-1,-1],
  [14,10,0,-1],[14,10,0,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],[13,16,3,-1],
  [14,6,-2,-1],[14,9,-1,-1],[13,12,1,-1],[13,12,1,-1],[18,14,2,-1],[18,14,2,-1],[13,12,1,-1],[13,12,1,-1],
  [18,8,-1,-1],[18,8,-1,-1],[8,18,4,-1],[8,18,4,-1],[18,8,-1,-1],[18,18,4,-1],[18,18,4,-1],[14,10,0,-1],
  [18,12,1,-1],[18,12,1,-1],[12,18,4],[12,18,4],[19,12,1],[18,18,4,-1],[18,18,4,-1],[14,10,1,-1],
  [6,11,-1],[18,10,1,-1],[11,12,1,-1],[11,12,1,-1],[16,15,0,-1],[16,15,5,-1],[11,20,5,-2],[2,8,-1,-1],
  [11,15,1],[9,14,0,-1],[12,7,-1,-1],[9,18,2],[14,16,1,-1],[13,16,1,-1],[14,14,0,-1],[14,14,0,-1],
  [11,14,0,-1],[16,16,1],[14,16,1],[11,15,1],[16,14,0],[12,16,1],[17,15,1],[12,18,3],
  [17,15,1],[14,14,0,1],[16,17,3,-1],[15,16,1],[13,16,1],[23,15,1],[21,17,1,1],[15,15,1,-1],
  [15,15,1],[14,18,3,-2],[17,15,1],[13,16,1],[16,15,0],[15,15,1,1],[14,15,1],[21,15,1],
  [16,14,0,-1],[15,17,3],[16,14,0],[12,13,1,-1],[12,13,1,-1],[12,13,1,-1],[11,13,1,-1],[12,13,1,-1],
  [10,14,0,-1],[11,14,0,-1],[6,20,5,-3],[6,20,5],[6,20,5,-3],[6,20,5],[8,20,5,-1],[8,20,5,-1],
  [5,20,5,-2],[5,20,5,-1],[2,20,5,-2],[6,20,5,-2],[8,22,6,-1],[12,22,6],[8,20,5,-1],[4,14,2,-1],
  [16,21,20,-1],[15,14,0],[15,15,1,-1],[9,20,5,-1],[12,12,0,-1],[12,12,0,-1],[14,16,3,-1],[13,16,3,-1],
  [7,20,5,-1],[7,19,5,-1],[7,18,4,-1],[11,18,4,-1],[15,18,3],[14,19,4,-1],[14,16,1,-1],[14,18,3,-1],
  [8,37,66,95,123,152,181,209,
  238,267,295,324,353,382,410,439],[27,68,109,150,191,232,273,314],[471,348]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmsy10:[[15,2,-5,-2],[3,4,-4,-2],[12,12,0,-3],[10,11,0,-1],[17,14,1,-1],[12,12,0],[17,16,0,-1],[17,16,4,-1],
  [17,16,2,-1],[17,16,2,-1],[17,16,2,-1],[17,16,2,-1],[17,16,2,-1],[22,24,6,-1],[10,10,-1,-1],[10,10,-1,-1],
  [17,12,0,-1],[17,12,0,-1],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],[15,20,4,-2],
  [17,6,-3,-1],[17,11,-1,-1],[15,14,1,-2],[15,14,1,-2],[22,16,2,-1],[22,16,2,-1],[15,14,1,-2],[15,14,1,-2],
  [22,10,-1,-1],[22,10,-1,-1],[10,22,5,-1],[10,22,5,-1],[22,10,-1,-1],[22,22,5,-1],[22,22,5,-1],[17,12,0,-1],
  [22,14,1,-1],[22,14,1,-1],[14,22,5],[14,22,5],[22,14,1,-1],[22,22,5,-1],[22,22,5,-1],[17,12,1,-1],
  [7,13,-1],[22,12,1,-1],[12,14,1,-2],[12,14,1,-2],[19,18,0,-1],[19,18,6,-1],[13,24,6,-3],[2,10,-1,-1],
  [14,18,1],[11,17,0,-1],[14,7,-2,-1],[10,21,2,-1],[16,19,1,-1],[16,18,1,-1],[17,16,0,-1],[17,16,0,-1],
  [13,17,0,-1],[19,20,2],[16,18,1],[13,18,1],[19,17,0],[14,18,1],[20,18,1],[14,20,3,-1],
  [20,19,2],[17,17,0,1],[19,20,3,-1],[18,18,1],[16,18,1],[27,19,2],[25,21,2,1],[18,18,1,-1],
  [18,19,2],[17,20,3,-2],[20,18,1],[16,18,1],[19,18,0],[18,18,1,1],[15,18,1,-1],[24,18,1,-1],
  [19,17,0,-1],[18,21,4],[18,17,0,-1],[14,16,1,-1],[14,16,1,-1],[14,16,1,-1],[14,16,1,-1],[14,16,1,-1],
  [13,17,0,-1],[13,17,0,-1],[6,24,6,-4],[7,24,6],[6,24,6,-4],[7,24,6],[9,24,6,-2],[9,24,6,-1],
  [6,24,6,-2],[6,24,6,-1],[2,24,6,-2],[6,24,6,-3],[10,26,7,-1],[14,26,7],[10,24,6,-1],[5,16,2,-1],
  [20,24,23,-1],[17,17,0],[18,18,1,-1],[11,24,6,-1],[14,15,0,-1],[14,15,0,-1],[16,20,4,-2],[16,20,4,-1],
  [8,22,5,-1],[9,23,6,-1],[9,22,5,-1],[13,22,5,-1],[18,22,4],[17,22,4,-1],[17,19,1,-1],[17,22,4,-1],
  [10,45,79,114,148,183,217,252,
  286,321,355,390,424,459,493,528],[34,83,132,181,230,279,329,378],[565,419]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmsy10:[[19,2,-6,-2],[4,4,-5,-2],[15,15,0,-4],[11,13,-1,-2],[20,17,1,-1],[15,15,0],[20,20,0,-1],[20,20,5,-1],
  [20,20,3,-1],[20,20,3,-1],[20,20,3,-1],[20,20,3,-1],[20,20,3,-1],[27,28,7,-1],[12,12,-1,-1],[12,12,-1,-1],
  [20,14,0,-1],[20,13,-1,-1],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],[19,23,4,-2],
  [20,8,-3,-1],[20,13,-1,-1],[19,18,2,-2],[19,18,2,-2],[27,19,2,-1],[27,19,2,-1],[19,18,2,-2],[18,17,1,-2],
  [27,11,-2,-1],[27,11,-2,-1],[11,26,6,-2],[11,26,6,-2],[27,11,-2,-1],[27,27,6,-1],[27,26,6,-1],[20,13,-1,-1],
  [27,17,1,-1],[27,17,1,-1],[17,26,6],[17,27,6],[27,17,1,-1],[27,27,6,-1],[27,26,6,-1],[20,14,1,-1],
  [7,16,-1,-1],[27,14,1,-1],[15,18,2,-2],[15,18,2,-2],[23,21,0,-1],[23,22,7,-1],[15,28,7,-4],[3,12,-1,-1],
  [17,22,1],[14,21,0,-1],[17,9,-2,-1],[13,26,3,-1],[20,22,1,-1],[19,22,1,-1],[20,20,0,-1],[20,20,0,-1],
  [15,20,0,-1],[23,23,2],[19,22,1,-1],[16,22,1],[23,20,0],[17,22,1],[24,21,1],[17,25,4,-1],
  [24,22,2],[20,20,0,1],[24,24,4,-1],[21,22,1,-1],[18,22,1,-1],[33,23,2],[30,25,2,1],[22,22,1,-1],
  [22,22,2],[20,25,4,-3],[25,21,1],[19,22,1],[23,21,0],[21,21,1,1],[19,22,2,-1],[29,22,2,-1],
  [23,20,0,-1],[21,24,4],[22,20,0,-1],[17,19,1,-1],[17,19,1,-1],[17,19,1,-1],[17,19,1,-1],[17,19,1,-1],
  [15,20,0,-1],[16,21,0,-1],[8,30,8,-5],[8,30,8],[8,30,8,-5],[8,30,8],[11,30,8,-2],[11,30,8,-2],
  [7,30,8,-3],[7,30,8,-1],[2,30,8,-3],[8,30,8,-3],[11,31,8,-2],[17,31,8],[12,30,8,-1],[6,20,3,-1],
  [23,30,28,-2],[20,20,0,-1],[22,21,1,-1],[13,28,7,-1],[17,18,0,-1],[17,18,0,-1],[19,23,4,-2],[20,23,4,-1],
  [9,27,6,-2],[11,28,7,-1],[11,27,6,-1],[16,27,6,-1],[22,25,4],[20,26,5,-1],[20,22,1,-1],[20,25,4,-1],
  [12,53,95,136,177,218,260,301,
  342,384,425,466,507,549,590,631],[39,98,157,216,274,333,392,451],[676,500]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmsy10:[[22,3,-7,-2],[4,5,-6,-3],[17,17,0,-5],[13,15,-1,-2],[23,19,1,-2],[17,17,0],[23,23,0,-2],[23,23,6,-2],
  [24,23,3,-1],[24,23,3,-1],[24,23,3,-1],[24,23,3,-1],[24,23,3,-1],[31,33,8,-1],[14,15,-1,-1],[14,15,-1,-1],
  [23,17,0,-2],[23,15,-1,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],[22,27,5,-2],
  [24,9,-4,-1],[23,16,-1,-2],[22,21,2,-2],[22,21,2,-2],[30,23,3,-2],[30,23,3,-2],[22,21,2,-2],[22,21,2,-2],
  [30,13,-2,-2],[30,13,-2,-2],[13,31,7,-2],[13,31,7,-2],[30,13,-2,-2],[31,31,7,-2],[31,31,7,-2],[24,15,-1,-1],
  [30,19,1,-2],[30,19,1,-2],[19,31,7,-1],[19,31,7,-1],[32,19,1,-1],[31,31,7,-1],[31,31,7,-1],[24,16,1,-1],
  [8,18,-1,-1],[31,16,1,-1],[18,21,2,-2],[18,21,2,-2],[27,25,0,-2],[27,25,8,-2],[18,33,8,-4],[4,13,-2,-1],
  [19,25,1],[15,24,0,-2],[19,10,-3,-2],[15,30,3,-1],[24,26,1,-1],[23,25,1,-1],[23,23,0,-2],[23,23,0,-2],
  [18,24,0,-1],[26,27,2,-1],[22,25,1,-1],[19,25,1],[26,24,0],[19,25,1,-1],[29,26,2],[20,28,4,-1],
  [28,26,2],[23,24,0,1],[28,28,4,-1],[24,25,1,-1],[22,25,1,-1],[37,26,2,-1],[35,29,2,1],[25,25,1,-2],
  [25,26,2],[24,29,5,-3],[29,25,1],[22,25,1],[26,25,0,-1],[25,25,1,1],[22,26,2,-1],[35,26,2,-1],
  [27,24,0,-1],[24,29,5,-1],[25,24,0,-1],[20,22,1,-1],[20,22,1,-1],[20,22,1,-1],[19,22,1,-2],[19,22,1,-2],
  [18,24,0,-1],[17,24,0,-2],[10,35,9,-5],[10,35,9],[10,35,9,-5],[10,35,9],[13,35,9,-2],[13,35,9,-2],
  [9,35,9,-3],[8,35,9,-2],[2,35,9,-4],[9,35,9,-4],[13,37,10,-2],[19,37,10,-1],[13,35,9,-2],[7,23,3,-1],
  [27,35,33,-2],[24,24,0,-1],[26,26,2,-1],[15,33,8,-1],[19,21,0,-2],[19,21,0,-2],[22,27,5,-3],[22,27,5,-2],
  [11,31,7,-2],[12,32,8,-2],[12,31,7,-2],[19,31,7,-1],[25,30,5,-1],[23,31,6,-2],[24,27,2,-1],[24,30,5,-1],
  [14,64,114,163,213,263,312,362,
  412,461,511,561,610,660,710,759],[48,119,190,260,331,402,472,543],[814,603]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmsy10:[[26,3,-9,-3],[5,5,-8,-3],[20,20,0,-6],[16,18,-1,-2],[28,24,2,-2],[20,20,0],[28,28,0,-2],[28,28,7,-2],
  [28,28,4,-2],[28,28,4,-2],[28,28,4,-2],[28,28,4,-2],[28,28,4,-2],[37,39,9,-2],[17,17,-2,-2],[17,17,-2,-2],
  [28,20,0,-2],[28,18,-1,-2],[26,33,6,-3],[26,33,6,-3],[26,32,6,-3],[26,32,6,-3],[26,32,6,-3],[26,32,6,-3],
  [28,10,-5,-2],[28,18,-2,-2],[26,25,2,-3],[26,25,2,-3],[37,27,3,-2],[37,27,3,-2],[26,24,2,-3],[26,24,2,-3],
  [37,15,-3,-2],[37,15,-3,-2],[15,37,8,-3],[15,37,8,-3],[37,15,-3,-2],[37,37,8,-2],[37,37,8,-2],[28,18,-1,-2],
  [37,23,1,-2],[37,23,1,-2],[23,37,8,-1],[23,37,8,-1],[39,23,1,-1],[37,37,8,-2],[37,37,8,-2],[28,20,1,-2],
  [10,22,-1,-1],[37,20,1,-2],[21,25,2,-3],[21,25,2,-3],[32,30,0,-2],[32,30,9,-2],[22,39,9,-5],[3,16,-2,-2],
  [23,30,1],[19,29,0,-2],[23,12,-3,-2],[18,36,4,-1],[28,31,1,-2],[27,30,1,-2],[28,28,0,-2],[28,28,0,-2],
  [21,29,0,-2],[32,32,2,-1],[27,30,1,-1],[22,30,1],[32,28,0],[23,30,1,-1],[34,30,2],[24,34,5,-1],
  [34,30,2],[27,28,0,1],[34,33,5,-1],[29,30,1,-1],[26,30,1,-1],[45,31,2,-1],[42,34,2,2],[30,30,1,-2],
  [30,30,2],[29,35,6,-4],[35,29,1],[27,30,1],[32,30,0,-1],[30,30,2,1],[26,30,2,-1],[42,30,2,-1],
  [32,28,0,-2],[29,34,6,-1],[31,28,0,-1],[23,26,1,-2],[23,26,1,-2],[23,26,1,-2],[23,26,1,-2],[23,26,1,-2],
  [21,29,0,-2],[21,29,0,-2],[11,42,11,-7],[11,42,11],[11,42,11,-7],[10,42,11,-1],[15,42,11,-3],[15,42,11,-3],
  [10,42,11,-4],[10,42,11,-2],[3,42,11,-4],[10,42,11,-5],[15,44,12,-3],[23,44,12,-1],[17,42,11,-2],[7,28,4,-2],
  [32,42,40,-3],[29,28,0,-1],[31,30,2,-2],[18,39,9,-2],[23,25,0,-2],[23,25,0,-2],[27,33,6,-3],[27,33,6,-2],
  [14,38,9,-2],[14,38,9,-2],[14,38,9,-2],[22,37,8,-2],[30,36,6,-1],[28,37,7,-2],[28,32,2,-2],[28,36,6,-2],
  [17,77,136,196,255,314,374,433,
  493,552,612,671,730,790,849,909],[58,142,227,311,396,481,565,650],[974,721]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmsy10:[[30,3,-11,-4],[6,6,-9,-4],[24,24,0,-7],[19,22,-1,-3],[34,28,2,-2],[24,24,0],[34,33,0,-2],[34,34,9,-2],
  [34,33,4,-2],[34,33,4,-2],[34,33,4,-2],[34,33,4,-2],[34,33,4,-2],[45,47,11,-2],[20,20,-2,-2],[20,20,-2,-2],
  [34,24,0,-2],[34,22,-1,-2],[30,39,7,-4],[30,39,7,-4],[30,38,7,-4],[30,39,7,-4],[30,38,7,-4],[30,39,7,-4],
  [34,12,-6,-2],[34,22,-2,-2],[30,29,2,-4],[30,29,2,-4],[45,32,4,-2],[45,32,4,-2],[30,29,2,-4],[30,29,2,-4],
  [45,18,-3,-2],[45,18,-3,-2],[18,44,10,-3],[18,44,10,-3],[45,18,-3,-2],[45,45,10,-2],[45,44,10,-2],[34,22,-1,-2],
  [45,28,2,-2],[45,28,2,-2],[28,44,10,-1],[28,44,10,-1],[47,28,2,-1],[45,45,10,-2],[45,44,10,-2],[34,23,1,-2],
  [12,26,-2,-1],[45,23,1,-2],[25,29,2,-4],[25,29,2,-4],[38,35,0,-3],[39,36,11,-2],[26,46,11,-6],[4,19,-3,-2],
  [28,35,1],[23,34,0,-2],[28,14,-4,-2],[21,42,4,-2],[33,38,2,-2],[32,36,1,-2],[34,33,0,-2],[34,33,0,-2],
  [26,34,0,-2],[38,39,3,-1],[32,37,2,-1],[27,37,2],[37,34,0,-1],[27,37,2,-1],[41,36,2],[28,41,6,-2],
  [39,37,3,-1],[33,34,0,2],[39,40,6,-2],[35,37,2,-1],[31,37,2,-1],[54,38,3,-1],[50,41,3,2],[37,37,2,-2],
  [35,37,3,-1],[34,42,7,-5],[40,36,2,-1],[32,37,2],[38,36,0,-1],[35,36,2,1],[32,37,3,-1],[50,37,3,-1],
  [38,34,0,-2],[35,41,7,-1],[37,34,0,-1],[28,32,2,-2],[28,31,1,-2],[28,32,2,-2],[28,31,1,-2],[28,31,1,-2],
  [25,34,0,-2],[26,34,0,-2],[13,50,13,-8],[13,50,13,-1],[13,50,13,-8],[13,50,13,-1],[18,50,13,-3],[18,50,13,-3],
  [12,50,13,-5],[12,50,13,-2],[3,50,13,-5],[12,50,13,-6],[18,52,14,-3],[28,52,14,-1],[20,50,13,-2],[9,33,4,-2],
  [39,49,47,-3],[34,34,0,-1],[37,36,2,-2],[21,46,11,-2],[27,30,0,-3],[27,30,0,-3],[31,39,7,-4],[31,39,7,-3],
  [16,45,10,-3],[17,46,11,-2],[17,45,10,-2],[27,44,10,-2],[36,43,7,-1],[34,44,8,-2],[34,38,2,-2],[34,43,7,-2],
  [21,92,164,235,306,378,449,521,
  592,663,735,806,878,949,1020,1092],[68,170,271,373,475,576,678,780],[1170,865]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmsy10:[[36,3,-13,-5],[7,7,-11,-5],[30,29,0,-8],[23,26,-2,-3],[40,34,2,-3],[29,29,0],[40,40,0,-3],[40,40,10,-3],
  [40,40,5,-3],[40,40,5,-3],[40,40,5,-3],[40,40,5,-3],[40,40,5,-3],[53,56,13,-3],[24,24,-3,-3],[24,24,-3,-3],
  [40,28,-1,-3],[40,26,-2,-3],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],[37,47,9,-4],
  [40,15,-7,-3],[40,26,-3,-3],[37,35,3,-4],[37,35,3,-4],[53,38,4,-3],[53,38,4,-3],[37,35,3,-4],[37,35,3,-4],
  [53,22,-4,-3],[53,22,-4,-3],[22,53,12,-4],[22,53,12,-4],[53,22,-4,-3],[53,53,12,-3],[53,53,12,-3],[40,26,-2,-3],
  [53,33,2,-3],[53,33,2,-3],[34,53,12,-1],[34,53,12,-1],[55,33,2,-2],[53,54,12,-3],[53,53,12,-3],[40,28,1,-3],
  [15,31,-2,-1],[53,28,1,-3],[31,35,3,-4],[31,35,3,-4],[46,43,0,-3],[46,43,13,-3],[30,56,13,-8],[5,23,-3,-3],
  [33,43,2],[27,41,0,-3],[33,16,-5,-3],[25,51,5,-2],[40,45,2,-2],[38,43,1,-3],[40,40,0,-3],[40,40,0,-3],
  [30,41,0,-3],[46,46,3,-1],[39,44,2,-1],[32,44,2],[45,41,0,-1],[33,44,2,-1],[48,43,2,-1],[34,49,7,-2],
  [48,44,3,-1],[40,41,0,2],[48,48,7,-2],[43,44,2,-1],[38,44,2,-1],[65,45,3,-1],[60,49,3,2],[43,44,2,-3],
  [43,44,3,-1],[41,50,8,-6],[49,43,2,-1],[37,44,2,-1],[46,43,0,-1],[42,43,2,1],[37,44,3,-2],[60,44,3,-2],
  [45,41,0,-3],[42,49,8,-1],[44,41,0,-2],[33,38,2,-3],[33,38,2,-3],[33,38,2,-3],[33,38,2,-3],[33,38,2,-3],
  [30,41,0,-3],[30,41,0,-3],[15,60,15,-10],[15,60,15,-1],[15,60,15,-10],[15,60,15,-1],[22,60,15,-4],[22,60,15,-4],
  [14,60,15,-6],[14,60,15,-3],[3,60,15,-7],[15,60,15,-7],[22,62,16,-4],[34,62,16,-1],[24,60,15,-3],[10,40,5,-3],
  [47,60,57,-4],[40,41,0,-2],[45,43,2,-2],[25,56,13,-3],[33,36,0,-3],[33,36,0,-3],[38,47,9,-5],[38,47,9,-3],
  [18,55,13,-4],[20,55,13,-3],[20,54,12,-3],[32,53,12,-3],[44,51,8,-1],[40,53,10,-3],[40,45,2,-3],[40,51,8,-3],
  [25,111,196,282,368,454,539,625,
  711,797,882,968,1054,1140,1225,1311],[82,204,326,448,570,692,814,936],[1404,1039]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{cmti10:[[5,5,0],[6,5,0],[5,6,1,-1],[5,5,0],[6,5,0],[6,5,0],[6,5,0],[5,5,0,-1],
  [5,5,0,-1],[5,5,0,-1],[6,5,0],[6,7,2],[5,7,2],[5,7,2],[7,7,2],[9,7,2,2],
  [3,3,0],[4,5,2,1],[1,2,-3,-2],[2,2,-3,-2],[2,2,-3,-2],[2,2,-3,-2],[2,2,-3,-2],[2,2,-3,-3],
  [2,2,2,-1],[4,7,2],[5,3,0],[5,3,0],[4,5,1],[7,5,0],[6,6,1,-1],[8,6,1,2],
  [3,1,-2],[3,5,0],[3,2,-3,-1],[5,7,2,-1],[5,5,0],[5,7,1,-1],[6,6,1],[2,2,-3,-1],
  [3,7,2,-1],[3,7,2],[3,3,-2,-1],[5,5,1,-1],[2,3,2],[3,1,-1],[2,1,0],[5,8,2],
  [4,6,1],[3,5,0,-1],[4,6,1],[4,6,1],[4,7,2],[4,6,1],[4,6,1],[4,5,0,-1],
  [4,6,1],[4,6,1],[2,3,0],[2,5,2],[3,6,2],[5,3,0,-1],[3,6,2],[3,5,0,-1],
  [5,5,0,-1],[5,5,0],[6,5,0],[5,6,1,-1],[6,5,0],[6,5,0],[6,5,0],[5,6,1,-1],
  [6,5,0],[4,5,0],[5,6,1],[6,5,0],[5,5,0],[7,5,0],[6,5,0],[5,6,1,-1],
  [5,5,0],[5,7,2,-1],[5,6,1],[5,6,1],[5,5,0,-1],[5,6,1,-1],[5,5,0,-1],[7,5,0,-1],
  [8,5,0,2],[5,5,0,-1],[5,5,0],[3,8,2],[2,3,-2,-2],[3,8,2],[2,1,-4,-2],[2,1,-4,-1],
  [2,3,-2,-1],[4,3,0],[4,5,0],[4,3,0],[4,5,0],[4,3,0],[4,7,2],[4,5,2],
  [4,5,0],[3,5,0],[4,7,2,1],[4,5,0],[2,5,0],[6,3,0],[4,3,0],[4,3,0],
  [4,5,2],[4,5,2],[4,3,0],[3,3,0],[3,5,0],[4,3,0],[4,3,0],[5,3,0],
  [4,3,0],[4,5,2],[3,3,0],[3,1,-1,-1],[6,1,-1,-1],[6,4,-1,2],[2,1,-4,-2],[2,1,-4,-2],
  [3,11,20,28,37,45,54,62,
  71,79,88,96,105,113,122,130],[9,17,26,34,42,51,59,67],[140,73]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{cmti10:[[6,6,0],[6,6,0],[6,7,1,-1],[5,6,0],[6,6,0],[7,6,0],[7,6,0],[6,6,0,-1],
  [5,6,0,-1],[6,6,0,-1],[6,6,0],[7,8,2,1],[6,8,2,1],[6,8,2,1],[9,8,2,1],[9,8,2,1],
  [3,4,0],[4,6,2,1],[2,2,-4,-2],[3,2,-4,-2],[3,1,-4,-2],[3,2,-4,-2],[3,1,-4,-2],[3,2,-4,-3],
  [2,2,2,-1],[6,8,2,1],[6,4,0],[6,4,0],[4,5,1],[8,6,0],[8,7,1,-1],[9,7,1,2],
  [3,1,-2],[2,6,0,-1],[3,3,-3,-1],[6,8,2,-1],[6,6,0],[6,7,1,-1],[6,7,1,-1],[1,3,-3,-2],
  [3,8,2,-1],[3,8,2],[4,4,-2,-1],[5,6,1,-1],[2,3,2],[3,1,-1],[1,1,0,-1],[5,8,2],
  [4,7,1,-1],[3,6,0,-1],[5,7,1],[5,7,1],[4,8,2],[5,7,1],[4,7,1,-1],[4,7,1,-1],
  [5,7,1],[5,7,1],[2,4,0,-1],[3,6,2],[3,6,2],[6,2,-1,-1],[4,6,2],[4,6,0,-1],
  [6,7,1,-1],[6,6,0],[6,6,0],[6,7,1,-1],[7,6,0],[6,6,0],[6,6,0],[6,7,1,-1],
  [7,6,0],[4,6,0],[5,7,1],[7,6,0],[5,6,0],[8,6,0],[7,6,0],[6,7,1,-1],
  [6,6,0],[6,8,2,-1],[6,7,1],[5,7,1],[6,6,0,-1],[6,7,1,-1],[6,6,0,-1],[8,6,0,-1],
  [9,6,0,2],[6,6,0,-1],[6,6,0],[4,8,2],[3,3,-3,-2],[3,8,2],[2,2,-4,-2],[1,2,-4,-2],
  [2,3,-3,-1],[5,4,0],[3,6,0,-1],[4,4,0],[5,6,0],[4,4,0],[5,8,2,1],[4,6,2],
  [5,6,0],[3,6,0],[4,8,2,1],[4,6,0],[3,6,0],[7,4,0],[5,4,0],[4,4,0],
  [4,6,2],[4,6,2],[4,4,0],[4,5,1],[3,5,0],[5,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-2,-1],[7,1,-2,-1],[3,2,-4,-2],[3,2,-4,-2],[3,2,-4,-2],
  [3,14,24,34,44,54,64,75,
  85,95,105,115,126,136,146,156],[11,21,31,41,51,61,71,81],[168,87]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{cmti10:[[7,7,0],[8,7,0],[7,8,1,-1],[7,7,0],[8,7,0],[9,7,0],[7,7,0,-1],[7,7,0,-2],
  [7,7,0,-1],[6,7,0,-2],[7,7,0,-1],[9,9,2,1],[7,9,2,1],[8,9,2,1],[11,9,2,1],[11,9,2,1],
  [3,5,0,-1],[5,7,2,1],[2,2,-5,-3],[3,2,-5,-3],[3,2,-5,-3],[4,2,-5,-2],[4,1,-5,-2],[3,3,-5,-4],
  [3,2,2,-1],[7,9,2,1],[7,6,1,-1],[7,6,1,-1],[6,7,1],[10,7,0],[10,8,1,-1],[10,9,1,2],
  [3,2,-2,-1],[3,8,0,-1],[4,3,-4,-2],[8,9,2,-1],[6,8,1,-1],[8,9,1,-1],[7,9,1,-1],[2,3,-4,-2],
  [4,10,2,-1],[4,10,2],[4,5,-3,-2],[7,7,1,-1],[3,3,2],[3,2,-1,-1],[2,1,0,-1],[6,10,2],
  [5,8,1,-1],[4,7,0,-1],[5,8,1,-1],[5,8,1,-1],[5,9,2],[5,8,1,-1],[5,8,1,-1],[6,8,1,-1],
  [5,10,1,-1],[6,10,1],[2,5,0,-1],[3,7,2],[4,7,2],[7,3,-1,-1],[5,7,2],[6,9,0],
  [7,8,1,-1],[7,7,0],[8,7,0],[7,8,1,-1],[8,7,0],[8,7,0],[8,7,0],[7,8,1,-1],
  [9,7,0],[5,7,0],[6,8,1,-1],[9,7,0],[7,7,0],[10,7,0],[9,7,0],[7,8,1,-1],
  [8,7,0],[7,9,2,-1],[8,8,1],[7,8,1],[7,7,0,-1],[7,8,1,-2],[7,8,1,-2],[9,8,1,-2],
  [11,7,0,2],[7,7,0,-2],[7,7,0],[5,10,2],[4,3,-4,-2],[3,10,2,-1],[4,2,-5,-2],[2,2,-5,-2],
  [2,3,-4,-2],[5,6,1,-1],[4,8,1,-1],[4,6,1,-1],[5,8,1,-1],[4,6,1,-1],[6,9,2,1],[5,7,2],
  [6,7,0],[3,7,0,-1],[5,9,2,1],[5,9,0],[2,7,0,-1],[9,9,0],[5,5,0,-1],[4,6,1,-1],
  [5,7,2],[4,7,2,-1],[4,5,0,-1],[5,5,0],[3,7,0,-1],[5,6,1,-1],[4,6,1,-1],[6,6,1,-1],
  [6,6,1],[4,7,2,-1],[5,5,0],[5,1,-2,-1],[10,1,-2,-1],[8,5,-2,2],[4,2,-5,-2],[4,2,-5,-2],
  [4,16,28,40,51,63,75,87,
  99,111,123,135,146,158,170,182],[13,24,36,47,59,71,82,94],[195,102]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{cmti10:[[9,9,0],[8,9,0,-1],[9,10,1,-1],[8,9,0],[8,9,0,-1],[10,9,0],[9,9,0,-1],[8,9,0,-2],
  [8,9,0,-1],[8,9,0,-2],[8,9,0,-1],[10,12,3,1],[9,12,3,1],[9,12,3,1],[12,12,3,1],[13,12,3,1],
  [3,7,1,-1],[5,9,3,1],[3,3,-6,-3],[3,3,-6,-4],[4,2,-6,-3],[4,3,-6,-3],[4,2,-6,-3],[3,3,-6,-5],
  [3,3,3,-1],[8,12,3,1],[8,7,1,-1],[8,7,1,-1],[6,8,1,-1],[12,9,0],[10,10,1,-2],[13,10,1,3],
  [3,2,-3,-1],[4,9,0,-1],[5,5,-4,-2],[9,12,3,-1],[8,10,1,-1],[9,10,1,-1],[9,10,1,-1],[3,5,-4,-2],
  [5,12,3,-1],[5,12,3],[5,5,-4,-2],[8,8,1,-1],[2,5,3,-1],[3,1,-2,-1],[2,2,0,-1],[8,12,3],
  [6,9,1,-1],[5,8,0,-1],[6,9,1,-1],[6,9,1,-1],[6,11,3],[6,9,1,-1],[6,9,1,-1],[7,9,1,-1],
  [6,9,1,-1],[6,9,1,-1],[3,6,0,-1],[3,9,3,-1],[4,9,3],[9,4,-1,-1],[5,9,3,-1],[5,9,0,-2],
  [9,10,1,-1],[9,9,0],[9,9,0],[9,10,1,-1],[10,9,0],[9,9,0],[9,9,0],[9,10,1,-1],
  [10,9,0],[6,9,0],[7,10,1,-1],[10,9,0],[8,9,0],[12,9,0],[10,9,0],[9,10,1,-1],
  [9,9,0],[9,12,3,-1],[9,10,1],[7,10,1,-1],[8,9,0,-2],[8,10,1,-2],[9,10,1,-2],[10,10,1,-2],
  [13,9,0,3],[9,9,0,-2],[8,9,0,-1],[5,12,3,-1],[5,5,-4,-3],[6,12,3,1],[4,3,-6,-3],[2,2,-6,-3],
  [3,5,-4,-2],[6,7,1,-1],[5,10,1,-1],[5,7,1,-1],[6,10,1,-1],[5,7,1,-1],[7,12,3,1],[6,9,3],
  [6,9,0,-1],[3,9,1,-1],[6,11,3,1],[5,10,1,-1],[3,9,0,-1],[9,7,1,-1],[6,7,1,-1],[6,7,1,-1],
  [7,9,3],[5,9,3,-1],[5,6,0,-1],[4,7,1,-1],[4,9,1,-1],[6,7,1,-1],[5,7,1,-1],[8,7,1,-1],
  [7,7,1],[6,9,3,-1],[6,7,1],[6,1,-3,-1],[11,1,-3,-1],[10,6,-3,3],[4,2,-6,-3],[4,2,-6,-3],
  [5,19,34,48,62,77,91,106,
  120,135,149,163,178,192,207,221],[16,30,45,59,73,87,101,115],[237,125]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{cmti10:[[9,10,0,-1],[10,10,0,-1],[9,11,1,-2],[9,10,0],[10,10,0,-1],[11,10,0,-1],[10,10,0,-1],[9,10,0,-3],
  [9,10,0,-2],[9,10,0,-3],[10,10,0,-1],[12,13,3,1],[10,13,3,1],[10,13,3,1],[14,13,3,1],[15,13,3,1],
  [4,8,1,-1],[6,10,3,1],[2,3,-7,-4],[4,3,-7,-4],[4,2,-7,-4],[4,3,-7,-4],[5,2,-7,-3],[4,3,-7,-6],
  [4,3,3,-1],[9,13,3,1],[9,8,1,-1],[9,8,1,-1],[7,10,2,-1],[13,10,0,-1],[13,11,1,-2],[15,12,1,3],
  [4,2,-4,-1],[5,10,0,-1],[6,5,-5,-2],[11,13,3,-1],[9,11,1,-1],[10,12,1,-2],[11,11,1,-1],[3,5,-5,-3],
  [6,15,4,-2],[6,15,4],[6,7,-4,-2],[9,9,1,-2],[3,5,3,-1],[4,2,-2,-1],[2,2,0,-1],[9,15,4],
  [7,11,1,-1],[6,10,0,-1],[7,11,1,-1],[7,11,1,-1],[7,13,3],[7,11,1,-1],[7,11,1,-1],[7,11,1,-2],
  [7,11,1,-1],[7,11,1,-1],[4,6,0,-1],[4,9,3,-1],[5,10,3],[10,5,-1,-1],[6,10,3,-1],[6,10,0,-2],
  [9,11,1,-2],[9,10,0,-1],[10,10,0,-1],[10,11,1,-2],[10,10,0,-1],[10,10,0,-1],[10,10,0,-1],[10,11,1,-2],
  [11,10,0,-1],[7,10,0],[8,11,1,-1],[11,10,0,-1],[8,10,0,-1],[13,10,0,-1],[11,10,0,-1],[9,11,1,-2],
  [10,10,0,-1],[9,13,3,-2],[9,11,1,-1],[8,11,1,-1],[10,10,0,-2],[10,11,1,-2],[9,11,1,-3],[12,11,1,-3],
  [15,10,0,3],[10,10,0,-3],[9,10,0,-1],[6,15,4,-1],[6,5,-5,-3],[6,15,4,1],[5,3,-7,-3],[2,2,-8,-3],
  [3,5,-5,-2],[7,8,1,-1],[6,11,1,-1],[6,8,1,-1],[7,11,1,-1],[6,8,1,-1],[8,13,3,1],[7,10,3],
  [7,11,1,-1],[4,11,1,-1],[6,13,3,1],[6,11,1,-1],[4,11,1,-1],[11,8,1,-1],[8,8,1,-1],[7,8,1,-1],
  [8,10,3],[6,10,3,-1],[6,8,1,-1],[5,8,1,-1],[5,10,1,-1],[7,8,1,-1],[6,8,1,-1],[9,8,1,-1],
  [8,8,1],[7,10,3,-1],[6,8,1,-1],[7,1,-3,-1],[14,1,-3,-1],[11,7,-3,3],[5,2,-8,-3],[5,2,-8,-3],
  [6,23,40,56,73,90,107,124,
  141,158,175,192,209,226,243,260],[19,36,52,69,85,102,119,135],[279,146]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{cmti10:[[11,12,0,-1],[12,12,0,-1],[12,13,1,-2],[10,13,0,-1],[12,12,0,-1],[14,12,0,-1],[13,12,0,-1],[12,12,0,-3],
  [11,12,0,-2],[11,12,0,-3],[12,12,0,-1],[14,16,4,1],[12,16,4,1],[12,16,4,1],[17,16,4,1],[17,16,4,1],
  [5,9,1,-1],[7,12,4,1],[3,4,-8,-5],[5,4,-8,-5],[5,3,-8,-4],[6,4,-8,-4],[6,1,-9,-4],[4,4,-9,-8],
  [5,4,4,-1],[11,16,4,1],[12,9,1,-1],[12,9,1,-1],[9,11,2,-1],[15,12,0,-1],[16,13,1,-2],[17,14,1,3],
  [5,3,-4,-1],[5,13,0,-2],[6,6,-6,-3],[12,16,4,-2],[11,13,1,-1],[13,14,1,-2],[12,14,1,-2],[4,6,-6,-3],
  [7,17,4,-2],[7,17,4],[7,8,-5,-3],[11,11,1,-2],[3,6,4,-1],[5,2,-3,-1],[2,2,0,-2],[11,17,4],
  [8,13,1,-2],[6,12,0,-2],[9,13,1,-1],[9,13,1,-1],[8,16,4],[9,13,1,-1],[8,13,1,-2],[9,13,1,-2],
  [9,13,1,-1],[9,13,1,-1],[4,8,0,-2],[5,12,4,-1],[5,13,4,-1],[12,5,-2,-2],[7,13,4,-1],[7,13,0,-3],
  [12,13,1,-2],[11,13,0,-1],[12,12,0,-1],[12,13,1,-2],[13,12,0,-1],[12,12,0,-1],[12,12,0,-1],[12,13,1,-2],
  [14,12,0,-1],[8,12,0,-1],[10,13,1,-1],[14,12,0,-1],[10,12,0,-1],[16,12,0,-1],[14,12,0,-1],[12,13,1,-2],
  [12,12,0,-1],[12,16,4,-2],[12,13,1,-1],[10,13,1,-1],[11,12,0,-3],[12,13,1,-3],[12,13,1,-3],[16,13,1,-3],
  [17,12,0,3],[12,12,0,-3],[11,12,0,-1],[7,17,4,-1],[7,6,-6,-4],[7,17,4,1],[5,3,-9,-4],[3,3,-9,-4],
  [3,6,-6,-3],[8,9,1,-1],[6,13,1,-2],[7,9,1,-1],[9,13,1,-1],[6,9,1,-2],[9,16,4,1],[8,12,4,-1],
  [8,13,1,-1],[5,12,1,-1],[7,16,4,1],[8,13,1,-1],[5,13,1,-1],[14,9,1,-1],[9,9,1,-1],[8,9,1,-1],
  [9,12,4],[8,12,4,-1],[8,9,1,-1],[6,9,1,-1],[6,12,1,-1],[9,9,1,-1],[8,9,1,-1],[11,9,1,-1],
  [8,9,1,-1],[8,12,4,-1],[7,9,1,-1],[9,1,-4,-1],[16,1,-4,-2],[13,8,-4,3],[6,3,-9,-4],[6,3,-9,-4],
  [7,27,47,68,88,109,129,149,
  170,190,210,231,251,271,292,312],[22,42,61,81,101,121,141,161],[335,175]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{cmti10:[[13,14,0,-1],[14,15,0,-1],[13,16,1,-3],[12,15,0,-1],[14,14,0,-1],[16,14,0,-1],[15,14,0,-1],[13,15,0,-4],
  [12,14,0,-3],[13,14,0,-4],[14,15,0,-2],[17,19,4,1],[13,19,4,1],[14,19,4,1],[20,20,5,1],[20,20,5,1],
  [6,10,1,-1],[8,13,4,1],[4,4,-10,-5],[5,4,-10,-6],[6,3,-10,-5],[7,4,-10,-5],[8,1,-11,-4],[5,5,-10,-9],
  [5,4,4,-2],[13,19,4,1],[14,10,1,-1],[13,10,1,-2],[10,13,2,-1],[18,14,0,-1],[18,16,1,-3],[15,17,2,-2],
  [5,3,-5,-2],[6,15,0,-2],[8,6,-8,-3],[15,18,4,-2],[13,16,1,-1],[14,17,2,-3],[14,16,1,-2],[4,6,-8,-4],
  [8,20,5,-3],[8,20,5],[8,9,-6,-4],[12,13,2,-3],[4,7,4,-1],[6,2,-3,-1],[3,3,0,-2],[13,20,5],
  [10,15,1,-2],[8,14,0,-2],[10,15,1,-1],[11,15,1,-1],[9,18,4,-1],[10,15,1,-2],[10,15,1,-2],[10,15,1,-3],
  [9,15,1,-2],[9,15,1,-2],[4,9,0,-2],[5,13,4,-1],[6,15,5,-1],[14,6,-2,-2],[8,15,5,-1],[8,15,0,-3],
  [13,16,1,-3],[13,15,0,-1],[14,14,0,-1],[14,16,1,-3],[15,14,0,-1],[14,14,0,-1],[14,14,0,-1],[14,16,1,-3],
  [16,14,0,-1],[9,14,0,-1],[12,15,1,-1],[17,14,0,-1],[12,14,0,-1],[19,14,0,-1],[16,14,0,-1],[13,16,1,-3],
  [14,14,0,-1],[13,19,4,-3],[14,15,1,-1],[12,16,1,-1],[13,14,0,-3],[13,15,1,-4],[14,15,1,-4],[18,15,1,-4],
  [21,14,0,4],[14,14,0,-4],[13,14,0,-1],[8,20,5,-1],[8,7,-7,-5],[9,20,5,1],[6,4,-10,-5],[3,3,-11,-5],
  [4,6,-8,-4],[9,10,1,-2],[8,15,1,-2],[8,10,1,-2],[10,15,1,-2],[8,10,1,-2],[10,19,4,1],[9,14,5,-1],
  [10,15,1,-1],[6,14,1,-1],[9,18,4,1],[9,15,1,-1],[5,15,1,-1],[16,10,1,-1],[11,10,1,-1],[9,10,1,-2],
  [11,13,4],[8,13,4,-2],[9,10,1,-1],[8,10,1,-1],[7,14,1,-1],[11,10,1,-1],[9,10,1,-1],[13,10,1,-1],
  [10,10,1,-1],[10,13,4,-1],[9,10,1,-1],[9,1,-5,-2],[19,1,-5,-2],[7,4,-10,-5],[7,3,-11,-5],[6,3,-11,-5],
  [8,32,57,81,106,130,155,179,
  204,228,252,277,301,326,350,375],[26,50,74,98,122,145,169,193],[402,209]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{cmti10:[[16,17,0,-1],[17,18,0,-1],[16,18,1,-3],[15,18,0,-1],[17,17,0,-1],[20,17,0,-1],[17,17,0,-2],[15,17,0,-5],
  [15,17,0,-3],[15,17,0,-5],[17,17,0,-2],[20,22,5,1],[16,22,5,1],[17,22,5,1],[23,22,5,1],[24,22,5,1],
  [6,12,1,-2],[9,16,5,1],[4,5,-12,-7],[6,5,-12,-8],[7,3,-12,-6],[8,5,-12,-6],[9,2,-13,-5],[5,5,-13,-11],
  [6,5,5,-2],[15,22,5,1],[16,12,1,-2],[16,12,1,-2],[13,16,3,-1],[22,17,0,-1],[23,18,1,-3],[24,20,2,4],
  [7,4,-6,-2],[7,18,0,-2],[9,8,-9,-4],[18,22,5,-2],[15,18,1,-2],[18,20,2,-3],[17,19,1,-3],[4,8,-9,-5],
  [10,24,6,-3],[10,24,6],[10,11,-7,-4],[15,16,2,-3],[5,8,5,-1],[7,2,-4,-2],[4,3,0,-2],[15,24,6],
  [12,17,1,-2],[9,16,0,-2],[12,17,1,-2],[12,17,1,-2],[11,21,5,-1],[12,17,1,-2],[12,17,1,-2],[12,17,1,-3],
  [12,17,1,-2],[12,17,1,-2],[6,11,0,-2],[7,16,5,-1],[7,18,6,-1],[17,6,-3,-2],[9,18,6,-2],[10,18,0,-4],
  [16,18,1,-3],[16,18,0,-1],[17,17,0,-1],[17,18,1,-3],[18,17,0,-1],[17,17,0,-1],[17,17,0,-1],[17,18,1,-3],
  [20,17,0,-1],[11,17,0,-1],[13,18,1,-2],[20,17,0,-1],[14,17,0,-1],[23,17,0,-1],[20,17,0,-1],[16,18,1,-3],
  [17,17,0,-1],[16,22,5,-3],[17,18,1,-1],[15,18,1,-1],[16,17,0,-4],[17,18,1,-4],[16,18,1,-5],[22,18,1,-5],
  [24,17,0,4],[16,17,0,-5],[15,17,0,-2],[10,24,6,-1],[9,8,-9,-6],[10,24,6,1],[7,4,-13,-6],[3,3,-13,-6],
  [4,8,-9,-5],[11,12,1,-2],[9,18,1,-2],[10,12,1,-2],[12,18,1,-2],[10,12,1,-2],[12,22,5,1],[11,16,5,-1],
  [12,18,1,-1],[6,17,1,-2],[10,21,5,1],[11,18,1,-1],[6,18,1,-2],[19,12,1,-2],[12,12,1,-2],[11,12,1,-2],
  [13,16,5],[10,16,5,-2],[10,12,1,-2],[9,12,1,-1],[7,16,1,-2],[12,12,1,-2],[10,12,1,-2],[15,12,1,-2],
  [12,12,1,-1],[11,16,5,-2],[10,12,1,-1],[12,1,-6,-2],[22,1,-6,-3],[8,5,-12,-6],[8,3,-13,-6],[8,3,-13,-6],
  [10,39,68,98,127,156,186,215,
  245,274,303,333,362,391,421,450],[32,61,90,118,147,176,204,233],[482,253]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{cmti10:[[20,20,0,-1],[20,21,0,-2],[19,22,1,-4],[18,21,0,-1],[20,20,0,-2],[24,20,0,-1],[21,20,0,-2],[19,21,0,-6],
  [18,20,0,-4],[18,20,0,-6],[20,21,0,-2],[23,27,6,1],[19,27,6,1],[20,27,6,1],[28,27,6,1],[29,27,6,1],
  [8,14,1,-2],[11,19,6,1],[5,7,-14,-8],[6,7,-14,-10],[8,5,-14,-8],[9,5,-15,-8],[11,2,-16,-6],[7,6,-15,-13],
  [7,6,6,-3],[18,27,6,1],[19,14,1,-2],[18,14,1,-3],[14,19,3,-2],[27,20,0,-1],[27,22,1,-4],[21,24,2,-3],
  [8,4,-8,-2],[8,21,0,-3],[10,10,-11,-5],[21,27,6,-3],[19,22,1,-2],[21,24,2,-4],[21,22,1,-3],[5,10,-11,-6],
  [11,30,8,-4],[12,30,8],[12,13,-9,-5],[18,18,2,-4],[5,9,6,-2],[8,2,-5,-2],[4,3,0,-3],[18,30,8],
  [14,21,1,-3],[11,20,0,-3],[14,21,1,-2],[15,21,1,-2],[13,26,6,-1],[14,21,1,-3],[14,21,1,-3],[14,21,1,-4],
  [14,21,1,-2],[13,21,1,-3],[6,13,0,-3],[7,19,6,-2],[9,22,7,-1],[20,8,-3,-3],[11,22,7,-2],[11,21,0,-5],
  [19,22,1,-4],[19,21,0,-1],[20,20,0,-2],[20,22,1,-4],[22,20,0,-1],[21,20,0,-1],[21,20,0,-1],[20,22,1,-4],
  [24,20,0,-1],[14,20,0,-1],[16,21,1,-2],[24,20,0,-1],[17,20,0,-1],[27,20,0,-2],[24,20,0,-1],[19,22,1,-4],
  [21,20,0,-1],[19,27,6,-4],[20,21,1,-1],[17,22,1,-2],[19,20,0,-5],[20,21,1,-5],[20,21,1,-6],[27,21,1,-6],
  [28,20,0,4],[21,20,0,-5],[19,20,0,-2],[11,30,8,-2],[10,9,-11,-8],[12,30,8,1],[8,5,-15,-7],[4,4,-16,-7],
  [5,9,-11,-6],[13,14,1,-3],[11,22,1,-3],[11,14,1,-3],[14,22,1,-3],[11,14,1,-3],[15,27,6,1],[14,19,6,-1],
  [14,22,1,-2],[8,20,1,-2],[12,25,6,1],[13,22,1,-2],[7,22,1,-2],[23,14,1,-2],[15,14,1,-2],[12,14,1,-3],
  [15,19,6],[12,19,6,-3],[13,14,1,-2],[11,14,1,-2],[9,20,1,-2],[15,14,1,-2],[13,14,1,-2],[19,14,1,-2],
  [14,14,1,-1],[13,19,6,-2],[12,14,1,-2],[14,1,-7,-2],[27,1,-7,-3],[10,7,-14,-7],[10,4,-16,-7],[9,4,-16,-7],
  [12,47,82,117,152,187,222,257,
  293,328,363,398,433,468,503,539],[37,72,106,140,175,209,243,278],[577,301]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{cmti10:[[22,24,0,-2],[24,25,0,-2],[22,25,1,-5],[20,25,0,-2],[24,23,0,-2],[27,24,0,-2],[25,24,0,-2],[22,24,0,-7],
  [20,24,0,-5],[21,24,0,-7],[23,24,0,-3],[27,31,7,1],[22,31,7,1],[23,31,7,1],[33,31,7,1],[33,31,7,1],
  [10,16,1,-2],[13,22,7,2],[6,7,-17,-9],[8,7,-17,-11],[10,5,-17,-9],[11,7,-17,-9],[12,1,-19,-8],[7,7,-18,-16],
  [9,7,7,-3],[21,31,7,1],[22,16,1,-3],[22,16,1,-3],[17,23,4,-2],[31,24,0,-2],[31,25,1,-5],[24,28,2,-4],
  [9,5,-9,-3],[10,25,0,-3],[12,11,-13,-6],[25,31,7,-4],[21,25,1,-3],[24,28,2,-5],[24,26,1,-4],[6,11,-13,-7],
  [13,35,9,-5],[13,35,9],[14,16,-10,-6],[22,21,2,-4],[6,11,7,-2],[9,3,-6,-3],[5,4,0,-3],[21,35,9],
  [15,24,1,-4],[12,23,0,-4],[17,24,1,-2],[17,24,1,-3],[15,30,7,-1],[17,24,1,-3],[16,24,1,-4],[17,24,1,-5],
  [16,24,1,-3],[16,24,1,-3],[8,15,0,-3],[9,22,7,-2],[9,25,8,-2],[23,9,-4,-4],[13,25,8,-2],[13,25,0,-6],
  [22,25,1,-5],[22,25,0,-2],[23,24,0,-2],[23,25,1,-5],[25,24,0,-2],[24,24,0,-2],[23,24,0,-2],[23,25,1,-5],
  [27,24,0,-2],[15,24,0,-2],[19,25,1,-3],[28,24,0,-2],[20,24,0,-2],[32,24,0,-2],[27,24,0,-2],[22,25,1,-5],
  [23,24,0,-2],[22,31,7,-5],[23,25,1,-2],[20,25,1,-2],[22,23,0,-6],[23,25,1,-6],[23,25,1,-7],[31,25,1,-7],
  [33,24,0,5],[24,24,0,-6],[22,24,0,-2],[13,35,9,-2],[12,11,-13,-9],[14,35,9,1],[9,6,-18,-9],[5,4,-19,-8],
  [6,11,-13,-7],[16,16,1,-3],[13,25,1,-3],[13,16,1,-3],[16,25,1,-3],[13,16,1,-3],[17,31,7,1],[16,22,7,-1],
  [17,25,1,-2],[10,24,-294,-2],[15,30,7,2],[15,25,1,-2],[8,25,1,-3],[27,16,1,-2],[18,16,1,-2],[15,16,1,-3],
  [18,22,7],[14,22,7,-3],[15,16,1,-2],[13,16,1,-2],[10,23,1,-3],[17,16,1,-2],[15,16,1,-2],[22,16,1,-2],
  [17,16,1,-1],[16,22,7,-2],[14,16,1,-2],[16,2,-8,-3],[32,2,-8,-4],[11,7,-17,-9],[12,4,-19,-8],[10,4,-19,-9],
  [14,56,98,141,183,225,267,310,
  352,394,437,479,521,563,606,648],[46,87,128,170,211,253,294,335],[694,363]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{cmti10:[[27,28,0,-2],[28,30,0,-3],[27,30,1,-6],[25,30,0,-2],[28,28,0,-3],[33,28,0,-2],[29,28,0,-3],[27,29,0,-8],
  [24,28,0,-6],[26,28,0,-8],[28,29,0,-4],[32,38,9,1],[26,38,9,1],[27,38,9,1],[39,38,9,1],[40,38,9,1],
  [11,20,1,-3],[16,28,9,2],[6,9,-20,-12],[9,9,-20,-14],[11,6,-20,-11],[13,8,-21,-11],[15,3,-22,-9],[9,8,-22,-19],
  [10,8,8,-4],[25,38,9,1],[27,20,1,-3],[26,20,1,-4],[21,27,5,-2],[37,28,0,-2],[37,30,1,-6],[30,34,3,-4],
  [11,5,-11,-3],[12,30,0,-4],[14,13,-16,-7],[30,37,8,-4],[26,30,1,-3],[29,34,3,-6],[28,31,1,-5],[7,13,-16,-9],
  [16,42,11,-6],[16,42,11],[16,18,-13,-8],[26,26,3,-5],[7,13,8,-3],[11,3,-7,-3],[6,5,0,-4],[26,42,11],
  [19,29,1,-4],[15,28,0,-4],[20,29,1,-3],[20,29,1,-3],[19,36,8,-1],[20,29,1,-4],[20,29,1,-4],[20,29,1,-6],
  [19,29,1,-4],[19,29,1,-4],[9,18,0,-4],[10,26,8,-3],[12,30,9,-2],[28,10,-5,-4],[16,30,9,-3],[15,30,0,-8],
  [27,30,1,-6],[27,30,0,-2],[29,28,0,-2],[28,30,1,-6],[30,28,0,-2],[29,28,0,-2],[28,28,0,-2],[28,30,1,-6],
  [33,28,0,-2],[19,28,0,-2],[23,29,1,-3],[34,28,0,-2],[24,28,0,-2],[39,28,0,-2],[33,28,0,-2],[27,30,1,-6],
  [28,28,0,-2],[27,37,8,-6],[28,29,1,-2],[23,30,1,-3],[26,28,0,-7],[27,29,1,-8],[28,29,1,-8],[37,29,1,-8],
  [40,28,0,6],[28,28,0,-8],[26,28,0,-3],[16,42,11,-3],[14,13,-16,-11],[16,42,11,1],[11,7,-22,-11],[5,5,-23,-10],
  [7,13,-16,-8],[18,20,1,-4],[15,30,1,-4],[16,20,1,-4],[19,30,1,-4],[16,20,1,-4],[20,38,9,1],[18,28,9,-2],
  [19,30,1,-3],[11,28,1,-3],[17,36,9,2],[18,30,1,-3],[10,30,1,-3],[32,20,1,-3],[21,20,1,-3],[17,20,1,-4],
  [21,27,8],[17,27,8,-4],[17,20,1,-3],[15,20,1,-3],[13,27,1,-3],[20,20,1,-3],[18,20,1,-3],[26,20,1,-3],
  [20,20,1,-2],[19,28,9,-3],[17,20,1,-2],[20,2,-10,-3],[38,2,-10,-5],[13,9,-20,-11],[14,5,-23,-10],[12,5,-23,-11],
  [17,67,118,168,219,270,320,371,
  421,472,522,573,624,674,725,775],[55,104,154,203,253,302,352,401],[831,434]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{cmti10:[[32,34,0,-3],[34,35,0,-3],[32,37,2,-7],[30,35,0,-2],[34,34,0,-3],[39,34,0,-3],[35,34,0,-4],[31,35,0,-10],
  [29,34,0,-7],[31,34,0,-10],[34,35,0,-4],[40,45,10,2],[32,45,10,2],[34,45,10,2],[47,45,10,2],[49,45,10,2],
  [13,23,1,-4],[18,32,10,2],[8,10,-24,-14],[11,11,-24,-16],[14,7,-24,-13],[15,9,-25,-13],[17,2,-27,-11],[10,9,-26,-23],
  [12,10,10,-5],[30,45,10,1],[32,23,1,-4],[31,23,1,-5],[24,33,6,-3],[45,34,0,-2],[44,37,2,-8],[36,40,3,-5],
  [13,7,-13,-4],[14,35,0,-5],[18,15,-19,-8],[36,44,10,-5],[31,36,1,-4],[35,40,3,-7],[34,37,2,-6],[9,15,-19,-10],
  [19,50,13,-7],[18,50,13,-1],[20,22,-15,-9],[31,31,3,-6],[8,16,10,-3],[13,3,-9,-4],[6,6,0,-5],[30,50,13,-1],
  [23,35,2,-5],[18,33,0,-5],[23,34,1,-4],[24,35,2,-4],[22,43,10,-2],[23,34,1,-5],[23,34,1,-5],[24,34,1,-7],
  [24,35,2,-4],[23,34,1,-5],[10,22,0,-5],[12,32,10,-3],[14,36,11,-2],[33,12,-6,-5],[18,36,11,-4],[18,35,0,-9],
  [32,36,1,-7],[32,35,0,-2],[33,34,0,-3],[33,37,2,-7],[35,34,0,-3],[34,34,0,-3],[33,34,0,-3],[33,37,2,-7],
  [39,34,0,-3],[23,34,0,-2],[27,36,2,-4],[39,34,0,-3],[28,34,0,-3],[46,34,0,-3],[39,34,0,-3],[32,37,2,-7],
  [33,34,0,-3],[32,45,10,-7],[33,36,2,-3],[28,37,2,-3],[32,34,0,-8],[33,36,2,-9],[33,35,1,-10],[45,36,2,-10],
  [48,34,0,7],[34,34,0,-9],[31,34,0,-4],[19,50,13,-3],[17,15,-19,-13],[19,50,13,1],[13,8,-26,-13],[6,6,-27,-12],
  [8,15,-19,-10],[22,23,1,-5],[18,35,1,-5],[18,23,1,-5],[23,35,1,-5],[18,23,1,-5],[25,45,10,2],[22,32,10,-2],
  [24,35,1,-3],[13,34,1,-4],[20,43,10,2],[22,35,1,-3],[11,35,1,-4],[38,23,1,-4],[25,23,1,-4],[20,23,1,-5],
  [25,32,10],[20,32,10,-5],[20,23,1,-4],[18,23,1,-3],[15,32,1,-4],[24,23,1,-4],[21,23,1,-4],[31,23,1,-4],
  [24,23,1,-2],[22,32,10,-4],[20,23,1,-3],[23,2,-12,-4],[45,2,-12,-6],[16,11,-24,-13],[16,6,-27,-12],[14,6,-27,-13],
  [20,81,141,202,263,324,385,445,
  506,567,628,688,749,810,871,932],[64,124,183,243,302,362,421,481],[998,521]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{cmti10:[[39,41,0,-3],[41,43,0,-4],[39,44,2,-8],[35,43,0,-3],[41,40,0,-4],[48,41,0,-3],[43,41,0,-4],[38,42,0,-12],
  [34,41,0,-9],[37,41,0,-12],[40,42,0,-5],[47,55,13,2],[38,55,13,2],[40,55,13,2],[56,55,13,2],[58,55,13,2],
  [15,28,1,-5],[21,39,13,2],[9,12,-29,-17],[13,12,-29,-20],[16,9,-29,-16],[18,11,-30,-16],[21,2,-33,-13],[12,12,-31,-28],
  [14,12,12,-6],[37,55,13,2],[38,28,1,-5],[37,28,1,-6],[29,39,7,-4],[53,41,0,-3],[53,44,2,-9],[42,48,4,-7],
  [16,8,-16,-5],[17,43,0,-6],[21,18,-23,-10],[43,53,12,-6],[37,43,1,-5],[42,49,4,-8],[41,45,2,-7],[9,18,-23,-13],
  [22,60,15,-9],[22,60,15,-1],[24,27,-18,-11],[37,37,4,-8],[10,19,12,-4],[15,4,-11,-5],[7,7,0,-6],[36,60,15,-1],
  [27,42,2,-6],[21,40,0,-7],[28,42,2,-5],[29,42,2,-5],[26,52,12,-2],[28,42,2,-6],[27,42,2,-7],[29,42,2,-8],
  [28,42,2,-5],[27,42,2,-6],[12,26,0,-6],[14,38,12,-4],[16,43,13,-3],[40,15,-7,-6],[21,43,13,-5],[22,43,0,-11],
  [39,43,1,-8],[38,43,0,-3],[41,41,0,-3],[40,44,2,-8],[43,41,0,-3],[41,41,0,-3],[41,41,0,-3],[40,44,2,-8],
  [48,41,0,-3],[27,41,0,-3],[32,43,2,-5],[48,41,0,-3],[34,41,0,-3],[56,41,0,-4],[48,41,0,-3],[39,44,2,-8],
  [40,41,0,-3],[39,54,12,-8],[40,43,2,-3],[34,44,2,-4],[38,40,0,-10],[40,43,2,-11],[40,43,2,-12],[54,43,2,-12],
  [57,41,0,8],[40,41,0,-12],[38,41,0,-4],[23,60,15,-4],[20,18,-23,-16],[23,60,15,996],[16,10,-31,-15],[7,7,-33,-15],
  [10,18,-23,-12],[26,27,1,-6],[21,42,1,-6],[22,28,1,-6],[27,42,1,-6],[22,28,1,-6],[29,54,12,2],[26,39,13,-3],
  [28,42,1,-4],[15,40,1,-5],[23,52,13,2],[26,42,1,-4],[13,42,1,-5],[45,28,1,-5],[30,28,1,-5],[24,28,1,-6],
  [31,38,12],[24,38,12,-6],[24,28,1,-5],[21,28,1,-4],[17,38,1,-5],[28,28,1,-5],[25,28,1,-5],[37,28,1,-5],
  [28,28,1,-3],[26,40,13,-5],[25,28,1,-3],[28,2,-15,-5],[55,2,-15,-7],[18,11,-30,-16],[20,7,-33,-14],[17,7,-33,-16],
  [24,97,170,243,316,389,462,535,
  608,681,754,827,900,973,1046,1119],[77,149,220,292,363,434,506,577],[1198,625]]});
org.mathdox.formulaeditor.MathCanvas.addFont(50, 
{bbold10:[[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],
  [4,5,0],[4,5,0],[4,5,0],[4,3,0],[4,7,2],[3,5,2],[3,5,0],[3,3,0],
  [3,7,2],[4,5,2],[3,5,0],[2,3,0],[4,3,0],[3,5,0],[4,5,2],[4,3,0],
  [3,7,2],[4,3,0],[4,5,2],[4,3,0],[3,3,0],[4,3,0],[3,7,2],[3,5,2],
  [3,7,2],[2,5,0],[4,3,-2],[5,7,2],[4,7,1],[4,8,2],[5,5,0],[2,3,-2],
  [3,8,2],[2,8,2],[4,5,1],[5,5,1],[2,4,2],[3,1,-1],[2,2,0],[4,8,2],
  [4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,5,0],[4,7,0],[4,5,0],[4,5,0],
  [4,5,0],[4,5,0],[2,3,0],[2,5,2],[5,5,1],[2,2,-1],[5,5,1],[6,5,0,2],
  [4,5,0],[4,5,0],[4,5,0],[4,5,0],[5,5,0],[4,5,0],[4,5,0],[4,5,0],
  [5,5,0],[2,5,0],[4,5,0],[4,5,0],[4,5,0],[5,5,0],[5,5,0],[6,5,0,2],
  [4,5,0],[4,7,2],[4,5,0],[4,5,0],[4,5,0],[5,5,0],[4,5,0],[6,5,0],
  [6,5,0,2],[4,5,0],[4,5,0],[3,8,2],[4,8,2],[2,8,2],[3,8,2],[2,8,2],
  [2,3,-2],[3,3,0],[4,5,0],[3,3,0],[3,5,0],[3,3,0],[3,5,0],[3,5,2],
  [4,5,0],[2,5,0],[3,7,2],[4,5,0],[2,5,0],[5,3,0],[4,3,0],[3,3,0],
  [4,5,2],[3,5,2],[4,3,0],[3,3,0],[3,5,0],[4,3,0],[3,3,0],[5,3,0],
  [3,3,0],[3,5,2],[3,3,0],[3,1,-1],[2,8,2],[6,1,-1],[6,4,-1,2],[5,3,0],
  [3,10,16,23,30,37,44,51,
  58,65,72,79,86,93,100,106],[9,18,27,36,45,54,63,72],[114,79]]});
org.mathdox.formulaeditor.MathCanvas.addFont(60, 
{bbold10:[[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],
  [5,6,0],[5,6,0],[5,6,0],[5,4,0],[4,8,2],[4,6,2],[4,6,0],[4,4,0],
  [3,8,2],[4,6,2],[4,6,0],[2,4,0],[4,4,0],[4,6,0],[4,6,2],[4,4,0],
  [3,8,2],[4,4,0],[4,6,2],[5,4,0],[4,4,0],[4,4,0],[4,8,2],[4,6,2],
  [4,8,2],[2,6,0],[4,4,-2],[6,8,2],[5,8,1],[5,10,3],[6,6,0],[2,4,-2],
  [3,9,2],[2,9,2],[5,6,1],[6,6,1],[2,4,2],[3,1,-1],[2,2,0],[5,9,2],
  [4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],[4,6,0],
  [4,6,0],[4,6,0],[2,4,0],[2,6,2],[6,6,1],[2,2,-1],[6,6,1],[5,6,0],
  [4,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],
  [5,6,0],[2,6,0],[5,6,0],[5,6,0],[5,6,0],[6,6,0],[5,6,0],[5,6,0],
  [5,6,0],[5,8,2],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[5,6,0],[7,6,0],
  [5,6,0],[5,6,0],[5,6,0],[3,9,2],[5,9,2],[2,9,2],[3,9,2],[2,9,2],
  [2,4,-2],[4,4,0],[5,6,0],[4,4,0],[4,6,0],[4,4,0],[3,6,0],[4,6,2],
  [4,6,0],[2,6,0],[3,8,2],[4,6,0],[2,6,0],[6,4,0],[4,4,0],[4,4,0],
  [5,6,2],[4,6,2],[4,4,0],[3,4,0],[3,6,0],[4,4,0],[4,4,0],[6,4,0],
  [4,4,0],[4,6,2],[4,4,0],[4,1,-2],[2,9,2],[7,1,-2],[6,4,-2,2],[6,4,0],
  [3,11,20,28,36,45,53,61,
  70,78,86,95,103,111,119,128],[11,22,33,43,54,65,76,87],[137,94]]});
org.mathdox.formulaeditor.MathCanvas.addFont(70, 
{bbold10:[[6,7,0],[6,7,0],[6,8,1],[6,7,0],[6,7,0],[6,7,0],[6,7,0],[6,7,0],
  [6,7,0],[6,7,0],[6,7,0],[5,6,1],[5,9,2],[5,8,3],[5,8,1],[5,6,1],
  [4,9,2],[5,7,2],[5,8,1],[3,5,0],[5,5,0],[5,7,0],[5,7,2],[5,5,0],
  [4,9,2],[5,5,0],[5,7,2],[5,6,1],[5,5,0],[5,6,1],[5,9,2],[5,7,2],
  [5,9,2],[3,8,1],[5,4,-3],[7,9,2],[6,9,1],[6,11,3],[7,8,1],[3,4,-3],
  [4,11,3],[3,11,3],[7,7,1],[7,7,1],[3,4,2],[4,1,-2],[3,3,1],[5,11,3],
  [5,8,1],[5,7,0],[5,7,0],[5,8,1],[5,7,0],[5,8,1],[5,8,1],[5,7,0],
  [5,8,1],[5,8,1],[3,6,1],[3,7,2],[8,6,1],[3,3,-1],[7,6,1,-1],[6,8,1],
  [5,8,1],[6,7,0],[6,7,0],[6,8,1],[7,7,0],[6,7,0],[6,7,0],[6,8,1],
  [7,7,0],[3,7,0],[6,8,1],[6,7,0],[6,7,0],[7,7,0],[7,7,0],[6,8,1],
  [6,7,0],[6,9,2],[6,7,0],[6,8,1],[6,7,0],[7,8,1],[6,7,0],[8,7,0],
  [8,7,0,2],[6,7,0],[6,7,0],[4,11,3],[5,11,3],[3,11,3],[4,11,3],[3,11,3],
  [3,4,-3],[5,6,1],[6,8,1],[5,6,1],[5,8,1],[5,6,1],[4,7,0],[5,8,3],
  [5,7,0],[3,7,0],[4,10,3],[5,7,0],[3,7,0],[7,5,0],[5,5,0],[5,6,1],
  [6,7,2],[5,7,2],[5,5,0],[4,6,1],[4,8,1],[5,6,1],[5,5,0],[7,5,0],
  [5,5,0],[5,8,3],[5,5,0],[4,1,-2],[3,11,3],[8,1,-2],[7,5,-2,2],[7,6,1],
  [4,13,23,33,42,52,62,72,
  81,91,101,110,120,130,139,149],[13,25,38,51,63,76,89,101],[160,110]]});
org.mathdox.formulaeditor.MathCanvas.addFont(85, 
{bbold10:[[7,8,0],[7,8,0],[7,10,1],[7,8,0],[7,8,0],[7,8,0],[7,8,0],[7,9,0],
  [7,8,0],[7,8,0],[7,9,0],[7,7,1],[6,12,3],[6,8,3],[6,10,1],[6,7,1],
  [5,12,3],[6,9,3],[6,10,1],[3,5,0],[6,5,0],[6,9,0],[6,8,3],[6,5,0],
  [5,12,3],[6,5,0],[6,9,3],[7,6,1],[6,5,0],[6,6,1],[6,12,3],[6,8,3],
  [6,12,3],[3,9,1],[6,5,-4],[9,11,3],[7,10,1],[7,13,4],[9,10,1],[3,5,-4],
  [4,12,3],[4,12,3],[8,8,1],[9,8,1],[3,6,3],[5,1,-2],[3,4,1],[7,12,3],
  [6,9,1],[6,8,0],[6,8,0],[6,9,1],[6,8,0],[6,9,1],[6,9,1],[6,8,0],
  [6,9,1],[6,9,1],[3,7,1],[3,9,3],[9,7,1],[3,4,-1],[8,7,1,-1],[7,10,1],
  [6,10,1],[7,8,0],[7,8,0],[7,10,1],[8,8,0],[7,8,0],[7,8,0],[7,10,1],
  [8,8,0],[3,8,0],[7,9,1],[7,8,0],[7,8,0],[8,8,0],[8,8,0],[7,10,1],
  [7,8,0],[7,12,3],[7,8,0],[7,10,1],[7,8,0],[8,9,1],[7,8,0],[10,8,0],
  [7,8,0],[7,8,0],[7,8,0],[4,12,3],[7,12,3],[4,12,3],[4,12,3],[4,12,3],
  [3,6,-3],[6,7,1],[7,10,1],[6,7,1],[6,10,1],[6,7,1],[5,9,0],[6,9,3],
  [6,9,0],[3,8,0],[5,11,3],[6,9,0],[3,9,0],[8,6,0],[6,6,0],[6,7,1],
  [7,9,3],[6,9,3],[6,6,0],[5,7,1],[5,10,1],[6,6,1],[6,5,0],[8,5,0],
  [6,5,0],[6,8,3],[6,5,0],[5,2,-2],[3,12,3],[10,2,-2],[6,6,-3],[8,6,1],
  [5,16,28,40,52,63,75,87,
  99,110,122,134,146,157,169,181],[17,32,47,63,78,93,109,124],[194,135]]});
org.mathdox.formulaeditor.MathCanvas.addFont(100, 
{bbold10:[[7,10,0,-1],[8,10,0],[9,11,1],[8,10,0],[8,10,0,-1],[7,10,0,-1],[9,10,0],[8,10,0],
  [9,10,0],[8,10,0],[9,10,0],[8,8,1],[8,13,3],[6,9,3],[6,11,1],[6,8,1],
  [6,13,3],[8,10,3],[6,11,1],[3,6,0],[8,6,0],[6,10,0],[8,9,3],[7,6,0],
  [6,13,3],[7,6,0],[7,10,3],[8,7,1],[6,6,0],[7,7,1],[6,13,3],[6,9,3],
  [7,13,3],[4,11,1],[8,6,-4],[10,13,3],[8,13,2],[8,16,5],[10,11,1],[4,6,-4],
  [4,15,4,-1],[4,15,4],[8,10,2,-1],[10,10,2],[4,6,3],[5,2,-2],[4,4,1],[8,15,4],
  [7,11,1],[6,9,0,-1],[7,10,0],[7,11,1],[7,9,0],[7,10,1],[7,11,1],[7,9,0],
  [7,11,1],[7,11,1],[4,8,1],[4,10,3],[10,9,1,-1],[4,3,-2],[10,9,1,-1],[8,11,1],
  [7,11,1],[8,10,0],[7,10,0,-1],[9,11,1],[8,10,0,-1],[7,10,0,-1],[7,10,0,-1],[9,11,1],
  [8,10,0,-1],[3,10,0,-1],[8,11,1],[7,10,0,-1],[7,10,0,-1],[8,10,0,-1],[8,10,0,-1],[9,11,1],
  [7,10,0,-1],[9,13,3],[7,10,0,-1],[8,11,1],[8,10,0],[8,11,1,-1],[8,10,0],[12,10,0],
  [12,10,0,3],[8,10,0],[9,10,0],[4,15,4,-1],[8,15,4],[4,15,4],[4,15,4,-1],[4,15,4],
  [4,6,-4],[6,8,1],[9,11,1],[6,8,1],[6,11,1],[6,8,1],[6,10,0],[6,10,3],
  [8,10,0],[4,10,0],[5,13,3],[8,10,0],[3,10,0],[10,7,0],[8,7,0],[6,8,1],
  [9,10,3],[6,10,3],[8,7,0],[5,8,1],[6,11,1],[7,7,1],[7,6,0],[9,6,0],
  [6,6,0],[7,9,3],[6,6,0],[6,1,-3],[3,15,4,-1],[11,1,-3],[8,6,-4],[9,7,1],
  [5,19,33,47,61,74,88,102,
  116,130,144,158,171,185,199,213],[19,37,55,73,92,110,128,146],[228,158]]});
org.mathdox.formulaeditor.MathCanvas.addFont(120, 
{bbold10:[[9,12,0,-1],[10,12,0],[10,13,1],[10,12,0],[10,12,0],[9,12,0,-1],[10,12,0],[10,12,0],
  [10,12,0],[10,12,0],[10,12,0],[9,9,1],[9,16,4],[8,12,4],[8,13,1],[8,9,1],
  [7,16,4],[9,12,4],[8,13,1],[4,8,0],[9,8,0],[8,12,0],[9,12,4],[8,8,0],
  [7,16,4],[8,8,0],[8,12,4],[9,9,1],[7,8,0],[8,9,1],[7,16,4],[8,12,4],
  [8,16,4],[4,13,1,-1],[9,7,-5],[12,16,4],[9,15,2],[10,19,6],[12,13,1],[4,7,-5],
  [5,18,5,-1],[5,18,5],[11,12,2],[12,12,2],[4,7,4],[6,1,-3],[4,4,1],[9,18,5],
  [9,12,1],[8,11,0],[9,11,0],[9,12,1],[9,11,0],[9,12,1],[9,12,1],[9,11,0],
  [9,12,1],[9,12,1],[4,9,1],[4,12,4],[12,10,1,-1],[4,4,-2],[12,10,1,-1],[9,13,1],
  [8,13,1],[10,12,0],[9,12,0,-1],[10,13,1],[10,12,0,-1],[9,12,0,-1],[9,12,0,-1],[10,13,1],
  [10,12,0,-1],[3,12,0,-1],[9,13,1],[9,12,0,-1],[9,12,0,-1],[10,12,0,-1],[10,12,0,-1],[10,13,1],
  [9,12,0,-1],[10,16,4],[9,12,0,-1],[9,13,1],[10,12,0],[10,13,1,-1],[10,12,0],[13,12,0],
  [10,12,0],[10,12,0],[10,12,0],[5,18,5,-1],[9,18,5],[5,18,5],[5,18,5,-1],[5,18,5],
  [4,7,-5],[8,9,1],[10,13,1],[8,9,1],[8,13,1],[8,9,1],[7,12,0],[8,12,4],
  [9,12,0],[4,12,0],[6,16,4],[9,12,0],[4,12,0],[11,8,0],[9,8,0],[8,9,1],
  [10,12,4],[8,12,4],[9,8,0],[6,9,1],[7,13,1],[8,9,1],[7,8,0],[11,8,0],
  [8,8,0],[7,12,4],[8,8,0],[7,1,-4],[3,18,5,-1],[14,1,-4],[9,7,-5],[11,9,1],
  [6,23,40,56,73,89,106,123,
  139,156,172,189,206,222,239,255],[22,44,65,87,109,130,152,174],[274,189]]});
org.mathdox.formulaeditor.MathCanvas.addFont(144, 
{bbold10:[[11,14,0,-1],[12,14,0],[11,15,1,-1],[12,14,0],[12,14,0,-1],[11,14,0,-1],[11,14,0,-1],[12,14,0],
  [12,14,0,-1],[12,14,0],[11,14,0,-1],[11,10,1],[10,18,4,-1],[9,13,4],[9,15,1],[9,10,1],
  [7,18,4,-1],[10,13,4,-1],[9,15,1],[4,9,0,-1],[10,9,0,-1],[9,14,0],[10,13,4,-1],[9,9,0,-1],
  [7,18,4,-1],[10,9,0],[9,13,4,-1],[11,10,1],[9,9,0],[9,10,1,-1],[9,18,4],[9,13,4],
  [9,18,4,-1],[4,15,1,-1],[11,8,-6],[14,18,4,-1],[10,18,2,-1],[11,23,7],[14,15,1,-1],[5,8,-6],
  [6,20,5,-1],[6,20,5],[12,14,2,-1],[14,14,2,-1],[5,8,4],[8,1,-4],[5,5,1],[11,20,5],
  [9,14,1,-1],[9,13,0,-1],[9,13,0,-1],[9,14,1,-1],[9,13,0,-1],[9,14,1,-1],[9,14,1,-1],[9,13,0,-1],
  [9,14,1,-1],[9,14,1,-1],[5,10,1],[5,13,4],[14,12,1,-1],[5,4,-3],[14,12,1,-1],[10,15,1,-1],
  [9,15,1,-1],[12,14,0],[11,14,0,-1],[11,15,1,-1],[12,14,0,-1],[11,14,0,-1],[11,14,0,-1],[11,15,1,-1],
  [12,14,0,-1],[4,14,0,-1],[10,15,1,-1],[11,14,0,-1],[11,14,0,-1],[12,14,0,-1],[12,14,0,-1],[11,15,1,-1],
  [11,14,0,-1],[11,18,4,-1],[11,14,0,-1],[10,15,1,-1],[12,14,0],[12,15,1,-1],[12,14,0],[16,14,0],
  [11,14,0,-1],[12,14,0],[11,14,0,-1],[6,20,5,-1],[11,20,5],[6,20,5],[6,20,5,-1],[6,20,5],
  [5,8,-6],[9,10,1],[11,15,1,-1],[9,10,1],[9,15,1],[9,10,1],[7,14,0,-1],[9,13,4],
  [10,14,0,-1],[5,14,0],[7,18,4],[10,14,0,-1],[4,14,0,-1],[13,9,0,-1],[10,9,0,-1],[9,10,1],
  [11,13,4,-1],[9,13,4],[10,9,0,-1],[8,10,1],[7,15,1,-1],[9,10,1,-1],[9,9,0],[13,9,0],
  [9,9,0],[9,13,4],[9,9,0],[9,2,-4],[4,20,5,-1],[16,2,-4],[11,8,-6],[13,10,1],
  [8,28,47,67,87,107,127,147,
  167,187,207,227,247,267,287,307],[26,52,78,104,130,156,182,208],[329,226]]});
org.mathdox.formulaeditor.MathCanvas.addFont(173, 
{bbold10:[[13,17,0,-1],[14,17,0],[14,18,1,-1],[14,17,0],[14,17,0,-1],[13,17,0,-1],[14,17,0,-1],[14,17,0],
  [14,17,0,-1],[14,17,0],[14,17,0,-1],[13,12,1],[12,22,5,-1],[11,16,5],[11,18,1],[11,12,1],
  [9,22,5,-1],[12,16,5,-1],[11,18,1],[5,11,0,-1],[12,11,0,-1],[11,17,0],[12,16,5,-1],[11,11,0,-1],
  [9,22,5,-1],[12,11,0],[11,16,5,-1],[13,12,1],[11,11,0],[11,12,1,-1],[11,22,5],[11,16,5],
  [11,22,5,-1],[5,18,1,-1],[12,9,-8,-1],[17,22,5,-1],[13,21,2,-1],[13,27,8,-1],[17,18,1,-1],[5,9,-8,-1],
  [7,24,6,-1],[7,24,6],[15,16,2,-1],[17,16,2,-1],[5,10,5,-1],[9,2,-4],[5,6,1,-1],[13,24,6],
  [11,17,1,-1],[11,16,0,-1],[11,16,0,-1],[11,17,1,-1],[11,16,0,-1],[11,17,1,-1],[11,17,1,-1],[11,16,0,-1],
  [11,17,1,-1],[11,17,1,-1],[5,12,1,-1],[5,16,5,-1],[17,14,1,-1],[5,6,-3,-1],[17,14,1,-1],[13,18,1,-1],
  [11,18,1,-1],[14,17,0],[13,17,0,-1],[14,18,1,-1],[14,17,0,-1],[13,17,0,-1],[13,17,0,-1],[14,18,1,-1],
  [14,17,0,-1],[5,17,0,-1],[13,18,1,-1],[13,17,0,-1],[13,17,0,-1],[15,17,0,-1],[14,17,0,-1],[14,18,1,-1],
  [13,17,0,-1],[14,22,5,-1],[13,17,0,-1],[13,18,1,-1],[14,17,0],[14,18,1,-1],[14,17,0],[19,17,0],
  [14,17,0,-1],[14,17,0],[14,17,0,-1],[7,24,6,-1],[13,24,6],[7,24,6],[7,24,6,-1],[7,24,6],
  [5,10,-7,-1],[11,12,1],[14,18,1,-1],[11,12,1],[11,18,1],[11,12,1],[9,17,0,-1],[11,16,5],
  [12,17,0,-1],[5,17,0,-1],[9,22,5],[12,17,0,-1],[5,17,0,-1],[15,11,0,-1],[12,11,0,-1],[11,12,1],
  [14,16,5,-1],[11,16,5],[12,11,0,-1],[9,12,1],[9,18,1,-1],[11,12,1,-1],[11,11,0],[15,11,0],
  [11,11,0],[11,16,5],[11,11,0],[10,2,-5],[5,24,6,-1],[19,2,-5],[12,10,-7,-1],[15,12,1],
  [9,33,57,81,105,129,153,177,
  201,225,249,273,296,320,344,368],[33,64,95,126,158,189,220,251],[395,273]]});
org.mathdox.formulaeditor.MathCanvas.addFont(207, 
{bbold10:[[15,20,0,-2],[17,20,0],[17,21,1,-1],[17,20,0],[17,20,0,-1],[15,20,0,-2],[17,20,0,-1],[17,20,0],
  [17,20,0,-1],[17,20,0],[17,20,0,-1],[16,14,1],[14,27,6,-1],[13,19,6],[13,22,1],[13,14,1],
  [10,26,6,-1],[14,19,6,-1],[13,22,1],[6,13,0,-1],[14,13,0,-1],[13,20,0],[14,19,6,-1],[13,13,0,-1],
  [10,26,6,-1],[14,13,0],[13,19,6,-1],[16,14,1],[13,13,0],[13,14,1,-1],[13,26,6],[13,19,6],
  [13,26,6,-1],[7,21,1,-1],[14,12,-9,-1],[20,26,6,-1],[15,25,3,-1],[16,32,10,-1],[20,21,1,-1],[6,12,-9,-1],
  [8,30,8,-2],[8,30,8],[17,20,3,-1],[20,20,3,-1],[6,12,6,-1],[11,2,-5],[6,7,1,-1],[15,30,8],
  [14,20,1,-1],[13,19,0,-1],[14,19,0,-1],[14,20,1,-1],[14,19,0,-1],[14,20,1,-1],[14,20,1,-1],[14,19,0,-1],
  [14,20,1,-1],[14,20,1,-1],[6,14,1,-1],[6,19,6,-1],[20,16,1,-2],[6,7,-4,-1],[20,16,1,-2],[15,21,1,-1],
  [14,21,1,-1],[17,20,0],[15,20,0,-2],[17,21,1,-1],[17,20,0,-2],[15,20,0,-2],[15,20,0,-2],[17,21,1,-1],
  [17,20,0,-2],[6,20,0,-2],[15,21,1,-1],[15,20,0,-2],[15,20,0,-2],[16,20,0,-2],[17,20,0,-2],[17,21,1,-1],
  [15,20,0,-2],[17,26,6,-1],[15,20,0,-2],[15,21,1,-1],[17,20,0],[17,21,1,-2],[17,20,0],[23,20,0],
  [17,20,0,-1],[17,20,0],[17,20,0,-1],[8,30,8,-2],[15,30,8],[8,30,8],[8,30,8,-2],[8,30,8],
  [6,11,-9,-1],[13,14,1],[16,21,1,-1],[13,14,1],[13,21,1],[13,14,1],[10,21,0,-1],[13,19,6],
  [14,20,0,-1],[6,20,0,-1],[10,26,6],[14,20,0,-1],[6,20,0,-1],[19,13,0,-1],[14,13,0,-1],[13,14,1],
  [16,19,6,-1],[13,19,6],[14,13,0,-1],[11,14,1],[10,21,1,-1],[13,14,1,-1],[13,13,0],[19,13,0],
  [13,13,0],[13,19,6],[13,13,0],[12,2,-6],[6,30,8,-2],[23,2,-6],[14,11,-9,-1],[19,14,1],
  [11,40,68,97,126,154,183,211,
  240,269,297,326,355,383,412,441],[38,75,113,150,187,225,262,299],[472,325]]});
org.mathdox.formulaeditor.MathCanvas.addFont(249, 
{bbold10:[[18,24,0,-2],[20,24,0],[20,25,1,-1],[20,24,0],[20,24,0,-1],[18,24,0,-2],[20,24,0,-1],[20,24,0],
  [20,24,0,-1],[20,24,0],[20,24,0,-1],[18,17,1],[17,32,7,-1],[15,23,8],[15,26,1],[15,17,1],
  [13,31,7,-1],[17,23,7,-1],[15,26,1],[7,15,0,-1],[17,15,0,-1],[15,24,0],[17,22,7,-1],[15,15,0,-1],
  [13,31,7,-1],[17,15,0],[15,23,7,-1],[18,16,1],[16,15,0],[15,16,1,-1],[16,31,7],[15,22,7],
  [16,31,7,-1],[8,25,1,-2],[17,14,-11,-1],[24,31,7,-1],[18,30,3,-1],[19,39,12,-1],[24,25,1,-1],[8,14,-11,-1],
  [10,35,9,-2],[10,35,9],[21,23,3,-1],[24,23,3,-1],[8,14,7,-1],[13,3,-6],[8,8,1,-1],[18,35,9],
  [16,24,1,-1],[17,23,0,-1],[16,23,0,-1],[16,24,1,-1],[16,23,0,-1],[16,24,1,-1],[16,24,1,-1],[16,23,0,-1],
  [16,24,1,-1],[16,24,1,-1],[8,17,1,-1],[8,23,7,-1],[24,19,1,-2],[8,8,-5,-1],[24,19,1,-2],[18,25,1,-1],
  [16,25,1,-1],[20,24,0],[18,24,0,-2],[20,25,1,-1],[20,24,0,-2],[18,24,0,-2],[18,24,0,-2],[20,25,1,-1],
  [20,24,0,-2],[7,24,0,-2],[18,25,1,-1],[18,24,0,-2],[18,24,0,-2],[20,24,0,-2],[20,24,0,-2],[20,25,1,-1],
  [18,24,0,-2],[20,31,7,-1],[18,24,0,-2],[18,25,1,-1],[20,24,0],[20,25,1,-2],[20,24,0],[28,24,0],
  [20,24,0,-1],[20,24,0],[20,24,0,-1],[10,35,9,-2],[18,35,9],[10,35,9],[10,35,9,-2],[10,35,9],
  [8,13,-11,-1],[15,17,1],[20,25,1,-1],[15,17,1],[15,25,1],[15,17,1],[13,25,0,-1],[15,24,8],
  [17,24,0,-1],[8,24,0,-1],[12,32,8],[17,24,0,-1],[7,24,0,-1],[22,16,0,-1],[17,16,0,-1],[15,17,1],
  [20,23,7,-1],[15,23,7],[17,16,0,-1],[13,17,1],[13,25,1,-1],[15,16,1,-1],[16,15,0],[22,15,0],
  [15,15,0],[16,23,8],[15,15,0],[15,2,-8],[7,35,9,-2],[28,2,-8],[17,13,-11,-1],[22,16,1],
  [13,48,82,117,151,185,220,254,
  289,323,358,392,427,461,496,530],[47,92,137,182,226,271,316,361],[568,392]]});
org.mathdox.formulaeditor.MathCanvas.addFont(298, 
{bbold10:[[21,29,0,-3],[23,29,0,-1],[24,30,1,-2],[23,29,0,-1],[23,29,0,-2],[21,29,0,-3],[24,29,0,-2],[23,29,0,-1],
  [24,29,0,-2],[23,29,0,-1],[24,29,0,-2],[21,20,1,-1],[20,38,8,-2],[18,27,9,-1],[18,31,1,-1],[18,20,1,-1],
  [14,37,8,-2],[20,27,8,-2],[18,31,1,-1],[8,18,0,-2],[20,18,0,-2],[18,29,0,-1],[20,26,8,-2],[18,18,0,-2],
  [14,37,8,-2],[19,18,0,-1],[18,27,8,-2],[21,19,1,-1],[17,18,0,-1],[18,19,1,-2],[17,37,8,-1],[18,26,8,-1],
  [18,37,8,-2],[9,30,1,-2],[21,17,-13,-1],[28,37,8,-2],[21,36,4,-2],[23,46,14,-1],[28,30,1,-2],[9,17,-13,-1],
  [11,42,11,-3],[11,42,11,-1],[25,28,4,-2],[28,28,4,-2],[9,16,8,-1],[14,2,-8,-1],[9,9,1,-1],[21,42,11,-1],
  [19,28,1,-2],[19,27,0,-2],[19,27,0,-2],[19,28,1,-2],[19,27,0,-2],[19,28,1,-2],[19,28,1,-2],[19,27,0,-2],
  [19,28,1,-2],[19,28,1,-2],[9,20,1,-1],[9,27,8,-1],[28,23,1,-3],[9,9,-6,-1],[28,23,1,-3],[21,30,1,-2],
  [19,30,1,-2],[23,29,0,-1],[21,29,0,-3],[24,30,1,-2],[24,29,0,-3],[21,29,0,-3],[21,29,0,-3],[24,30,1,-2],
  [24,29,0,-3],[8,29,0,-3],[21,30,1,-2],[21,29,0,-3],[21,29,0,-3],[23,29,0,-3],[24,29,0,-3],[24,30,1,-2],
  [21,29,0,-3],[24,37,8,-2],[21,29,0,-3],[21,30,1,-2],[23,29,0,-1],[24,30,1,-3],[23,29,0,-1],[33,29,0,-1],
  [24,29,0,-2],[23,29,0,-1],[24,29,0,-2],[11,42,11,-3],[21,42,11,-1],[11,42,11,-1],[11,42,11,-3],[11,42,11,-1],
  [9,16,-13,-1],[18,20,1,-1],[23,30,1,-2],[18,20,1,-1],[18,30,1,-1],[18,20,1,-1],[14,30,0,-2],[18,28,9,-1],
  [20,29,0,-2],[9,28,0,-1],[15,37,9],[20,29,0,-2],[8,29,0,-2],[26,19,0,-2],[20,19,0,-2],[18,20,1,-1],
  [23,27,8,-2],[18,27,8,-1],[20,19,0,-2],[14,20,1,-1],[14,30,1,-2],[18,19,1,-2],[18,18,0,-1],[26,18,0,-1],
  [18,18,0,-1],[18,27,9,-1],[18,18,0,-1],[16,2,-10,-1],[8,42,11,-3],[32,2,-10,-1],[21,16,-13,-1],[26,19,1,-1],
  [16,57,98,140,181,222,263,304,
  346,387,428,469,511,552,593,634],[56,110,163,217,271,325,378,432],[680,469]]});
org.mathdox.formulaeditor.MathCanvas.addFont(358, 
{bbold10:[[25,34,0,-4],[28,34,0,-1],[29,36,1,-2],[28,34,0,-1],[29,34,0,-2],[25,34,0,-4],[29,34,0,-2],[28,35,0,-1],
  [29,34,0,-2],[28,34,0,-1],[29,35,0,-2],[26,23,1,-1],[24,46,10,-2],[21,33,11,-1],[21,37,1,-1],[21,23,1,-1],
  [18,45,10,-2],[24,32,10,-2],[21,37,1,-1],[9,22,0,-2],[24,22,0,-2],[21,35,0,-1],[24,32,10,-2],[22,22,0,-2],
  [18,45,10,-2],[23,22,0,-1],[22,32,10,-2],[26,23,1,-1],[21,22,0,-1],[22,23,1,-2],[21,45,10,-1],[21,32,10,-1],
  [22,45,10,-2],[10,35,1,-3],[24,20,-16,-2],[34,44,10,-2],[26,43,5,-2],[27,55,17,-2],[34,36,1,-2],[10,20,-16,-2],
  [13,51,13,-4],[13,51,13,-1],[30,34,5,-2],[34,34,5,-2],[10,19,10,-2],[17,3,-9,-1],[10,10,1,-2],[25,51,13,-1],
  [23,34,1,-2],[23,32,0,-2],[23,33,0,-2],[23,34,1,-2],[23,32,0,-2],[23,33,1,-2],[23,34,1,-2],[23,32,0,-2],
  [23,34,1,-2],[23,34,1,-2],[10,23,1,-2],[10,32,10,-2],[33,27,1,-4],[10,11,-7,-2],[33,27,1,-4],[26,36,1,-2],
  [23,36,1,-2],[28,34,0,-1],[25,34,0,-4],[29,36,1,-2],[28,34,0,-4],[25,34,0,-4],[25,34,0,-4],[29,36,1,-2],
  [28,34,0,-4],[9,34,0,-4],[26,35,1,-2],[25,34,0,-4],[25,34,0,-4],[28,34,0,-4],[28,34,0,-4],[29,36,1,-2],
  [25,34,0,-4],[29,45,10,-2],[25,34,0,-4],[26,36,1,-2],[28,34,0,-1],[28,35,1,-4],[28,34,0,-1],[39,34,0,-1],
  [29,34,0,-2],[28,34,0,-1],[29,34,0,-2],[13,51,13,-4],[25,51,13,-1],[13,51,13,-1],[13,51,13,-4],[13,51,13,-1],
  [10,20,-15,-2],[21,23,1,-1],[28,36,1,-2],[21,23,1,-1],[21,36,1,-1],[21,23,1,-1],[18,36,0,-2],[21,33,11,-1],
  [24,35,0,-2],[10,34,0,-2],[18,45,11],[24,35,0,-2],[9,35,0,-2],[32,22,0,-2],[24,22,0,-2],[21,23,1,-1],
  [28,32,10,-2],[21,32,10,-1],[24,22,0,-2],[17,23,1,-1],[18,36,1,-2],[22,23,1,-2],[21,22,0,-1],[31,22,0,-1],
  [21,22,0,-1],[21,33,11,-1],[21,22,0,-1],[20,2,-12,-1],[9,51,13,-4],[39,2,-12,-1],[24,20,-15,-2],[31,23,1,-1],
  [19,69,118,168,217,267,316,366,
  415,465,514,564,614,663,713,762],[66,130,195,260,324,389,453,518],[816,563]]});
org.mathdox.formulaeditor.MathCanvas.addFont(430, 
{bbold10:[[31,41,0,-4],[34,41,0,-1],[34,43,1,-3],[34,41,0,-1],[34,41,0,-3],[31,41,0,-4],[34,41,0,-3],[34,42,0,-1],
  [34,41,0,-3],[34,41,0,-1],[34,42,0,-3],[31,28,1,-1],[28,54,12,-3],[26,39,13,-1],[26,43,1,-1],[26,28,1,-1],
  [20,54,12,-3],[28,39,12,-3],[26,43,1,-1],[11,26,0,-3],[28,26,0,-3],[26,42,0,-1],[28,38,12,-3],[25,26,0,-3],
  [20,54,12,-3],[28,26,0,-1],[25,39,12,-3],[31,27,1,-1],[26,26,0,-1],[25,27,1,-3],[26,54,12,-1],[26,38,12,-1],
  [26,54,12,-3],[12,42,1,-4],[29,23,-19,-2],[40,53,12,-3],[30,51,5,-3],[32,66,20,-2],[40,43,1,-3],[12,23,-19,-2],
  [16,60,15,-4],[16,60,15,-1],[35,40,5,-3],[40,40,5,-3],[12,23,12,-2],[21,3,-11,-1],[12,12,1,-2],[31,60,15,-1],
  [27,40,1,-3],[27,39,0,-3],[27,39,0,-3],[27,40,1,-3],[27,39,0,-3],[27,40,1,-3],[27,40,1,-3],[27,39,0,-3],
  [27,40,1,-3],[27,40,1,-3],[12,28,1,-2],[12,39,12,-2],[41,33,2,-4],[12,12,-9,-2],[41,33,2,-4],[30,43,1,-3],
  [27,43,1,-3],[34,41,0,-1],[31,41,0,-4],[34,43,1,-3],[34,41,0,-4],[31,41,0,-4],[31,41,0,-4],[34,43,1,-3],
  [34,41,0,-4],[11,41,0,-4],[30,42,1,-3],[31,41,0,-4],[31,41,0,-4],[34,41,0,-4],[34,41,0,-4],[34,43,1,-3],
  [31,41,0,-4],[34,54,12,-3],[31,41,0,-4],[30,43,1,-3],[34,41,0,-1],[34,42,1,-4],[34,41,0,-1],[47,41,0,-1],
  [34,41,0,-3],[34,41,0,-1],[34,41,0,-3],[16,60,15,-4],[31,60,15,-1],[16,60,15,-1],[16,60,15,-4],[16,60,15,-1],
  [12,23,-19,-2],[26,28,1,-1],[33,43,1,-3],[26,28,1,-1],[26,43,1,-1],[26,28,1,-1],[20,42,0,-3],[26,40,13,-1],
  [28,42,0,-3],[12,41,0,-2],[21,54,13],[28,42,0,-3],[11,42,0,-3],[37,27,0,-3],[28,27,0,-3],[26,28,1,-1],
  [33,39,12,-3],[26,39,12,-1],[28,27,0,-3],[21,28,1,-1],[20,43,1,-3],[25,27,1,-3],[26,26,0,-1],[37,26,0,-1],
  [26,26,0,-1],[26,39,13,-1],[26,26,0,-1],[24,3,-14,-1],[11,60,15,-4],[47,3,-14,-1],[29,23,-19,-2],[37,27,1,-1],
  [23,82,142,201,261,320,380,439,
  499,558,618,677,737,796,856,915],[79,157,234,312,389,467,544,622],[980,675]]});
});

  $package("org.mathdox.formulaeditor.options");

$identify("org/mathdox/formulaeditor/Options.js");

// currently only org.mathdox.formulaeditor.options should be created
// further functions could be placed in an org.mathdox.formulaeditor.options
// record.

// ancientOrbeon: if set to true: do not warn about old orbeon
// contextParsingExpression: set to an object describing the context for the ExpressionParser
// debug: is debug enabled ?
// decimalMark: character for decimal mark
// - '.' : use period as in US
// - ',' : use comma as in Europe
// dragPalette: if set to true: enable draggable Palette
// fontSize: set font size 
// paletteHighlight: highlight Palette
// - true (default): highlight Palette onmouseover
// - false: do not highlight Palette
// indentXML: indent created XML
// inputStyle: set default style for Editor Canvases
// modeArith1Divide: set mode for handling arith1.divide
// - normal: automatically put unary minus and times expressions as enumerators
// - restricted: only parse power and higher priority (default)
// optionArith1PowerInversePrefix
// - true : allow sin^-1(x) -> arcsin(x)
// - false : (default)
// optionArith1PowerPrefix
// - true : allow sin^2(x)
// - false : (default)
// optionArith1UnaryMinusBrackets
// - true: lower priority unary_minus, e.g. 1 + (-2)
// - false: "normal" priority unary_minus e.g. 1 + -2 (default)
// optionInterval1Brackets
// - object with 4 strings
//   lo: left symbol for left-open interval
//   lc: left symbol for left-closed interval
//   ro: right symbol for right-open interval
//   rc: right symbol for right-closed interval
//   default: { lo: "(", lc: "[", ro: ")", rc: "]" }
// optionListSeparatorFixed
// - list separator for non-editable lists
//   default : same as getListSeparator()
// optionResizeBrackets
// - true : use Bracketed when loading openmath
// - false : do not use Bracketed
//   NOTE: Bracketed can only be deleted completely.
// optionVerboseStyle
// - "true": add style to divide and times
// - "false": (default)
// onloadFocus: set focus on load 
// - true gives focus to the first formulaeditor
// - <id> as string gives focus to the formulaeditor corresponding to the
//   textarea with id <id>
// paletteShow : default behaviour when showing palettes, choices : 
// - "all" gives a palette if not specified by class
// - "none" gives no palette if not specified by class
// - "one" (default) gives a palette if not specified by class when there
//   is none in the page yet, 
// paletteStyle: set default style for Palette Canvases
// paletteURL: url for palette
// styleArith1Times: behavior for times symbol
// - "dot" show a middle dot (default)
// - "cross" show a cross
// - "star" show an asterisk
// styleTransc1Log: behavior for logarithm symbol
// - "function" log(10, x)
// - "prefix"   ^10 log (x)
// - "postfix"  log_10(x)
// undo: whether to enable experimental undo
// - true (default): enable undo
// - false: disable undo
// useBar : enable Bar to turn palette on/off
// - true (default): enable bar
// - false: disable bar

$main(function() {
  org.mathdox.formulaeditor.Options = $extend(Object, {
    defaultOptions : {
      debug: false,
      decimalMark: '.',
      featureUndo: true,
      modeArith1Divide: 'restricted',
      optionVerboseStyle: 'false',
      optionArith1UnaryMinusBrackets : 'false',
      optionInterval1Brackets : {lo: '(', lc: '[', ro: ')', rc:']'},
      optionResizeBrackets: true,
      styleArith1Divide: 'mfrac',
      styleArith1Times: 'dot',
      styleTransc1Log: 'function',
      symbolArith1Times: '·' // U+00B7 Middle dot
    },
    getOption : function(name) {
      if (org.mathdox.formulaeditor.options[name] !== undefined) {
        return org.mathdox.formulaeditor.options[name];
      } else if (this.defaultOptions[name] !== undefined) {
        return this.defaultOptions[name];
      } else {
	return null;
      }
    },
    getArith1DivideMode : function () {
      var option = this.getOption("modeArith1Divide");

      if (option == 'normal' || option == 'restricted' || option == 'inline') {
      	return option;
      } else {
        return "restricted";
      }
    },
    /*
    getArith1DivideSymbol : function () {
      if (option == 'colon') {
        return ':'; // normal colon, 
        // NOTE: it might be better to return U+2236 ratio, but that would be
        // confusing to the user
      } else if (option == 'div') {
        return '÷'; // U+00F7 is division sign 
      } else if (option == 'slash') {
        return '∕'; // U+2215 is division slash
      } else {
        return '∕'; // U+2215 is division slash
      }
    }, */
    getArith1PowerOptionInversePrefix : function () {
      var option = this.getOption("optionArith1PowerInversePrefix");

      if (option == 'true') {
      	return "true";
      } else {
        return "false";
      }
    },
    getArith1PowerOptionPrefix : function () {
      var option = this.getOption("optionArith1PowerPrefix");

      if (option == 'true') {
      	return "true";
      } else {
        return "false";
      }
    },
    getArith1TimesStyle : function () {
      var option = this.getOption("styleArith1Times");

      if (option == 'dot' || option == 'cross' || option == 'star') {
	return option;
      }

      return this.defaultOptions.styleArith1Times;
    },
    getArith1TimesSymbol : function () {
      var option = this.getOption("styleArith1Times");

      if (option == 'dot') {
        return '·'; // U+00B7 Middle dot
      } else if (option == 'cross') {
        return '×'; // U+00D7 is cross
      } else if (option == 'star') {
        return '*';
      }
      return this.defaultOptions.symbolArith1Times;
    },
    getArith1UnaryMinusOptionBrackets : function() {
     var option = this.getOption("optionArith1UnaryMinusBrackets");

      if (option == 'true') {
      	return "true";
      } else {
        return "false";
      }
    },
    getDecimalMark: function() {
      var mark = this.getOption("decimalMark");
      if (mark === '.' || mark === ',') {
        return mark;
      } else { 
        // use default 
        return this.defaultOptions.decimalMark;
      }
    },
    getInterval1BracketsOption: function() {
     var option = this.getOption("optionInterval1Brackets");

      if (typeof option === "object" && typeof option.lo === "string" && typeof option.lc === "string" && typeof option.ro === "string" && typeof option.rc === "string") {
      	return option;
      } else {
        console.log("ERROR: invalid option for Interval1Brackets: "+option);
	return this.defaultOptions.optionInterval1Brackets;
      }
    },
    getListSeparator : function() {
      var mark = this.getDecimalMark();
      
      if (mark === '.') {
        return ',';
      } else if (mark === ',') {
        return ';';
      } else { // should not happen
        alert("Options: unable to get listseparator.");
        return null;
      }
    },
    getListSeparatorFixed : function() {
      var option = this.getOption("optionListSeparatorFixed");
      var sep = this.getListSeparator();
      
      if (option !== null) {
	return option;
      } else {
	return sep;
      }
    },
    getResizeBracketsOption : function() {
      var option = this.getOption("optionResizeBrackets");

      if (option == true || option == false) {
        return option;
      } 

      return this.defaultOptions.optionResizeBrackets;
    },

    getTransc1LogStyle : function () {
      var option = this.getOption("styleTransc1Log");

      if (option == 'prefix' || option == 'postfix' || option == 'function') {
        return option;
      } 

      return this.defaultOptions.styleTransc1Log;
    },
    getVerboseStyleOption : function() {
      var option = this.getOption("optionVerboseStyle");

      if (option == 'true' || option == 'false') {
        return option;
      } 

      return this.defaultOptions.optionVerboseStyle;
    },

    getExpressionParsingContext: function() {
      return {
        decimalMark                    : this.getDecimalMark(),
        listSeparator                  : this.getListSeparator(),
        optionArith1DivideMode         : this.getArith1DivideMode(),
        optionArith1PowerInversePrefix : this.getArith1PowerOptionInversePrefix(),
        optionArith1PowerPrefix        : this.getArith1PowerOptionPrefix(),
        optionArith1UnaryMinusBrackets : this.getArith1UnaryMinusOptionBrackets(),
        styleTransc1Log                : this.getTransc1LogStyle(),
        symbolArith1Times              : this.getArith1TimesSymbol()
      };
    },

    getPresentationContext: function() {
      return {
        decimalMark                    : this.getDecimalMark(),
        listSeparator                  : this.getListSeparator(),
        listSeparatorFixed             : this.getListSeparatorFixed(),
        modeArith1Divide               : this.getArith1DivideMode(),
        optionArith1UnaryMinusBrackets : this.getArith1UnaryMinusOptionBrackets(),
        optionInterval1Brackets        : this.getInterval1BracketsOption(),
        optionResizeBrackets           : this.getResizeBracketsOption(),
        styleTransc1Log                : this.getTransc1LogStyle(),
        symbolArith1Times              : this.getArith1TimesSymbol()
      };
    }
  });
});


  $identify("org/mathdox/formulaeditor/OrbeonForms.js");

$require("org/mathdox/formulaeditor/FormulaEditor.js");

var ORBEON;

$main(function(){

  if (ORBEON && ORBEON.xforms && ORBEON.xforms.Document) {

    /**
     * Extend the save function of the formula editor to use the orbeon update
     * mechanism, see also:
     * http://www.orbeon.com/ops/doc/reference-xforms-2#xforms-javascript
     */
    org.mathdox.formulaeditor.FormulaEditor =
      $extend(org.mathdox.formulaeditor.FormulaEditor, {

        save : function() {

          // call the parent function
          arguments.callee.parent.save.apply(this, arguments);

          // let orbeon know about the change of textarea content
          var textarea = this.textarea;
          if (textarea.id) {
            ORBEON.xforms.Document.setValue(textarea.id, textarea.value);
          }

        }

    });

    /**
     * Override Orbeon's xformsHandleResponse method so that it initializes any
     * canvases that might have been added by the xforms engine.
     */

    /* prevent an error if the xformsHandleResponse doesn't exist */
    var xformsHandleResponse;

    var oldXformsHandleResponse;
    var newXformsHandleResponse;
    var ancientOrbeon;
    
    if (xformsHandleResponse) {
      oldXformsHandleResponse = xformsHandleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponse) {
      oldXformsHandleResponse = ORBEON.xforms.Server.handleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponseDom) {
      oldXformsHandleResponse = ORBEON.xforms.Server.handleResponseDom;
    } else if (ORBEON.xforms.server && ORBEON.xforms.server.AjaxServer && ORBEON.xforms.server.AjaxServer.handleResponseDom) {
      // orbeon 3.9
      oldXformsHandleResponse = ORBEON.xforms.server.AjaxServer.handleResponseDom;
    } else {
      if (org.mathdox.formulaeditor.options.ancientOrbeon !== undefined &&
        org.mathdox.formulaeditor.options.ancientOrbeon == true) {
	ancientOrbeon = true;
      } else {
	ancientOrbeon = false;
        alert("ERROR: detected orbeon, but could not add response handler");
      }
    }
    newXformsHandleResponse = function(request) {

      // call the overridden method
      if (ancientOrbeon != true ) {
        oldXformsHandleResponse.apply(this, arguments);
      }

      // go through all canvases in the document
      var canvases = document.getElementsByTagName("canvas");
      for (var i=0; i<canvases.length; i++) {

        // initialize a FormulaEditor for each canvas
        var canvas = canvases[i];
        if (canvas.nextSibling) {
          if (canvas.nextSibling.tagName.toLowerCase() == "textarea") {

            var FormulaEditor = org.mathdox.formulaeditor.FormulaEditor;
            var editor = new FormulaEditor(canvas.nextSibling, canvas);

            // (re-)load the contents of the textarea into the editor
            editor.load();

          }

        }

      }
      
    };
    
    if (xformsHandleResponse) {
      xformsHandleResponse = newXformsHandleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponse) {
      ORBEON.xforms.Server.handleResponse = newXformsHandleResponse;
    } else if (ORBEON.xforms.Server && ORBEON.xforms.Server.handleResponseDom) {
      ORBEON.xforms.Server.handleResponseDom = newXformsHandleResponse;
    } else if (ORBEON.xforms.server && ORBEON.xforms.server.AjaxServer && ORBEON.xforms.server.AjaxServer.handleResponseDom) {
      ORBEON.xforms.server.AjaxServer.handleResponseDom = newXformsHandleResponse;
    } 

  }

});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/Palettes.js");

$main(function(){
  org.mathdox.formulaeditor.Palettes = {
    /**
     * The palettestring
     */
    defaultPalette: ""+
"<OMOBJ version='2.0' xmlns='http://www.openmath.org/OpenMath'>\n"+
"  <OMA>\n"+
"    <OMS cd='editor1' name='palette'/>\n"+
"    <OMA>\n"+
"      <OMS cd='editor1' name='palette_tab'/>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMS cd='arith1' name='plus'/>\n"+
"        <OMS cd='arith1' name='minus'/>\n"+
"        <OMS cd='arith1' name='times'/>\n"+
"        <OMS cd='logic1' name='and'/>\n"+
"        <OMS cd='logic1' name='or'/>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='cos'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='root'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMI>2</OMI>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"calculus1\" name=\"int\"/>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"x\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"calculus1\" name=\"defint\"/>\n"+
"          <OMA>\n"+
"            <OMS cd=\"interval1\" name=\"interval\"/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"x\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMS cd='editor1' name='palette_whitespace'/>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_cc'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMS cd='relation1' name='lt'/>\n"+
"        <OMS cd='relation1' name='leq'/>\n"+
"        <OMS cd='relation1' name='eq'/>\n"+
"        <OMS cd='relation1' name='geq'/>\n"+
"        <OMS cd='relation1' name='gt'/>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='sin'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='root'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"arith1\" name=\"product\"/>\n"+
"          <OMA>\n"+
"            <OMS cd=\"interval1\" name=\"integer_interval\"/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"n\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd=\"arith1\" name=\"sum\"/>\n"+
"            <OMA>\n"+
"              <OMS cd=\"interval1\" name=\"integer_interval\"/>\n"+
"              <OMS cd='editor1' name='input_box'/>\n"+
"              <OMS cd='editor1' name='input_box'/>\n"+
"            </OMA>\n"+
"          <OMBIND>\n"+
"            <OMS cd=\"fns1\" name=\"lambda\"/>\n"+
"            <OMBVAR>\n"+
"              <OMV name=\"n\"/>\n"+
"            </OMBVAR>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMBIND>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg1' name='determinant'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_co'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMS cd='nums1' name='pi'/>\n"+
"        <OMS cd='nums1' name='e'/>\n"+
"        <OMS cd='nums1' name='i'/>\n"+
"        <OMS cd='nums1' name='infinity'/>\n"+
"        <OMS cd='editor1' name='palette_whitespace'/>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='tan'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='list1' name='list'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='vector'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_oc'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"      <OMA>\n"+
"        <OMS cd='editor1' name='palette_row'/>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='divide'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='power'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='abs'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='integer1' name='factorial'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='arith1' name='power'/>\n"+
"          <OMS cd='nums1' name='e'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='ln'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='transc1' name='log'/>\n"+
"          <OMI>10</OMI>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='vector'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"          <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='linalg2' name='matrix'/>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"          <OMA>\n"+
"            <OMS cd='linalg2' name='matrixrow'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"            <OMS cd='editor1' name='input_box'/>\n"+
"          </OMA>\n"+
"        </OMA>\n"+
"        <OMA>\n"+
"          <OMS cd='interval1' name='interval_oo'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"  	  <OMS cd='editor1' name='input_box'/>\n"+
"        </OMA>\n"+
"      </OMA>\n"+
"    </OMA>\n"+
"  </OMA>\n"+
"</OMOBJ>\n"+
  ""};
});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/Services.js");

// load XMLHttpRequest methods
$require("com/oreilly/javascript/tdg/XML.js");
$require("com/oreilly/javascript/tdg/XMLHttp.js");

$main(function(){

  /**
   * Class that represents calls to services
   */
  org.mathdox.formulaeditor.Services = {
    url : "/phrasebook/",

    perform : function (service, action, data, callback) {
      var HTTP = com.oreilly.javascript.tdg.XMLHttp;
      var xmlValueOf = this.xmlValueOf;
      var onreturn = function(result) {
        /* 
          check if the result was ok 
          if it was call the callback function with the data
          otherwise show an alert window with the error message
        */
	var xmlData = com.oreilly.javascript.tdg.XML.parse(result);
	
        var statusNodeList = xmlData.documentElement.getElementsByTagName(
	  "status");
        if (statusNodeList.length === 0) {
          alert("Error: no status element found in service response");
          return;
        }
        var statusText = xmlValueOf(statusNodeList.item(0));

        if (statusText != "ok") { /* error */
          var errorNodeList = xmlData.documentElement.getElementsByTagName(
	    "error");
          var errorText = xmlValueOf(errorNodeList.item(0));
        
          alert("ERROR (while using service " + service + "/" + action + 
            "): " + errorText);
          return;
        } 
        
        /* everything went ok */
        var resultNodeList = xmlData.documentElement.getElementsByTagName(
	  "data");

        callback(xmlValueOf(resultNodeList.item(0)));
      };
      var values = {
        output: "xml",
        service: service,
        action: action,
        data: data
      };
      HTTP.post(this.url, values, onreturn); 
    },

    openmath2gap : function(openmath, callback) {
      return this.perform("gap", "translate_openmath_native", openmath, 
        callback);
    },

    /* 
      function like xsl:value-of, converts an XML element to the contained 
      text 
    */
    xmlValueOf : function(node) {
      var i;
      var buffer = []; // use a buffer for efficiency
     
      switch (node.nodeType) {
        case 1: // ELEMENT_NODE
          for (i=0; i<node.childNodes.length; i++) {
            buffer.push(arguments.callee(node.childNodes[i]));
          }
          return buffer.join("");
        case 2: // ATTRIBUTE_NODE
        case 3: // TEXT_NODE
        case 4: // CDATA_SECTION_NODE
          return node.nodeValue;
        case 7: // PROCESSING_INSTRUCTION_NODE
          return "";
        case 8: // COMMENT_NODE
          return "";
        case 9: // DOCUMENT_NODE
          return arguments.callee(node.Element);
        case 10: // DOCUMENT_TYPE_NODE
          return "";
        case 11: // DOCUMENT_FRAGMENT_NODE
          return "";
      }
      return "";
    }
  };
});


  
$identify("org/mathdox/formulaeditor/modules/arith1/minus.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "-",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>-</mo>"
  };

  /**
   * Define a semantic tree node that represents arith1.minus.
   */
  org.mathdox.formulaeditor.semantics.Arith1Minus =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='arith1' name='minus'/>",
        mathml   : symbol.mathml

      },

      associative : false,
      precedence : 120

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for arith1.minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleArith1Minus : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Arith1Minus();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__minus"] = new org.mathdox.formulaeditor.semantics.Keyword("arith1", "minus", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "-" == "-" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression120 = minus | super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1minus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1minus = 
      //    expression120 "-" expression130
      arith1minus : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression120"),
              pG.literal("-"),
              pG.rule("expression130")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Arith1Minus(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression120 = arith1minus | 
      //   super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1minus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1minus = 
      //    expression120 ("-"|"-") expression130
      arith1minus : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression120"),
  	    pG.alternation(
  	      pG.literal("-"),
  	      pG.literal("-")
  	    ),
              pG.rule("expression130")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Arith1Minus(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/arith1/plus.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "+",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>+</mo>",
    mathml_invisible : ( "⁤" != "" ? "<mo>⁤</mo>" : null )
  };

  /**
   * Define a semantic tree node that represents arith1.plus.
   */
  org.mathdox.formulaeditor.semantics.Arith1Plus =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='arith1' name='plus'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 120

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for arith1.plus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleArith1Plus : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Arith1Plus();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__plus"] = new org.mathdox.formulaeditor.semantics.Keyword("arith1", "plus", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "+" == "+" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression120 = plus | super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1plus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1plus = 
      //    expression120 "+" expression130
      arith1plus :
        pG.transform(
          pG.concatenation(
            pG.rule("expression120"),
            pG.literal("+"),
            pG.rule("expression130"),
            pG.repetition(
              pG.concatenation(
                pG.literal("+"),
                pG.rule("expression130")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Arith1Plus();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Arith1Plus && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression120 = arith1plus | 
      //   arith1plusalt | super.expression120
      expression120 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("arith1plus"),
          parent.expression120).apply(this, arguments);
      },

      // arith1plus = 
      //    expression120 "+" expression130
      arith1plus :
        pG.transform(
          pG.concatenation(
            pG.rule("expression120"),
	    pG.alternation(
	      pG.literal("+"),
	      pG.literal("+")
	    ),
            pG.rule("expression130"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("+"),
	          pG.literal("+")
	        ),
                pG.rule("expression130")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Arith1Plus();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Arith1Plus) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/abs.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.Abs =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        mathml   : ["<mo>|</mo>","","<mo>|</mo>"],
        onscreen : ["|","","|"],
        openmath : "<OMS cd='arith1' name='abs'/>"

      },

      precedence : 0

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.abs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns an absolute value object based on the OpenMath node.
      */
      handleArith1Abs : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Abs(operand);

      }

    });

  /**
   * Add parsing code for absolute values.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression160 = abs | super.expression160
        expression160 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("abs"),
            parent.expression160).apply(this, arguments);
        },

        // abs = "|" expression "|"
        abs :
          pG.transform(
            pG.concatenation(
              pG.literal("|"),
              pG.rule("expression"),
              pG.literal("|")
            ),
            function(result) {
              return new semantics.Abs(result[1]);
            }
          )
        };
      });

});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/divide.js");

$require("org/mathdox/formulaeditor/modules/arith1/plus.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Fraction.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a division.
   */
  org.mathdox.formulaeditor.semantics.Divide =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {
        openmath : "<OMS cd='arith1' name='divide'/>"
      },

      style: "mfrac",

      //precedence : 160,
      precedence : 170,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        return new presentation.Fraction(
          new presentation.Row(this.operands[0].getPresentation(context)),
          new presentation.Row(this.operands[1].getPresentation(context))
        );

      },

      getSymbolOpenMath : function() {
        var options = new org.mathdox.formulaeditor.Options();
        var result;
        if (options.getVerboseStyleOption() == "true") {
          var arr = this.symbol.openmath.split("/");
          result = arr.join(" style='" + this.style  + "'/");
        } else {
          result = this.symbol.openmath;
        }
        return result;
      },

      getMathML : function() {
        return "<mfrac>" +
          this.operands[0].getMathML() +
          this.operands[1].getMathML() +
          "</mfrac>";
      }

  });
  
  org.mathdox.formulaeditor.semantics.DivideInline =
    $extend(org.mathdox.formulaeditor.semantics.Divide, {
      //precedence : 130,
      precedence : 140,

      style: "colon",
      
      symbol : {
        mathml: "<mo>:</mo>",
	onscreen: ":",
        openmath : "<OMS cd='arith1' name='divide'/>"
      },

      getMathML : function() {
	// parent = Divide, parent.parent is MultaryOperation
	// use the default MultaryOperation method
        return arguments.callee.parent.getMathML.parent.getMathML.call(this);
      },

      getPresentation : function() {
	// parent = Divide, parent.parent is MultaryOperation
	// use the default MultaryOperation method
        return arguments.callee.parent.getPresentation.parent.getPresentation.call(this, arguments);
      }

  });


  /**
  * Extend the OpenMathParser object with parsing code for arith1.divide.
  */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Divide object based on the OpenMath node.
      */
      handleArith1Divide : function(node) {

        // parse the left and right operands
        var children = node.childNodes;
        var left  = this.handle(children.item(1));
        var right = this.handle(children.item(2));

        // construct a divide object
	var result;

	if (node.getAttribute("style") == "colon") {
          result = new org.mathdox.formulaeditor.semantics.DivideInline(left, right);
	} else {
          result = new org.mathdox.formulaeditor.semantics.Divide(left, right);
	}

        return result;
      }
  });

  /**
   * Add the parsing code for division.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( function(context) { 
    return {

      // expression130 = divide_inline | super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("divide_inline"),
          parent.expression130).apply(this, arguments);
      },

      // expression160 = divide | divide_silent_addition | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("divide"),
          pG.rule("divide_silent_addition"),
          parent.expression160).apply(this, arguments);
      },

      // divide = never
      divide : pG.never,

      // divide_inline = expression130 ":" expression140
      divide_inline :
        pG.transform(
          pG.concatenation(
            pG.rule("expression130"),
            pG.literal(':'),
            pG.rule("expression140")
          ),
          function(result) {
            return new semantics.DivideInline(result[0], result[2]);
          }
        ),

      divide_silent_addition : 
        pG.transform(
          pG.concatenation(
            pG.rule("integer"),
            pG.rule("divide")),
          function(result) {
            var semantics = org.mathdox.formulaeditor.semantics; 
            var plus = new semantics.Arith1Plus(result[0],result[1]);
            plus.style="invisible";
            return plus;
          }
        ),

      // parseNumber = divide | divide_silent_addition | parseNumber
      parseNumber : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("divide"),
          pG.rule("divide_silent_addition"),
          parent.parseNumber).apply(this, arguments);
      }
    };
  });


  /**
   * Add a key handler for the '/' and '%' keys.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the '/' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the '/' key has been pressed
          if (String.fromCharCode(event.charCode) == "/") {

            var Fraction = org.mathdox.formulaeditor.presentation.Fraction;
            var index    = editor.cursor.position.index;
            var length   = this.children.length;

	    // search for an expression of precedence level 130 (or 150 if
	    // restricted) to the left of the cursor, and of level 150 to the
	    // right of the cursor
	    var leftexpr;

	    if (editor.getExpressionParsingContext().optionArith1DivideMode == 'restricted') {
	      leftexpr = "expression150";
	    } else { // 'normal'
	      leftexpr = "expression130";
	    }
	    var parsedleft = this.getSemantics(editor.getExpressionParsingContext(), 0, index, leftexpr, true);
            var parsedright = this.getSemantics(editor.getExpressionParsingContext(), index, length, "expression150");

            // create the left and right operands of the fraction
            var right = this.remove(index, parsedright.index);
            var left  = this.remove(parsedleft.index,  index);

            // insert the fraction into the row
            this.insert(parsedleft.index, new Fraction(left, right));
            editor.cursor.position = right.getFollowingCursorPosition();

            // update the editor state
            editor.redraw();
            editor.save();
            return false;

          } else if (String.fromCharCode(event.charCode) == "%") {
            var presentation = org.mathdox.formulaeditor.presentation;
            var index    = editor.cursor.position.index;

            // create the fraction
            var fraction = new presentation.Fraction(
              new presentation.Row(new presentation.BlockSymbol()),
              new presentation.Row(new presentation.BlockSymbol()));

            // insert the fraction into the row
            this.insert(index, fraction);

            // move the cursor into the fraction
            editor.cursor.moveRight();
            
            // update the editor state
            editor.redraw();
            editor.save();
            return false;
          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });
    
});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/power.js");

$require("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/semantics/FunctionApplication.js");
$require("org/mathdox/formulaeditor/semantics/Integer.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a power function.
   */
  org.mathdox.formulaeditor.semantics.Power =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        openmath : "<OMS cd='arith1' name='power'/>"

      },

      precedence : 150,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        
        // add braces to base, if necessary

        var base = this.operands[0].getPresentation(context);

        if (this.useBrackets(this.operands[0], base) === true) {
          base = new presentation.Row(new presentation.Symbol("("), base, 
            new presentation.Symbol(")"));
        }
        return new presentation.Row(
          base,
          new presentation.Superscript(
            this.operands[1].getPresentation(context))
        );
      },

      getMathML : function() {
	var Options = new org.mathdox.formulaeditor.Options();

        // add braces to base, if necessary
	// use same method as for presentation (unfortunately this means getting the presentation)

        var basePres = this.operands[0].getPresentation(Options.getPresentationContext());
        var base = this.operands[0].getMathML();

        if (this.useBrackets(this.operands[0], basePres) === true) {
	  // NOTE: nicer would be to add an option bracketed to getMathML of base
	  // no double mrow then
          base = "<mrow><mo>(</mo>" + base + "<mo>)</mo></mrow>";
        }

        return "<msup>" + base +
          this.operands[1].getMathML() +
          "</msup>";
      },

      useBrackets : function(sem, pres) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var semantics = org.mathdox.formulaeditor.semantics;

	var positiveint = (sem instanceof semantics.Integer && sem.value >=0 );

	var brackets = false;

	if (positiveint === true) {
          brackets = false;
	} else if (pres instanceof presentation.Row && pres.children.length > 1) {
          brackets = true;
        } else if (pres instanceof presentation.Root) {
          brackets = true;
        } else if (pres instanceof presentation.Fraction) {
          brackets = true;
        }

        return brackets;
      }
    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.power.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Power object based on the OpenMath node.
      */
      handleArith1Power : function(node) {

        // parse the base and exponent
        var children = node.childNodes;
        var base     = this.handle(children.item(1));
        var exponent = this.handle(children.item(2));

        // construct a Power object
        return new org.mathdox.formulaeditor.semantics.Power(base, exponent);

      }

    });

  /**
   * Add the parsing code for power operations.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { 
      var func_powCheck = function(oper) {
        return false;
      };

      var func_powUpdate = function(oper) {
        return oper;
      };

      var func_powInvCheck = function(oper) {
        return false;
      };

      var func_powInvUpdate = function(oper) {
        return oper;
      };

      var names = [
        "arccos", "arccosh", "arccot", "arccoth", "arccsc", "arccsch",
        "arcsec", "arcsech", "arcsin", "arcsinh", "arctan", "arctanh", "cos",
        "cosh", "cot", "coth", "csc", "csch", /* "exp", "ln", "log", */ "sec",
        "sech", "sin", "sinh", "tan", "tanh"
      ];

      if (context.optionArith1PowerInversePrefix === "true") {
        func_powInvCheck = function(operInput) {
            var oper;
  
            oper = operInput;
            // oper should be a function application
            if (! (oper instanceof semantics.FunctionApplication) ) {
              return false;
            }
  
            // symbol should exist
            if (oper.symbol === undefined || oper.symbol === null) {
              return false;
            } 
  
            oper = oper.symbol;
  
            if (! (oper instanceof semantics.Power) ) {
              return false;
            }
            
            if (!((oper.operands[0] instanceof semantics.Keyword) && oper.operands[0].cd == "transc1")) {
              // base of power is not a transc1 function
              return false;
            }
  
            if (names.indexOf(oper.operands[0].name) === -1 ) {
              return false;
            }

            // exponent should be negative
            if (oper.operands[1] instanceof semantics.Arith1Unary_minus) {
              return true;
            }
  
            return false;
          };
          func_powInvUpdate = function(oper) {
  
            if (func_powInvCheck(oper)) {
              var oldsymbol = oper.symbol.operands[0];
              var oldname = oldsymbol.name;
              var newname;

              if (oldname.substring(0,3) == "arc") {
                newname = oldname.substring(3);
              } else {
                newname = "arc" + oldname;
              }

              var basename = oldsymbol.cd + "__" + newname;
              var base = org.mathdox.formulaeditor.parsing.openmath.KeywordList[basename];

              var negativeExponent = oper.symbol.operands[1]; 
              var exponent = negativeExponent.operands[0]; 

              var power;

              if (exponent instanceof semantics.Integer && exponent.value == 1) {
                power = base;
              } else {
                power = new semantics.Power(base, exponent);
              }

              return new semantics.FunctionApplication(power, oper.operands, oper.style);
            } else {
              return oper;
            }
          };
        } 

      if (context.optionArith1PowerPrefix === "true") {
        func_powCheck = function(operInput) {
          var oper;

          oper = operInput;
          // oper should be a function application
          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          oper = oper.symbol;

          if (! (oper instanceof semantics.Power) ) {
            return false;
          }
          
          if (!((oper.operands[0] instanceof semantics.Keyword) && oper.operands[0].cd == "transc1")) {
            // base of power is not a transc1 function
            return false;
          }

          if (names.indexOf(oper.operands[0].name) === -1 ) {
            return false;
          }

          // exponent should be variable: sin^n (x) or an integer: sin^2(x)
          if ((oper.operands[1] instanceof semantics.Variable) ) {
            return true;
          }

          if ((oper.operands[1] instanceof semantics.Integer) && oper.operands[1].value > 0 ) {
            return true;
          }

          return false;
        };
        func_powUpdate = function(oper) {

          if (func_powCheck(oper)) {
            var symbol = oper.symbol.operands[0];

            var base = new semantics.FunctionApplication(symbol, oper.operands);

            var exponent = oper.symbol.operands[1]; 

            return new semantics.Power(base, exponent);
          } else {
            return oper;
          }
        };
      } 

      return {

      // expression150 = power | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("power"),
          parent.expression150).apply(this, arguments);
      },

      // power = expression160 superscript
      power :
        pG.transform(
          pG.concatenation(
            pG.rule("expression160"),
            pG.rule("superscript")
          ),
          function(result) {
            return new semantics.Power(result[0], result[1]);
          }
        ),
      // note copy from ExpressionParser
      func_Update: function(oper) {
        var parent = arguments.callee.parent;
        return parent.func_Update( func_powUpdate( func_powInvUpdate( oper ) ) );
      },

      
      func_symbol: function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("restrictedpower"),
          parent.func_symbol).apply(this, arguments);
      },

      // useful for invisible multiplication (should not start with a number)
      // restrictedpower = restrictedexpression160 superscript
      restrictedpower :
        pG.transform(
          pG.concatenation(
            pG.rule("restrictedexpression160"),
            pG.rule("superscript")
          ),
          function(result) {
            return new semantics.Power(result[0], result[1]);
          }
        ),

      // superscript = 0
      superscript : pG.never
      };
    });

  /**
   * Add a key handler for the '^' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the '^' key.
       */
      onkeypress : function(event, editor) {
        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the '^' key has been pressed
          if (String.fromCharCode(event.charCode) == "^") {

            var Superscript =
              org.mathdox.formulaeditor.presentation.Superscript;

            var index  = editor.cursor.position.index;
            var length = this.children.length;

            // search for an expression of precedence level 130 to the right of
            // the cursor
            var parsed = this.getSemantics(editor.getExpressionParsingContext(), index, length, "expression130");

            // create the operand of the superscript operation
            var operand = this.remove(index, parsed.index);

            // insert the fraction into the row
            this.insert(index, new Superscript(operand));
            editor.cursor.position = operand.getFollowingCursorPosition();

            // update the editor state
            editor.redraw();
            editor.save();
            return false;

          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });

});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/product.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a product.
   */
  org.mathdox.formulaeditor.semantics.Product =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : integer_interval
      // operand 1 : lambda expression
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        
        return new presentation.Row(
          new presentation.Product(
            new presentation.Row(this.operands[0].operands[1].getPresentation(
              context)),
            new presentation.Row(
              this.operands[1].variables[0].getPresentation(context),
              new presentation.Symbol("="),
              this.operands[0].operands[0].getPresentation(context)
            )
          ),
          new presentation.Symbol("("),
          this.operands[1].expression.getPresentation(context),
          new presentation.Symbol(")")
        );
      
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='arith1' name='product'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
        "</OMA>";
      
      },

      getMathML : function() {
        return "<mrow>"+
	  "<munderover>" +
	  "<mrow>"+
          this.operands[1].variables[0].getMathML() +
          "<mo>=</mo>"+
          this.operands[0].operands[0].getMathML() +
	  "</mrow>"+
          // U+03A0 greek capital letter pi
	  "<mo>Π</mo>"+
          this.operands[0].operands[1].getMathML() +
          "</munderover>"+
          this.operands[1].expression.getMathML() +
	  "</mrow>";
      }
    
    });

  /**
   * Defines an on-screen product.
   */
  org.mathdox.formulaeditor.presentation.Product =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

      /**
       * top and bottom rows are smaller
       */
      fontSizeModifierArray : [-1,0,-1],

      initialize : function(above, below) {

        var parent = arguments.callee.parent;
        // U+03A0 greek capital letter pi
        var pi  = new org.mathdox.formulaeditor.presentation.Symbol("Π");
        return parent.initialize.call(this, above, pi, below);

      },

      copy : function() {
        return this.clone(this.children[0].copy(), this.children[2].copy());
      },

      getSemantics : function(context) {

        var semantics = org.mathdox.formulaeditor.semantics;

        var above = this.children[0].getSemantics(context).value;
        var below = this.children[2].getSemantics(context).value;

        if (below instanceof semantics.Relation1Eq) {

          return {
            value : [below.operands[1], above, below.operands[0]],
            rule  : "product"
          };

        }
        else {

          return null;

        }

      }

  });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.product.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Product object based on the OpenMath node.
       */
      handleArith1Product : function(node) {

        var children = node.childNodes;
        var integer_interval = this.handle(children.item(1));
        var lambda   = this.handle(children.item(2));

	if (lambda.variables.length === 0) {
	  alert("arith1.product needs a nonempty OMBVAR");
	  return null;
	}

        return new org.mathdox.formulaeditor.semantics.Product(integer_interval, lambda);

      }

    });


  /**
   * Add the parsing code for products.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression150 = product expression150 | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.transform(
            pG.concatenation(
              pG.rule("product"),
              pG.rule("expression150")
            ),
            function(result) {

              return new semantics.Product(
                new semantics.Integer_interval(result[0][0], result[0][1]),
                new semantics.Lambda([result[0][2]], result[1])
              );

            }
          ),
          parent.expression150).apply(this, arguments);
      },

      // product = never
      product : pG.never
    };
  });

});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/root.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/presentation/Root.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

$main(function(){

  var semantics = org.mathdox.formulaeditor.semantics;

  /**
   * Defines a semantic tree node that represents a root.
   */
  semantics.Arith1Root =
    $extend(semantics.MultaryOperation, {

      argcount : 2,

      symbol : {

        openmath : "<OMS cd='arith1' name='root'/>"

      },

      precedence : 160,

      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        return new presentation.Root(
          this.operands[0].getPresentation(context),
          this.operands[1].getPresentation(context)
        );
      },

      getMathML : function() {
	var base = this.operands[0];
	var index = this.operands[1];

	// TODO: also generate msqrt if index is integer, value 2
	if (index instanceof semantics.Integer && index && index.value == 2) {
	  // note: inferred mrow, but we might produce one
          return "<msqrt>" + base.getMathML() + "</msqrt>";
	} else {
          return "<mroot>" + base.getMathML() + index.getMathML() + "</mroot>";
	}
      }

  });

  /**
  * Extend the OpenMathParser object with parsing code for arith1.divide.
  */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Root object based on the OpenMath node.
      */
      handleArith1Root : function(node) {

        // parse the left and right operands
        var children = node.childNodes;
        var middle  = this.handle(children.item(1));
        var base  = this.handle(children.item(2));

        // construct a root object
        return new semantics.Arith1Root(middle, base);

      }

  });

  /**
   * Add the parsing code for division.
   */
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression160 = root | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("root"),
          parent.expression160).apply(this, arguments);
      },

      // root = never
      root : pG.never
    };
  });

  org.mathdox.formulaeditor.parsing.expression.KeywordList.rt = {
    parseResultFun : function(oper, array) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var root = new semantics.Arith1Root();
      root.initialize.apply(root, array);

      return root;
    }
  };

  org.mathdox.formulaeditor.parsing.expression.KeywordList.sqrt = {
    parseResultFun : function(oper, array) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var root = new semantics.Arith1Root();
      array.push(new semantics.Integer(2));

      root.initialize.apply(root, array);

      return root;
    }
  };

    org.mathdox.formulaeditor.parsing.expression.KeywordList.rt;


});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/sum.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a sum.
   */
  org.mathdox.formulaeditor.semantics.Sum =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : integer_interval
      // operand 1 : lambda expression
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        
        return new presentation.Row(
          new presentation.Sum(
            new presentation.Row(
              this.operands[0].operands[1].getPresentation(context)),
            new presentation.Row(
              this.operands[1].variables[0].getPresentation(context),
              new presentation.Symbol("="),
              this.operands[0].operands[0].getPresentation(context)
            )
          ),
          new presentation.Symbol("("),
          this.operands[1].expression.getPresentation(context),
          new presentation.Symbol(")")
        );
      
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='arith1' name='sum'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
        "</OMA>";
      
      },

      getMathML : function() {
        return "<mrow>"+
	  "<munderover>" +
	  "<mrow>"+
          this.operands[1].variables[0].getMathML() +
          "<mo>=</mo>"+
          this.operands[0].operands[0].getMathML() +
	  "</mrow>"+
          // U+03A3 greek capital letter sigma
	  "<mo>Σ</mo>"+
          this.operands[0].operands[1].getMathML() +
          "</munderover>"+
          this.operands[1].expression.getMathML() +
	  "</mrow>";
      }
    
    });

  /**
   * Defines an on-screen sum.
   */
  org.mathdox.formulaeditor.presentation.Sum =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

    /**
     * top and bottom rows are smaller
     */
    fontSizeModifierArray : [-1,0,-1],

    initialize : function(above, below) {

      var parent = arguments.callee.parent;
      // U+03A3 greek capital letter sigma
      var sigma  = new org.mathdox.formulaeditor.presentation.Symbol("Σ");
      return parent.initialize.call(this, above, sigma, below);

    },

    copy : function() {
      return this.clone(this.children[0].copy(), this.children[2].copy());
    },

    getSemantics : function(context) {

      var semantics = org.mathdox.formulaeditor.semantics;

        var above = this.children[0].getSemantics(context).value;
        var below = this.children[2].getSemantics(context).value;

        if (below instanceof semantics.Relation1Eq) {

          return {
            value : [below.operands[1], above, below.operands[0]],
            rule  : "sum"
          };

        }
        else {

          return null;

        }

      }

  });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.sum.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Sum object based on the OpenMath node.
       */
      handleArith1Sum : function(node) {

        var children = node.childNodes;
        var integer_interval = this.handle(children.item(1));
        var lambda   = this.handle(children.item(2));

	if (lambda.variables.length === 0) {
	  alert("arith1.sum needs a nonempty OMBVAR");
	  return null;
	}

        return new org.mathdox.formulaeditor.semantics.Sum(integer_interval, lambda);

      }

    });


  /**
   * Add the parsing code for sums.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression150 = sum expression150 | super.expression150
        expression150 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.concatenation(
                pG.rule("sum"),
                pG.rule("expression150")
              ),
              function(result) {

                return new semantics.Sum(
                  new semantics.Integer_interval(result[0][0], result[0][1]),
                  new semantics.Lambda([result[0][2]], result[1])
                );

              }
            ),
            parent.expression150).apply(this, arguments);
        },

        // sum = never
        sum : pG.never
      };
    });

});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/times.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/power.js");

$main(function(){
  /** 
   * describe how this symbol should be presented
   */
  var symbol = {
    // U+00B7 middle dot
    onscreen         : "·",
    openmath         : null,
    // U+00B7 middle dot
    mathml           : "<mo>·</mo>",
    // U+2062 invisible times
    mathml_invisible : "<mo>⁢</mo>"
  };

  /**
   * Defines a semantic tree node that represents a multiplication.
   */
  org.mathdox.formulaeditor.semantics.KeywordTimes =
    $extend(org.mathdox.formulaeditor.semantics.Keyword, {

      getSymbolOnscreen : function(context) {
        return context.symbolArith1Times;
      }

    });

  /**
   * Defines a semantic tree node that represents a multiplication.
   */
  org.mathdox.formulaeditor.semantics.Times =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='arith1' name='times'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible
      },

      getSymbolOnscreen : function(context) {
        return context.symbolArith1Times;
      },

      getSymbolMathML : function() {
        options = new org.mathdox.formulaeditor.Options();
        return "<mo>"+ options.getArith1TimesSymbol() +"</mo>";
      },

      getSymbolOpenMath : function() {
        var options = new org.mathdox.formulaeditor.Options();
	var result;
	if (options.getVerboseStyleOption() == "true") {
	  var arr = this.symbol.openmath.split("/");
          result = arr.join(" style='" + options.getArith1TimesStyle()  + "'/");
	} else {
	  result = this.symbol.openmath;
	}
        return result;
      },

      precedence : 130,
      precedence : 140

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.times.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Times object based on the OpenMath node.
       */
      handleArith1Times : function(node, style) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Times object
        var result = new org.mathdox.formulaeditor.semantics.Times();
        result.initialize.apply(result, operands);
	if (style == "invisible") {
          result.style = style;
        }
        return result;

      }

    });

  /**
   * Add the parsing code for multiplication.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression130 = times | super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("times"),
          parent.expression130).apply(this, arguments);
      },

      // expression150 = times | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("invisibletimes"),
          parent.expression150).apply(this, arguments);
      },

      // invisibletimes = number variable
      invisibletimes:
        pG.transform(
          pG.concatenation(
            pG.rule("parseNumber"),
            pG.alternation(
              pG.rule("restrictedexpression160"),
              pG.rule("restrictedpower")
            )
          ),
          function(result) {
            var times = new semantics.Times(result[0], result[1]);
            times.style = "invisible";
            return times;
          }
        ),

      // times = expression130 "·" expression140
      times :
        pG.transform(
          pG.concatenation(
            pG.rule("expression130"),
            pG.literal(context.symbolArith1Times),
            pG.rule("expression140")
          ),
          function(result) {
            return new semantics.Times(result[0], result[2]);
          }
        )
      };
    });

  /**
   * Add a key handler for the '*' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the '*' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the '*' key has been pressed
          if (String.fromCharCode(event.charCode) == "*") {

            // substitute the charCode of "·" for "*".
            var newEvent = {};
            for (var x in event) {
              newEvent[x] = event[x];
            }
            newEvent.charCode = editor.getPresentationContext().symbolArith1Times.charCodeAt(0);
            event = newEvent;

          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });
  
  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__times"] = new org.mathdox.formulaeditor.semantics.KeywordTimes("arith1", "times", symbol, "infix");

});

  $identify("org/mathdox/formulaeditor/modules/arithmetic/unary_minus.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Arith1Unary_minus =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {

        onscreen : ["-","",""],
        openmath : "<OMS cd='arith1' name='unary_minus'/>",
        mathml   : [ "<mo>-</mo>", "", ""]

      },

      precedence : 140,

      getPrecedence: function(context) {
	var precedence;

        if (context.optionArith1UnaryMinusBrackets === 'true') {
          precedence = 120;
        } else {
          precedence = 140;
        }

	return precedence;
      },
      getInnerPrecedence: function(context) {
	var precedence;

        if (context.optionArith1UnaryMinusBrackets === 'true') {
          precedence = 130;
        } else {
          precedence = 130;
        }

	return precedence;
      },
      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var array = [];
        var symbolOnscreen = this.getSymbolOnscreen(context);
        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[0]!=="") {
            array.push(new presentation.Row(symbolOnscreen[0]));
          }
        }

        var operand = this.operands[0];

        if (operand.getPrecedence && operand.getPrecedence(context) != 0 &&
	    operand.getPrecedence(context) < this.getInnerPrecedence(context)) {
          array.push(new presentation.Symbol("("));
          array.push(operand.getPresentation(context));
          array.push(new presentation.Symbol(")"));
        } else {
          array.push(operand.getPresentation(context));
        }

        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[2]!=="") {
            array.push(new presentation.Row(symbolOnscreen[2]));
          }
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);
        return result;

      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary minus object based on the OpenMath node.
      */
      handleArith1Unary_minus : function(node) {

        var operand = this.handle(node.childNodes.item(1));
	var result = new org.mathdox.formulaeditor.semantics.Arith1Unary_minus(operand);

        return result;

      }

    });

  /**
   * Add the parsing code for unary symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { 
	var precedence;

        if (context.optionArith1UnaryMinusBrackets === 'true') {
          precedence = 120;
        } else {
          precedence = 140;
        }

        var rulesEnter = [];
        var positionEnter = 0;
    
        rulesEnter.push(pG.literal("-"));
        positionEnter++;
        rulesEnter.push(pG.rule("expression140"));
        var result = { arith1unary_minus :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Arith1Unary_minus(result[positionEnter]);
            }
          )
        };

        if (precedence == 120) {
          result.expression120 = function() {
            var parent = arguments.callee.parent;
            pG.alternation(
              pG.rule("arith1unary_minus"),
              parent.expression120).apply(this, arguments);
          };
        } else {
          result.expression140 = function() {
            var parent = arguments.callee.parent;
            pG.alternation(
              pG.rule("arith1unary_minus"),
              parent.expression140).apply(this, arguments);
          };
        }
      
      return result;
  });

});

  $package("org.mathdox.formulaeditor.modules.calculus1");

$identify("org/mathdox/formulaeditor/modules/calculus1/defint.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a definite integration.
   */
  org.mathdox.formulaeditor.semantics.Defint =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : interval
      // operand 1 : lambda expression
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        
        return new presentation.Row(
          new presentation.Defint(
            new presentation.Row(
              this.operands[0].operands[0].getPresentation(context)),
            new presentation.Row(
              this.operands[0].operands[1].getPresentation(context))
          ),
          this.operands[1].expression.getPresentation(context),
          // U+2146 Differential d
          new presentation.Symbol("ⅆ"),
          this.operands[1].variables[0].getPresentation(context)
        );
      
      },
      
      getMathML : function() {
      	// U+222B integral 
        return "<mrow><msubsup><mo>∫</mo>" +
          // below: lower boundry
          this.operands[0].operands[0].getMathML() +
          // above: higher boundry
          this.operands[0].operands[1].getMathML() +
          "</msubsup>"+
          this.operands[1].expression.getMathML() +
          "<mo>ⅆ</mo>"+
          this.operands[1].variables[0].getMathML() +
	  "</mrow>";
      },

      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='calculus1' name='defint'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
        "</OMA>";
      
      }
    
    });

  /**
   * Defines an on-screen (definite) integral.
   */
  org.mathdox.formulaeditor.presentation.Defint =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

      /**
       * top and bottom rows are smaller
       */
      fontSizeModifierArray : [-1,0,-1],

      initialize : function(below, above) {

        var parent = arguments.callee.parent;
        // U+222B integral
        var defint  = new org.mathdox.formulaeditor.presentation.Symbol("∫");
        return parent.initialize.call(this, above, defint, below);

      },

      copy : function() {
        var above = this.children[0];
        var below = this.children[2];
        return this.clone(below.copy(), above.copy());
      },

      getSemantics : function(context) {

        var above = this.children[0].getSemantics(context).value;
        var below = this.children[2].getSemantics(context).value;

        return {
          value : [below, above],
          rule  : "defint"
        };

      }

  });

  /**
   * Extend the OpenMathParser object with parsing code for calculus1.defint.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Sum object based on the OpenMath node.
       */
      handleCalculus1Defint : function(node) {

        var children = node.childNodes;
        var interval = this.handle(children.item(1));
        var lambda   = this.handle(children.item(2));

	if (lambda === null || lambda.variables.length === 0) {
	  alert("calculus1.defint needs a nonempty OMBVAR");
	  return null;
	}

        return new org.mathdox.formulaeditor.semantics.Defint(interval, lambda);

      }

    });


  /**
   * Add the parsing code for definite integrals.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression150 = defint expression 'd' variable | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.transform(
            pG.concatenation(
              pG.rule("defint"),
              pG.rule("expression"),
	      // U+2146 differential d
              pG.literal("ⅆ"),
              pG.rule("variable")
            ),
            function(result) {

              return new semantics.Defint(
                new semantics.Interval(result[0][0], result[0][1]),
                new semantics.Lambda(result[3], result[1])
              );

            }
          ),
          parent.expression150).apply(this, arguments);
      },

      // defint = never
      defint : pG.never,
      calculus1defint_partial: 
        pG.transform(
          pG.concatenation(
            pG.rule("defint"),
            pG.rule("expression")
          ),
          function(result) {
            // just return the expression
            // return value should probably not be used anyway
            return result[0];
          }
        )
    };
  });

  /**
   * Add a key handler for the 'd' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the 'd' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the 'd' key has been pressed
          if (String.fromCharCode(event.charCode) == "d") {

            // search for a partial integral expression to the left of
            // the cursor
            var index = editor.cursor.position.index;
            var parsedleft = this.getSemantics(editor.getExpressionParsingContext(), 0, index, 
              "calculus1defint_partial", true);

            if (parsedleft.value !== null || parsedleft.index > 0) {
              // found a partial calculus1int expression
              // U+2146 differential d
              var presentation = org.mathdox.formulaeditor.presentation;
              this.insert(index, new presentation.Symbol("ⅆ"));
              editor.cursor.moveRight();
            
              // update the editor state
              editor.redraw();
              editor.save();
              return false;
            }
          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });


});

  $identify("org/mathdox/formulaeditor/modules/calculus1/diff.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){
 
  var presentation = org.mathdox.formulaeditor.presentation;
  var semantics = org.mathdox.formulaeditor.semantics;

  // U+2032 [superscript] prime
  var mathmlSymbol= [ "", "", "<mo>′</mo>"];
  
  var symbol =  {
    // U+2032 [superscript] prime
    onscreen : ["","","′"],
    openmath : "<OMS cd='calculus1' name='diff'/>",
    mathml   : mathmlSymbol
  };

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Calculus1Diff =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {
        onscreen : symbol.onscreen,
        openmath : symbol.openmath,
        mathml   : mathmlSymbol
      },

      precedence : 150

    });

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Calculus1Nthdiff =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {
        onscreen : symbol.onscreen,
        openmath : "<OMS cd='calculus1' name='nthdiff'/>",
        mathml   : mathmlSymbol
      },

      precedence : 150,

      getSymbolMathML: function(context) {
        var symbol = ["",""];
        var primes=[];
        var i=0;

        for (i=0;i<this.operands[0].value;i++) {
          // U+2032 [superscript] prime
          primes.push("′");
        }
        symbol.push("<mo>"+primes.join("")+"</mo>");

        return symbol;
      },

      getSymbolOnscreen: function(context) {
        var symbol = ["", ""];
        var primes=[];
        var i=0;

        for (i=0;i<this.operands[0].value;i++) {
          // U+2032 [superscript] prime
          primes.push("′");
        }
        symbol.push(primes.join(""));

        return symbol;
      },

      getMathML: function(context) {
        var array = [];
        var operand = this.operands[1];
	
	array.push("<mrow>");

        if (operand.getPrecedence && operand.getPrecedence(context) != 0 && operand.getPrecedence(context)< this.getPrecedence(context)) {
          array.push("<mfenced>");
	  array.push(operand.getMathML(context));
          array.push("</mfenced>");
        } else {
	  array.push(operand.getMathML(context));
        }

        var symbol_mathml = this.getSymbolMathML();
        array.push(symbol_mathml[2]);
        
        // join row to result string
        var result = array.join("");

        return result;
      },

      getPresentation: function(context) {
        var array=[];
        var operand = this.operands[1];

        if (operand.getPrecedence && operand.getPrecedence(context) != 0 && operand.getPrecedence(context)< this.getPrecedence(context)) {
          array.push(new presentation.Symbol("("));
          array.push(operand.getPresentation(context));
          array.push(new presentation.Symbol(")"));
        } else {
          array.push(operand.getPresentation(context));
        }

        // symbolOnscreen is an array (defined above), removed check
        var symbol = this.getSymbolOnscreen(context);
        var row = new presentation.Row(symbol[2]);

        array.push(row);
        
        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);

        return result;
      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary object based on the OpenMath node.
      */
      handleCalculus1Diff : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Calculus1Diff(operand);

      },

      handleCalculus1Nthdiff : function(node) {
        var n = this.handle(node.childNodes.item(1));
        var func = this.handle(node.childNodes.item(2));
        var retval = new org.mathdox.formulaeditor.semantics.Calculus1Nthdiff(n, func);
        return retval;
      }
    });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["calculus1__diff"] = new org.mathdox.formulaeditor.semantics.Keyword("calculus", "diff", symbol, "unary");
  org.mathdox.formulaeditor.parsing.openmath.KeywordList["calculus1__nthdiff"] = new org.mathdox.formulaeditor.semantics.Keyword("calculus", "nthdiff", symbol, "binary");

  /**
   * Add the parsing code for unary symbol.
   */
  var pG = new org.mathdox.parsing.ParserGenerator();

  // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression150 = calculus1diff | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("calculus1diff"),
          parent.expression150).apply(this, arguments);
      },

      func_symbol : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("calculus1diff"),
          parent.func_symbol).apply(this, arguments);
      },

      // calculus1diff = expression160 "′*"
      calculus1diff :
        pG.transform(
          pG.concatenation(
            pG.rule("expression160"),
            pG.repetitionplus(
              pG.literal("′")
            )
          ),
          function(result) {
            var retval;
            var n = result.length - 1;

            if (n == 1) {
              retval = new semantics.Calculus1Diff(result[0]);
            } else {
              retval = new semantics.Calculus1Nthdiff(new semantics.Integer(n), result[0]);
            }
            return retval;
          }
        )
    };
  });

});

  $package("org.mathdox.formulaeditor.modules.calculus1");

$identify("org/mathdox/formulaeditor/modules/calculus1/int.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an integration.
   */
  org.mathdox.formulaeditor.semantics.Integration =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      // operand : lambda expression
      lambda: null,
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
        var result = new presentation.Row();
        var row;

        row = [
          // U+222B integral
          new presentation.Symbol('∫'),
          this.lambda.expression.getPresentation(context),
          // U+2146 differential D
          new presentation.Symbol("ⅆ"),
          this.lambda.variables[0].getPresentation(context)
        ];

        result.initialize.apply(result, row);
        
        return result;
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='calculus1' name='int'/>" +
          this.lambda.getOpenMath() +
        "</OMA>";
      },

      getMathML : function() {
        // U+222B integral
        return "<mrow><mo>∫</mo>"+
          this.lambda.expression.getMathML() +
          // U+2146 differential D
          "<mo>ⅆ</mo>"+
          this.lambda.variables[0].getMathML()+
          "</mrow>";
      },

      initialize : function() {
        this.lambda = arguments[0];
      }
    
    });

  /**
   * Extend the OpenMathParser object with parsing code for calculus1.int.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Integration object based on the OpenMath node.
       */
      handleCalculus1Int : function(node) {

        var children = node.childNodes;
        var lambda   = this.handle(children.item(1));

        if (lambda === null || lambda.variables.length === 0) {
          alert("calculus1.int needs a nonempty OMBVAR");
          return null;
        }

        return new org.mathdox.formulaeditor.semantics.Integration(lambda);
      }

    });


  /**
   * Add the parsing code for integrals.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression150 = calculus1int | super.expression150
      expression150 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("calculus1int"),
          parent.expression150).apply(this, arguments);
      },
      // U+222B integral
      // calculus1int '∫' expression 'd' variable 
      calculus1int: 
        pG.transform(
          pG.concatenation(
            // U+222B integral
            pG.literal("∫"),
            pG.rule("expression"),
            pG.literal("ⅆ"),
            pG.rule("variable")
          ),
          function(result) {
            var integration;

            integration =  new semantics.Integration(
              new semantics.Lambda(result[3], result[1])
            );

            return integration;
          }
        ),
      calculus1int_partial: 
        pG.transform(
          pG.concatenation(
            // U+222B integral
            pG.literal("∫"),
            pG.rule("expression")
          ),
          function(result) {
            // just return the expression
            // return value should probably not be used anyway
            return result[1];
          }
        )
    };
  });

  /**
   * Add a key handler for the 'd' key.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Row, {

      /**
       * Override the onkeypress method to handle the 'd' key.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          // check whether the 'd' key has been pressed
          if (String.fromCharCode(event.charCode) == "d") {

            // search for a partial integral expression to the left of
            // the cursor
            var index = editor.cursor.position.index;
            var parsedleft = this.getSemantics(editor.getExpressionParsingContext(), 0, index, 
              "calculus1int_partial", true);
	
            if (parsedleft.value !== null || parsedleft.index > 0) {
              // found a partial calculus1int expression
              // U+2146 differential d
              var presentation = org.mathdox.formulaeditor.presentation;
              this.insert(index, new presentation.Symbol("ⅆ"));
              editor.cursor.moveRight();
            
              // update the editor state
              editor.redraw();
              editor.save();
              return false;
            }
          }

        }

        // call the overridden method
        return arguments.callee.parent.onkeypress.call(this, event, editor);

      }

    });


});

  $identify("org/mathdox/formulaeditor/modules/complex1/complex_cartesian.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/modules/arith1/plus.js");
$require("org/mathdox/formulaeditor/modules/arithmetic/times.js");
$require("org/mathdox/formulaeditor/modules/keywords.js");

$main(function(){
  /**
   * Extend the OpenMathParser object with parsing code for arith1.times.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Times object based on the OpenMath node.
       */
      handleComplex1Complex_cartesian : function(node, style) {

        var semantics = org.mathdox.formulaeditor.semantics;
        // parse the children of the OMA
        var children = node.childNodes;

        var realpart = this.handle(children.item(1));

        var complexI = org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__i"];

        var imagpart = this.handle(children.item(2));
        var complexpart;

        // construct a Times object
        var result;

        if (imagpart instanceof semantics.Arith1Unary_minus) {
          complexpart = new semantics.Times(imagpart.operands[0], complexI);
          result = new semantics.Arith1Minus(realpart, complexpart);
        } else if (imagpart instanceof semantics.Integer || imagpart.getValueAsString().charAt(0)=='-') {
          var posInt = new semantics.Integer(imagpart.value.slice(1));
          complexpart = new semantics.Times(posInt, complexI);
          result = new semantics.Arith1Minus(realpart, complexpart);
        } else {
          complexpart = new semantics.Times(imagpart, complexI);
          result = new semantics.Arith1Plus(realpart, complexpart);
        }

        return result;
      }

    });

});

  $identify("org/mathdox/formulaeditor/modules/editor1/palette.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/modules/keywords.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");
$require("org/mathdox/formulaeditor/presentation/PTabContainer.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){
  /**
   * Define a semantic tree node that represents the editor1.palette
   */
  org.mathdox.formulaeditor.semantics.Editor1Palette =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

    symbol : {
      mathml   : ["<mtr><mtd>","</mtd><mtd>","</mtd></mtr>"],
      onscreen : ["[", ",", "]"],
      openmath : "<OMS cd='editor1' name='palette_row'/>"
    },
    
    precedence : 0,

    getPresentation : function(context) {
      var tabs=[];
      var i;

      for (i=0;i<this.operands.length;i++) {
        tabs.push(this.operands[i].getPresentation(context));
      }

      var result = new org.mathdox.formulaeditor.presentation.PTabContainer();

      result.initialize.apply(result,tabs);

      return result;
    }
  });

  /**
   * Define a semantic tree node that represents the editor1.palette_row
   */
  org.mathdox.formulaeditor.semantics.Editor1Palette_row =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
    
    symbol : {
      mathml   : ["<mtr><mtd>","</mtd><mtd>","</mtd></mtr>"],
      onscreen : ["[", ",", "]"],
      openmath : "<OMS cd='editor1' name='palette_row'/>"
    },
    
    precedence : 0

  });

  /**
   * Define a semantic tree node that represents the editor1.palette_tab
   */
  org.mathdox.formulaeditor.semantics.Editor1Palette_tab =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
  
    symbol : {
      mathml   : ["<mtable>","","</mtable>"],
      onscreen : ["[", ",", "]"],
      openmath : "<OMS cd='editor1' name='palette'/>"
    },
    
    precedence : 0,

    title : null,

    getPaletteEntry : function(context,semanticEntry) {
      var modifiedContext = {};
      for (var name in context) {
        modifiedContext[name] = context[name];
      }
      modifiedContext.inPalette = true;

      if (semanticEntry === null || semanticEntry === undefined) {
        semanticEntry = org.mathdox.formulaeditor.parsing.openmath.KeywordList["editor1__palette_whitespace"];
      }
      
      // presentation for the palette
      var entry = semanticEntry.getPresentation(modifiedContext);
      entry.semanticEntry = semanticEntry;
      // add presentation to insert
      entry.insertablePresentation = function() { 
        return this.semanticEntry.getPresentation(context);
      };
      // add function to insert, XXX possibly add library function to
      // presentation node ?
      entry.insertCopy = function(position) {

        if (this.insertablePresentation === null || 
            this.insertablePresentation === undefined ) {
          return; // nothing to insert
        }

        var toInsert = this.insertablePresentation();

        for (var i=0;i<toInsert.children.length;i++) {
          //alert("inserting: "+i+" : "+toInsert.children[i]);

          var moveright = position.row.insert(position.index, 
            toInsert.children[i], (i === 0));
          if (moveright) {
            position.index++;
          }
        }
      };
      return entry;

    },

    getPresentation : function(context) {
      var rows = [];
      var row; // counter
      var col; // counter
      for (row=0;row<this.operands.length;row++) {
        var cols = [];
        for (col=0;col<this.operands[row].operands.length;col++) {
          // semantic version of the entry
          var semanticEntry = this.operands[row].operands[col];
          
          // presentation for the palette
          var entry = this.getPaletteEntry(context,semanticEntry);

          cols.push(entry);
        }
        rows.push(cols);  
      }
      // calculate the (maximum) number of columns
      var numcols = 0;
      for (row=0;row<rows.length;row++){
        if (numcols < rows[row].length) {
          numcols = rows[row].length;
        }
      }
      for (row=0;row<rows.length;row++) {
        if (rows[row].length<numcols) {
          cols = rows[row];
          for (col = cols.length; col<numcols; col++) {
            cols.push(this.getPaletteEntry(context));
          }
        }
      }
      
      var pArray = new org.mathdox.formulaeditor.presentation.PArray();
      pArray.margin = 10.0;
      pArray.initialize.apply(pArray,rows);

      return pArray;
    }, 

    initialize : function() {
      if (arguments[0] instanceof org.mathdox.formulaeditor.semantics.Editor1Palette_tabname) {
        this.title = arguments[0];
	/* arguments is not really an array, arguments.slice(1) has to be done in a different way */
        this.operands = Array.prototype.slice.call(arguments,[1]);
      } else {
        this.title = null;
        this.operands = arguments;
      }
    }
  });

  org.mathdox.formulaeditor.semantics.Editor1Palette_tabname =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

    symbol : {
      mathml   : ["<mtr><mtd>","","</mtd></mtr>"],
      onscreen : ["", "" , ""],
      openmath : "<OMS cd='editor1' name='palette_tabname'/>"
    },
    
    precedence : 0,
  });

  // XXX todo parse parsing palette/palette_row in OM
  /**
   * Extend the OpenMathParser object with parsing code for editor1.palette
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns a Editor1Palette object based on the OpenMath node.
     */
    handleEditor1Palette : function(node) {

      // parse the operands of the OMA
      var children = node.childNodes;
      var operands = [];
      var child;
      for (var i=1; i<children.length; i++) {
        child = this.handle(children.item(i));
        if (child !== null) {
          // not a comment
          operands.push(child);
        }
      }

      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette();
      /* check if the first child is a palette tab */
      child = children.item(1);
      if ((child !==null) && (child !== undefined) &&
        (child.localName=="OMA")) {
        child = child.childNodes.item(0);
      }
      if ((child !==null) && (child !== undefined) &&
        (child.localName=="OMS") &&
        (child.getAttribute("cd") == "editor1") &&
        (child.getAttribute("name") == "palette_tab")) {

        // first child is a tab
        // construct a Editor1Palette object
        result.initialize.apply(result,operands);
      } else {
        // first child is not a tab : construct a Editor1Palette object with a
        // single tab
        var tab = new org.mathdox.formulaeditor.semantics.Editor1Palette_tab();

        tab.initialize.apply(tab,operands);

        result.initialize.apply(result,[tab]);
      }

      return result;
    },

    /**
     * Returns a Editor1Palette_row object based on the OpenMath node.
     */
    handleEditor1Palette_row : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct a Editor1Palette_row object
      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette_row();
      result.initialize.apply(result,operands);
      return result;

    },

    /**
     * Returns a Editor1Palette_tab object based on the OpenMath node.
     */
    handleEditor1Palette_tab : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct a Editor1Palette_row object
      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette_tab();
      result.initialize.apply(result,operands);
      return result;

    },

    /**
     * Returns a Editor1Palette_tabname object based on the OpenMath node.
     */
    handleEditor1Palette_tabname : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct a Editor1Palette_tabname object
      var result = new org.mathdox.formulaeditor.semantics.Editor1Palette_tabname();
      result.initialize.apply(result,operands);
      return result;
    }
  });
});

  $identify("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$require("org/mathdox/formulaeditor/semantics/Lambda.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");

$main(function(){

  /**
   * Extend the OpenMathParser object with parsing code for fns1.lambda.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns an absolute value object based on the OpenMath node.
      */
      handleFns1Lambda : function(node) {

        // parse the children of the OMBIND
        var children = node.childNodes;

        // children.item(0) is OMS: fns1.lambda
        // children.item(1) is OMBVAR
        // children.item(2) is the expression

        if (children.length < 3) {
          // not enough arguments
          alert("parsing OpenMath fns1.lambda: not enough arguments");
          return null; 
        }
        var ombvarNode = children.item(1);
        if (ombvarNode.nodeType != 1) { // ELEMENT node
          alert("parsing OpenMath fns1.lambda: could not find OMBVAR node ");
          return null;
        }
        var ombvarChildren = ombvarNode.childNodes;
        var variables = [];
        var i; // counter
        for (i=0; i<ombvarChildren.length; i++) {
          variables.push(this.handle(ombvarChildren.item(i)));
        }

        var expressionNode = children.item(2);
        if (children.item(2).nodeType != 1) { // ELEMENT node
          alert("parsing OpenMath fns1.lambda: could not find expression node");
          return null;
        }
        var expression = this.handle(expressionNode);

        // construct a List1List object
        var semantics = org.mathdox.formulaeditor.semantics;
        var lambda = new semantics.Lambda(variables, expression);

        return lambda;
      }

    });


  /**
   * Add the parsing code for lambda functions.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( function(context) {
    return {

      // expression160 = list | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("fns1lambda"),
          parent.expression160).apply(this, arguments);
      },

      // U+03BB greek small letter lamda
      // lambda = "λ" ( variable | "(" variable ( "," variable )* ")" ) "."
      // ( variable | "(" expression ")" )
      fns1lambda :
        pG.transform(
          pG.concatenation(
            // U+03BB greek small letter lamda
            pG.literal("λ"),
            pG.alternation(
              pG.rule("variable"),
              pG.concatenation(
                pG.literal("("),
                pG.rule("variable"),
                pG.repetition(
                  pG.concatenation(
                    pG.literal(","),
                    pG.rule("variable")
                  )
                ),
                pG.literal(")")
              )
            ),
            pG.literal("."),
            pG.alternation(
              pG.rule("variable"),
              pG.concatenation(
                pG.literal("("),
                pG.rule("expression"),
                pG.literal(")")
              )
            )
          ),
          function(result) {
            var semantics = org.mathdox.formulaeditor.semantics;

            // result[0] = lambda

            // parse variables
            var variables = [];

            var i = 1;

            if (i<result.length && result[i] != "(") {
              // only one variable
              variables.push(result[i]);
              
              i++;
              // result[i] = "."
            } else {
              // multiple variables, result[i] == "("
              i++;
              // result[i] = ")" or result[i] = variable
              while (i<result.length && result[i] != ")") {
                variables.push(result[i]);
                i++;
                // result[i] = "," or result[i] = ")"
                if (i<result.length && result[i] == ",") {
                  // skip comma
                  i++;
                }
                // result[i] = variable or result[i] = ")"
              }
              // result[i] = ")"
              i++;
              // result[i] = '.'
            }
            // result[i] = '.'
            i++;
            // result[i] = variable or result[i] = "("
            if (i<result.length && result[i] != "(") {
              // only one variable
              expression = result[i];
              i++;
            } else {
              // result[i] = "("
              i++;
              expression = result[i];
              i++;
              // result[i] = ")"
              i++;
            }
            return new semantics.Lambda(variables,expression);
          }
        )
      };
    });

  org.mathdox.formulaeditor.parsing.expression.KeywordList.lambda = {
    parseResultFun : function(oper, array) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var lambda = new semantics.Lambda();
      lambda.initialize.apply(lambda, array);

      return lambda;
    }
  };
});

  
$identify("org/mathdox/formulaeditor/modules/integer1/factorial.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var mathmlSymbol= [ "", "", ""];
  
  if ("" !== "") {
    mathmlSymbol[0] = "<mo></mo>";
  }
  if ("!" !== "") {
    mathmlSymbol[2] = "<mo>!</mo>";
  }

  var symbol =  {
    onscreen : ["","","!"],
    openmath : "<OMS cd='integer1' name='factorial'/>",
    mathml   : mathmlSymbol
  };

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Integer1Factorial =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {
        onscreen : symbol.onscreen,
        openmath : symbol.openmath,
        mathml   : mathmlSymbol
      },

      precedence : 140

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary minus object based on the OpenMath node.
      */
      handleInteger1Factorial : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Integer1Factorial(operand);

      }

    });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["integer1__factorial"] = new org.mathdox.formulaeditor.semantics.Keyword("integer1", "factorial", symbol, "unary");

  /**
   * Add the parsing code for unary symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  var rulesEnter = [];
  var positionEnter = 0;
  if ("" !== "") {
    rulesEnter.push(pG.literal(""));
    positionEnter++;
  }
  rulesEnter.push(pG.rule("expression150"));
  if ("!" !== "") {
    rulesEnter.push(pG.literal("!"));
  }

  if (( ""  === ""  ) &&
      ( "!" === "!" )) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = integer1factorial | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("integer1factorial"),
            parent.expression140).apply(this, arguments);
        },

        // integer1factorial = "" expression150 "!"
        integer1factorial :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Integer1Factorial(result[positionEnter]);
            }
          )
      };
    });
  } else { // allow alternative as displayed on the screen
    var rulesScreen = [];
    var positionScreen = 0;
    if ("" !== "") {
      rulesScreen.push(pG.literal(""));
      positionScreen++;
    }
    rulesScreen.push(pG.rule("expression150"));
    if ("!" !== "") {
      rulesScreen.push(pG.literal("!"));
    }
  
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = integer1factorial | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("integer1factorial"),
            pG.rule("integer1factorialalt"),
            parent.expression140).apply(this, arguments);
        },

        // integer1factorial = "" expression150 "!"
        integer1factorial :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Integer1Factorial(result[positionEnter]);
            }
          ),

        // integer1factorialalt = "" expression150 "!"
        integer1factorialalt :
          pG.transform(
            pG.concatenation.apply(pG, rulesScreen),
            function(result) {
              return new semantics.Integer1Factorial(result[positionScreen]);
            }
          )
       };
     });
   }

});

  $identify("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Integer_interval =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 is lower bound
      // operand 1 is upper bound

      symbol : {

        onscreen : ["[",",","]"],
        openmath : "<OMS cd='interval1' name='integer_interval'/>"

      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.integer_interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Integer_interval : function(node) {

        var children = node.childNodes;
        var lower = this.handle(children.item(1));
        var upper = this.handle(children.item(2));

        return new org.mathdox.formulaeditor.semantics.Integer_interval(lower, upper);

      }

    });
  

});

  $identify("org/mathdox/formulaeditor/modules/interval1/interval.js");

$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      // operand 0 is lower bound
      // operand 1 is upper bound

      symbol : {

        onscreen : ["[",",","]"],
        openmath : "<OMS cd='interval1' name='interval'/>"

      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval : function(node) {

        var children = node.childNodes;
        var lower = this.handle(children.item(1));
        var upper = this.handle(children.item(2));

        return new org.mathdox.formulaeditor.semantics.Interval(lower, upper);

      }

    });
  

});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_cc.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_cc =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_cc'/>"

      },

      leftOpen: false,
      rightOpen: false,
      className: "Interval1Interval_cc"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_cc : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_cc();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_co.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_co =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_co'/>"

      },

      leftOpen: false,
      rightOpen: true,
      className: "Interval1Interval_co"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_co : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_co();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  $identify("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/presentation/Boxed.js");
$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/PseudoRow.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_multi =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      /* to be filled in by extending classes */
      symbol : null,
      leftOpen: null,
      rightOpen: null,
      className: null,

      getPresentation: function (context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var semantics = org.mathdox.formulaeditor.semantics;

	var contents = [];
	var children = [];
	var child;

	var option = context.optionInterval1Brackets;

	var bracket;

	if (this.leftOpen) {
	  bracket = option.lo;
	} else {
	  bracket = option.lc;
	}

	var left = new presentation.Bracket(bracket);

	child = new presentation.Row(this.operands[0].getPresentation(context));
	children.push(child);
	contents.push(child);

	/* use the fixed list separator string from the context */
	var listSep = context.listSeparatorFixed;

	var i;
	for (i = 0; i<listSep.length; i++) {
	  contents.push(new presentation.Symbol(listSep.charAt(i)));
	}

	child = new presentation.Row(this.operands[1].getPresentation(context));
	children.push(child);
	contents.push(child);

	if (this.rightOpen) {
	  bracket = option.ro;
	} else {
	  bracket = option.rc;
	}

        var right = new presentation.Bracket(bracket);
	var prow = new presentation.PseudoRow();
	prow.initialize.apply(prow, contents);

	var row = new presentation.Row(new presentation.Bracketed(left, prow, right));

	return new presentation.Boxed(semantics[this.className], children, row);
      }

    });
});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_oc.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_oc =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_oc'/>"

      },

      leftOpen: true,
      rightOpen: false,
      className: "Interval1Interval_oc"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_oc : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_oc();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  
$identify("org/mathdox/formulaeditor/modules/interval1/interval_oo.js");

$package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/modules/interval1/interval_multi.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an interval.
   */
  org.mathdox.formulaeditor.semantics.Interval1Interval_oo =
    $extend(org.mathdox.formulaeditor.semantics.Interval1Interval_multi, {

      symbol : {

        openmath : "<OMS cd='interval1' name='interval_oo'/>"

      },

      leftOpen: true,
      rightOpen: true,
      className: "Interval1Interval_oo"

    });

  /**
   * Extend the OpenMathParser object with parsing code for
   * interval1.interval
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns an Interval object based on the OpenMath node.
       */
      handleInterval1Interval_oo : function(node) {

        var children = node.childNodes;
	var arr = [];

	for (var i = 1; i<children.length; i++) {
	  var child = this.handle(children.item(i));
	  if (child !== null) {
            /* ignore comments */
            arr.push(child);
	  }
	}

	var result = new org.mathdox.formulaeditor.semantics.Interval1Interval_oo();
	result.initialize.apply(result, arr);

        return result;
      }

    });

});

  
$identify("org/mathdox/formulaeditor/modules/keywords.js");

$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  var semantics = org.mathdox.formulaeditor.semantics;
  var cd;
  var name;
  var symbol;
  var newvars = [];
  var regex = /^[A-Za-z]*$/;

  var hasOnlyLetters = function(s) {
    return regex.test(s);
  };

  
  /**
   * Define the arith1.gcd keyword.
   */
  cd = "arith1";
  name = "gcd";
  symbol = { 
    onscreen: "gcd", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>gcd</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["gcd"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( "gcd" !== "gcd" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["gcd"] = new semantics.Keyword(cd, name, symbol, "function", null);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__gcd"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( ! hasOnlyLetters("gcd") ) {
    newvars.push( "gcd" );
  }
  
  /**
   * Define the arith1.lcm keyword.
   */
  cd = "arith1";
  name = "lcm";
  symbol = { 
    onscreen: "lcm", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>lcm</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["lcm"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( "lcm" !== "lcm" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["lcm"] = new semantics.Keyword(cd, name, symbol, "function", null);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["arith1__lcm"] = new semantics.Keyword(cd, name, symbol, "function", null);

  if ( ! hasOnlyLetters("lcm") ) {
    newvars.push( "lcm" );
  }
  
  /**
   * Define the editor1.input_box keyword.
   */
  cd = "editor1";
  name = "input_box";
  symbol = { 
    onscreen: "□", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>□</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["□"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "□" !== "□" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["□"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["editor1__input_box"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("□") ) {
    newvars.push( "□" );
  }
  
  /**
   * Define the editor1.palette_whitespace keyword.
   */
  cd = "editor1";
  name = "palette_whitespace";
  symbol = { 
    onscreen: " ", 
    openmath : null, // use default with model:cd and model:name
    mathml : ""
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList[""] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "" !== " " ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList[" "] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["editor1__palette_whitespace"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters(" ") ) {
    newvars.push( " " );
  }
  
  /**
   * Define the linalg1.determinant keyword.
   */
  cd = "linalg1";
  name = "determinant";
  symbol = { 
    onscreen: "det", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>det</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["det"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "det" !== "det" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["det"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["linalg1__determinant"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("det") ) {
    newvars.push( "det" );
  }
  
  /**
   * Define the logic1.false keyword.
   */
  cd = "logic1";
  name = "false";
  symbol = { 
    onscreen: "false", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>false</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["false"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "false" !== "false" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["false"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__false"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("false") ) {
    newvars.push( "false" );
  }
  
  /**
   * Define the logic1.true keyword.
   */
  cd = "logic1";
  name = "true";
  symbol = { 
    onscreen: "true", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>true</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["true"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "true" !== "true" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["true"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__true"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("true") ) {
    newvars.push( "true" );
  }
  
  /**
   * Define the nums1.e keyword.
   */
  cd = "nums1";
  name = "e";
  symbol = { 
    onscreen: "e", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>e</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["e"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "e" !== "e" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["e"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__e"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("e") ) {
    newvars.push( "e" );
  }
  
  /**
   * Define the nums1.i keyword.
   */
  cd = "nums1";
  name = "i";
  symbol = { 
    onscreen: "i", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>i</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["i"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "i" !== "i" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["i"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__i"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("i") ) {
    newvars.push( "i" );
  }
  
  /**
   * Define the nums1.infinity keyword.
   */
  cd = "nums1";
  name = "infinity";
  symbol = { 
    onscreen: "∞", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>∞</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["infinity"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "infinity" !== "∞" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["∞"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__infinity"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("∞") ) {
    newvars.push( "∞" );
  }
  
  /**
   * Define the nums1.pi keyword.
   */
  cd = "nums1";
  name = "pi";
  symbol = { 
    onscreen: "π", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>π</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["pi"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "pi" !== "π" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["π"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["nums1__pi"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("π") ) {
    newvars.push( "π" );
  }
  
  /**
   * Define the permutation1.sign keyword.
   */
  cd = "permutation1";
  name = "sign";
  symbol = { 
    onscreen: "sgn", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sgn</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sgn"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sgn" !== "sgn" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sgn"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["permutation1__sign"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sgn") ) {
    newvars.push( "sgn" );
  }
  
  /**
   * Define the plangeo7.triangle keyword.
   */
  cd = "plangeo7";
  name = "triangle";
  symbol = { 
    onscreen: "△", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mo>△</mo>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["triangle"] = new semantics.Keyword(cd, name, symbol, "function", 3);

  if ( "triangle" !== "△" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["△"] = new semantics.Keyword(cd, name, symbol, "function", 3);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["plangeo7__triangle"] = new semantics.Keyword(cd, name, symbol, "function", 3);

  if ( ! hasOnlyLetters("△") ) {
    newvars.push( "△" );
  }
  
  /**
   * Define the setname1.C keyword.
   */
  cd = "setname1";
  name = "C";
  symbol = { 
    onscreen: "ℂ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℂ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["CC"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "CC" !== "ℂ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℂ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__C"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℂ") ) {
    newvars.push( "ℂ" );
  }
  
  /**
   * Define the setname1.N keyword.
   */
  cd = "setname1";
  name = "N";
  symbol = { 
    onscreen: "ℕ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℕ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["NN"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "NN" !== "ℕ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℕ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__N"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℕ") ) {
    newvars.push( "ℕ" );
  }
  
  /**
   * Define the setname1.P keyword.
   */
  cd = "setname1";
  name = "P";
  symbol = { 
    onscreen: "ℙ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℙ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["PP"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "PP" !== "ℙ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℙ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__P"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℙ") ) {
    newvars.push( "ℙ" );
  }
  
  /**
   * Define the setname1.Q keyword.
   */
  cd = "setname1";
  name = "Q";
  symbol = { 
    onscreen: "ℚ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℚ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["QQ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "QQ" !== "ℚ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℚ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__Q"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℚ") ) {
    newvars.push( "ℚ" );
  }
  
  /**
   * Define the setname1.R keyword.
   */
  cd = "setname1";
  name = "R";
  symbol = { 
    onscreen: "ℝ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℝ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["RR"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "RR" !== "ℝ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℝ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__R"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℝ") ) {
    newvars.push( "ℝ" );
  }
  
  /**
   * Define the setname1.Z keyword.
   */
  cd = "setname1";
  name = "Z";
  symbol = { 
    onscreen: "ℤ", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ℤ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["ZZ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "ZZ" !== "ℤ" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ℤ"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["setname1__Z"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("ℤ") ) {
    newvars.push( "ℤ" );
  }
  
  /**
   * Define the set1.emptyset keyword.
   */
  cd = "set1";
  name = "emptyset";
  symbol = { 
    onscreen: "∅", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>∅</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["emptyset"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( "emptyset" !== "∅" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["∅"] = new semantics.Keyword(cd, name, symbol, "constant", 0);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["set1__emptyset"] = new semantics.Keyword(cd, name, symbol, "constant", 0);

  if ( ! hasOnlyLetters("∅") ) {
    newvars.push( "∅" );
  }
  
  /**
   * Define the transc1.arccos keyword.
   */
  cd = "transc1";
  name = "arccos";
  symbol = { 
    onscreen: "arccos", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccos</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccos" !== "arccos" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccos"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccos") ) {
    newvars.push( "arccos" );
  }
  
  /**
   * Define the transc1.arccosh keyword.
   */
  cd = "transc1";
  name = "arccosh";
  symbol = { 
    onscreen: "arccosh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccosh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccosh" !== "arccosh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccosh") ) {
    newvars.push( "arccosh" );
  }
  
  /**
   * Define the transc1.arccot keyword.
   */
  cd = "transc1";
  name = "arccot";
  symbol = { 
    onscreen: "arccot", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccot</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccot" !== "arccot" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccot"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccot") ) {
    newvars.push( "arccot" );
  }
  
  /**
   * Define the transc1.arccoth keyword.
   */
  cd = "transc1";
  name = "arccoth";
  symbol = { 
    onscreen: "arccoth", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccoth</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccoth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccoth" !== "arccoth" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccoth"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccoth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccoth") ) {
    newvars.push( "arccoth" );
  }
  
  /**
   * Define the transc1.arccsc keyword.
   */
  cd = "transc1";
  name = "arccsc";
  symbol = { 
    onscreen: "arccsc", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccsc</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccsc" !== "arccsc" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsc"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccsc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccsc") ) {
    newvars.push( "arccsc" );
  }
  
  /**
   * Define the transc1.arccsch keyword.
   */
  cd = "transc1";
  name = "arccsch";
  symbol = { 
    onscreen: "arccsch", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arccsch</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arccsch" !== "arccsch" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arccsch"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arccsch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arccsch") ) {
    newvars.push( "arccsch" );
  }
  
  /**
   * Define the transc1.arcsec keyword.
   */
  cd = "transc1";
  name = "arcsec";
  symbol = { 
    onscreen: "arcsec", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsec</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsec" !== "arcsec" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsec"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsec") ) {
    newvars.push( "arcsec" );
  }
  
  /**
   * Define the transc1.arcsech keyword.
   */
  cd = "transc1";
  name = "arcsech";
  symbol = { 
    onscreen: "arcsech", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsech</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsech" !== "arcsech" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsech"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsech") ) {
    newvars.push( "arcsech" );
  }
  
  /**
   * Define the transc1.arcsin keyword.
   */
  cd = "transc1";
  name = "arcsin";
  symbol = { 
    onscreen: "arcsin", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsin</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsin" !== "arcsin" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsin"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsin") ) {
    newvars.push( "arcsin" );
  }
  
  /**
   * Define the transc1.arcsinh keyword.
   */
  cd = "transc1";
  name = "arcsinh";
  symbol = { 
    onscreen: "arcsinh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arcsinh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arcsinh" !== "arcsinh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arcsinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arcsinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arcsinh") ) {
    newvars.push( "arcsinh" );
  }
  
  /**
   * Define the transc1.arctan keyword.
   */
  cd = "transc1";
  name = "arctan";
  symbol = { 
    onscreen: "arctan", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arctan</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arctan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arctan" !== "arctan" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arctan"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arctan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arctan") ) {
    newvars.push( "arctan" );
  }
  
  /**
   * Define the transc1.arctanh keyword.
   */
  cd = "transc1";
  name = "arctanh";
  symbol = { 
    onscreen: "arctanh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>arctanh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["arctanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "arctanh" !== "arctanh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["arctanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__arctanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("arctanh") ) {
    newvars.push( "arctanh" );
  }
  
  /**
   * Define the transc1.cos keyword.
   */
  cd = "transc1";
  name = "cos";
  symbol = { 
    onscreen: "cos", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>cos</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["cos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "cos" !== "cos" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["cos"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__cos"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("cos") ) {
    newvars.push( "cos" );
  }
  
  /**
   * Define the transc1.cosh keyword.
   */
  cd = "transc1";
  name = "cosh";
  symbol = { 
    onscreen: "cosh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>cosh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["cosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "cosh" !== "cosh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["cosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__cosh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("cosh") ) {
    newvars.push( "cosh" );
  }
  
  /**
   * Define the transc1.cot keyword.
   */
  cd = "transc1";
  name = "cot";
  symbol = { 
    onscreen: "cot", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>cot</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["cot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "cot" !== "cot" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["cot"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__cot"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("cot") ) {
    newvars.push( "cot" );
  }
  
  /**
   * Define the transc1.coth keyword.
   */
  cd = "transc1";
  name = "coth";
  symbol = { 
    onscreen: "coth", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>coth</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["coth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "coth" !== "coth" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["coth"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__coth"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("coth") ) {
    newvars.push( "coth" );
  }
  
  /**
   * Define the transc1.csc keyword.
   */
  cd = "transc1";
  name = "csc";
  symbol = { 
    onscreen: "csc", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>csc</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["csc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "csc" !== "csc" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["csc"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__csc"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("csc") ) {
    newvars.push( "csc" );
  }
  
  /**
   * Define the transc1.csch keyword.
   */
  cd = "transc1";
  name = "csch";
  symbol = { 
    onscreen: "csch", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>csch</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["csch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "csch" !== "csch" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["csch"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__csch"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("csch") ) {
    newvars.push( "csch" );
  }
  
  /**
   * Define the transc1.exp keyword.
   */
  cd = "transc1";
  name = "exp";
  symbol = { 
    onscreen: "exp", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>exp</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["exp"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "exp" !== "exp" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["exp"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__exp"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("exp") ) {
    newvars.push( "exp" );
  }
  
  /**
   * Define the transc1.ln keyword.
   */
  cd = "transc1";
  name = "ln";
  symbol = { 
    onscreen: "ln", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>ln</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["ln"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "ln" !== "ln" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["ln"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__ln"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("ln") ) {
    newvars.push( "ln" );
  }
  
  /**
   * Define the transc1.log keyword.
   */
  cd = "transc1";
  name = "log";
  symbol = { 
    onscreen: "log", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>log</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["log"] = new semantics.Keyword(cd, name, symbol, "function", 2);

  if ( "log" !== "log" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["log"] = new semantics.Keyword(cd, name, symbol, "function", 2);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__log"] = new semantics.Keyword(cd, name, symbol, "function", 2);

  if ( ! hasOnlyLetters("log") ) {
    newvars.push( "log" );
  }
  
  /**
   * Define the transc1.sec keyword.
   */
  cd = "transc1";
  name = "sec";
  symbol = { 
    onscreen: "sec", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sec</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sec" !== "sec" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sec"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sec"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sec") ) {
    newvars.push( "sec" );
  }
  
  /**
   * Define the transc1.sech keyword.
   */
  cd = "transc1";
  name = "sech";
  symbol = { 
    onscreen: "sech", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sech</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sech" !== "sech" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sech"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sech"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sech") ) {
    newvars.push( "sech" );
  }
  
  /**
   * Define the transc1.sin keyword.
   */
  cd = "transc1";
  name = "sin";
  symbol = { 
    onscreen: "sin", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sin</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sin" !== "sin" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sin"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sin"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sin") ) {
    newvars.push( "sin" );
  }
  
  /**
   * Define the transc1.sinh keyword.
   */
  cd = "transc1";
  name = "sinh";
  symbol = { 
    onscreen: "sinh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>sinh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["sinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "sinh" !== "sinh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["sinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__sinh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("sinh") ) {
    newvars.push( "sinh" );
  }
  
  /**
   * Define the transc1.tan keyword.
   */
  cd = "transc1";
  name = "tan";
  symbol = { 
    onscreen: "tan", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>tan</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["tan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "tan" !== "tan" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["tan"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__tan"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("tan") ) {
    newvars.push( "tan" );
  }
  
  /**
   * Define the transc1.tanh keyword.
   */
  cd = "transc1";
  name = "tanh";
  symbol = { 
    onscreen: "tanh", 
    openmath : null, // use default with model:cd and model:name
    mathml : "<mi>tanh</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.KeywordList["tanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( "tanh" !== "tanh" ) {
    org.mathdox.formulaeditor.parsing.expression.KeywordList["tanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);
  }

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["transc1__tanh"] = new semantics.Keyword(cd, name, symbol, "function", 1);

  if ( ! hasOnlyLetters("tanh") ) {
    newvars.push( "tanh" );
  }
  
  var pG = new org.mathdox.parsing.ParserGenerator();
  if(newvars.length > 0) {
    var args = [];
    for (var i=0;i < newvars.length; i++) {
      args.push(pG.literal(newvars[i]));
    }
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {
        variable : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.alternation.apply(this, args),
              function(result) {
                var result_joined = result.join("");

                // this should be in the keywordlist
                return org.mathdox.formulaeditor.parsing.expression.KeywordList[result_joined];
              }
            ),
            parent.variable).apply(this, arguments);
        }
      };
    });
  }
});

  $identify("org/mathdox/formulaeditor/modules/limit1/limit.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Column.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/modules/relation1/eq.js");
$require("org/mathdox/formulaeditor/modules/interval1/integer_interval.js");
$require("org/mathdox/formulaeditor/modules/fns1/lambda.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents a sum.
   */
  org.mathdox.formulaeditor.semantics.Limit =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      // operand 0 : limiting value
      // NOT USED YET operand 1 : method of approach
      // operand 2 : function
    
      getPresentation : function(context) {
      
        var presentation = org.mathdox.formulaeditor.presentation;
       
        return new presentation.Row(
          new presentation.Limit(
            new presentation.Row(
              this.operands[2].variables[0].getPresentation(context),
              // U+2192 rightwards arrow
              new presentation.Symbol("→"),
              this.operands[0].getPresentation(context)
            )
          ),
          new presentation.Symbol("("),
          this.operands[2].expression.getPresentation(context),
          new presentation.Symbol(")")
        );
      
      },
      
      getOpenMath : function() {
      
        return "<OMA>" +
          "<OMS cd='limit1' name='limit'/>" +
          this.operands[0].getOpenMath() +
          this.operands[1].getOpenMath() +
          this.operands[2].getOpenMath() +
        "</OMA>";
      
      },

      getMathML : function() {
        return "<mrow>"+
          "<munder>"+
            "<mo>lim</mo>"+
            "<mrow>"+
              this.operands[2].variables[0].getMathML() +
              // U+2192 rightwards arrow
              "<mo>→</mo>"+
              this.operands[0].getMathML() +
            "</mrow>" +
          "</munder>" +
          this.operands[2].expression.getMathML() +
        "</mrow>";
      }
    
    });

  /**
   * Defines an on-screen limit.
   */
  org.mathdox.formulaeditor.presentation.Limit =
    $extend(org.mathdox.formulaeditor.presentation.Column, {

    /**
     * top and bottom rows are smaller
     */
    fontSizeModifierArray : [0,-1],

    /**
     * use top row as baseline
     */
    baselineIndex: 0,

    initialize : function(below) {

      var parent = arguments.callee.parent;
      // U+03A3 greek capital letter sigma
      
      var lim  = new org.mathdox.formulaeditor.semantics.Keyword("limit1","limit",{onscreen:"lim"},"function").getPresentation();
      return parent.initialize.call(this, lim, below);
    },

    getSemantics : function(context) {

      var semantics = org.mathdox.formulaeditor.semantics;

      var below = this.children[1].getSemantics(context, null, null, "approach").value;

      if (below !== null) {
        return {
          value : below,
          rule  : "limit"
        };

      }
      else {
        return null;
      }
    }
  });

  /**
   * Extend the OpenMathParser object with parsing code for limit1.limit.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Limit object based on the OpenMath node.
       */
      handleLimit1Limit : function(node) {


        var children = node.childNodes;
        var value = this.handle(children.item(1));
        var method = this.handle(children.item(2));
        var lambda   = this.handle(children.item(3));

        if (lambda.variables.length === 0) {
          alert("limit1.limit needs a nonempty OMBVAR");
          return null;
        }

        return new org.mathdox.formulaeditor.semantics.Limit(value, method, lambda);

      }

    });


  /**
   * Add the parsing code for limits.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression150 = limit expression150 | super.expression150
        expression150 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.concatenation(
                pG.rule("limit"),
                pG.rule("expression150")
              ),
              function(result) {

                return new semantics.Limit(
                  result[0][2], 
                  new semantics.Keyword("limit1", "null", null, "constant"),
                  new semantics.Lambda([result[0][0]], result[1])
                );

              }
            ),
            parent.expression150).apply(this, arguments);
        },

        approach : function() {
          var parent = arguments.callee.parent;
          pG.concatenation(
            pG.rule("variable"),
            pG.rule("rightarrow"),
            pG.rule("expression")
          ).apply(this, arguments);
        },
        
        rightarrow: function() {
          var parent = arguments.callee.parent;
          pG.transform(
            pG.alternation(
              pG.concatenation(pG.literal("-"), pG.literal(">")),
              // U+2192 rightwards arrow
              pG.literal("→")
            ),
            function(result){
              // U+2192 rightwards arrow
              return "→";
            }
          ).apply(this, arguments);
        },

        // limit = never
        limit : pG.never
      };
    });

});

  $identify("org/mathdox/formulaeditor/modules/linalg/matrix.js");

$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Matrix.js");
$require("org/mathdox/formulaeditor/presentation/Vector.js");
$require("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");
$require("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  /**
   * Define a semantic tree node that represents the linalg2.matrix
   */
  org.mathdox.formulaeditor.semantics.Linalg2Matrix =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mtable>","","</mtable>"],
        onscreen : ["[", ",", "]"],
        openmath : "<OMS cd='linalg2' name='matrix'/>"

      },

      precedence : 0,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        
        // add inMatrix to a copy of the context
        // XXX see if an extend like function can be used
        var modifiedContext = {};
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.inMatrix = true;

        var rows = [];

        for ( var row =0 ; row<this.operands.length ; row++) {
          var currentRow = [];
          for (var col = 0 ; col<this.operands[row].operands.length; col++) {
            var entry = this.operands[row].operands[col].getPresentation(
              modifiedContext);
            currentRow.push(entry);
          }
          rows[row] = currentRow;
        }

        var result = new presentation.Matrix();
        result.initialize.apply(result,rows);
       
        return result;
      }

    });

  /**
   * Define a semantic tree node that represents the linalg2.vector
   */
  org.mathdox.formulaeditor.semantics.Linalg2Vector =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        mathml   : ["<mo>[</mo>","<mo>,</mo>","<mo>]</mo>"],
        onscreen : ["[", ",", "]"],
        openmath : "<OMS cd='linalg2' name='vector'/>"

      },

      precedence : 0,

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var entries = [];
        var vector = new presentation.Vector();

        // add inVector to a copy of the context
        // XXX see if an extend like function can be used
        var modifiedContext = {};
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.inVector = true;

        for (var i=0; i<this.operands.length; i++) {
          entries.push(this.operands[i].getPresentation(modifiedContext));
        }
       
        vector.initialize.apply(vector, entries);

        return vector;
      }

    });

  /**
   * Extend the OpenMathParser object with parsing code for linalg2.matrixrow
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
       * Returns a Linalg2Matrixrow object based on the OpenMath node.
       */
      handleLinalg2Matrix : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Linalg2Matrix object
        var result = new org.mathdox.formulaeditor.semantics.Linalg2Matrix();
        result.initialize.apply(result,operands);

        return result;
      },

      /**
       * Returns a Linalg2Matrixrow object based on the OpenMath node.
       */
      handleLinalg2Matrixrow : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Linalg2Matrixrow object
        var result = new org.mathdox.formulaeditor.semantics.Linalg2Matrixrow();
        result.initialize.apply(result,operands);
        return result;

      },

      /**
       * Returns a Linalg2Vector object based on the OpenMath node.
       */
      handleLinalg2Vector : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a Linalg2Vector object
        var result = new org.mathdox.formulaeditor.semantics.Linalg2Vector();
        result.initialize.apply(result, operands);
        return result;

      }

    });

  /**
   * Add the parsing code for Matrixlike.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression160 = Linalg2Matrixlike | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("Linalg2Matrixlike"),
          parent.expression160).apply(this, arguments);
      },

      // Linalg2Matrixrow = "[" expression ("," expression)* "]"
      Linalg2Matrixlike :
        pG.transform(
          pG.concatenation(
            pG.literal("["),
            pG.rule("expression"),
            pG.repetition(
              pG.concatenation(
                pG.literal(context.listSeparator),
                pG.rule("expression")
              )
            ),
            pG.literal("]")
          ),
          function(result) {
            var array = [];
	    var i; // counter
            for (i=1; i+1<result.length; i=i+2) {
              array.push(result[i]);
            }
            var matrixLike;
            var allvector = true;
            for (i=0; i<array.length; i++) {
              allvector = allvector && 
                array[i] instanceof semantics.Linalg2Vector;
            }
            if (allvector) {
              /*
               * convert vectors in array to matrixrows
               */
              var matrixRows = [];
              for (i=0; i<array.length; i++) {
                var row = new semantics.Linalg2Matrixrow();
                row.initialize.apply(row, array[i].operands);
                matrixRows.push(row);
              }
              // create a new matrix
              matrixLike = new semantics.Linalg2Matrix();
              matrixLike.initialize.apply(matrixLike, matrixRows);
            } else {
              // create a vector 
              matrixLike = new semantics.Linalg2Vector();
              matrixLike.initialize.apply(matrixLike, array);
            }
            return matrixLike;
          }
        )
      };
    });

});

  $identify("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");

$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){
  /**
   * Define a semantic tree node that represents the linalg2.matrixrow
   */
  org.mathdox.formulaeditor.semantics.Linalg2Matrixrow =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mtr><mtd>","</mtd><mtd>","</mtd></mtr>"],
        onscreen : ["[", ",", "]"],
        openmath : "<OMS cd='linalg2' name='matrixrow'/>"

      },

      precedence : 0

    });
});

  $identify("org/mathdox/formulaeditor/modules/list1/list.js");

$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.List1List =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mo>{</mo>","<mo>,</mo>","<mo>}</mo>"],
        onscreen : ["{",",","}"],
        openmath : "<OMS cd='list1' name='list'/>"

      },

      precedence : 0

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.abs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns an absolute value object based on the OpenMath node.
      */
      handleList1List : function(node) {

        // parse the children of the OMA
        var children = node.childNodes;
        var operands = [];
        for (var i=1; i<children.length; i++) {
          operands.push(this.handle(children.item(i)));
        }

        // construct a List1List object
        var result = new org.mathdox.formulaeditor.semantics.List1List();
        result.initialize.apply(result, operands);
        return result;

      }

    });

  /**
   * Add the parsing code for lists.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression160 = list | super.expression160
      expression160 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("list"),
          parent.expression160).apply(this, arguments);
      },

      // abs = "{" expression "}"
      list :
        pG.transform(
          pG.concatenation(
            pG.literal("{"),
            pG.rule("expression"),
            pG.repetition(
              pG.concatenation(
                pG.literal(context.listSeparator),
                pG.rule("expression")
              )
            ),
            pG.literal("}")
          ),
          function(result) {
            var array = [];
            for (var i=1; i+1<result.length; i=i+2) {
              array.push(result[i]);
            }
            var list = new semantics.List1List();
            list.initialize.apply(list, array);
            return list;
          }
        )
      };
    });

});

  
$identify("org/mathdox/formulaeditor/modules/logic1/and.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "∧",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>∧</mo>",
    mathml_invisible : ( "" != "" ? "<mo></mo>" : null )
  };

  /**
   * Define a semantic tree node that represents logic1.and.
   */
  org.mathdox.formulaeditor.semantics.Logic1And =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='logic1' name='and'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 100

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.and.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1And : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1And();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__and"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "and", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "&&" == "∧" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression100 = and | super.expression100
      expression100 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1and"),
          parent.expression100).apply(this, arguments);
      },

      // logic1and = 
      //    expression100 "&&" expression110
      logic1and :
        pG.transform(
          pG.concatenation(
            pG.rule("expression100"),
            pG.literal("&&"),
            pG.rule("expression110"),
            pG.repetition(
              pG.concatenation(
                pG.literal("&&"),
                pG.rule("expression110")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1And();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Logic1And && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression100 = logic1and | 
      //   logic1andalt | super.expression100
      expression100 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1and"),
          parent.expression100).apply(this, arguments);
      },

      // logic1and = 
      //    expression100 "&&" expression110
      logic1and :
        pG.transform(
          pG.concatenation(
            pG.rule("expression100"),
	    pG.alternation(
	      pG.literal("&&"),
	      pG.literal("∧")
	    ),
            pG.rule("expression110"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("&&"),
	          pG.literal("∧")
	        ),
                pG.rule("expression110")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1And();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Logic1And) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/logic1/equivalent.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "⇔",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>⇔</mo>",
    mathml_invisible : ( "" != "" ? "<mo></mo>" : null )
  };

  /**
   * Define a semantic tree node that represents logic1.equivalent.
   */
  org.mathdox.formulaeditor.semantics.Logic1Equivalent =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='logic1' name='equivalent'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 70

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.equivalent.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1Equivalent : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1Equivalent();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__equivalent"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "equivalent", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<=>" == "⇔" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression70 = equivalent | super.expression70
      expression70 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1equivalent"),
          parent.expression70).apply(this, arguments);
      },

      // logic1equivalent = 
      //    expression70 "<=>" expression80
      logic1equivalent :
        pG.transform(
          pG.concatenation(
            pG.rule("expression70"),
            pG.literal("<=>"),
            pG.rule("expression80"),
            pG.repetition(
              pG.concatenation(
                pG.literal("<=>"),
                pG.rule("expression80")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Equivalent();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Logic1Equivalent && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression70 = logic1equivalent | 
      //   logic1equivalentalt | super.expression70
      expression70 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1equivalent"),
          parent.expression70).apply(this, arguments);
      },

      // logic1equivalent = 
      //    expression70 "<=>" expression80
      logic1equivalent :
        pG.transform(
          pG.concatenation(
            pG.rule("expression70"),
	    pG.alternation(
	      pG.literal("<=>"),
	      pG.literal("⇔")
	    ),
            pG.rule("expression80"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("<=>"),
	          pG.literal("⇔")
	        ),
                pG.rule("expression80")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Equivalent();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Logic1Equivalent) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/logic1/implies.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "⇒",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>⇒</mo>"
  };

  /**
   * Define a semantic tree node that represents logic1.implies.
   */
  org.mathdox.formulaeditor.semantics.Logic1Implies =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='logic1' name='implies'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 80

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.implies.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1Implies : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1Implies();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__implies"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "implies", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "=>" == "⇒" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression80 = implies | super.expression80
      expression80 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1implies"),
          parent.expression80).apply(this, arguments);
      },

      // logic1implies = 
      //    expression80 "=>" expression90
      logic1implies : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression80"),
              pG.literal("=>"),
              pG.rule("expression90")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Logic1Implies(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression80 = logic1implies | 
      //   super.expression80
      expression80 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1implies"),
          parent.expression80).apply(this, arguments);
      },

      // logic1implies = 
      //    expression80 ("=>"|"⇒") expression90
      logic1implies : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression80"),
  	    pG.alternation(
  	      pG.literal("=>"),
  	      pG.literal("⇒")
  	    ),
              pG.rule("expression90")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Logic1Implies(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/logic1/not.js");

$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var mathmlSymbol= [ "", "", ""];
  
  if ("¬" !== "") {
    mathmlSymbol[0] = "<mo>¬</mo>";
  }
  if ("" !== "") {
    mathmlSymbol[2] = "<mo></mo>";
  }

  var symbol =  {
    onscreen : ["¬","",""],
    openmath : "<OMS cd='logic1' name='not'/>",
    mathml   : mathmlSymbol
  };

  /**
   * Defines a semantic tree node that represents a unary minus.
   */
  org.mathdox.formulaeditor.semantics.Logic1Not =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      

      symbol : {
        onscreen : symbol.onscreen,
        openmath : symbol.openmath,
        mathml   : mathmlSymbol
      },

      precedence : 140

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.unary_minus.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a unary minus object based on the OpenMath node.
      */
      handleLogic1Not : function(node) {

        var operand = this.handle(node.childNodes.item(1));
        return new org.mathdox.formulaeditor.semantics.Logic1Not(operand);

      }

    });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__not"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "not", symbol, "unary");

  /**
   * Add the parsing code for unary symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  var rulesEnter = [];
  var positionEnter = 0;
  if ("!" !== "") {
    rulesEnter.push(pG.literal("!"));
    positionEnter++;
  }
  rulesEnter.push(pG.rule("expression150"));
  if ("" !== "") {
    rulesEnter.push(pG.literal(""));
  }

  if (( "!"  === "¬"  ) &&
      ( "" === "" )) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = logic1not | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("logic1not"),
            parent.expression140).apply(this, arguments);
        },

        // logic1not = "!" expression150 ""
        logic1not :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Logic1Not(result[positionEnter]);
            }
          )
      };
    });
  } else { // allow alternative as displayed on the screen
    var rulesScreen = [];
    var positionScreen = 0;
    if ("¬" !== "") {
      rulesScreen.push(pG.literal("¬"));
      positionScreen++;
    }
    rulesScreen.push(pG.rule("expression150"));
    if ("" !== "") {
      rulesScreen.push(pG.literal(""));
    }
  
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

        // expression140 = logic1not | super.expression140
        expression140 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("logic1not"),
            pG.rule("logic1notalt"),
            parent.expression140).apply(this, arguments);
        },

        // logic1not = "!" expression150 ""
        logic1not :
          pG.transform(
            pG.concatenation.apply(pG, rulesEnter),
            function(result) {
              return new semantics.Logic1Not(result[positionEnter]);
            }
          ),

        // logic1notalt = "¬" expression150 ""
        logic1notalt :
          pG.transform(
            pG.concatenation.apply(pG, rulesScreen),
            function(result) {
              return new semantics.Logic1Not(result[positionScreen]);
            }
          )
       };
     });
   }

});

  
$identify("org/mathdox/formulaeditor/modules/logic1/or.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen         : "∨",
    openmath         : null, // use default with model:cd and model:name
    mathml           : "<mo>∨</mo>",
    mathml_invisible : ( "" != "" ? "<mo></mo>" : null )
  };

  /**
   * Define a semantic tree node that represents logic1.or.
   */
  org.mathdox.formulaeditor.semantics.Logic1Or =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen         : symbol.onscreen,
        openmath         : "<OMS cd='logic1' name='or'/>",
        mathml           : symbol.mathml,
        mathml_invisible : symbol.mathml_invisible

      },

      precedence : 90

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for logic1.or.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleLogic1Or : function(node, style) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Logic1Or();
      result.initialize.apply(result, operands);

      if (style == "invisible") {
        result.style = style;
      }

      return result;
    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["logic1__or"] = new org.mathdox.formulaeditor.semantics.Keyword("logic1", "or", symbol, "infix");

  /**
   * Add the parsing code for an infix sign.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "||" == "∨" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression90 = or | super.expression90
      expression90 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1or"),
          parent.expression90).apply(this, arguments);
      },

      // logic1or = 
      //    expression90 "||" expression100
      logic1or :
        pG.transform(
          pG.concatenation(
            pG.rule("expression90"),
            pG.literal("||"),
            pG.rule("expression100"),
            pG.repetition(
              pG.concatenation(
                pG.literal("||"),
                pG.rule("expression100")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Or();
            var operands = [];
            var i;

	    // if the operator is the same rewrite it
	    // except if the style is invisible 
            if (result[0] instanceof semantics.Logic1Or && result[0].style!="invisible" && result[0].inside_braces !== true ) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression90 = logic1or | 
      //   logic1oralt | super.expression90
      expression90 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("logic1or"),
          parent.expression90).apply(this, arguments);
      },

      // logic1or = 
      //    expression90 "||" expression100
      logic1or :
        pG.transform(
          pG.concatenation(
            pG.rule("expression90"),
	    pG.alternation(
	      pG.literal("||"),
	      pG.literal("∨")
	    ),
            pG.rule("expression100"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("||"),
	          pG.literal("∨")
	        ),
                pG.rule("expression100")
              )
            )
          ),
          function(result) {
            var retval = new semantics.Logic1Or();
            var operands = [];
            var i;

            if (result[0] instanceof semantics.Logic1Or) {
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
	      operands.push(result[0]);
            }

	    for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  $identify("org/mathdox/formulaeditor/modules/nums1/rational.js");

$require("org/mathdox/formulaeditor/modules/arithmetic/divide.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$main(function(){

  /**
  * Extend the OpenMathParser object with parsing code for arith1.divide.
  */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a Divide object based on the OpenMath node.
      */
      handleNums1Rational : function(node) {
	return this.handleArith1Divide(node);
      }
  });

});

  
$identify("org/mathdox/formulaeditor/modules/permutation1/left_compose.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "∘",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>∘</mo>"
  };

  /**
   * Define a semantic tree node that represents permutation1.left_compose.
   */
  org.mathdox.formulaeditor.semantics.Permutation1Left_compose =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='permutation1' name='left_compose'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 130

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for permutation1.left_compose.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handlePermutation1Left_compose : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Permutation1Left_compose();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["permutation1__left_compose"] = new org.mathdox.formulaeditor.semantics.Keyword("permutation1", "left_compose", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "∘" == "∘" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression130 = left_compose | super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("permutation1left_compose"),
          parent.expression130).apply(this, arguments);
      },

      // permutation1left_compose = 
      //    expression130 "∘" expression140
      permutation1left_compose : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression130"),
              pG.literal("∘"),
              pG.rule("expression140")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Permutation1Left_compose(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression130 = permutation1left_compose | 
      //   super.expression130
      expression130 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("permutation1left_compose"),
          parent.expression130).apply(this, arguments);
      },

      // permutation1left_compose = 
      //    expression130 ("∘"|"∘") expression140
      permutation1left_compose : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression130"),
  	    pG.alternation(
  	      pG.literal("∘"),
  	      pG.literal("∘")
  	    ),
              pG.rule("expression140")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Permutation1Left_compose(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  $identify("org/mathdox/formulaeditor/modules/permutation1/permutation.js");

$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$main(function(){

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.Cycle =
    $extend(org.mathdox.formulaeditor.semantics.MultaryListOperation, {

      symbol : {

        mathml   : ["<mo>(</mo>","<mo>,</mo>","<mo>)</mo>"],
        onscreen : ["(",",",")"],
        openmath : "<OMS cd='permutation1' name='cycle'/>"

      },

      precedence : 0

    });

  /**
   * Defines a semantic tree node that represents an absolute value.
   */
  org.mathdox.formulaeditor.semantics.Permutation =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        mathml   : ["","",""],
        onscreen : ["","",""],
        openmath : "<OMS cd='permutation1' name='permutation'/>"

      },

      precedence : 0

    });

  /**
   * Extend the OpenMathParser object with parsing code for arith1.abs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

      /**
      * Returns a cycle object based on the OpenMath node.
      */
      handlePermutation1Cycle : function(node) {
        var operands = [];
        var result;
        var i;

        for (i=1; i<node.childNodes.length; i++) {
          operands.push(this.handle(node.childNodes.item(i)));
        }
        result = new org.mathdox.formulaeditor.semantics.Cycle();
        result.initialize.apply(result, operands);

        return result;
      }, 
      
      /**
      * Returns a permutation object based on the OpenMath node.
      */
      handlePermutation1Permutation : function(node) {
        var operands = [];
        var result;
        var i;

        for (i=1; i<node.childNodes.length; i++) {
          operands.push(this.handle(node.childNodes.item(i)));
        }
        result = new org.mathdox.formulaeditor.semantics.Permutation();
        result.initialize.apply(result, operands);

        return result;

      }

    });

  /**
   * Add the parsing code for permutations.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

        // expression160 = permutation | super.expression160
        expression160 : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.rule("permutation"),
            parent.expression160).apply(this, arguments);
        },

        // permutation = "(" (omString | integer) ("," (omString | integer))+ ")"
        permutation :
          pG.transform(
            pG.repetitionplus(
              pG.concatenation(
                pG.literal("("),
                pG.alternation(
                  pG.rule("integer"),
                  pG.rule("omString")
                ),
                pG.repetitionplus(
                  pG.concatenation(
                    pG.literal(context.listSeparator),
                    pG.alternation(
                      pG.rule("integer"),
                      pG.rule("omString")
                    )
                  )
                ),
                pG.literal(")")
              )
            ),
            function(result) {
              var cycles = [];
              var entries;
              var i=0;
              var perm;
              while (i<result.length) {
                // result[i] = '('
                i++;

                entries = [];
                while (i<result.length && result[i] != ')') {
                  entries.push(result[i]);
                  i++;
                  // result[i] = ')' or ','
                  if (i<result.length && result[i] == context.listSeparator) {
                    i++;
                  }
                  // result[i] = ')' or result[i] = <entry>
                }
                // result[i] == ')' 
                i++;
                
                var cycle = new semantics.Cycle();
                cycle.initialize.apply(cycle, entries);
                cycles.push(cycle);
              }

              perm = new semantics.Permutation();
              perm.initialize.apply(perm, cycles);
              return perm;
            }
          )
        };
      });

});

  $identify("org/mathdox/formulaeditor/modules/relation1/IntervalNotation.js");

$require("org/mathdox/formulaeditor/modules/logic1/and.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { 
      return {
	infix_Update: function(expr) {
	  var parent = arguments.callee.parent;
          var semantics = org.mathdox.formulaeditor.semantics;
          var result;
          var arg1, arg2;

          if ((expr instanceof semantics.Relation1Lt || expr instanceof semantics.Relation1Leq) &&
              (expr.operands[0] instanceof semantics.Relation1Lt || expr.operands[0] instanceof semantics.Relation1Leq)) {
            arg1 = expr.operands[0];
            console.log("1<x<2");

            if (expr instanceof semantics.Relation1Lt) {
              arg2 = new semantics.Relation1Lt(arg1.operands[1], expr.operands[1]);
            } else { //Leq
              arg2 = new semantics.Relation1Leq(arg1.operands[1], expr.operands[1]);
            }

            result = new semantics.Logic1And(arg1, arg2);
          } else if ((expr instanceof semantics.Relation1Gt || expr instanceof semantics.Relation1Geq) &&
              (expr.operands[0] instanceof semantics.Relation1Gt || expr.operands[0] instanceof semantics.Relation1Geq)) {
            arg1 = expr.operands[0];
            console.log("1>x>2");

            if (expr instanceof semantics.Relation1Gt) {
              arg2 = new semantics.Relation1Gt(arg1.operands[1], expr.operands[1]);
            } else { //Geq
              arg2 = new semantics.Relation1Geq(arg1.operands[1], expr.operands[1]);
            }

            result = new semantics.Logic1And(arg1, arg2);
          } else { // change nothing
            result = expr;
          }

          return parent.infix_Update(result);
	}
      };
    }
  );
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/approx.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≈",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≈</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.approx.
   */
  org.mathdox.formulaeditor.semantics.Relation1Approx =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='approx'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.approx.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Approx : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Approx();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__approx"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "approx", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "~~" == "≈" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = approx | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1approx"),
          parent.expression110).apply(this, arguments);
      },

      // relation1approx = 
      //    expression110 "~~" expression120
      relation1approx : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("~~"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Approx(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1approx | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1approx"),
          parent.expression110).apply(this, arguments);
      },

      // relation1approx = 
      //    expression110 ("~~"|"≈") expression120
      relation1approx : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("~~"),
  	      pG.literal("≈")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Approx(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/eq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");

$main(function(){

  var symbol = {
    onscreen : "=",
    openmath : null, // use default with cd and name from model
    mathml   : "<mo>=</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.eq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Eq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='eq'/>",
        mathml   : symbol.mathml

      },

      precedence : 110

    });
 
  /**
   * Define a semantic tree node that represents relation2.eqs.
   */
  org.mathdox.formulaeditor.semantics.Relation2Eqs =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation2' name='eqs'/>",
        mathml   : symbol.mathml

      },

      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for 
   * relation1.eq and relation2.eqs.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Eq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Eq();
      result.initialize.apply(result, operands);
      return result;

    },
    handleRelation2Eqs : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation2Eqs();
      result.initialize.apply(result, operands);
      return result;

    }


  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__eq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "eq", symbol, "infix");
  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation2__eqs"] = new org.mathdox.formulaeditor.semantics.Keyword("relation2", "eqs", symbol, "infix");

  /**
   * Add the parsing code for an infix-different symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "=" == "=" ) {
    // only one expression, same on screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression110 = relation1eqrelation2eqs | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1eqrelation2eqs"),
          parent.expression110).apply(this, arguments);
      },

      // relation1eqrelation2eqs = 
      //    expression110 "=" expression120
      relation1eqrelation2eqs :
        pG.transform(
          pG.concatenation(
            pG.rule("expression110"),
            pG.literal("="),
            pG.rule("expression120"),
            pG.repetition(
              pG.concatenation(
                pG.literal("="),
                pG.rule("expression120")
              )
            )
          ),
          function(result) {
	    var retval;
            var operands = [];
            var i;

            if ((result[0] instanceof semantics.Relation1Eq) ||
                (result[0] instanceof semantics.Relation1Eq)) {

              retval = new semantics.Relation2Eqs();
              for (i=0; i<result[0].operands.length;i++) {
	        operands.push(result[0].operands[i]);
              }
	    } else {
              retval = new semantics.Relation1Eq();
	      operands.push(result[0]);
            }

            for (i=1; 2*i<result.length; i++) {
              operands.push(result[2*i]);
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  } else { // allow alternative as displayed on the screen
  org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
    function(context) { return {

      // expression110 = relation1eqrelation2eqs | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1eqrelation2eqs"),
          parent.expression110).apply(this, arguments);
      },

      // relation1eqrelation2eqs = 
      //    expression110 "=" expression120
      relation1eqrelation2eqs :
        pG.transform(
          pG.concatenation(
            pG.rule("expression110"),
	    pG.alternation(
	      pG.literal("="),
	      pG.literal("=")
	    ),
            pG.rule("expression120"),
            pG.repetition(
              pG.concatenation(
	        pG.alternation(
	          pG.literal("="),
	          pG.literal("=")
	        ),
                pG.rule("expression120")
              )
            )
          ),
          function(result) {
            var retval;
	    if (result.length < 3){
              retval = new semantics.Relation1Eq();
	    } else {
              retval = new semantics.Relation2Eqs();
	    }
            var operands = [];
            var i;

            for (i=0; 2*i<result.length; i++) {
              operands[i] = result[2*i];
            }
            retval.operands = operands;

            return retval;
          }
        )
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/geq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≥",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≥</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.geq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Geq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='geq'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.geq.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Geq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Geq();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__geq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "geq", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( ">=" == "≥" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = geq | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1geq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1geq = 
      //    expression110 ">=" expression120
      relation1geq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal(">="),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Geq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1geq | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1geq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1geq = 
      //    expression110 (">="|"≥") expression120
      relation1geq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal(">="),
  	      pG.literal("≥")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Geq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/gt.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : ">",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>&gt;</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.gt.
   */
  org.mathdox.formulaeditor.semantics.Relation1Gt =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='gt'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.gt.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Gt : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Gt();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__gt"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "gt", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( ">" == ">" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = gt | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1gt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1gt = 
      //    expression110 ">" expression120
      relation1gt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal(">"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Gt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1gt | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1gt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1gt = 
      //    expression110 (">"|">") expression120
      relation1gt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal(">"),
  	      pG.literal(">")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Gt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/leq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≤",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≤</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.leq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Leq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='leq'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.leq.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Leq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Leq();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__leq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "leq", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<=" == "≤" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = leq | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1leq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1leq = 
      //    expression110 "<=" expression120
      relation1leq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("<="),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Leq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1leq | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1leq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1leq = 
      //    expression110 ("<="|"≤") expression120
      relation1leq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("<="),
  	      pG.literal("≤")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Leq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/lt.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "<",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>&lt;</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.lt.
   */
  org.mathdox.formulaeditor.semantics.Relation1Lt =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='lt'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.lt.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Lt : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Lt();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__lt"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "lt", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<" == "<" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = lt | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1lt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1lt = 
      //    expression110 "<" expression120
      relation1lt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("<"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Lt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1lt | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1lt"),
          parent.expression110).apply(this, arguments);
      },

      // relation1lt = 
      //    expression110 ("<"|"<") expression120
      relation1lt : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("<"),
  	      pG.literal("<")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Lt(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/relation1/neq.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "≠",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>≠</mo>"
  };

  /**
   * Define a semantic tree node that represents relation1.neq.
   */
  org.mathdox.formulaeditor.semantics.Relation1Neq =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='relation1' name='neq'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for relation1.neq.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleRelation1Neq : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Relation1Neq();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["relation1__neq"] = new org.mathdox.formulaeditor.semantics.Keyword("relation1", "neq", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "<>" == "≠" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = neq | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1neq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1neq = 
      //    expression110 "<>" expression120
      relation1neq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("<>"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Neq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = relation1neq | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("relation1neq"),
          parent.expression110).apply(this, arguments);
      },

      // relation1neq = 
      //    expression110 ("<>"|"≠") expression120
      relation1neq : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("<>"),
  	      pG.literal("≠")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Relation1Neq(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/set1/in.js");

$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){

  var symbol = {
    onscreen : "∈",
    openmath : null, // use default with model:cd and model:name
    mathml   : "<mo>∈</mo>"
  };

  /**
   * Define a semantic tree node that represents set1.in.
   */
  org.mathdox.formulaeditor.semantics.Set1In =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {

      symbol : {

        onscreen : symbol.onscreen,
        openmath : "<OMS cd='set1' name='in'/>",
        mathml   : symbol.mathml

      },

      associative : true,
      precedence : 110

    });
  
  /**
   * Extend the OpenMathParser object with parsing code for set1.in.
   */
  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser =
    $extend(org.mathdox.formulaeditor.parsing.openmath.OpenMathParser, {

    /**
     * Returns an equality object based on the OpenMath node.
     */
    handleSet1In : function(node) {

      // parse the children of the OMA
      var children = node.childNodes;
      var operands = [];
      for (var i=1; i<children.length; i++) {
        operands.push(this.handle(children.item(i)));
      }

      // construct the corresponding object
      var result = new org.mathdox.formulaeditor.semantics.Set1In();
      result.initialize.apply(result, operands);

      return result;

    }

  });

  org.mathdox.formulaeditor.parsing.openmath.KeywordList["set1__in"] = new org.mathdox.formulaeditor.semantics.Keyword("set1", "in", symbol, "infix");

  /**
   * Add the parsing code for an infix-once symbol.
   */
  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  if ( "∈" == "∈" ) {
    // only one expression, same on screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = in | super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("set1in"),
          parent.expression110).apply(this, arguments);
      },

      // set1in = 
      //    expression110 "∈" expression120
      set1in : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
              pG.literal("∈"),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Set1In(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  } else { // allow alternative as displayed on the screen
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {

      // expression110 = set1in | 
      //   super.expression110
      expression110 : function() {
        var parent = arguments.callee.parent;
        pG.alternation(
          pG.rule("set1in"),
          parent.expression110).apply(this, arguments);
      },

      // set1in = 
      //    expression110 ("∈"|"∈") expression120
      set1in : function() {
          var parent = arguments.callee.parent;
          return pG.transform(
            pG.concatenation(
              pG.rule("expression110"),
  	    pG.alternation(
  	      pG.literal("∈"),
  	      pG.literal("∈")
  	    ),
              pG.rule("expression120")
            ),
            function(result) {
              return parent.infix_Update(new semantics.Set1In(result[0], result[2]));
            }
          ).apply(this, arguments);
        }
      };
    });
  }
});

  
$identify("org/mathdox/formulaeditor/modules/variables.js");

$require("org/mathdox/formulaeditor/semantics/Variable.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/parsing/expression/VariableList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");
$require("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  var semantics = org.mathdox.formulaeditor.semantics;
  var name;
  var symbol;
  var newvars = [];
  var regex = /^[A-Za-z]*$/;

  var hasOnlyLetters = function(s) {
    return regex.test(s);
  };

  
  /**
   * Define the alpha variable.
   */
  name = "alpha";
  symbol = { 
    onscreen: "α", 
    mathml : "<mi>α</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["alpha"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["α"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["alpha"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("α") ) {
    newvars.push( "α" );
  }
  
  /**
   * Define the beta variable.
   */
  name = "beta";
  symbol = { 
    onscreen: "β", 
    mathml : "<mi>β</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["beta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["β"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["beta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("β") ) {
    newvars.push( "β" );
  }
  
  /**
   * Define the gamma variable.
   */
  name = "gamma";
  symbol = { 
    onscreen: "γ", 
    mathml : "<mi>γ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["gamma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["γ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["gamma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("γ") ) {
    newvars.push( "γ" );
  }
  
  /**
   * Define the delta variable.
   */
  name = "delta";
  symbol = { 
    onscreen: "δ", 
    mathml : "<mi>δ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["delta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["δ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["delta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("δ") ) {
    newvars.push( "δ" );
  }
  
  /**
   * Define the epsilon variable.
   */
  name = "epsilon";
  symbol = { 
    onscreen: "ϵ", 
    mathml : "<mi>ϵ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["epsilon"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϵ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["epsilon"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϵ") ) {
    newvars.push( "ϵ" );
  }
  
  /**
   * Define the varepsilon variable.
   */
  name = "varepsilon";
  symbol = { 
    onscreen: "φ", 
    mathml : "<mi>φ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varepsilon"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["φ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varepsilon"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("φ") ) {
    newvars.push( "φ" );
  }
  
  /**
   * Define the zeta variable.
   */
  name = "zeta";
  symbol = { 
    onscreen: "ζ", 
    mathml : "<mi>ζ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["zeta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ζ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["zeta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ζ") ) {
    newvars.push( "ζ" );
  }
  
  /**
   * Define the eta variable.
   */
  name = "eta";
  symbol = { 
    onscreen: "η", 
    mathml : "<mi>η</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["eta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["η"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["eta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("η") ) {
    newvars.push( "η" );
  }
  
  /**
   * Define the theta variable.
   */
  name = "theta";
  symbol = { 
    onscreen: "θ", 
    mathml : "<mi>θ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["theta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["θ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["theta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("θ") ) {
    newvars.push( "θ" );
  }
  
  /**
   * Define the vartheta variable.
   */
  name = "vartheta";
  symbol = { 
    onscreen: "ϑ", 
    mathml : "<mi>ϑ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["vartheta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϑ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["vartheta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϑ") ) {
    newvars.push( "ϑ" );
  }
  
  /**
   * Define the kappa variable.
   */
  name = "kappa";
  symbol = { 
    onscreen: "κ", 
    mathml : "<mi>κ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["kappa"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["κ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["kappa"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("κ") ) {
    newvars.push( "κ" );
  }
  
  /**
   * Define the mu variable.
   */
  name = "mu";
  symbol = { 
    onscreen: "μ", 
    mathml : "<mi>μ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["mu"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["μ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["mu"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("μ") ) {
    newvars.push( "μ" );
  }
  
  /**
   * Define the nu variable.
   */
  name = "nu";
  symbol = { 
    onscreen: "ν", 
    mathml : "<mi>ν</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["nu"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ν"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["nu"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ν") ) {
    newvars.push( "ν" );
  }
  
  /**
   * Define the xi variable.
   */
  name = "xi";
  symbol = { 
    onscreen: "ξ", 
    mathml : "<mi>ξ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["xi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ξ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["xi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ξ") ) {
    newvars.push( "ξ" );
  }
  
  /**
   * Define the varpi variable.
   */
  name = "varpi";
  symbol = { 
    onscreen: "ϖ", 
    mathml : "<mi>ϖ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varpi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϖ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varpi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϖ") ) {
    newvars.push( "ϖ" );
  }
  
  /**
   * Define the rho variable.
   */
  name = "rho";
  symbol = { 
    onscreen: "ρ", 
    mathml : "<mi>ρ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["rho"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ρ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["rho"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ρ") ) {
    newvars.push( "ρ" );
  }
  
  /**
   * Define the varrho variable.
   */
  name = "varrho";
  symbol = { 
    onscreen: "ϱ", 
    mathml : "<mi>ϱ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varrho"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϱ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varrho"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϱ") ) {
    newvars.push( "ϱ" );
  }
  
  /**
   * Define the sigma variable.
   */
  name = "sigma";
  symbol = { 
    onscreen: "σ", 
    mathml : "<mi>σ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["sigma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["σ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["sigma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("σ") ) {
    newvars.push( "σ" );
  }
  
  /**
   * Define the varsigma variable.
   */
  name = "varsigma";
  symbol = { 
    onscreen: "ς", 
    mathml : "<mi>ς</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varsigma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ς"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varsigma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ς") ) {
    newvars.push( "ς" );
  }
  
  /**
   * Define the tau variable.
   */
  name = "tau";
  symbol = { 
    onscreen: "τ", 
    mathml : "<mi>τ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["tau"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["τ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["tau"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("τ") ) {
    newvars.push( "τ" );
  }
  
  /**
   * Define the upsilon variable.
   */
  name = "upsilon";
  symbol = { 
    onscreen: "υ", 
    mathml : "<mi>υ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["upsilon"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["υ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["upsilon"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("υ") ) {
    newvars.push( "υ" );
  }
  
  /**
   * Define the phi variable.
   */
  name = "phi";
  symbol = { 
    onscreen: "ϕ", 
    mathml : "<mi>ϕ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["phi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ϕ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["phi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ϕ") ) {
    newvars.push( "ϕ" );
  }
  
  /**
   * Define the varphi variable.
   */
  name = "varphi";
  symbol = { 
    onscreen: "φ", 
    mathml : "<mi>φ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["varphi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["φ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["varphi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("φ") ) {
    newvars.push( "φ" );
  }
  
  /**
   * Define the chi variable.
   */
  name = "chi";
  symbol = { 
    onscreen: "χ", 
    mathml : "<mi>χ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["chi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["χ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["chi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("χ") ) {
    newvars.push( "χ" );
  }
  
  /**
   * Define the psi variable.
   */
  name = "psi";
  symbol = { 
    onscreen: "ψ", 
    mathml : "<mi>ψ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["psi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ψ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["psi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ψ") ) {
    newvars.push( "ψ" );
  }
  
  /**
   * Define the omega variable.
   */
  name = "omega";
  symbol = { 
    onscreen: "ω", 
    mathml : "<mi>ω</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["omega"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["ω"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["omega"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("ω") ) {
    newvars.push( "ω" );
  }
  
  /**
   * Define the Gamma variable.
   */
  name = "Gamma";
  symbol = { 
    onscreen: "Γ", 
    mathml : "<mi>Γ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Gamma"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Γ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Gamma"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Γ") ) {
    newvars.push( "Γ" );
  }
  
  /**
   * Define the Delta variable.
   */
  name = "Delta";
  symbol = { 
    onscreen: "Δ", 
    mathml : "<mi>Δ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Delta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Δ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Delta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Δ") ) {
    newvars.push( "Δ" );
  }
  
  /**
   * Define the Theta variable.
   */
  name = "Theta";
  symbol = { 
    onscreen: "Θ", 
    mathml : "<mi>Θ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Theta"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Θ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Theta"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Θ") ) {
    newvars.push( "Θ" );
  }
  
  /**
   * Define the Lamda variable.
   */
  name = "Lamda";
  symbol = { 
    onscreen: "Λ", 
    mathml : "<mi>Λ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Lamda"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Λ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Lamda"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Λ") ) {
    newvars.push( "Λ" );
  }
  
  /**
   * Define the Xi variable.
   */
  name = "Xi";
  symbol = { 
    onscreen: "Ξ", 
    mathml : "<mi>Ξ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Xi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Ξ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Xi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Ξ") ) {
    newvars.push( "Ξ" );
  }
  
  /**
   * Define the Phi variable.
   */
  name = "Phi";
  symbol = { 
    onscreen: "Φ", 
    mathml : "<mi>Φ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Phi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Φ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Phi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Φ") ) {
    newvars.push( "Φ" );
  }
  
  /**
   * Define the Psi variable.
   */
  name = "Psi";
  symbol = { 
    onscreen: "Ψ", 
    mathml : "<mi>Ψ</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Psi"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Ψ"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Psi"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Ψ") ) {
    newvars.push( "Ψ" );
  }
  
  /**
   * Define the Omega variable.
   */
  name = "Omega";
  symbol = { 
    onscreen: "Ω", 
    mathml : "<mi>Ω</mi>"
  };
  
  org.mathdox.formulaeditor.parsing.expression.VariableList["Omega"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.expression.VariableList["Ω"] = new semantics.Variable(name, symbol);

  org.mathdox.formulaeditor.parsing.openmath.VariableList["Omega"] = new semantics.Variable(name, symbol);

  if ( ! hasOnlyLetters("Ω") ) {
    newvars.push( "Ω" );
  }
  
  var pG = new org.mathdox.parsing.ParserGenerator();
  if(newvars.length > 0) {
    var args = [];
    for (var i=0;i < newvars.length; i++) {
      args.push(pG.literal(newvars[i]));
    }
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction( 
      function(context) { return {
        variable : function() {
          var parent = arguments.callee.parent;
          pG.alternation(
            pG.transform(
              pG.alternation.apply(this, args),
              function(result) {
                var result_joined = result.join("");

                // this should be in the keywordlist
                return org.mathdox.formulaeditor.parsing.expression.VariableList[result_joined];
              }
            ),
            parent.variable).apply(this, arguments);
        }
      };
    });
  }
});

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");

$require("org/mathdox/parsing/Parser.js");
$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");

$main(function() {

    var ParsingParser = org.mathdox.parsing.Parser;
    var functions = new Array();

    var cachedContext = null;

    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser =
      $extend(Object, {
        getParser : function(context) {
          var i;

          if (context === null || context === undefined) {
	    context = this.getContext();
	  }

	  if (context.parser === undefined) {

            var parser = ParsingParser;

            for (i=0;i<functions.length;i++) {
              parser = $extend(parser, functions[i](context));
            }

	    context.parser = parser;
	  }

	  return context.parser;
        }
      });

    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.addFunction = function(fun) {
      functions.push(fun);
    };
    
    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.clearCache = function() {
      cachedContext = null;
    }

    org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.getContext = function() {
      if (cachedContext === null) {

        var Options = new org.mathdox.formulaeditor.Options();

        /* set context options based on options */
	/* XXX move this to options.getCachedContext() */

	cachedContext = Options.getExpressionParsingContext();
      }

      return cachedContext;
    };

    /* initialize with ExpressionParser rules */
    var ExpressionParser = new org.mathdox.formulaeditor.parsing.expression.ExpressionParser();

    functions.push(ExpressionParser.getRules);
}

);

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/ExpressionParser.js");

$require("org/mathdox/parsing/Parser.js");
$require("org/mathdox/parsing/ParserGenerator.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/presentation/Subscript.js");
$require("org/mathdox/formulaeditor/semantics/FunctionApplication.js");
$require("org/mathdox/formulaeditor/semantics/Integer.js");
$require("org/mathdox/formulaeditor/semantics/SemanticFloat.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");

$main(function() {

  var semantics = org.mathdox.formulaeditor.semantics;
  var pG = new org.mathdox.parsing.ParserGenerator();

  org.mathdox.formulaeditor.parsing.expression.ExpressionParser =
    $extend(Object, { getRules: function(context) { 
      var func_subCheck = function(oper) {
        return false;
      };
      
      var func_subUpdate = function(oper) {
        return oper;
      };

      // expression160 = braces | integer | variable
      var expression160 = pG.alternation(
        pG.rule("braces"),
        pG.rule("parseNumber"),
        pG.rule("func"),
        pG.rule("func_sub"),
        pG.rule("variable"),
        pG.rule("omSymbol"),
        pG.rule("omString")
      );

      if (context.styleTransc1Log === "postfix") {
        func_subCheck = function(operInput) {
         
          var oper;

          oper = operInput;
          // oper should be a function application
          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          oper = oper.symbol;

          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          // symbol should be a keyword
          if (!( oper.symbol instanceof semantics.Keyword)) {
            return false;
          }  
          
          if (oper.symbol.cd == "transc1" && oper.symbol.name == "log" ) {
            return true;
          }
          
          return false;
        };
        func_subUpdate = function(oper) {
          if (func_subCheck(oper)) {
            var symbol = oper.symbol.symbol;

            // use the operands from the subscript before the others
            var arr = oper.symbol.operands.concat(oper.operands);

            // and return the "flattened" function
            return new semantics.FunctionApplication(symbol, arr, "firstsub");
          } else {
            return oper;
          }
        };
      } else if (context.styleTransc1Log === "sangwin") {
        func_subCheck = function(operInput) {
         
          var oper;

          oper = operInput;
          // oper should be a function application
          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          oper = oper.symbol;

          if (! (oper instanceof semantics.FunctionApplication) ) {
            return false;
          }

          // symbol should exist
          if (oper.symbol === undefined || oper.symbol === null) {
            return false;
          } 

          // symbol should be a keyword
          if (!( oper.symbol instanceof semantics.Keyword)) {
            return false;
          }  
          
          if (oper.symbol.cd == "transc1" && oper.symbol.name == "log" ) {
            return true;
          }
          
          return false;
        };
        func_subUpdate = function(oper) {
          if (func_subCheck(oper)) {
            var symbol = oper.symbol.symbol;

            // use the operands from the subscript before the others
            var arr = oper.symbol.operands.concat(oper.operands);

            // and return the "flattened" function
            return new semantics.FunctionApplication(symbol, arr, "firstsub");
          } else {
            return oper;
          }
        };
 	
      }

      var rule_func_super;
      var rule_expression160;

      if (context.styleTransc1Log === "prefix") {
	rule_expression160 = pG.alternation(
          pG.rule("braces"),
          pG.rule("parseNumber"),
          pG.rule("func"),
          pG.rule("func_sub"),
          pG.rule("func_super"),
          pG.rule("variable"),
          pG.rule("omSymbol"),
          pG.rule("omString")
        );

	rule_func_super = 
          pG.transform(
            pG.concatenation(
	      pG.rule("superscript"),
              pG.alternation(
                pG.rule("variable"),
                pG.rule("omSymbol")
              ),
              pG.literal('('),
              pG.rule("expression"),
              pG.repetition(
                pG.concatenation(
                  pG.literal(context.listSeparator),
                  pG.rule("expression")
                )
              ),
              pG.literal(')')
	    ),
          function(result) {
            var array = [];
            var i,j; // counters
            var semantics = org.mathdox.formulaeditor.semantics;
           
	    array.push(result[0]);
	    var oper = result[1];
            var str;

	    // 2 : literal '('
            i=3;
            while (i < result.length) {
              array.push(result[i]);

              i=i+2;
            }
            return new semantics.FunctionApplication(oper, array);
          }
	);
      } else {
	rule_expression160 = pG.alternation(
          pG.rule("braces"),
          pG.rule("parseNumber"),
          pG.rule("func"),
          pG.rule("func_sub"),
          pG.rule("variable"),
          pG.rule("omSymbol"),
          pG.rule("omString")
        );
        rule_func_super = pG.never;
      }

      return {
        // TODO make this list alphabetical

        // start = expression
        start : pG.rule("expression"),

        // expression = expression70
        expression  : pG.rule("expression70"), 

        // expression70 = expression80
        expression70 : pG.rule("expression80"), // equivalence, ...

        // expression80 = expression90
        expression80 : pG.rule("expression90"), // implies, ...

        // expression90 = expression100
        expression90 : pG.rule("expression100"), // or, ...

        // expression100 = expression110
        expression100 : pG.rule("expression110"), // and, ...

        // expression110 = expression120
        expression110 : pG.rule("expression120"), // equals, lessthan,
                                                  // morethan, ...

        // expression120 = expression130
        expression120 : pG.rule("expression130"), // plus, minus 
        					  // forall

        // expression130 = expression140
        expression130 : pG.rule("expression140"), // times

        // expression140 = expression150
        expression140 : pG.rule("expression150"), // unary minus

        // expression150 = expression160
        expression150 : pG.rule("expression160"), // power

        // expression160 = braces | integer | variable
        expression160 : rule_expression160, // use version defined above

        // restrictedexpression160 = braces | variable | func
        // no number allowed, for silent multiplication
        restrictedexpression160 :
          pG.alternation(
            pG.rule("braces"),
            pG.rule("func"),
            pG.rule("func_sub"),
            pG.rule("variable"),
            pG.rule("omSymbol")
          ),

        biginteger : pG.never,

        // integer = [0..9]+
        integer :
          pG.transform(
            pG.repetitionplus(
              pG.range('0','9')
            ),
            function(result) {
              var numstr = result.join("");

              // remove starting 0s
              pos = 0;
              while (pos < numstr.length && numstr.charAt(pos) == '0') {
                pos++;
              }
              if (pos > 0) {
                if (pos == numstr.length) {
                  numstr = "0";
                } else {
                  numstr = numstr.substr(pos);
                }
              }

	      if (numstr.length <= 10) {
                return new semantics.Integer(Number(result.join("")));
              } else {
                return new semantics.Integer( {
                    value : numstr,
                    rule : "bigint"
                  }
                );
	      }
            }
          ),

        // float = [0..9]+ ++ context.decimalMark ++ [0-9]*
        parseFloat :
          pG.transform(
            pG.concatenation( 
              pG.repetitionplus(
                pG.range('0','9')
              ),
              pG.literal(context.decimalMark),
              pG.repetitionplus(
                pG.range('0','9')
              )
            ),
            function(result) {
              // replace decimalMark by a period
              var res=[];
	      var i;
              for (i=0; i<result.length; i++) {
		if (result[i] instanceof Object) {
                  res.push(result[i].value);
		} else {
                  res.push(result[i]);
		}
              }

              var string = res.join("");
              res=[];

              for (i=0; i<string.length; i++) {
		if (string.charAt(i)>='0' && string.charAt(i)<='9' ) {
                  res.push(string.charAt(i));
		} else {
                  res.push('.');
		}
              }

              return new semantics.SemanticFloat(res.join(""));
            }
          ),

        // number: float | integer
        parseNumber :
          pG.alternation(
            pG.rule("parseFloat"),
            pG.rule("biginteger"),
            pG.rule("integer")
          ),

        // variable = ([a..z]|[A..Z]) ([a..z]|[A..Z]|[0..9])*
        variable :
          pG.transform(
            pG.concatenation(
              pG.alternation(
                pG.range('a','z'),
                pG.range('A','Z')
              ),
              pG.repetition(
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9')
                )
              )
            ),
            function(result) {
              // store result.join(""); in a variable since it is used twice
              var result_joined=result.join("");

              if (org.mathdox.formulaeditor.parsing.expression.KeywordList[
                      result_joined] === undefined ||
                  org.mathdox.formulaeditor.parsing.expression.KeywordList[
                      result_joined] === null) {
                // not in the list of variables that are symbols
                return new semantics.Variable(result_joined);
              } else {
                // in the list of symbols, return the corresponding object
                // instead
                // TODO: check if we need to update the presentation tree
                return org.mathdox.formulaeditor.parsing.expression.KeywordList[result_joined];
              }
            }
          ),
        // omString = "([a..z]|[A..Z]|[0..9]|' _.-')*"
        // TODO: maybe add more symbols
        omString:
          pG.transform(
            pG.concatenation(
              pG.literal('"'),
              pG.repetitionplus( 
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9'),
                  pG.literal(' '),
                  pG.literal('_'),
                  pG.literal('.'),
                  pG.literal('-')
                )
              ),
              pG.literal('"')
            ),
            function(result) {
              return new semantics.SString(result.slice(1,result.length-1).join(""));
            }
          ),
        
        // omSymbol = ([a..z]|[A..Z]) ([a..z]|[A..Z]|[0..9]|'_')* '.' ([a..z]|[A..Z])([a..z]|[A..Z]|[0..9]|_)*
        omSymbol:
          pG.transform(
            pG.concatenation(
              pG.alternation(
                pG.range('a','z'),
                pG.range('A','Z')
              ),
              pG.repetition(
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9'),
                  pG.literal('_')
                )
              ),
              pG.literal('.'),
              pG.alternation(
                pG.range('a','z'),
                pG.range('A','Z')
              ),
              pG.repetition(
                pG.alternation(
                  pG.range('a','z'),
                  pG.range('A','Z'),
                  pG.range('0','9'),
                  pG.literal('_')
                )
              )
            ),

            /* 
             * XXX: hard to check whether something is a constant or a function
             */
            function(result) {
              var symbolinfo = result.join("").split('.');
              var cd=symbolinfo[0];
              var name=symbolinfo[1];

              var symbol = {
                onscreen: null,
                openmath: null,
                mathml: "&lt;mi&gt;"+cd+"."+name+"&lt;/mi&gt;"
              };
              return new semantics.Keyword(cd,name,symbol,"constant");
            }
          ),

        // braces = '(' expression ')'
        braces :
          pG.transform(
            pG.concatenation(
              pG.literal('('),
              pG.rule("expression"),
              pG.literal(')')
            ),
            function(result) {
              result[1].inside_braces = true;
              return result[1];
            }
          ),

        separatedArguments :
          pG.transform(
            pG.concatenation(
              pG.rule("expression"),
              pG.repetitionplus(
                pG.concatenation(
                  pG.literal(context.listSeparator),
                  pG.rule("expression")
                )
              )
            ),
            function(result) {
              var array = [];
              var i;
              for (i=0;i<result.length;i+=2) {
                array.push(result[i]);
              }
              return array;
            }
          ),
        // NOTE: produces an object for the first rule and an array for the second
        // for use with presentation/Bracketed.js parsing
	functionArguments : 
	  pG.alternation(
            pG.rule("expression"),
            pG.rule("separatedArguments")
          ),
        bracesWithSeparatedArguments :
	  pG.transform(
	    pG.concatenation(
              pG.literal('('),
	      pG.rule("separatedArguments"),
              pG.literal(')')
            ),
            function (result) {
              return result[1];
            }
          ),

        // function = variable '(' expr ( ',' expr ) * ')'
        func : function() {
	  var obj = this;

          pG.transform(
            pG.concatenation(
              pG.rule("func_symbol"),
              pG.repetitionplus(
		pG.alternation(
                  pG.rule("braces"),
                  pG.rule("bracesWithSeparatedArguments")
                )
              )
            ),
            function(result) {
              var array;
              var i; 
              
              var oper = result[0];
              
              for (i=1; i<result.length; i++) {
                if (result[i] instanceof Array) {
                  array = result[i];
                } else {
                  array = [];
                  array.push(result[i]);
                }

                if (oper.parseResultFun !== undefined) {
                  // special case: result function in operation
                  oper = oper.parseResultFun(oper, array);
                } else {
                  oper = new org.mathdox.formulaeditor.semantics.FunctionApplication(oper, array);
                }
              }

              // check for log_2(x) updates
              oper = obj.func_Update(oper);
              return oper;
            }
          ).apply(this, arguments);
	  },
        func_symbol: pG.alternation(
            pG.rule("variable"),
            pG.rule("omSymbol"),
            pG.rule("braces"),
            pG.rule("func_sub")
          ),
        func_sub:
          pG.transform(
            pG.concatenation(
              pG.alternation(
                pG.rule("variable"),
                pG.rule("omSymbol"),
                pG.rule("braces")
              ),
              pG.repetitionplus(
                pG.alternation(
                  pG.concatenation(
                    pG.literal('_'),
                    pG.alternation(
                      pG.rule("variable"),
                      pG.rule("omSymbol"),
                      pG.rule("integer"),
                      pG.concatenation(
                        pG.literal('{'),
                        pG.rule("expression"),
                        //repetition(
                        //  concatenation(
                        //    literal(","),
                        //    rule("expression")
                        //  )
                        //),
                        pG.literal('}')
                      )
                    )
                  ),
                  pG.rule("subscript")
                )
              )
            ),
            function(result) {
              var array;
              var i,j; // counters
              var semantics = org.mathdox.formulaeditor.semantics;
              
              var oper = result[0];
              var str;

              i=1;
              while (i < result.length) {
                // current position == '_' (or subscript)
                if (result[i]== "_") {
                  // current position == '_'
                  i++;
                }

                if (i<result.length && result[i] != '{') {
                  // simple argument
                  oper = new semantics.FunctionApplication(oper, [result[i]], 
                    "sub");
                  i++;
                  // current position == '_', subscript or end
                } else {
                  i++;
                  // current position: first argument
                  array = [];
                  // current position should be an argument
                  while (i<result.length && result[i] != '}') {
                    // function argument
                    array.push(result[i]);
                    i++;

                    if (i<result.length && result[i]==',') {
                      // comma -> skip
                      i++;
                    }
                  }
                  // current position should be '}'
                  oper = new semantics.FunctionApplication(oper, array, "sub");

                  i++;
                  // current position == '_', subscript or end
                }
              }

              return oper;
            }
          ),
        func_super: rule_func_super,
	func_Update: func_subUpdate,
	// update function for infix expression
	infix_Update : function(expr) {
	  return expr;
	},
          // subscript : rule only occurs from presentation
        subscript: pG.never,
          // superscript : rule only occurs from presentation
	superscript: pG.never
        };
      }

    });

  }

);

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.expression.KeywordList = {};
});

  $package("org.mathdox.formulaeditor.parsing.expression");

$identify("org/mathdox/formulaeditor/parsing/expression/VariableList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.expression.VariableList = {};
});

  $package("org.mathdox.formulaeditor.parsing.mathml");

$identify("org/mathdox/formulaeditor/parsing/mathml/MathMLParser.js");

// NOTE: expression is on purpose, there is no keyword/variable list for mathml parsing yet
$require("org/mathdox/formulaeditor/Options.js");
$require("org/mathdox/formulaeditor/parsing/expression/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/expression/VariableList.js");
$require("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");
$require("org/mathdox/formulaeditor/presentation/Root.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

$main(function(){

  org.mathdox.formulaeditor.parsing.mathml.MathMLParser = 
      $extend(org.mathdox.formulaeditor.parsing.xml.XMLParser, {
    
    name: "MathMLParser",

    /* main handle function */
    handlemath: function(node, context) {
      return this.handlemrow(node, context);
    },

    /** 
     * artificial handle functions, not called by tags, 
     * but as helper functions 
     */
    handleTextNode: function(node, context, style) {
      // TODO:
      // - create symbols here
      // - ignore some symbols
      // - what to do with symbols that can't be shown
      var presentation = org.mathdox.formulaeditor.presentation;

      // use ""+... to force casting to string
      var value = ""+node.firstChild.nodeValue;

      var row;

      var arr = [];
      var i;

      for (i=0; i<value.length; i++) {
        var ch = value.charAt(i);
	if (org.mathdox.formulaeditor.presentation.SymbolAliases[ch] !== null) {
          if (style === null || style === undefined) {
	    arr.push(new presentation.Symbol(ch));
          } else {
	    arr.push(new presentation.Symbol(ch, style));
	  }
	}
      }
      row = new presentation.Row();
      row.initialize.apply(row, arr);

      return row;
    },

    /* 1 attribute is expected, if more are present an mrow is inferred, handle it as such.*/
    handleInferredMrow: function(node, context) {
      var children = node.childNodes;

      if (children.length != 1) {
        return this.handlemrow(node, context);
      } else {
        return this.handle(children.item(0));
      }
    },

    /** 
     * order based on mathml specs, in groups: token elements, general layout
     * schemata, script and limit schemata, tabular math, elementary math, enlivening expressions
     */
    /* 3.2 token elements */
    /* token math:mi */
    handlemi: function(node, context) {
      // TODO: check for layout information
      var result;
      var value = ""+node.firstChild.nodeValue;
      var parsing = org.mathdox.formulaeditor.parsing;
      var options = new org.mathdox.formulaeditor.Options();
      var presentation = org.mathdox.formulaeditor.presentation;

      if (parsing.expression.KeywordList[value] !== undefined) {
        result = new presentation.Row(
            parsing.expression.KeywordList[value].getPresentation(options.getPresentationContext()));
      } else if (parsing.expression.VariableList[value] !== undefined) {
        result = new presentation.Row(
	    parsing.expression.VariableList[value].getPresentation(options.getPresentationContext()));
      } else {
        result = this.handleTextNode(node, context, "math");
      }

      return result;
    },
    /* token math:mn */
    handlemn: function(node, context) {
      return this.handleTextNode(node, context);
    },
    /* token math:mo */
    handlemo: function(node, context) {
      return this.handleTextNode(node, context);
    },

    /* token math:ms */
    handlems: function(node, context) {
      var presentation = org.mathdox.formulaeditor.presentation;
      return new presentation.Row(new presentation.Symbol("\""), this.handleTextNode(node, context), 
	new presentation.Symbol("\""));
    },

    /* token math:mspace */
    handlemspace: function(node, context) {
      return null;
    },
    /* token math:mtext */
    handlemtext: function(node, context) {
      return this.handleTextNode(node, context);
    },
    /** 
     * general layout schemata
     *
     * supported elements:
     * mrow, mfrac, msqrt, mroot, mstyle(*), merror(*), mpadded(*),
     * mphantom(**), mfenced, menclose(*)
     *
     * notes: 
     *  * treated as mrow
     *  ** returns null
     */

    /* general layout : math:mrow */
    handlemrow: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        if (child !== null) { 
          // ignore comments
          entries.push(child);
        }
      }

      var row = new presentation.Row();
      row.initialize.apply(row, entries);
      return row;
    },

    /* general layout : math:mfrac */
    handlemfrac: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Fraction(entries[0], entries[1]);
    },    

    /* general layout : math:sqrt */
    handlemsqrt: function(node, context) {
      var presentation = org.mathdox.formulaeditor.presentation;
      
      var index = this.handleInferredMrow(node, context);
      var base = new presentation.Row("2");

      return new presentation.Row(new presentation.Root(index, base));
    },

    /* general layout : math:mroot */
    handlemroot: function(node, context) {
      var children = node.childNodes;

      var base = this.handle(children.item(0), context);
      var index = this.handle(children.item(1), context);

      var presentation = org.mathdox.formulaeditor.presentation;

      return new presentation.Root(index, base);
    },

    /*
     * general layout : math:mstyle 
     * currently : ignore, treat as row
     */
    handlemstyle: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:merror 
     * currently : ignore, treat as row
     */
    handlemerror: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:mpadded 
     * currently : ignore, treat as row
     */
    handlempadded: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:mphantom 
     * currently : return null
     */
    handlempadded: function(node, context) {
      return this.handlemrow(node, context);
    },

    /*
     * general layout : math:mphantom 
     */
    handlemfenced: function(node, context) {
      var opensymbol = node.getAttribute("open");
      var closesymbol = node.getAttribute("close");
      var separators = node.getAttribute("separators");
      var children = node.childNodes;

      var presentation = org.mathdox.formulaeditor.presentation;
      var entries = [];
      var i;

      if (opensymbol === null || opensymbol === undefined) {
	opensymbol = '(';
      } 
      entries.push(new presentation.Symbol(opensymbol));
      
      var separr;
      if (separators === null || separators === undefined) {
	separators = ',';
	separr = [ separators ];
      } else {
	separr = separators.split("\\s+");
	// check for empty parts
	if (separr[0] === "") {
	  // remove first element
	  separr = separr.slice(1);
	}

	if (separr.length>0) {
	  if (separr[separr.length] === "") {
	    // remove last element
	    separr.splice(separr.length-1);
          }
	}

	// check if length is 1, and if so update
	if (separr.length==1) {
	  var arr = [];

	  for (i=0;i<separr[0].length;i++) {
	    arr.push(separr[0].charAt(i));
	  }
	  separr = arr;
	}
      }

      // for each child : add child and possibly separator
      for (i = children.length - 1; i>=0; i--) {
        if (i>0) {
          // separator-attribute is not empty
	  var sep;
	  if (separr.length>0) { 
	    if (i<=separr.length) {
	      sep = separr[i];
	    } else {
	      sep = separr[0];
	    }
	  }
	  for (var j=0;j<sep.length;j++) {
            entries.push(new presentation.Symbol(sep.charAt[j]));
	  }
	}

	// add child
        var child = this.handle(children.item(i), context);

	entries.push(child);
      }

      if (closesymbol === null || closesymbol === undefined) {
	closesymbol = ')';
      } 
      entries.push(new presentation.Symbol(closesymbol));

      var row = new presentation.Row();
      row.initialize.apply(row, entries);
      return row;
    },

    /*
     * general layout : math:menclose 
     * currently : ignore, treat as row
     */
    handlemenclose: function(node, context) {
      return this.handlemrow(node, context);
    },

    /* 
     * script and limit schemata 
     *
     * supported elements:
     * msub, msup, msubsup
     *
     * not supported elements:
     * munder, mover, mmultiscripts
     */
     
    /* script and limit schemata : math:msub */
    handlemsub: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Row(entries[0], new presentation.Subscript(entries[1]));
    },

    /* script and limit schemata : math:msup */
    handlemsup: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Row(entries[0], new presentation.Superscript(entries[1]));
    },

    /* script and limit schemata : math:msubsup */
    handlemsubsup: function(node, context) {
      var children = node.childNodes;
      var entries = [];
      var presentation = org.mathdox.formulaeditor.presentation;

      for (var i=0; i<children.length; i++) {
        var child = this.handle(children.item(i), context);

        entries.push(child);
      }

      return new presentation.Row(entries[0], new presentation.Subscript(entries[1]), new presentation.Superscript(entries[2]));
    }
  });

});

  $package("org.mathdox.formulaeditor.parsing.openmath");

$identify("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.openmath.KeywordList = {};
});

  $package("org.mathdox.formulaeditor.parsing.openmath");

$identify("org/mathdox/formulaeditor/parsing/openmath/OpenMathParser.js");

$require("org/mathdox/formulaeditor/parsing/openmath/KeywordList.js");
$require("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");
$require("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");
$require("org/mathdox/formulaeditor/semantics/FunctionApplication.js");
$require("org/mathdox/formulaeditor/semantics/Integer.js");
$require("org/mathdox/formulaeditor/semantics/SemanticFloat.js");
$require("org/mathdox/formulaeditor/semantics/String.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");

$main(function(){

  org.mathdox.formulaeditor.parsing.openmath.OpenMathParser = $extend(
        org.mathdox.formulaeditor.parsing.xml.XMLParser, {

    name: "OpenMathParser",

    /**
     * Handles an <OMOBJ> node by processing its child node.
     */
    handleOMOBJ: function(node) {

      var child = node.firstChild;

      if (child !== null) {
        return this.handle(child);
      }
      else {
        return null;
      }

    },

    /**
     * Handle an <OMA> node.
     */
    handleOMA: function(node) {
      var symbol;
      var semantics = org.mathdox.formulaeditor.semantics;

      var style = node.getAttribute("style");

      // handle <OMA>'s with as first argument an <OMS/>
      if ("OMS" == node.firstChild.localName) {

        // helper function that uppercases first character of provided string
        var uppercase = function(string) {
            return string.substring(0,1).toUpperCase() + string.substring(1);
        };

        // figure out which handler method to call; for instance, for handling 
        // an <OMA> with as first argument <OMS cd='arith1' name='plus'/>, the
        // handleArith1Plus method is called
        var symbolname= node.firstChild.getAttribute("cd") + "__" + node.firstChild.getAttribute("name");

        var handler = "handle";

        handler += uppercase(node.firstChild.getAttribute("cd"));
        handler += uppercase(node.firstChild.getAttribute("name"));

        // call the handler method
        if (handler in this) {
          return this[handler](node, style);
        } else if (org.mathdox.formulaeditor.parsing.openmath.KeywordList[symbolname] !== null && org.mathdox.formulaeditor.parsing.openmath.KeywordList[symbolname] !== undefined) {
          /* return a FunctionApplication at the end */
          symbol = this.handleOMS(node.firstChild);
        } else {
          var cd = node.firstChild.getAttribute("cd");
          var name = node.firstChild.getAttribute("name");
          var keywordsymbol = {
            onscreen : null,
            openmath : null,
            mathml: "<mi>"+cd+"."+name+"</mi>"
          };
          symbol = new semantics.Keyword(cd, name, keywordsymbol, "function");
        }

      } else if ("OMV" == node.firstChild.localName) {
        /* return a FunctionApplication at the end */
        symbol = this.handleOMV(node.firstChild);
      } else if ("OMA" == node.firstChild.localName) {
        symbol = this.handleOMA(node.firstChild);
      } else {
        throw new Error(
          "OpenMathParser doesn't know how to handle an <OMA> that does " +
          "not have an <OMS/> or <OMV/> as first argument");

      }

      if (symbol) {
        var children = node.childNodes;
        var operands = [];

        for (var i=1; i<children.length; i++) {
          var child = this.handle(children.item(i));

          if (child !== null) { 
            // ignore comments
            operands.push(child);
          }
        }
       
        if (style !== "" && style !== null) {
          return new semantics.FunctionApplication(symbol, operands, style);
        } else {
          return new semantics.FunctionApplication(symbol, operands);
        }
      }
    },

    /**
     * Handles an <OMBIND> node by pretending its an <OMA> node.
     */
    handleOMBIND: function(node) {

      return this.handleOMA(node);

    },

    /**
     * Ignores an <OMBVAR> node.
     */
    handleOMBVAR: function(node) {

      return this.handle(node.firstChild);

    },

    /**
     * Handles an <OMF> node.
     */
    handleOMF: function(node) {

      var semantics = org.mathdox.formulaeditor.semantics;
      if (node.getAttribute("dec")) {
        return new semantics.SemanticFloat(node.getAttribute("dec"));
      }

    },

    /**
     * Handles an <OMI> node.
     */
    handleOMI: function(node) {

      var semantics = org.mathdox.formulaeditor.semantics;
      return new semantics.Integer(parseInt(node.firstChild.nodeValue));

    },

    /**
     * Handles an <OMS> node that is translated to a symbol without arguments
     */
    handleOMS: function(node) {
      var symbolname= node.getAttribute("cd") + "__" + node.getAttribute("name");
      var keyword = org.mathdox.formulaeditor.parsing.openmath.KeywordList[symbolname];

      if (keyword !== null && keyword !== undefined) {
        if (keyword.type == "constant" || keyword.type == "function") {
          return keyword;
        } else if (keyword.type == "infix" || keyword.type == "unary") {
          //check if parent is palette_row
          var error = false; // set to true if an error is found
          var parentNode = node.parentNode;
          var omsNode = parentNode.firstChild;
          if (omsNode.localName!="OMS") {
            throw new Error(
              "OpenMathParser doesn't know how to handle this keyword of unknown type ("+keyword.type+"): " + node + " when it is not first in an <OMA>. First sibling is "+ omsNode.localName+".");
          }
          if (omsNode.getAttribute("cd")=="editor1" && 
            omsNode.getAttribute("name")=="palette_row") {
            // inside a palette_row -> return the found infix symbol
            return keyword;
          } else {
            throw new Error(
              "OpenMathParser doesn't know how to handle this keyword of unknown type ("+keyword.type+"): " + node + " when it is not first in an <OMA>. INFO: was expecting symbol reference 'editor1.palette_row' instead found '"+omsNode.getAttribute("cd")+"."+omsNode.getAttribute("name")+"'.");
          }

        } else {
          throw new Error(
            "OpenMathParser doesn't know how to handle this keyword of unknown type ("+keyword.type+"): " + node + " when it is not first in an <OMA>.");
        }
      } else {
        var semantics = org.mathdox.formulaeditor.semantics;
        var cd = node.getAttribute("cd");
        var name = node.getAttribute("name");
        var keywordsymbol = {
          onscreen : null,
          openmath : null,
          mathml: "<mi>"+cd+"."+name+"</mi>"
        };
        return new semantics.Keyword(cd, name, keywordsymbol, "constant");
      }
    },

    /**
     * Handles an <OMSTR> node.
     */
    handleOMSTR: function(node) {
      var semantics = org.mathdox.formulaeditor.semantics;
      var children = [];
      var name="";
      var i;
      var child;
      for (i=0;i<node.childNodes.length; i++) {
	child = node.childNodes.item(i);
        if (child.nodeType == 3) { // Node.TEXT_NODE
	  children.push(child.nodeValue);
	}
      }
      return new semantics.SString(children.join(""));
    },
    /**
     * Handles an <OMV> node.
     */
    handleOMV: function(node) {

      var semantics = org.mathdox.formulaeditor.semantics;
      var varname= node.getAttribute("name");
      var variable = org.mathdox.formulaeditor.parsing.openmath.VariableList[varname];

      if (variable !== null && variable !== undefined) {
	return variable;
      } else {
      	return new semantics.Variable(varname);
      }

    }

  });

});

  $package("org.mathdox.formulaeditor.parsing.openmath");

$identify("org/mathdox/formulaeditor/parsing/openmath/VariableList.js");

$main(function(){
  org.mathdox.formulaeditor.parsing.openmath.VariableList = {};
});

  $package("org.mathdox.formulaeditor.parsing.xml");

$identify("org/mathdox/formulaeditor/parsing/xml/XMLParser.js");

$main(function(){

  org.mathdox.formulaeditor.parsing.xml.XMLParser = $extend(Object, {

    name: "XMLParser",

    /**
     * Parses the supplied OpenMath xml, and returns a
     * org.mathdox.formulaeditor.semantics.Node.
     */
    parse: function(xml, context) {
      var rootnode;
      var xmlDoc;

      if (window.DOMParser)
      {
        parser=new DOMParser();
        xmlDoc=parser.parseFromString(xml,"text/xml");
      } else {
        // XXX: old Internet Explorer
        // test in IE 8 without this to see if we can remove legacy code

        xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async=false;
        xmlDoc.loadXML(xml); 
      } 
      rootnode = xmlDoc.documentElement;

      /* remove comment nodes, since we don't want to parse them */
      if (rootnode !== null) {
        this.removeComments(rootnode);
        this.removeWhitespace(rootnode);
      } else {
        return null;
      }
      
      /* do the actual parsing */
      if (rootnode !== null) {
        return this.handle(rootnode, context);
      } else {
        return null;
      }

    },

    /**
     * Extracts the local name of the node, and uses that to figure out which
     * method should be called to handle this node. For instance, when an
     * <OMI> node is encountered, the handleOMI method is called.
     */
    handle: function(node, context) {
      if (node.localName === null) {
        // XML comment or text
        return null;
      }

      var handler = "handle" + node.localName;

      if (handler in this) {
	if (context !== null && context!== undefined) {
          return this[handler](node, context);
	} else {
          return this[handler](node);
	}
      }
      else {
        throw new Error( this.name+" doesn't know how to handle this "+
            "node: " + node +". INFO: 1.");
      }

    },

    /**
     * Removes all comment nodes from a DOM XML tree
     */
    removeComments: function(node) {
      var children = node.childNodes;

      for (var i=children.length - 1; i>=0; i--) {
        var child = children.item(i);

        if (child) {
          if (child.nodeType == 8) { // 8: COMMENT_NODE
            node.removeChild(child);
          } else if (child.hasChildNodes()) {
            this.removeComments(child);
          }
        }
      }
    },

    /**
     * Removes all whitespace text nodes from a DOM XML tree
     */
    removeWhitespace: function(node) {
      var children = node.childNodes;

      for (var i=children.length - 1; i>=0; i--) {
        var child = children.item(i);

        if (child) {
          if (child.nodeType == 3) { // 3: TEXT_NODE
            var value = child.nodeValue.trim();
	    if (value === "") {
              node.removeChild(child);
	    }
          } else if (child.hasChildNodes()) {
            this.removeWhitespace(child);
          }
        }
      }
    }

  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/BlockSymbol.js");

$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){
  /**
   * Representation of an empty space in a row in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.BlockSymbol =
    $extend(org.mathdox.formulaeditor.presentation.Symbol, {

    initialize : function() {
      // U+25A1 white square
      this.value = '□';

      if (arguments.length == 1) {
        this.onscreen = arguments[0];
      } else {
        this.onscreen = "f";
      }
    },

    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone(this.onscreen);
    },
    draw : function(canvas, context, x, y, invisible) {
      var fontSizeModifier = 0;
      if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
        fontSizeModifier = context.fontSizeModifier;
      }

      this.dimensions = canvas.drawFBox(
        Math.round(x), Math.round(y), invisible, this.onscreen, this.typeface, fontSizeModifier);

      return this.dimensions;
    }
  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Boxed.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){
  org.mathdox.formulaeditor.presentation.Boxed =
    $extend(org.mathdox.formulaeditor.presentation.Node, {

    semanticClass : null,

    children : null,

    margin : 5,

    slowDelete: true,
    
    initialize : function(semanticClass, children, presentation) {
      this.semanticClass = semanticClass;
      this.children = children;
      this.presentation = presentation;
      this.updateChildren();
    },

    draw : function(canvas, context, x, y, invisible) { 
      var dim = this.presentation.draw(canvas, context, 0, 0, true);

      var height = this.presentation.dimensions.height;
      var width = this.presentation.dimensions.width;

      this.dimensions = {
        height : height + 2*this.margin,
        width : width + 2* this.margin,
        left : dim.left + x,
        top : dim.top + y - this.margin 
      }

      this.drawHighlight(canvas, invisible);

      if (!invisible) {
        canvas.drawBox(this.dimensions, "#7F7F7F");
        this.presentation.draw(canvas, context, x + this.margin, y, false);
      }

      return this.dimensions;
    },

    getFirstCursorPosition : function(index) {
      return this.getFollowingCursorPosition();
    },
    
    getLastCursorPosition : function(index) {
      return this.getPrecedingCursorPosition();
    },

    getFollowingCursorPosition : function(index) {
      var result = null;

      if (index === null||index === undefined ) {
	result = this.children[0].getFirstCursorPosition();
      } else if (index + 1 < this.children.length) {
	result = this.children[index+1].getFollowingCursorPosition();
      }

      if (((result === null)|| (result === undefined)) && (this.parent !== null)) {
        result = this.parent.getFollowingCursorPosition(this.index, false);
      }

      return result;
    },

    getPrecedingCursorPosition : function(index) {
      var result = null;

      if (index === null||index === undefined ) {
	result = this.children[this.children.length -1].getLastCursorPosition();
      } else if (index - 1 >= 0) {
	result = this.children[index-1].getPrecedingCursorPosition();
      }

      if (((result === null)|| (result === undefined)) && (this.parent !== null)) {
        return { row: this.parent, index: this.index };
      }

      return result;
    },

    getCursorPosition : function(x, y) {
      /* starting minimum is distance to closest side border */
      var dmin = Math.min(Math.abs(x- this.dimensions.left),Math.abs((this.dimensions.left+this.dimensions.width) - x));
      var dx;
      var idx = -1;
      
      for (var i = 0; i< this.children.length; i++) {
        var child = this.children[i];
        if (x < child.dimensions.left) {
          dx = child.dimensions.left - x;
        } else if (x <= child.dimensions.left + child.dimensions.width) {
          dx = 0;
        } else {
          dx = x - (child.dimensions.left + child.dimensions.width);
        }
        
	if (dx<dmin) {
          idx = i;
          dmin = dx;
        }
      }

      var pos;
      if (idx >=0) {
        pos = this.children[idx].getCursorPosition(x,y);
        if (pos !== null) {
          return pos;
        } else {
          if (x >= this.children[idx].dimensions.left + this.children[idx].dimensions.width) {
            return this.children[idx].getPrecedingCursorPosition();
          } else {
            return this.children[idx].getFollowingCursorPosition();
          }
        }
      } else { /* code from Node.js */
        if (this.parent !== null) {
          if (x < this.dimensions.left + this.dimensions.width / 2) {
            return this.parent.getPrecedingCursorPosition(this.index+1,false);
          }
          else {
            return this.parent.getFollowingCursorPosition(this.index,false);
          }
        } else {
          return null;
        }
      }
    },

    getSemantics : function(context) {
      var values = [];
      var i;
      for (i=0; i<this.children.length; i++) {
        values.push(this.children[i].getSemantics(context).value);
      }

      var value = null;

      if (this.semanticClass !== null) {
	value = new this.semanticClass();
	value.initialize.apply(value, values);
      }

      return {
        value : value,
        rule : "braces"
      }

    }
  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Bracket.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a mathematical bracket (with minimum height) in the
   * presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Bracket =
    $extend(org.mathdox.formulaeditor.presentation.Symbol, {

      /**
       * A string representation of the symbol.
       */
      value : null,
      /**
       * A string representation of the symbol for on the screen
       */
      onscreen : null,

      /*
       * Minimum desired height
       */
      minimumHeight : 1,

      /**
       * Initializes a Symbol node in the presentation tree using the specified
       * string representation of a symbol.
       */
      initialize : function() {

        if (arguments.length > 0) {
          this.value = arguments[0];
        }
        if (arguments.length > 1) {
          this.minimumHeight = arguments[1];
        }
        if (arguments.length > 2) {
          this.onscreen = arguments[2];
        }

      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        return this.clone(this.value, this.minimumHeight, this.onscreen);
      },

      /**
       * Draws the symbol to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var symbol = this.value;
        if (this.onscreen !== null) {
          symbol = this.onscreen;
        }

        this.dimensions = canvas.drawBracket(
          symbol, Math.round(x), Math.round(y), this.minimumHeight, invisible);

        return this.dimensions;

      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Bracketed.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Bracketed =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      // array
      middle : null,
      // left bracket
      leftBracket : null,
      // right bracket
      rightBracket : null,
      // should we draw boxes ?
      drawBox : false,
      // enable slow deleting
      slowDelete : true,

      /**
       * Draws the matrix to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var height;

        // invisible drawing of array to set dimensions
        
        this.middle.draw(canvas, context, 0, 0, true);

        // if the left and right symbols are brackets set the height
        // XXX check if they are brackets
        this.leftBracket.minimumHeight = 
          this.middle.dimensions.height;
        this.rightBracket.minimumHeight = 
          this.middle.dimensions.height;

        // invisible drawing of brackets to set dimensions
        this.leftBracket.draw(canvas, context, 0, 0, true);
        this.rightBracket.draw(canvas, context, 0, 0, true);

        height = Math.max(
            this.leftBracket.dimensions.height,
            this.middle.dimensions.height,
            this.rightBracket.dimensions.height);

        var yAdjust = 0;
        var yAdjustBrackets = 0;
        
        // brackets are higher than the array
        if (height>this.middle.dimensions.height) {
          yAdjust = (height - this.middle.dimensions.height)/2;
        }

        // brackets are smaller than the array
        // assuming right bracket has the same size as the left bracket
        if (this.leftBracket.dimensions.height<height) {
          yAdjustBrackets = (height - this.leftBracket.dimensions.height)/2;
        }

        this.dimensions = { 
          height : height,
          width : 
            this.leftBracket.dimensions.width +
            this.middle.dimensions.width +
            this.rightBracket.dimensions.width,
          left : x,
          top : y + this.middle.dimensions.top - yAdjust
        };
        
	this.drawHighlight(canvas, invisible);

        this.leftBracket.minimumHeight = this.middle.dimensions.height;
        this.leftBracket.draw(canvas, context,  
          x - this.leftBracket.dimensions.left, 
          this.dimensions.top + yAdjustBrackets - 
          this.leftBracket.dimensions.top, 
          invisible);

        this.middle.draw(canvas, context,  
          x + this.leftBracket.dimensions.width - this.middle.dimensions.left, 
          y, invisible);

        this.rightBracket.minimumHeight = this.middle.dimensions.height;
        this.rightBracket.draw(canvas, context, 
          x + this.rightBracket.dimensions.width + 
            this.middle.dimensions.width - this.rightBracket.dimensions.left,
          this.dimensions.top + yAdjustBrackets - 
          this.rightBracket.dimensions.top, 
          invisible);
        
        if ((!invisible) &&this.drawBox) {
          canvas.drawBox(this.middle.dimensions);
          canvas.drawBoxWithBaseline(this.leftBracket.dimensions, this.dimensions.top + this.dimensions.height - yAdjustBrackets);
          canvas.drawBoxWithBaseline(this.rightBracket.dimensions, this.dimensions.top + this.dimensions.height - yAdjustBrackets);
          canvas.drawBoxWithBaseline(this.dimensions,y);
        }

        return this.dimensions;
      },
      functionsFromRow : [ "getFirstCursorPosition",
        "getLastCursorPosition", "getLowerCursorPosition",
        "getHigherCursorPosition" ],
      getCursorPosition: function(x,y) {
        var dimensions;

        dimensions = this.leftBracket.dimensions;
        if (x < dimensions.left + dimensions.width) {
          if (this.parent !== null) {
            return { row: this.parent, index: this.index };
          } else {
            return null;
          }
          return this.getFollowingCursorPosition();
        }
        dimensions = this.middle.dimensions;
        if (x < dimensions.left + dimensions.width) {
          return this.middle.getCursorPosition(x,y);
        }
        if (this.parent !== null) {
          return { row: this.parent, index: this.index+1 };
        } else {
          return this.getPrecedingCursorPosition();
        }
      },
      getFollowingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          return this.middle.getFollowingCursorPosition();
        }
        
        var result = null;

        if (index === 0) {
          if (descend) {
            result = this.middle.getFollowingCursorPosition();
          }
        }

        if (result === null) {
          // when we're at the end of the matrix, ask the parent of the matrix
          // for the position following this matrix
          if (this.parent !== null) {
            return this.parent.getFollowingCursorPosition(this.index, false);
          }
        }
        
        return result;
      },
      getPrecedingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          return this.middle.getPrecedingCursorPosition();
        }
        
        var result = null;

        if (index == 1) {
          if (descend) {
            result = this.middle.getPrecedingCursorPosition();
          }
        }

        if (result === null) {
          // when we're at the beginning of the matrix, ask the parent of the
          // matrix for the position before this matrix
          if (this.parent !== null) {
            return this.parent.getPrecedingCursorPosition(this.index+1, false);
          }
        }
        
        return result;
      },
      initialize : function () {
        if (arguments.length>0) {
          this.leftBracket = arguments[0];
          this.middle = arguments[1];
          this.rightBracket = arguments[2];
          this.children = [];
          this.children.push(this.middle);
        } else {
          this.children = [];
        }

        var presentation = org.mathdox.formulaeditor.presentation;
        /* copy the cursor/position functions from Row */

        var row = new presentation.Row(); // only an instance has the functions

        for (var i=this.functionsFromRow.length - 1; i>=0; i--) {
          if (! this[this.functionsFromRow[i]] ) {
            this[this.functionsFromRow[i]] = 
              row[ this.functionsFromRow[i] ];
          }
        }
        this.updateChildren();
      },
      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also Presentation/Node.js
       */
      copy : function () {
        return this.clone(this.leftBracket.copy(), this.children[0].copy(), this.rightBracket.copy());
      },
      getSemantics: function(context) {
	var sem = this.middle.getSemantics(context, null, null, "functionArguments", null);
	var value = sem.value;

	if (!(value instanceof Array)) {
	  return {
            rule: "braces",
            value: value
          };
	} else if (value.length === 1) {
	  // NOTE: probably should not occur
	  return {
            rule: "braces",
            value: value[0]
          };
	} else {
          return {
	    rule: "bracesWithSeparatedArguments",
	    value: value
          };
        }
      }
    });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Column.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Column =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      slowDelete: true,
      /*
       * the margin between the entries
       */
      margin: 2.0,

      /**
       * should we draw a box around the column and all entries ?
       */
      drawBox : false,

      /**
       * To add a fontSizeModifier for each row; create a list with an entry for each row.
       * this is added to the fontSizeModifier of the context. 
       *
       * For example a column with three rows, where the top and lower row are smaller would have
       * fontSizeModifierArray = [ -1, 0, -1 ]
       *
       * Note the name Array: this is added because it is not a single value
       */
      fontSizeModifierArray : null,

      /**
       * To use a different baseline then the default set this variable.
       * The index here will be used to select the row which is placed on the baseline.
       * This is used for functions like logarithm.
       */
      baselineIndex: null,

      /**
       * Draws the column to the canvas.
       *
       * vertical align on middle column: Math.floor((this.children.length)/2)
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {

        // the amount of space between the column elements
        var margin = this.margin;
        var rowInfo = [];

        // determine the dimensions of the children, and the maximum width
        var maxWidth = 0;
        var totalHeight = 0;

        var childContextArray = [];

        for (var i=0; i<this.children.length; i++) {
          var height;
          var top;
          var baseline;

          var modifiedContext;
          
          if (this.fontSizeModifierArray !== null && 
            this.fontSizeModifierArray[i]!==undefined && this.fontSizeModifierArray[i]!== null) {

	    modifiedContext = { fontSizeModifier : 0 };
            for (var name in context) {
              modifiedContext[name] = context[name];
            }
            modifiedContext.fontSizeModifier = modifiedContext.fontSizeModifier + this.fontSizeModifierArray[i];
          } else {
            modifiedContext = context;
          }

          childContextArray.push(modifiedContext);

          var dimensions = this.children[i].draw(canvas, childContextArray[i], 0, 0, true);

          maxWidth = Math.max(maxWidth, dimensions.width);
          height = dimensions.height;
          if (i === 0) {
            baseline = 0;
            top = baseline + dimensions.top;
            totalHeight += height;
          } else {
            top = rowInfo[i-1].top + rowInfo[i-1].height + margin;
            baseline = top - dimensions.top;
            totalHeight += height + margin;
          }

          rowInfo[i] = {
            height: height,
            top: top,
            baseline: baseline
          };
        }

        // determine the baseline of the column (vertical aligned on middle
        // row, rounded down)
        
        var usedBaseline;
	if (this.baselineIndex === null) {
	  usedBaseline = rowInfo[Math.floor(this.children.length/2)].baseline;
        } else {
	  usedBaseline = rowInfo[this.baselineIndex].baseline;
        }

        var row; // counter
        for (row = 0; row < this.children.length; row++) {
          rowInfo[row].top -= usedBaseline;
          rowInfo[row].baseline -= usedBaseline;
        }

        this.dimensions = {
          top: y + rowInfo[0].top,
          left: x,
          width: maxWidth,
          height: totalHeight
        };

        this.drawHighlight(canvas, invisible);

        // center of the column
        var center = x + maxWidth/2;

        for (row = 0; row < this.children.length; row++) {
          var childLeft = center - this.children[row].dimensions.width/2;
          this.children[row].draw(canvas, childContextArray[row], childLeft, y + rowInfo[row].baseline, 
            invisible);
        }

        if ((!invisible) && this.drawBox) {
          canvas.drawBoxWithBaseline(this.dimensions,y);
        }

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        for (var i=0; i<this.children.length - 1; i++) {
          if (y < this.children[i+1].dimensions.top) {
            return this.children[i].getCursorPosition(x,y);
          }
        }
        return this.children[this.children.length - 1].getCursorPosition(x,y);

      },

      /**
       * See also Node.getFollowingCursorPosition(index).
       */
      getFollowingCursorPosition : function(index) {
        var result = null;

        if (index === null|| index === undefined) {
          var middle = Math.floor(this.children.length / 2);
          var i      = middle;
          while(result === null && 0<=i && i<this.children.length) {
            result = this.children[i].getFollowingCursorPosition();
            if (i>=middle) {
              i = 2*middle - i - 1;
            }
            else {
              i = 2*middle - i;
            }
          }
        }

        if ((result === null) && (this.parent !== null)) {
          result =  this.parent.getFollowingCursorPosition(this.index, false);
        }

        return result;

      },

      getPrecedingCursorPosition : function(index) {

        if (index === null || index === undefined) {
          var result = null;
          var middle = Math.floor(this.children.length / 2);
          var i      = middle;
          while(result === null && 0<=i && i<this.children.length) {
            result = this.children[i].getPrecedingCursorPosition();
            if (i>=middle) {
              i = 2*middle - i - 1;
            }
            else {
              i = 2*middle - i;
            }
          }
          return result;
        }

        if (this.parent !== null) {
          return this.parent.getPrecedingCursorPosition(this.index+1, false);
        }

        return null;

      },

      getLowerCursorPosition : function(index, x) {
        var last = this.children.length - 1;
        if (index === null || index === undefined) {
          return this.children[0].getLowerCursorPosition(null, x);
        }
        else {
          if (index < last) {
            return this.children[index + 1].getLowerCursorPosition(null, x);
          }
          else {
            return arguments.callee.parent.getLowerCursorPosition.call(this, index, x);
          }
        }
      },

      getHigherCursorPosition : function(index, x) {
        var last = this.children.length - 1;
        if (index === null || index === undefined) {
          return this.children[last].getHigherCursorPosition(null, x);
        }
        else {
          if (index > 0) {
            return this.children[index - 1].getHigherCursorPosition(null, x);
          }
          else {
            return arguments.callee.parent.getHigherCursorPosition.call(this, index, x);
          }
        }
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Editor.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of the editor root element in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Editor =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      /**
       * margin around the edges
       */
      margin : 4.0,

      /**
       * width of the palette enable/disable bar
       */
      barwidth: 10.0,

      /**
       * colors of the bar, default for on : AAF,  off: DDF
       */
      barcolor: { on: "#AAF", off: "#DDF" },

      /**
       * status of the bar, one of the following
       * "this": palette for this editor
       * "none": no palette at all
       * "other": palette for another editor
       */
      barstatus: null,

      /**
       * The arguments to the constructor are the children of this node.
       */
      initialize : function(pres, paletteEnabled) {
        var Row = org.mathdox.formulaeditor.presentation.Row;
        var row;

        if (paletteEnabled !== undefined && paletteEnabled !== null) {
          this.paletteEnabled = paletteEnabled;
        }

        this.children = [];
        if (pres) {
          row = new Row(pres);
          row.flatten();
        } else {
          row = new Row();
        }
        this.children.push(row);
        this.updateChildren();
      },
      
      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        // NOTE: assuming children contains a single row, and taking the first
        // subchild
        //
        // should also work with one children[0] less (but that might create an
        // additional row which needs updating away)
        return this.clone(this.children[0].copy(), this.paletteEnabled);
      },
 
      /**
       * Draws the editor to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var dimensions = this.children[0].draw(canvas, context, 0, 0, true);

        if (! invisible) {
          this.children[0].draw(canvas, context, x + this.margin - dimensions.left, y + this.margin);
        }

        /* draw bar */
        var boxdimensions = {
          left:   x + dimensions.width + 2 * this.margin,
          top:    y + dimensions.top, 
          height: dimensions.height + 2 * this.margin,
          width:  this.barwidth
        };
        /* draw the box */
        if (! invisible) {
	  var color;
          if (this.paletteEnabled) {
	    color = this.barcolor.on;
          } else {
	    color = this.barcolor.off;
	  }
          canvas.drawBox(boxdimensions, color, color);
        }

        this.dimensions = {
          left: x,
          top: boxdimensions.top,
          height: boxdimensions.height,
          width: dimensions.width + 2* this.margin + this.barwidth
        };

        return this.dimensions;
      },

      getCursorPosition : function(x, y) {
        if (x<this.dimensions.width - this.barwidth) {
          return this.children[0].getCursorPosition(x, y);
        } else {
          return null;
        }
      },

      getFirstCursorPosition : function(index) {
        return this.children[0].getFollowingCursorPosition();
      },
      getFollowingCursorPosition : function(index, descend) {
        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        if (!descend) {
          return null;
        }
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        return null;
      },
      getPrecedingCursorPosition : function(index, descend) {
        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        if (!descend) {
          return null;
        }
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        return null;
      },
      getLastCursorPosition : function(index) {
        return this.children[0].getPrecedingCursorPosition();
      },
      onmousedown : function(event, editor, x, y) {
        if (x>=this.dimensions.width - this.barwidth) {
          /* toggle bar */
          editor.togglePalette();
          if (editor.palette) {
            this.paletteEnabled = true;
          } else {
            this.paletteEnabled = false;
          }
        }
      },
      getSemantics : function (context) {
	return this.children[0].getSemantics(context);
      }
      
    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Fraction.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a fraction in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Fraction =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      slowDelete : true,

      /**
       * Draws the fraction on the canvas.
       *
       * vertically aligned on middle of previous symbol if present or middle
       * of a letter x (on the baseline) otherwise
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {

        var dim0;
        var presentation = org.mathdox.formulaeditor.presentation;
        if (this.parent instanceof presentation.Row && this.index > 0) {
          dim0 = this.parent.children[this.index - 1].dimensions;
        }
        else {
          dim0 = new presentation.Symbol("x").draw(canvas,context, x,y,true);
        }

        y = dim0.top + (dim0.height/2);

        x = Math.round(x);
        y = Math.round(y);

        var upper = this.children[0];
        var lower = this.children[1];

        var margin = 4.0;
        var lineWidth = 1.0;

        var upperDimensions = upper.draw(canvas, context, 0, 0, true);
        var lowerDimensions = lower.draw(canvas, context, 0, 0, true);

        var left   = x + Math.min(upperDimensions.left, lowerDimensions.left);
        var top    = y - upperDimensions.height - margin;
        var width  = Math.max(upperDimensions.width, lowerDimensions.width) + 
	  2 * margin;
        var height = upperDimensions.height + lowerDimensions.height + 
	  2 * margin + lineWidth;

        this.dimensions = {
          left   : left,
          top    : top,
          width  : width,
          height : height
        };

        this.drawHighlight(canvas, invisible);

        // draw upper part
        upper.draw(
          canvas, context,
          x + (width/2) - (upperDimensions.width/2),
          top - upperDimensions.top,
          invisible);

        if (!invisible) {

          // draw line
          var canvasContext = canvas.getContext();
          canvasContext.save();
          canvasContext.lineWidth = lineWidth;
          canvasContext.beginPath();
          canvasContext.moveTo(x,y);
          canvasContext.lineTo(x+width,y);
          canvasContext.stroke();
          canvasContext.closePath();
          canvasContext.restore();

        }

        // draw lower part
        lower.draw(
          canvas, context,
          x + (width/2) - (lowerDimensions.width/2),
          y + margin - lowerDimensions.top + 1,
          invisible);

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        var upper = this.children[0].dimensions;
        var lower = this.children[1].dimensions;

        if (y < ((upper.top + upper.height) + lower.top) / 2) {
          return this.children[0].getCursorPosition(x, y);
        }
        else {
          return this.children[1].getCursorPosition(x, y);
        }

      },

      getFollowingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row: this.parent, index: this.index + 1 };
          }
          else {
            return null;
          }
        }
      },

      getPrecedingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row: this.parent, index: this.index };
          }
          else {
            return null;
          }
        }
      },

      // TODO: something fishy when moving through 2/3/4
      getLowerCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          return this.children[0].getLowerCursorPosition(null, x);
        }
        else {
          if (index === 0) {
            return this.children[1].getLowerCursorPosition(null, x);
          }
          else {
            if (this.parent !== null ) {
              return this.parent.getLowerCursorPosition(this.index, x);
            } else {
              return null;
            }
          }
        }
      },

      getHigherCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          return this.children[1].getHigherCursorPosition(null, x);
        }
        else {
          if (index == 1) {
            return this.children[0].getHigherCursorPosition(null, x);
          }
          else {
            if (this.parent !== null) {
              return this.parent.getHigherCursorPosition(this.index, x);
            }
            else {
              return null;
            }
          }
        }
      },

      getSemantics : function(context) {
        return {
          value : new org.mathdox.formulaeditor.semantics.Divide(
                    this.children[0].getSemantics(context).value,
                    this.children[1].getSemantics(context).value),
          rule  : "divide"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Matrix.js");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");
$require("org/mathdox/formulaeditor/modules/linalg/matrixrow.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Matrix =
    $extend(org.mathdox.formulaeditor.presentation.Bracketed, {
      // variable to store the array to get the semantics
      pArray : null,

      initialize : function () {
        var presentation = org.mathdox.formulaeditor.presentation;
        var leftBracket = new presentation.Bracket('(');
        var rightBracket = new presentation.Bracket(')');

        this.pArray = new presentation.PArray();
          
        this.pArray.initialize.apply(this.pArray,arguments);
        this.pArray.margin = 10.0;

        arguments.callee.parent.initialize.call(this, leftBracket,
          this.pArray, rightBracket);
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        return this.clone.apply(this, this.copyArray(this.pArray.entries));
      },

      getSemantics : function(context) {
        var rows = this.pArray.entries; // this.middle is the pArray
        var semanticRows;
        var matrix;

        var semantics = org.mathdox.formulaeditor.semantics;
        semanticRows = [];
        for (var i=0;i<rows.length;i++) {
          var semanticRowEntries;

          semanticRowEntries = [];
          for (var j=0; j<rows[i].length;j++) {
            semanticRowEntries.push(rows[i][j].getSemantics(context).value);
          }
          var semanticRow = new semantics.Linalg2Matrixrow();
          semanticRow.initialize.apply(semanticRow, semanticRowEntries);
          semanticRows.push(semanticRow);
        }
        matrix = new semantics.Linalg2Matrix();
        matrix.initialize.apply(matrix, semanticRows);

        return {
          value : matrix,
          rule  : "braces"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a node in the presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Node = $extend(Object, {

    /**
     * The parent node of this node.
     */
    parent : null,

    /**
     * The amount of siblings preceding this node.
     */
    index : null,

    /**
     * The child nodes of this node.
     */
    children : [],

    /**
     * The position and dimensions of the node when it was last rendered to a
     * canvas.
     */
    dimensions : null,

    /**
     * Indicate if this should be drawn with a highlight. Note: not all items
     * might support highlights.
     */
    highlight: false,

    /**
     * Indicate if this should not be deleted directly. The item will be
     * highlighted instead.
     */
    slowDelete: false,

    /**
     * Indicate this is on the baseline (for superscript/subscript drawing)
     */
    onBaseline: true,

    /**
     * The arguments to the constructor are the children of this node.
     */
    initialize : function() {

      this.children = Array.prototype.slice.call(arguments);
      this.updateChildren();

    },

    /*
      if ( typeof Object.getPrototypeOf !== "function" ) {
        if ( typeof "test".__proto__ === "object" ) {
          Object.getPrototypeOf = function(object){
            return object.__proto__;
          };
        } else {
          Object.getPrototypeOf = function(object){
            // May break if the constructor has been tampered with
            return object.constructor.prototype;
          };
        }
      }
    */

    /**
     * Returns a copy of an object initialized with arguments args, which
     * should be an array.
     */
    clone: function() {
      var constructor = function(){};
      constructor.prototype = Object.getPrototypeOf(this);

      var result = new constructor();
      result.initialize.apply(result, arguments);
      
      return result;
    },

    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone.apply(this, this.copyArray(this.children));
    },

    /**
     * Returns a copy of an array of presentation objects, without index
     * information. To be used for copy/paste or undo.
     */
    copyArray: function(arr) {
      var result = [];

      for (var i=0;i<arr.length;i++) {
        if (arr[i] instanceof Array) {
          result.push(this.copyArray(arr[i]));
	} else {
          result.push(arr[i].copy());
        }
      }
      return result;
    },

    /**
     * Test to see if we can delete this item.
     *
     * Result: 
     *   Returns true if this can be deleted. Returns false if this should not
     *   be deleted yet. This allows highlighting an item before deleting it.
     */
    deleteItem: function() {
      if (this.slowDelete === true) {
        if (this.highlight === true) {
          return true;
        } else {
          this.setHighlight(true);

          return false;
        }
      } else {
        return true;
      }
    },

    /**
     * Draws the node on the specified canvas context. This is an abstract
     * method, so it is expected that subclasses will override this method.
     *
     * Parameter canvas: The 2d context of the canvas upon which this node is
     *   expected to draw itself
     * Parameter context: The draw context (subscript font is smaller; etc)
     * Parameters x,y: The (x,y) coordinate indicates where the left of the
     *   baseline of the node will appear.
     * Parameter invisible: This is an optional boolean parameter that indicates
     *   whether or not the node should be drawn to the canvas. It defaults to
     *  'false'. Setting this parameter to 'true' can be used to obtain
     *   information about the dimensions of the node, without actually
     *   drawing on the canvas.
     * Result : an object containing the values { left, top, width, height }
     *   that indicate the position and dimensions of the bounding rectangle
     *   of the node.
     */
    draw : function(canvas, context, x, y, invisible) {

      throw new Error("abstract method called");

    },

    /**
     * draws the background when highlighted
     *
     * Parameter dimensions: the size of the object
     */
    drawHighlight : function(canvas, invisible) {
      var dimensions = this.dimensions;
      if ( (invisible === undefined || invisible === null || invisible === false ) && this.highlight === true) {
        canvas.drawBox(dimensions, "#66C", "rgba(160,160,255,0.5)");
        //canvas.drawBox(dimensions, "#66C", "rgba(255,0,0,0.5)");
      }
    },

    /**
     * Returns the MathML presentation of the node. This is an abstract method,
     * so it is expected that subclasses will override this method.
     */
    getMathML : function(mrow) {
      throw new Error("abstract method called");
    },

    /**
     * Method which is called whenever this node changes. Calls the parent's
     * onchange method by default.
     */
    onchange : function(node) {

      if (this.parent !== null) {
        this.parent.onchange(this);
      }

    },

    /**
     * Called whenever a keypress has been detected when the cursor was at the
     * specified index. Does nothing by default, should be overridden to do
     * something usefull.
     */
    onkeypress : function(index, event) {

      // skip

    },

    /**
     * Called whenever a mouseclick has been detected at position (x,y), and no
     * new cursor position could be found. Put other actions here.
     * If the event is handled, return false.
     */
    onmousedown : function(event, editor, x, y) {
      // skip
      return true;

    },

    /**
     * Flattens the tree, meaning that all rows inside rows will be moved into
     * one row.
     */
    flatten : function() {

      // flatten the child nodes
      for (var i=0; i<this.children.length; i++) {
        if (! this.children[i]) {
          alert("no child at :"+i);
        } else if (! this.children[i].flatten) {
          alert("no flatten in : "+i+".");
        } else {
          this.children[i].flatten();
        }
      }

    },

    /**
     * Re-calculates each child's index value, and sets each child's parent
     * value. This method should be called after a change in the tree. When the
     * 'begin' argument is specified, only the children at index >= begin will
     * be updated.
     */
    updateChildren : function(begin) {

      if ((begin === null) || (begin === undefined)) {
        begin = 0;
      }
      for (var i=begin; i<this.children.length; i++) {
        if (! this.children[i]) {
          alert("empty child : "+i+".");
        } else {
          this.children[i].parent = this;
          this.children[i].index = i;
        }
      }

    },

    /**
     * Returns a keyboard cursor position closest to the specified screen
     * coordinates.
     */
    getCursorPosition : function(x, y) {

      if (this.parent !== null) {
        if (x < this.dimensions.left + this.dimensions.width / 2) {
          return this.parent.getPrecedingCursorPosition(this.index+1,false);
        }
        else {
          return this.parent.getFollowingCursorPosition(this.index,false);
        }
      }
      else {
        return null;
      }

    },

    getFirstCursorPosition : function(index) {
      if (this.parent !== null) {
        return this.parent.getFirstCursorPosition();
      }
      else {
        return null;
      }
    },

    getLastCursorPosition : function(index) {
      if (this.parent !== null) {
        return this.parent.getLastCursorPosition();
      }
      else {
        return null;
      }
    },

    /**
     * Returns the cursor position following the cursor position at the
     * specified index. When no cursor position can be provided, null is
     * returned. By default this method always returns null, override it to do
     * something useful.
     */
    getFollowingCursorPosition : function(index) {

      return null;

    },

    getPrecedingCursorPosition : function(index) {

      return null;

    },

    getLowerCursorPosition : function(index, x) {

      var presentation = org.mathdox.formulaeditor.presentation;

      if (this.parent !== null) {
        if ((index === null || index === undefined) && 
            this.parent instanceof presentation.Row) {
          return { row: this.parent, index: this.index };
        }
        else {
          return this.parent.getLowerCursorPosition(this.index, x);
        }
      }
      else {
        return null;
      }

    },

    getHigherCursorPosition : function(index, x) {

      var presentation = org.mathdox.formulaeditor.presentation;

      if (this.parent !== null) {
        if ((index === null || index === undefined) && 
            this.parent instanceof presentation.Row) {
          return { row: this.parent, index: this.index };
        } else {
          return this.parent.getHigherCursorPosition(this.index, x);
        }
      } else {
        return null;
      }

    },
    toString : function() {
      if (this.value) {
        return this.value;
      } else if (this.children) {
        var str = "[ ";
        for (var i=0; i<this.children.length; i++) {
          str+=this.children[i];
          if (i<this.children.length-1) {
            str +=", ";
          }
        }
        str+=" ]";
        return str;
      }
    },
    maxDimensions: function(x,y,arr) {
      var i;
      var maxdim={ top:y, left:x, width:0, height:0 };
      var top, bottom, left, right;

      for (i=0; i< arr.length;i++) {
        top = Math.min(maxdim.top,arr[i].top);
        bottom = Math.max(maxdim.top+maxdim.height, 
          arr[i].top+arr[i].height);
        left = Math.min(maxdim.left,arr[i].left);
        right = Math.max(maxdim.left+maxdim.width, 
          arr[i].left+arr[i].width);
        maxdim = { 
          top:top, 
          left:left, 
          width: right-left, 
          height: bottom - top
        };
      }
      return maxdim;
    },

    /**
     * Parameter highlight:
     *   true if this should be highlighted.
     */
    setHighlight: function(highlight) {
      if (highlight === true || highlight === false) {
        this.highlight = highlight;
      } else {
        console.log('presentation.Node.setHighlight: invalid argument '+highlight+', was expecting true or false.');
      }
      if (highlight === false && this.children.length>0) {
        var i;
        // NOTE: going through all children, could be done cheaper (but the
        // assumption is a redraw is done anyway, so this shouldn't matter)
        for (i=0;i<this.children.length;i++) {
          this.children[i].setHighlight(false);
        }
      }
    }

  });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/PArray.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.PArray =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
    /* 
     * number of rows 
     */
    rows : 0,
    /*
     * number of columsn
     */
    columns: 0,

    /*
     * the heights of the rows
     */
    rowInfo : null,
    /*
     * the widths of the columns
     */
    colInfo : null,

    /*
     * the margin between the entries
     */
    margin : 2.0,

    /*
     * Should we draw a box around the PArray and all entries ?
     */
    drawBox : false,

    /*
     * Should we "highlight" a certain entry in the PArray ?
     */
    highlight: null,

    /*
     * Determine the maximum height of a row
     * usage getMaxHeight(row) : max height of a row
     */
    getMaxHeight : function(row) {
      var maxHeight = 0;
      var highTop = 0;
      var lowBottom = 0;
      for (var col=0; col<this.columns; col++) {
        highTop = Math.min(highTop, this.entries[row][col].dimensions.top);
        lowBottom = Math.max(lowBottom, 
          this.entries[row][col].dimensions.top + 
          this.entries[row][col].dimensions.height);
      }
      maxHeight = lowBottom - highTop;
      return { height: maxHeight, top: highTop, bottom: lowBottom };
    },

    /*
     * Determine the width of a column
     * usage getMaxWidth(column) : max width of a column
     */
    getMaxWidth : function(col) {
      var maxWidth = 0;
      for (var row=0; row<this.rows; row++) {
        maxWidth = Math.max(maxWidth, this.entries[row][col].dimensions.width);
      }
      return maxWidth;
    },

    /**
     * Draws the matrix to the canvas.
     *
     * See also: org.mathdox.formulaeditor.presentation.Node.draw
     */
    draw : function(canvas, context, x, y, invisible) {

      // total height
      var totalHeight = 0;
      
      // fake drawing of children to set sizes
      
      var row; // row counter
      var col; // column counter
      for (row = 0; row < this.rows; row++) {
        for (col = 0; col < this.columns; col++) {
            if (this.entries[row][col] && this.entries[row][col].draw) {
              this.entries[row][col].draw(canvas, context, 0, 0, true);
            } else {
              alert("PArray could not draw row:"+row+", col:"+col+".");
            }
        }
      }
 
      for (row = 0; row < this.rows; row++) {
        var heightInfo = this.getMaxHeight(row);
        var rowHeight = heightInfo.height;
        var rowTop;
        var rowCenter;
        var rowBaseline;
        if (row === 0 ) {
          rowBaseline = 0;
          rowTop = rowBaseline + heightInfo.top;
          totalHeight += rowHeight;
        } else {
          rowTop = this.rowInfo[row-1].top + this.rowInfo[row-1].height + 
            this.margin;
          rowBaseline = rowTop - heightInfo.top;
          totalHeight += rowHeight + this.margin;
        }
        this.rowInfo[row] = {
          height : rowHeight,
          top : rowTop,
          baseline : rowBaseline
        };
      }

      // align on middle row: Math.floor((this.rows)/2)
      var usedBaseline = this.rowInfo[Math.floor((this.rows)/2)].baseline;

      // adjust rows for total height
      for (row = 0; row < this.rows; row++) {
        this.rowInfo[row].top -= usedBaseline;
        this.rowInfo[row].baseline -= usedBaseline;
      }

      // the widths of the columns
      var columnwidth = [];
      // total width
      var totalWidth = 0;

      for (col = 0; col < this.columns; col++) {
        var colWidth = this.getMaxWidth(col);
        if (col === 0 ) {
          colCenter = colWidth/2;
          totalWidth += colWidth;
        } else {
          colCenter = this.colInfo[col-1].center +this.colInfo[col-1].width/2+ this.margin + colWidth/2;
          totalWidth += colWidth + this.margin;
        }
        this.colInfo[col] = {
          left   : colCenter - colWidth/2,
          width  : colWidth,
          center : colCenter
        };
      }

      // draw all entries
      if (! invisible) {
        for (row=0; row<this.rows; row++) {
          for (col=0; col<this.columns; col++) {
            var entry       = this.entries[row][col];
            var entryWidth  = entry.dimensions.width;
            var entryHeight = entry.dimensions.height;
            var entryTop    = entry.dimensions.top;
            var highlight;

            if (this.highlight != null && this.highlight.row == row && this.highlight.col == col) {
              highlight = true;
            } else {
              highlight =false;
            }
    
            if (!invisible) {
              if (this.drawBox) {
                canvas.drawBoxWithBaseline(entry.dimensions, y + 
                  this.rowInfo[row].baseline);
              } else if (highlight) {
                //calculate box dimensions
                var boxdimensions = {
                  top:    y+this.rowInfo[row].top,
                  left:   x+this.colInfo[col].left,
                  width:  this.colInfo[col].width,
                  height: this.rowInfo[row].height
                }

		if (col+1 <this.columns) {
		  boxdimensions.width+=this.margin/2;
		}
		if (col > 0) {
		  boxdimensions.left-=this.margin/2;
		  boxdimensions.width+=this.margin/2;
		}
		if (row+1 <this.rows) {
		  boxdimensions.height+=this.margin/2;
		}
		if (row > 0) {
		  boxdimensions.top-=this.margin/2;
		  boxdimensions.height+=this.margin/2;
		}
                canvas.drawBox(boxdimensions, "#00F", "#DDF");
              }
            }

            entry.draw(
              canvas, context,
              x + this.colInfo[col].center - (entryWidth/2), 
                    // horizontally centered in column
              y + this.rowInfo[row].baseline,
              invisible);
          }
        }
      }
      this.dimensions = {
        top    : y+this.rowInfo[0].top,
        left   : x,
        width  : totalWidth,
        height : totalHeight
      };
      if ((!invisible) && this.drawBox) {
        canvas.drawBoxWithBaseline(this.dimensions, y);
      }
      return this.dimensions;
    },

    getCoordinatesFromPosition : function(x, y) {
      var row,col;

      // find the row
      row = 0;
      /*
       * Here rowHeight   = this.rowInfo[row].height and 
       *      entryHeight = this.entries[row][0].dimensions.height
       *
       * this.entries[row][0].dimensions.top is the top of the entry
       * subtract (rowHeight-entryHeight)/2 to get the top of the row
       * add rowHeight to get the bottom of the row
       *
       * if the coordinate is below the bottom, increase the row number
       */
      //while ((row<this.rows-1) && (y>this.rowInfo[row].top + this.rowInfo[row].height)) {
      while ((row<this.rows-1) && (y>this.entries[row][0].dimensions.top - (this.rowInfo[row].height - this.entries[row][0].dimensions.height)/2 + this.rowInfo[row].height)) {
        // not in row "row"
        row++;
      }

      // find the column
      col = 0;
             /*
       * Here colWidth   = this.colInfo[row].width and 
       *      entryWidth = this.entries[row][col].dimensions.width
       *
       * this.entries[row][col].dimensions.left is the left of the entry
       * subtract (colWidth - entryWidth)/2 to get the left of the column
       * add colWidth to get the right of the column
       *
       * if the coordinate is past the right, increase the column number
       */
      while ((col<this.columns-1) && (x> this.dimensions.left + this.colInfo[col].left + this.colInfo[col].width)) {
        // not in column "col"
        col++;
      }
      return {row:row, col:col};
    },
    getEntryFromPosition : function(x, y) {
        var coords = this.getCoordinatesFromPosition(x,y);
      return this.entries[coords.row][coords.col];
    },
    getCursorPosition : function(x, y) {
      return this.getEntryFromPosition(x,y).getCursorPosition(x,y);
    },

    
                      
   /**
     * See also Node.getFollowingCursorPosition(index).
     */
    getFollowingCursorPosition : function(index) {
      var result = null;
      var row, col;

      if (index === null || index === undefined) {
        middle = Math.floor(this.rows / 2);
        row    = middle;
        while(result === null && 0<=row && row < this.rows) {
          result = this.entries[row][0].getFollowingCursorPosition();
          if (row>=middle) {
            row = 2*middle - row - 1;
          }
          else {
            row = 2*middle - row;
          }
        }
        return result;
      }

      row = Math.floor(index / this.columns);
      col = index % this.columns;
      if (col+1<this.columns) {
        result = this.entries[row][col+1].getFirstCursorPosition();
      }

      if (((result === null)|| (result === undefined)) && (this.parent !== null)) {
        result = this.parent.getFollowingCursorPosition(this.index, false);
      }
      return result;

    },

    getPrecedingCursorPosition : function(index) {
      var result=null;
      var row = null;
      var col = null;

      if (index === null || index === undefined) {
        var middle = Math.floor(this.rows / 2);
        row    = middle;
        while(result === null && 0<=row && row < this.rows) {
          col = this.entries[row].length - 1;
          result = this.entries[row][col].getPrecedingCursorPosition();
          if (row>=middle) {
            row = 2*middle - row - 1;
          }
          else {
            row = 2*middle - row;
          }
        }
        return result;
      }

      if (index>0) {
        row = Math.floor(index / this.columns);
        col = index % this.columns;
        if (col>0) {
          result = this.entries[row][col-1].getLastCursorPosition();
        } 
      }

      if (((result === null) || (result === undefined))&& (this.parent !== null)) {
        result = this.parent.getPrecedingCursorPosition(this.index, false);
      }
      return result;
    },

    getLowerCursorPosition : function(index, x) {
      if (index === null || index === undefined) {
        return this.entries[0][0].getLowerCursorPosition(null, x);
      }

      var row = Math.floor(index / this.columns);
      var col = index % this.columns;
      var result;
      if (row+1<this.rows) {
        result = this.entries[row+1][col].getLowerCursorPosition(null, x);
      } 
      if (((result === null) || (result === undefined)) && (this.parent !== null)) {
        result = this.parent.getLowerCursorPosition(this.index, x);
      }
      return result;
    },

    getHigherCursorPosition : function(index, x) {
      
      if (index === null || index === undefined) {
        return this.entries[0][this.rows-1].getHigherCursorPosition(null, x);
      }

      if (index<this.children.length) {
        var row = Math.floor(index / this.columns);
        var col = index % this.columns;
        var result;
        if (row>0) {
          result = this.entries[row-1][col].getHigherCursorPosition(null, x);
        } 
        if (((result === null)||(result === undefined)) && (this.parent !== null)) {
          result = this.parent.getHigherCursorPosition(this.index, x);
        }
        return result;
      }

      return null;
    },
    initialize : function() {
      this.rowInfo = [];
      this.colInfo = [];
      if (arguments.length >0) {
        this.entries = Array.prototype.slice.call(arguments);
        this.rows = this.entries.length;
        this.columns = this.entries[0].length;
      }
      this.children = [];

      for (var row = 0; row < this.rows; row++) {
        for (var col = 0; col < this.columns; col++) {
          this.children.push(this.entries[row][col]);
        }
      }
      this.updateChildren();
    },
    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone.apply(this, this.copyArray(this.entries));
    }
  });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/PTabContainer.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");

$main(function(){

  /**
   * Representation of several tabs, [including a method to switch between
   * them]
   */
  org.mathdox.formulaeditor.presentation.PTabContainer =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
    /*
     * index of the current tab
     */
    currenttab: null,

    tabBarSize : 20,

    margin: 2.0,

    /**
     * Draws the current tab to the canvas.
     *
     * See also: org.mathdox.formulaeditor.presentation.Node.draw
     */
    draw : function(canvas, context, x, y, invisible) {

      if (this.current === null) {
        this.dimensions = { top:y, left:x, width:0, height:0 };
        return this.dimensions;
      }

      if ((this.children[this.current] === undefined) || (this.children[this.current] === null)) {
        this.dimensions = { top:y, left:x, width:0, height:0 };
        return this.dimensions;
      }

      /* calculate maximum dimensions */
      var dimArray = [];
      var maxDim;
      var boxDim;
      var tabBoxDim;
      var i;

      if (this.showTabBar()) {
        for (i=0; i< this.children.length; i++) {
          dimArray.push(this.children[i].draw(canvas,context,x,y+this.tabBarSize+this.margin,true));
        }
        maxDim = this.maxDimensions(x,y+this.tabBarSize+this.margin,dimArray);

        boxDim = { 
          top: maxDim.top - this.tabBarSize - this.margin, 
          left: maxDim.left, 
          width: maxDim.width, 
          height: this.tabBarSize
        };


        for (i=0; i< this.children.length; i++) {
          tabBoxDim = {
            top: boxDim.top,
            left: boxDim.left + (i/this.children.length)*boxDim.width,
            width: boxDim.width/this.children.length,
            height: boxDim.height
          };

          if (i == this.current) {
            if (!invisible) { 
              canvas.drawBox(tabBoxDim, "#00F", "#AAF"); 
            }
          } else {
            if (!invisible) { 
              canvas.drawBox(tabBoxDim, "#00F", "#DDF");
            }
          }
        }
        
        if (!invisible) { 
          canvas.drawBox(boxDim, "#00F");
        }
  
        this.children[this.current].draw(canvas, context, x, y + this.tabBarSize + this.margin, 
          invisible);
    
        this.dimensions = {
          top: maxDim.top - this.tabBarSize - this.margin,
          left: maxDim.left, 
          width: maxDim.width, 
          height: maxDim.height+this.tabBarSize + this.margin
        };
      } else { /* only 1 child, don't draw a bar */
        this.dimensions = this.children[0].draw(canvas, context, x, y, invisible);
      }

      return this.dimensions;
    },

    handleMouseClick : function (x,y,redraw) {
      var palcoords ;
      var index;

      if (this.showTabBar()) {
        if (y < this.dimensions.top + this.tabBarSize) {
          /* inside tabbar, insert nothing */
          index = Math.floor((x - this.dimensions.left) / 
            (this.dimensions.width) * this.children.length);
          
          this.current = index;

          redraw();

          return null;
        }
      }

      palcoords = this.children[this.current].getCoordinatesFromPosition(x,y);

      return {
        tab: this.current,
        row: palcoords.row,
        col: palcoords.col
      };
    },

    handleMouseMove : function (x,y,redraw) {
      if(x==null || y==null) {
	if (this.children[this.current].highlight) {
          this.children[this.current].highlight = null;

	  redraw();
	}

	return;
      }

      if (this.showTabBar()) {
        if (y < this.dimensions.top + this.tabBarSize) {

          if(this.children[this.current].highlight) {
            this.children[this.current].highlight = null;

	    redraw();
          }

          return;
        }
      }

      var oldhighlight = this.children[this.current].highlight;
      this.children[this.current].highlight = 
          this.children[this.current].getCoordinatesFromPosition(x,y);

      if ((!oldhighlight || !this.children[this.current].highlight) ||  
        (oldhighlight.col != this.children[this.current].highlight.col ||
          oldhighlight.row != this.children[this.current].highlight.row)) {

	redraw();
      } 

    },

    initialize : function() {
      if (arguments.length >0) {
        this.children = Array.prototype.slice.call(arguments);
        this.current = 0;
      }
      this.updateChildren();
    },

    /**
     * Returns a copy of this presentation object, without index information
     * To be used for copy/paste or undo. See also presentation/Node.js
     */
    copy : function() {
      return this.clone.apply(this, this.copyArray(this.children));
    },

    showTabBar : function() {
      return (this.children.length>1);
    }
  });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/PseudoRow.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){
  /**
   * Representation of a row, which will not be flattened
   */
  org.mathdox.formulaeditor.presentation.PseudoRow =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      
      // allow overwriting of abstract draw method
      draw: null,

      functionsFromRow : [ "getFirstCursorPosition", "getFollowingCursorPosition", "getPrecedingCursorPosition",
        "getLastCursorPosition", "getLowerCursorPosition",
        "getHigherCursorPosition", "draw", "isEmpty", "getMathML", "getSemantics", "insert", "replace", "remove" ],

      initialize : function () {
        this.children = Array.prototype.slice.call(arguments);

        var presentation = org.mathdox.formulaeditor.presentation;
        /* copy the cursor/position functions from Row */

        var row = new presentation.Row(); // only an instance has the functions
        
        for (var i=this.functionsFromRow.length - 1; i>=0; i--) {
          if (! this[this.functionsFromRow[i]] ) {
            this[this.functionsFromRow[i]] = 
              row[ this.functionsFromRow[i] ];
          }
        }

        this.updateChildren();
      },
    });
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Root.js");

$require("org/mathdox/formulaeditor/modules/keywords.js");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$require("org/mathdox/formulaeditor/semantics/Integer.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Root =
    $extend(org.mathdox.formulaeditor.presentation.Bracketed, {
      // base of the root (especially if not 2)
      base : null,

      // width of the line
      lineWidth : 1.0,

      // margin between the line and the row
      margin : 2.0,

      // should we draw boxes ?
      drawBox : false,
      
      drawBase : false,

      drawBaseQ: function() {
        var context;
        context = org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser.getContext();

        var baseSemantics = this.base.getSemantics(context);

        return (!baseSemantics || !baseSemantics.value || 
          !baseSemantics.value.value || (baseSemantics.value.value != 2));
      },

      /**
       * Draws the root to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var middleheight;
        var rootheight;
        var baseheight;
        var height;
        var vlheight;
        var drawBase;

        var fontSizeModifier = 0;
        if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
          fontSizeModifier = context.fontSizeModifier;
        }

        var baseContext = { fontSizeModifier : 0 };
        for (var name in context) {
          baseContext[name] = context[name];
        }
        baseContext.fontSizeModifier = baseContext.fontSizeModifier - 1;

        // invisible drawing of array to set dimensions
        
        this.middle.draw(canvas, context, 0, 0, true);

        middleheight = this.middle.dimensions.height + this.lineWidth + 
          this.margin*2;

        drawBase = this.drawBase;

        if (drawBase) {
          this.base.draw(canvas, baseContext, 0, 0, true);
          baseheight = this.base.dimensions.height;
          vlheight = canvas.drawSymbol("vl", 0, 0, true, null, fontSizeModifier).height;
        }

        // if the left and right symbols are brackets set the height
        // XXX check if they are brackets
        if (drawBase) {
          this.leftBracket.minimumHeight = Math.max(middleheight, 
            Math.min(2*baseheight+3*this.margin,
              baseheight+vlheight+3*this.margin ));
        } else {
          this.leftBracket.minimumHeight = middleheight;
        }

        // invisible drawing of brackets to set dimensions
        this.leftBracket.draw(canvas, context, 0, 0, true);

        rootheight = this.leftBracket.dimensions.height;

        height = rootheight;

        var yAdjust = 0;
        var yAdjustBrackets = 0;
        
        // bracket is higher than the array
        if (height>middleheight) {
          yAdjust = (height - middleheight)/2;
        }

        // baseXAdjust: negative number or 0 indicating how much the base sticks
        // out to the left
        var baseXAdjust = 0;
        if (drawBase) {
          baseXAdjust = Math.min(0, 
            this.leftBracket.dimensions.width/2 - this.base.dimensions.width);
        }
 
        var yAdjustMiddle = - (this.middle.dimensions.top+this.middle.dimensions.height) - 
          this.margin;

        this.dimensions = { 
          height : height,
          width : 
            this.leftBracket.dimensions.width +
            this.middle.dimensions.width - baseXAdjust + this.margin,
          left : x,
          //top : y - this.leftBracket.dimensions.height + yAdjust/2 
          top : y - this.leftBracket.dimensions.height + yAdjust/2 - yAdjustMiddle
        };
     
        this.drawHighlight(canvas, invisible);

        if (drawBase) {
          this.base.draw(canvas, baseContext,
            x - this.base.dimensions.left,
            y + yAdjust/2 - Math.min(rootheight/2, vlheight) - 
              (this.base.dimensions.top + this.base.dimensions.height) - 
              2*this.margin - yAdjustMiddle, 
            invisible);
        }

        this.leftBracket.draw(canvas, context,
          x - this.leftBracket.dimensions.left - baseXAdjust, 
          y - (this.leftBracket.dimensions.top +
            this.leftBracket.dimensions.height) + yAdjust/2 - yAdjustMiddle, 
          invisible);
        /* XXX adjust vertically */
        this.middle.draw(canvas, context,
          x - baseXAdjust + this.leftBracket.dimensions.width -
          this.middle.dimensions.left + this.margin , 
          y, invisible);

        if (!invisible) {
          // draw line
          var canvasContext = canvas.getContext();

          canvasContext.save();
          canvasContext.lineWidth = this.lineWidth;
          canvasContext.beginPath();
          canvasContext.moveTo(x-baseXAdjust+this.leftBracket.dimensions.width - 1,
            this.dimensions.top + this.lineWidth);
          canvasContext.lineTo(x+this.dimensions.width, 
            this.dimensions.top + this.lineWidth);
          canvasContext.stroke();
          canvasContext.closePath();
          canvasContext.restore();
        }

        /* XXX adjust */
        if ((!invisible) &&this.drawBox) {
          if (drawBase) {
            canvas.drawBox(this.base.dimensions);
          }
          canvas.drawBox(this.middle.dimensions);
          canvas.drawBox(this.leftBracket.dimensions);
          canvas.drawBoxWithBaseline(this.dimensions,y);
        }

        return this.dimensions;
      },

      getCursorPosition : function(x,y) {
        var dimensions;

        // check for base
        if (this.drawBase) {
          dimensions = this.base.dimensions;
          if (x < dimensions.left + dimensions.width) {
            return this.base.getCursorPosition(x,y);
          }
        } 

        // check for middle
        dimensions = this.middle.dimensions;
        if (! this.drawBase) {
          if (x < dimensions.left) {
            return { row: this.parent, index: this.index };
          }
        }
        if (x < dimensions.left + dimensions.width) {
          return this.middle.getCursorPosition(x,y);
        }
        return { row: this.parent, index: this.index };
      },

      getFollowingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          if (this.drawBase) {
            return this.base.getFollowingCursorPosition();
          } else {
            return this.middle.getFollowingCursorPosition();
          }
        }
        
        var result = null;

        if (index === 0) {
          if (descend) {
            if (this.drawBase) {
              result = this.base.getFollowingCursorPosition();
            } else {
              return this.middle.getFollowingCursorPosition();
            }
          }
          if (result === null) {
            result = this.middle.getFollowingCursorPosition();
          }
        }

        if (result === null) {
          // when we're at the end of the matrix, ask the parent of the matrix
          // for the position following this matrix
          if (this.parent !== null) {
            return this.parent.getFollowingCursorPosition(this.index, false);
          }
        }
        
        return result;
      },
      getPrecedingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in the array
        if (index === null || index === undefined) {
          return this.middle.getPrecedingCursorPosition();
        }
        
        var result = null;

        if (index == 1) {
          if (descend) {
            result = this.middle.getPrecedingCursorPosition();
          }
          if (result === null) {
            if (this.drawBase) {
              result = this.base.getPrecedingCursorPosition();
            }
          }
        }

        if (result === null) {
          // when we're at the beginning of the matrix, ask the parent of the
          // matrix for the position before this matrix
          if (this.parent !== null) {
            return { row: this.parent, index: this.index };
          }
        }
        
        return result;
      },
      initialize : function () {
        if (arguments.length>0) {
          this.leftBracket = 
            new org.mathdox.formulaeditor.presentation.Bracket("v");
          this.middle = arguments[0];
          this.base = arguments[1];
          this.children = [];
          this.children.push(this.base);
          this.children.push(this.middle);
        } else {
          this.children = [];
        }

        var presentation = org.mathdox.formulaeditor.presentation;
        /* copy the cursor/position functions from Row */

        var row = new presentation.Row(); // only an instance has the functions

        for (var i=this.functionsFromRow.length - 1; i>=0; i--) {
          if (! this[this.functionsFromRow[i]] ) {
            this[this.functionsFromRow[i]] = 
              row[ this.functionsFromRow[i] ];
          }
        }

        /* check if the base should be displayed */
        this.drawBase = this.drawBaseQ();

        this.updateChildren();
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        var result;
        if (this.children.length == 2) {
          result = this.clone(this.children[1].copy(), this.children[0].copy());
        } else {
          result = this.clone();
        }
        return result;
      },

      getSemantics : function(context) {
        var root;

        var semantics = org.mathdox.formulaeditor.semantics;
        root = new semantics.Arith1Root(this.middle.getSemantics(context).value, 
          this.base.getSemantics(context).value);
        return {
          value : root,
          rule  : "braces"
        };
      }


    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Row.js");

//$require("org/mathdox/formulaeditor/parsing/expression/ExpressionContextParser.js");
$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/BlockSymbol.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/SuperscriptSymbol.js");

$main(function(){

  /**
   * Representation of a row of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Row =
    $extend(org.mathdox.formulaeditor.presentation.Node, {

      initialize : function() {

        var SuperscriptSymbol = org.mathdox.formulaeditor.presentation.SuperscriptSymbol;
        var Symbol = org.mathdox.formulaeditor.presentation.Symbol;
        var BlockSymbol = org.mathdox.formulaeditor.presentation.BlockSymbol;
        var i; // counter

        if (arguments.length == 1 && typeof(arguments[0]) == "string") {
          var string = arguments[0];
          var array = [];
          for (i=0; i<string.length; i++) {
            array.push(this.newSymbol(string.charAt(i)));
          }
          return arguments.callee.parent.initialize.apply(this, array);
        }
        else {
          var children = Array.prototype.slice.call(arguments);

          if (children.length === 0) {
            children = [];
            children.push(null);
          }

          for (i=0; i<children.length; i++) {
            // an "empty" box is a symbol with the empty string
            if ((children[i] === null) || (children[i] === undefined)) {
              children[i] = new BlockSymbol();
            }
          }
          return arguments.callee.parent.initialize.apply(this, children);
        }

      },

      /**
       * Draws the row to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {

        if (this.children.length > 0) {

          // use following variables to maintain track of the bounding rectangle
          var left   = x;
          var top    = y;
          var right  = x;
          var bottom = y;


          // go through all child nodes in the row
          for (var i=0; i<this.children.length; i++) {

            var child = this.children[i];

            // draw the current child node
            var dimensions = child.draw(canvas, context, right, y, invisible);

            // update the dimensions of the bounding rectangle
            left   = Math.min(left, dimensions.left);
            top    = Math.min(top, dimensions.top);
            right  = Math.max(right, dimensions.left + dimensions.width);
            bottom = Math.max(bottom, dimensions.top + dimensions.height);

          }

          // return information about the bounding rectangle
          this.dimensions = {
            left:   left,
            top:    top,
            width:  right - left,
            height: bottom - top
          };

          return this.dimensions;

        }
        else {
          var fontSizeModifier = 0;
          if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
            fontSizeModifier = context.fontSizeModifier;
          }

          this.dimensions = canvas.drawFBox(x, y, true, null, null, fontSizeModifier);

          if (!invisible && this.parent) {
            canvas.drawFBox(x, y, invisible);
          }

          return this.dimensions;

        }

      },

      /**
       * Returns the MathML presentation of the node.
       */
      getMathML: function(mrow) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var result = [];
        var mode = "none";
        var newmode = "none";
        var arg = [];

        /* for all children add the corresponding mathml */
        /* TODO: do tricks for mi/mo/mn */

        var i;

        for (i = 0; i < this.children.length; i++) {
          if (this.children[i] instanceof presentation.Symbol) {
            newmode = "symbol";
          } else {
            newmode = "none";
          }

          if (newmode != mode) {
            if (mode != "none") {
              // TODO: do magic stuff
              // add result to result var
              arg = [];
            }
            if (newmode != "none") {
              arg = [];
            }
          } 
          if (newmode == "none") {
            result.push(this.children[i].getMathML());
          } else { // mode = "symbol"
            arg.push(this.children[i].value);
          }

          mode = newmode;
        }

        /**
         * wrap in mrow when not implicit
         * if length is 1, then skip (already 1 term, no row needed)
         */
        if (mrow !== undefined && mrow !== null && mrow === true && result.length != 1) {
          result = "<mrow>" + result.join("") + "</mrow>";
        } else {
          result = result.join("");
        }
      },

      /**
       * Generates a symbol in the correct style
       */
      newSymbol: function(character) {
	var SuperscriptSymbol = org.mathdox.formulaeditor.presentation.SuperscriptSymbol;
	var Symbol = org.mathdox.formulaeditor.presentation.Symbol;

        if (character == " ") {
          // spaces do not have a value
          return new Symbol([""," "]);
        } else if (((character >= 'a') && (character <='z'))||
                   ((character >= 'A') && (character <='Z'))) {
          return new Symbol(character, "math");
        } else if (character == "'" || character =="′" ) {
          // quote or U+2032 prime
          return new SuperscriptSymbol(character);
        } else {
          return new Symbol(character);
        }
      },

      /**
       * Handles an onkeydown event from the browser. Returns false when the
       * event has been handled and should not be handled by the browser,
       * returns true otherwise.
       */
      onkeydown : function(event, editor) {

        // only handle keypresses where alt, ctrl and shift are not held
        if (!event.altKey && !event.ctrlKey && !event.shiftKey) {

          // handle backspace and delete
          switch(event.keyCode) {

            case  8: // backspace
              var position = editor.cursor.position;
              if (position.index > 0) {
                // test if we should delete
                var del = this.children[position.index - 1].deleteItem();

                if (del) {
                  this.remove(position.index - 1);
                  position.index--;
                  // after deleting the last character, add a new input box
                  if (this.isEmpty()) {
                    this.insert(0);
                  }
                }
                editor.redraw();
                editor.save();
              }
              return false;

            case 46: // delete
              var position = editor.cursor.position;
              if (position.index <this.children.length) {
                // test if we should delete
                var del = this.children[position.index].deleteItem();

                if (del) {
                  this.remove(position.index);
                  // after deleting the last character, add a new input box
                  if (this.isEmpty()) {
                    this.insert(0);
                  }
                }
                editor.redraw();
                editor.save();
              }
              return false;
          }
        }

        // pass the event back to the browser
        return true;

      },

      /**
       * Handles an onkeypress event from the browser. Returns false when the
       * event has been handled and should not be handled by the browser,
       * returns true otherwise.
       */
      onkeypress : function(event, editor) {

        // only handle keypresses where alt and ctrl are not held
        if (!event.altKey && !event.ctrlKey) {

          var canvas    = editor.canvas;
          var fontName  = canvas.fontName;
          var fontSize  = canvas.fontSize;
          var character = String.fromCharCode(event.charCode);

          // XXX enter, fire DOMActivate event in the future
          if (event.charCode == 13) {
            return false;
          }

          // see whether there is a character for pressed key in current font
          if (canvas.getSymbolData(character)) {

            var moveright;

            // insert the character into the row, and move the cursor
	    moveright = this.insert(editor.cursor.position.index,
	      this.newSymbol(character));

            if (moveright) {
              editor.cursor.moveRight();
            }

            editor.redraw();
            editor.save();
            return false;

          }

        }

        // pass the event back to the browser
        return true;

      },

      /**
       * Flattens this row, meaning that all child nodes that are rows
       * themselves will be embedded into this row.
       */
      flatten : function() {

        var Row = org.mathdox.formulaeditor.presentation.Row;

        // call flatten on the child nodes
        arguments.callee.parent.flatten.apply(this);

        // go through all children
        var children = this.children;
        for (var i=0; i<children.length; i++) {
          var child = children[i];

          // check whether the child is a row
          if (child instanceof Row) {
            // insert the child node's children into the list of children
            children.splice.apply(children, [i,1].concat(child.children));
          }

        }
        this.updateChildren();

      },

      getCursorPosition : function(x, y) {

        var count = this.children.length;
        for (var i=0; i<count; i++) {
          var dimensions = this.children[i].dimensions;
          if (x < dimensions.left + dimensions.width || i == count - 1) {
            return this.children[i].getCursorPosition(x,y);
          }
        }

        return { row: this, index: 0 };

      },

      getFirstCursorPosition : function(index) {
        if (index === null || index === undefined || index > 0) {
          return this.getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return this.parent.getFirstCursorPosition();
          }
          else {
            return null;
          }
        }
      },

      getLastCursorPosition : function(index) {
        if (index === null || index === undefined ||
            index < this.children.length) {
          return this.getPrecedingCursorPosition();
        }
        if (this.parent !== null) {
          return this.parent.getLastCursorPosition();
        }
        else {
          return null;
        }
      },

      /**
       * Returns the cursor position following the specified index.
       * See also Node.getFollowingCursorPosition(index).
       */
      getFollowingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the first position in this row
        if (index === null || index === undefined) {
          return { row : this, index : 0 };
        }

        // ask the child at the specified index for the cursor position
        if (index < this.children.length) {
          var result = null;
          if (descend) {
            result = this.children[index].getFollowingCursorPosition();
          }
          if (result === null) {
            // when the child can not provide a cursor position, shift the
            // cursor one position in this row
            result = { row : this, index : index + 1 };
          }
          return result;
        }

        // when we're at the end of the row, ask the parent of the row for the
        // position following this row
        if (this.parent !== null) {
          return this.parent.getFollowingCursorPosition(this.index, false);
        }

        // no suitable cursor position could be found
        return null;

      },

      getPrecedingCursorPosition : function(index, descend) {

        // default value for descend
        if (descend === null || descend === undefined) {
          descend = true;
        }

        // when index is not specified, return the last position in this row
        if (index === null || index === undefined) {
          return { row : this, index : this.children.length };
        }

        // ask the child at the specified index for the cursor position
        if (index > 0) {
          var result = null;
          if (descend) {
            result = this.children[index-1].getPrecedingCursorPosition();
          }
          if (result === null) {
            // when the child can not provide a cursor position, shift the
            // cursor one position in this row
            result = { row : this, index : index - 1 };
          }
          return result;
        }

        // when we're at the beginning of the row, ask the parent of the row for
        // the position preceding this row
        if (this.parent !== null) {
          return this.parent.getPrecedingCursorPosition(this.index, false);
        }

        // no suitable cursor position could be found
        return null;

      },

      getLowerCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          var minimumDistance = null;
          var bestIndex = 0;
          for (var i=0; i<=this.children.length; i++) {
            var left;
            if (i<this.children.length) {
              left = this.children[i].dimensions.left;
            }
            else {
              if (this.children.length > 0) {
                var dimensions = this.children[this.children.length-1].dimensions;
                left = dimensions.left + dimensions.width;
              }
              else {
                left = this.dimensions.left;
              }
            }
            var distance = Math.abs(left-x);
            if (minimumDistance === null || distance < minimumDistance) {
              minimumDistance = distance;
              bestIndex = i;
            }
          }
          if (this.children[bestIndex] !== null &&
            this.children[bestIndex] !== undefined) {
            return this.children[bestIndex].getLowerCursorPosition(null, x);
          }
          else {
            return { row: this, index : bestIndex };
          }
        }
        else {
          return this.parent.getLowerCursorPosition(this.index, x);
        }
      },

      getHigherCursorPosition : function(index, x) {
        if (index === null || index === undefined) {
          var minimumDistance = null;
          var bestIndex = 0;
          for (var i=0; i<=this.children.length; i++) {
            var left;
            if (i<this.children.length) {
              left = this.children[i].dimensions.left;
            }
            else {
              if (this.children.length > 0) {
                var dimensions = this.children[this.children.length-1].dimensions;
                left = dimensions.left + dimensions.width;
              }
              else {
                left = this.dimensions.left;
              }
            }
            var distance = Math.abs(left-x);
            if (minimumDistance === null || distance < minimumDistance) {
              minimumDistance = distance;
              bestIndex = i;
            }
          }
          if (this.children[bestIndex] !== null &&
            this.children[bestIndex] !== undefined) {
            return this.children[bestIndex].getHigherCursorPosition(null, x);
          }
          else {
            return { row: this, index : bestIndex };
          }
        }
        else {
          return this.parent.getHigherCursorPosition(this.index, x);
        }
      },

      isEmpty : function() {
        return (this.children.length === 0);
      },

      insert : function(index, node, fillempty) {
        var BlockSymbol = org.mathdox.formulaeditor.presentation.BlockSymbol;
        var newindex = index;
        var moveright = true;

        if ((fillempty === null) || (fillempty === undefined)) {
          fillempty = true;
        }
        if ((node === null) || (node === undefined)) {
          node = new BlockSymbol();
        }

        if (fillempty && index<=this.children.length &&
          this.children[index] instanceof BlockSymbol) {
          this.children.splice(index, 1, node);
        } else if (fillempty && index-1>=0 &&
            this.children[index-1] instanceof BlockSymbol) {
          this.children.splice(index-1, 1, node);
          newindex = index - 1;
          moveright = false; // do not move right after inserting now
        } else {
          this.children.splice(newindex, 0, node);
        }
        this.updateChildren(newindex);

        //alert("index:"+index+" -> "+newindex+"\nmoveright: "+moveright);
        return moveright;
      },

      replace : function(index, node) {
        this.children.splice(index, 1, node);
        this.updateChildren(index);
      },

      remove : function(begin, end) {
        var result;
        if (end === null || end === undefined) {
          result = this.children[begin];
          this.children.splice(begin, 1);
          this.updateChildren(begin);
          return result;
        }
        else {
          result = new org.mathdox.formulaeditor.presentation.Row();
          result.initialize.apply(result, this.children.splice(begin, end-begin));
          this.updateChildren(begin);
          return result;
        }
      },

      getSemantics : function(context, begin, end, start, backward) {

        // assign default values to parameters
        if (begin    === null || begin    === undefined ) {
          begin    = 0;
        }
        if (end      === null || end      === undefined ) {
          end      = this.children.length;
        }
        if (start    === null || start    === undefined) {
          start    = "start";
        }
        if (backward === null || backward === undefined) {
          backward = false;
        }

        // use the expressionparser to parse the elements of the row
        var ContextParser;
        ContextParser = org.mathdox.formulaeditor.parsing.expression.ExpressionContextParser;

        var Parser;
        Parser = new ContextParser().getParser(context); //for now use empty context

        // create the input for the parser by serializing the row elements
        var input = "";
        // array to adjust for spaces (which have no semantics)
        var originalIndex = new Array();
        // adjust the index for the begin (XXX: shouldn't be necessary)
        originalIndex[begin] = begin;
        // counting spaces so far
        var adjustIndex = 0;

        // go through the row elements
        var children = this.children;
        for (var i=begin; i<end; i++) {

          // start a new variable scope
          (function(){

            // act differently based on the type of the row element
            var child = children[i];
            if (child instanceof org.mathdox.formulaeditor.presentation.Symbol) {

              // if the row element is a symbol, add its value to input string
              input = input + child.value;

              if (child.value == "") {
                // special case: space, count it
                adjustIndex=adjustIndex+1;
              }
            }
            else {

              // record the index of this row element in the parser input string
              var inputindex = input.length;

              // add a dummy to the input string
              input = input + '#';

              // retrieve the semantic tree node that represents the row element
              var semantics = child.getSemantics(context);

              // extend the parser so that it will parse the dummy into the
              // correct semantic tree node
              var extension = {};
              extension[semantics.rule] =
                function(context, index, result, continuation) {

                  var parent = arguments.callee.parent;

                  if (!context.backward && index == inputindex) {
                    continuation(index+1, result.concat([semantics.value]));
                  }
                  else if(context.backward && index - 1 == inputindex) {
                    continuation(index-1, [semantics.value].concat(result));
                  }
                  else {
                    parent[semantics.rule](context, index, result, continuation);
                  }

                };

              Parser = $extend(Parser, extension);

            }

          })();

          // adjust the index for this position
          originalIndex[i] = i + adjustIndex;
        }
        // adjust the index for the end
        originalIndex[end] = end + adjustIndex;

        // use the constructed parser and input to parse the row
        var parsebegin = backward ? input.length : 0           ;
        var parseend   = backward ? 0            : input.length;
        var parsed = new Parser().parse(input, parsebegin, backward, start);

        // return the result of parsing
        return {
          value : parsed.index == parseend ? parsed.value : null,
          index : originalIndex[parsed.index + begin],
          rule  : "braces"
        };

      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Subscript.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Represents a subscript expression.
   */
  org.mathdox.formulaeditor.presentation.Subscript =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      onBaseline : false,

      draw : function(canvas, context, x, y, invisible) {

        var subscript = this.children[0];

        var dim0;
        var presentation = org.mathdox.formulaeditor.presentation;

        var modifiedContext = { fontSizeModifier : 0 };
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.fontSizeModifier = modifiedContext.fontSizeModifier - 1;

        if (this.parent instanceof presentation.Row && this.index > 0) {
          dim0 = this.parent.children[this.index - 1].dimensions;
        }
        else {
          dim0 = new presentation.Symbol("x").draw(canvas,modifiedContext,x,y,true);
          dim0.left = x - dim0.width;
        }

        var tmp = subscript.draw(canvas,modifiedContext,0,0,true);

        var dim1 = subscript.draw(
          canvas, modifiedContext,
          dim0.left + dim0.width,
          dim0.top + dim0.height - tmp.top,
          invisible);

        var left   = dim1.left;
        var top    = Math.min(dim0.top,  dim1.top );
        var right  = dim1.left + dim1.width;
        var bottom = Math.max(dim0.top  + dim0.height, dim1.top  + dim1.height);

        this.dimensions = {
          left   : left,
          top    : top,
          width  : right - left,
          height : bottom - top
        };

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        return this.children[0].getCursorPosition(x,y);

      },

      getFollowingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index + 1 };
          }
          else {
            return null;
          }
        }
      },

      getPrecedingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index };
          }
          else {
            return null;
          }
        }
      },

      getSemantics : function(context) {
        return {
          value : this.children[0].getSemantics(context).value,
          rule  : "subscript"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Superscript.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");

$main(function(){

  /**
   * Represents a superscript expression.
   */
  org.mathdox.formulaeditor.presentation.Superscript =
    $extend(org.mathdox.formulaeditor.presentation.Node, {
      slowDelete : true,
      onBaseline : false,

      draw : function(canvas, context, x, y, invisible) {

        var superscript = this.children[0];

        var dim0;
        var presentation = org.mathdox.formulaeditor.presentation;

	var modifiedContext = { fontSizeModifier : 0 };
        for (var name in context) {
          modifiedContext[name] = context[name];
        }
        modifiedContext.fontSizeModifier = modifiedContext.fontSizeModifier - 1;

	/*
	 * Find a character earlier in the row on the baseline
	 */
        var index = 0;
	var xdim0, ydim0;
        if (this.parent instanceof presentation.Row) {
          index = this.index -1;
	  if (index>=0) { 
            xdim0 = this.parent.children[index].dimensions;
	  }
          while (index>0 && this.parent.children[index].onBaseline !== true) {
            index--;
	  }
        }

        if (index >= 0) {
	  //console.log("on baseline: "+this.parent.children[index].onBaseline);
          ydim0 = this.parent.children[index].dimensions;
	  dim0 = {
            left: xdim0.left,
            top: ydim0.top,
            width: xdim0.width,
            height: ydim0.height
	  }
        }
        else {
          dim0 = new presentation.Symbol("x").draw(canvas,modifiedContext,x,y,true);
          dim0.left = x - dim0.width;
        }

        var tmp = superscript.draw(canvas,modifiedContext,0,0,true);

        // warning drawing twice, should be possible to combine first dim1 with tmp
        var dim1 = superscript.draw(
          canvas,modifiedContext,
          dim0.left + dim0.width,
          dim0.top - (tmp.height + tmp.top),
          true);

        var left   = dim1.left;
        var top    = Math.min(dim0.top,  dim1.top );
        var right  = dim1.left + dim1.width;
        var bottom = Math.max(dim0.top  + dim0.height, dim1.top  + dim1.height);

        this.dimensions = {
          left   : left,
          top    : top,
          width  : right - left,
          height : bottom - top
        };

        if (invisible === false || invisible === null || invisible === undefined) {
          this.drawHighlight(canvas, invisible);
          // warning drawing twice
          superscript.draw(
            canvas,modifiedContext,
            dim0.left + dim0.width,
            dim0.top - (tmp.height + tmp.top),
            invisible);
        }

        return this.dimensions;

      },

      getCursorPosition : function(x, y) {

        return this.children[0].getCursorPosition(x,y);

      },

      getFollowingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getFollowingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index + 1 };
          }
          else {
            return null;
          }
        }
      },

      getPrecedingCursorPosition : function(index) {
        if (index === null || index === undefined) {
          return this.children[0].getPrecedingCursorPosition();
        }
        else {
          if (this.parent !== null) {
            return { row : this.parent, index: this.index };
          }
          else {
            return null;
          }
        }
      },

      getSemantics : function(context) {
        return {
          value : this.children[0].getSemantics(context).value,
          rule  : "superscript"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/SuperscriptSymbol.js");

$require("org/mathdox/formulaeditor/presentation/Superscript.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  var presentation = org.mathdox.formulaeditor.presentation;

  /**
   * Representation of a mathematical symbol that is always displayed as
   * superscript (like prime, U+2032, 
   */
  org.mathdox.formulaeditor.presentation.SuperscriptSymbol =
    $extend(org.mathdox.formulaeditor.presentation.Symbol, {
      onBaseline : false,

      children : null,

      initialize: function() {
        // call parent initilialization
        arguments.callee.parent.initialize.apply(this, arguments);

        // set this.children[0] for Superscript-draw
        if (this.value !== undefined && this.value !== null) {
          this.children = [];
          this.children.push(new presentation.Symbol(this.value));
        }
      },

      // use the draw function from Superscript
      draw: presentation.Superscript.prototype.draw
    });

});


  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Symbol.js");

$require("org/mathdox/formulaeditor/presentation/Node.js");
$require("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

$main(function(){

  /**
   * Representation of a mathematical symbol (number, letter, operator) in the
   * presentation tree.
   */
  org.mathdox.formulaeditor.presentation.Symbol =
    $extend(org.mathdox.formulaeditor.presentation.Node, {

      /**
       * A string representation of the symbol.
       */
      value : null,
      /**
       * A string representation of the symbol for on the screen
       */
      onscreen : null,
      /**
       * The typeface (currently supported: math, which means display as
       * slanted if possible)
       */
      typeface : null,

      /**
       * Initializes a Symbol node in the presentation tree using the specified
       * string representation of a symbol.
       */
      initialize : function() {
        
        if (arguments.length > 0) {
          if (arguments[0] instanceof Array) {
            this.value = arguments[0][0];
            if (arguments[0].length > 1) {
              this.onscreen = arguments[0][1];
            }
          } else {
            this.value = arguments[0];
          }
	  var aliases = org.mathdox.formulaeditor.presentation.SymbolAliases;

	  if (aliases[this.value] !== undefined && aliases[this.value] !== null) {
            this.value = aliases[this.value];
	  }
        }
        if (arguments.length > 1) {
          this.typeface = arguments[1];
        }
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        var result;
        var arg0;

        if (this.onscreen !== null) {
          arg0 = [ this.value, this.onscreen ];
        } else {
          arg0 = this.value;
        }

        if (this.typeface !== null) {
          result = this.clone(arg0, this.typeface);
        } else {
          result = this.clone(arg0);
        }
  
        return result;
      },

      /**
       * Draws the symbol to the canvas.
       *
       * See also: org.mathdox.formulaeditor.presentation.Node.draw
       */
      draw : function(canvas, context, x, y, invisible) {
        var symbol = this.value;
        if (this.onscreen !== null) {
          symbol = this.onscreen;
        }
       
        var fontSizeModifier = 0;
        if (context.fontSizeModifier!== undefined && context.fontSizeModifier !== null) {
          fontSizeModifier = context.fontSizeModifier;
        }

        this.dimensions = canvas.drawSymbol(
          symbol, Math.round(x), Math.round(y), invisible, this.typeface, 
          fontSizeModifier);

        return this.dimensions;

      }

    });

});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/SymbolAliases.js");

$main(function(){
  org.mathdox.formulaeditor.presentation.SymbolAliases = {
    // U+2062 invisible times -> '' empty string
    '⁢': null,
    // U+2064 invisible plus -> '' empty string
    '⁤' : null,
    // U+2217 asterisk operator -> U+002A asterisk
    '∗' : '*',
    // U+22C5 dot operator -> U+00B7 middle dot
    '⋅' : '·',
    // quote -> U+2032 [superscript] prime
    "'" : '′'
  };
});

  $package("org.mathdox.formulaeditor.presentation");

$identify("org/mathdox/formulaeditor/presentation/Vector.js");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/PArray.js");

$main(function(){

  /**
   * Representation of a column of mathematical expressions in the presentation
   * tree.
   */
  org.mathdox.formulaeditor.presentation.Vector =
    $extend(org.mathdox.formulaeditor.presentation.Bracketed, {
      // variable to store the array to get the semantics
      entries : null,

      initialize : function () {
        var presentation = org.mathdox.formulaeditor.presentation;
        var leftBracket = new presentation.Bracket('(');
        var rightBracket = new presentation.Bracket(')');

        this.middle = new presentation.Column();
        this.middle.initialize.apply(this.middle,arguments);
        this.middle.margin = 10.0;

        arguments.callee.parent.initialize.call(this, leftBracket, 
          this.middle, rightBracket);
      },

      /**
       * Returns a copy of this presentation object, without index information
       * To be used for copy/paste or undo. See also presentation/Node.js
       */
      copy : function() {
        return this.clone.apply(this, this.copyArray(this.middle.children));
      },

      getSemantics : function(context) {
        var semanticEntries;
        var vector;

        var semantics = org.mathdox.formulaeditor.semantics;
        semanticEntries = [];
        for (var i=0;i<this.middle.children.length;i++) {
          semanticEntries.push(this.middle.children[i].getSemantics(context).value);
        }
        vector = new semantics.Linalg2Vector();
        vector.initialize.apply(vector, semanticEntries);

        return {
          value : vector,
          rule  : "braces"
        };
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/FunctionApplication.js");

$require("org/mathdox/formulaeditor/semantics/Keyword.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary function application.
   */
  org.mathdox.formulaeditor.semantics.FunctionApplication =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The operands of the operation.
       */
      operands: null,
      
      /**
       * Information about the style
       * style="sub" means presentation should be subscript
       */
      style: null,
      /**
       * Information about the symbol that is used to represent this operation.
       */
      symbol: null,

      /**
       * Initializes the operation using the specified arguments as operands.
       */
      initialize : function(symbol, operands, style) {
        this.symbol = symbol;
        this.operands = operands;
        if (style !== undefined) {
          this.style = style;
        }
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;
        var semantics = org.mathdox.formulaeditor.semantics;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var pres = {}
        pres.array = [];

        var bracketed;

        var style = this.style;

        if ( (context.styleTransc1Log == "postfix") && 
            (this.symbol instanceof semantics.Keyword) && 
            (this.symbol.cd == "transc1") && (this.symbol.name == "log") ) {
          style = "firstsub";
        } else if ( (context.styleTransc1Log == "prefix") && 
            (this.symbol instanceof semantics.Keyword) && 
            (this.symbol.cd == "transc1") && (this.symbol.name == "log") ) {
          style = "firstsuper";
        }

        if (this.symbol instanceof semantics.MultaryOperation) {
          this.addPresentationBracketOpen(context, pres, "(");
        }
        if (style != "firstsuper") {
          pres.array.push(this.symbol.getPresentation(context));
        }
        if (this.symbol instanceof semantics.MultaryOperation) {
          this.addPresentationBracketClose(context, pres, ")");
        }
        if (style != "sub" && style != "firstsub" && style != "firstsuper") {
          // no brackets in subscript style "sub" or if the first argument is
          // handled differently
          this.addPresentationBracketOpen(context, pres, "(");
        }
        for (var i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
	  var sym;
          if (i>0) {
            sym = new presentation.Symbol(context.listSeparator);
            if (style == "sub") {
              // subscript style
              pres.array.push(new presentation.Subscript(sym));
              // first subscript (after the symbol)
            } else if ((style == "firstsub" ||style == "firstsuper") && i==1) {
              this.addPresentationBracketOpen(context, pres, "(");
            } else if (style == "firstsuper" && i==0) {
              // first superscript (before the symbol); 
              // print nothing yet
            } else {
              // normal style
              pres.array.push(sym);
            }
          }
          
          if (!operand) {
            alert("symbol: "+this.symbol.symbol.onscreen);
            alert("operands.length: "+this.operands.length);
            alert("operands[0]: "+this.operands[0]);
            alert("operands[1]: "+this.operands[1]);
          }
          sym = operand.getPresentation(context);
          if (style == "sub") {
            // subscript style
            pres.array.push(new presentation.Subscript(sym));
          } else if (style == "firstsub" && i==0) {
            pres.array.push(new presentation.Subscript(sym));
          } else if (style == "firstsuper" && i==0) {
            pres.array.push(new presentation.Superscript(sym));
              pres.array.push(this.symbol.getPresentation(context));
          } else {
            // normal style
            pres.array.push(sym);
          }
        }
        
        if (style != "sub") {
          // no brackets in subscript style "sub"
          this.addPresentationBracketClose(context, pres, ")");
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, pres.array);

        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {
        var semantics = org.mathdox.formulaeditor.semantics;
        var result;

        /* check number of arguments */
        if (this.symbol instanceof semantics.Keyword) {
          var argtest = this.symbol.checkArguments(this.operands);

          if (typeof argtest === "string") {
            result = "<OME><OMS cd='moreerrors' name='encodingError'/>";
            result += "<OMSTR>invalid expression entered: "+ argtest+"</OMSTR>";
            result += "</OME>";
            return result;
          }
          /* otherwise: everything is fine; continue */
        }

        if (this.style !== null) {
          result = "<OMA style='"+this.style+"'>";
        } else {
          result = "<OMA>";
        }

        result += this.symbol.getOpenMath();
        for (var i=0; i<this.operands.length; i++) {
          result = result + this.operands[i].getOpenMath();
        }
        result = result + "</OMA>";

        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {

        var result = "<mrow>" + this.symbol.getMathML() + "<mo>(</mo>";

        for (var i=0; i<this.operands.length; i++) {
          if (i>0) {
            result = result + "<mo>,</mo>";
          }
          result = result + this.operands[i].getMathML();
        }
        result = result + "<mo>)</mo>" + "</mrow>";

        return result;

      }

    });

});

  $package("org/mathdox/formulaeditor/semantics");

$identify("org/mathdox/formulaeditor/semantics/Integer.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){

  /**
  * Representation of an integer in the semantic tree.
  */
  org.mathdox.formulaeditor.semantics.Integer =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The integer value.
       */
      value : null,

      /**
       * Initializes a semantic tree node to represent an integer with the
       * specified value.
       */
      initialize : function(value) {
	// check for allowed types
	// 1: integer
	if (value === undefined || value === null) {
          this.value = 0;
	} else {
	  if (! ((typeof value == "number") || (typeof value == "object" && value.rule == "bigint"))) {
            console.log("MFE WARNING: integer object created with unknown type "+(typeof value));
	  }
	  this.value = value;
	}

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var string = this.value.toString();
        var symbols = [];

        for (var i=0; i<string.length; i++) {
          symbols[i] = new presentation.Symbol(string.charAt(i));
        }

        var result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMI>" + this.getValueAsString() + "</OMI>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        return "<mn>" + this.getValueAsString() + "</mn>";
      },

      getValueAsString: function() {
	if (typeof this.value == "number") {
	  return this.value.toString();
	} else if (typeof this.value == "string") { 
          console.log("MFE WARNING: found integer with unexpected type: string");
	  return this.value;
	} else if (typeof this.value == "object" && this.value.rule == "bigint") {
	  // bigint encoding, value.value is the string representation
	  return this.value.value;
	} else { // unknown type
          console.log("MFE ERROR: integer of unknown type");
	  return this.value.toString();
	}
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/Keyword.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of a keyword.
   */
  org.mathdox.formulaeditor.semantics.Keyword =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * Information about the symbol that is used to represent this keyword.
       */
      symbol : {

        /**
         * The symbol(s) that is/are used for rendering the keyword to the
         * screen.
         */
        onscreen : null,

        /**
         * The OpenMath symbol that is associated with this operation.
         */
        openmath : null,

        /**
         * The MathML representation of this operation.
         */
        mathml   : null

      },

      getSymbolOnscreen : function(context) {
        if (this.symbol.onscreen !== undefined) {
          return this.symbol.onscreen;
        } else {
          return null;
        }
      },

      /**
       * Initializes the keyword using the specified arguments as operands.
       * type should be one of the following strings:
       *
       * "constant" : constant like nums1.pi which probably cannot have
       *    arguments 
       * "function" : function like transc1.sin which probably should have
       *    arguments
       * "infix"    : infix operator like arith1.plus which can only occur
       *    without arguments in special places like an editor1.palette_row
       * "unary"    : unary operator like logic.not which can only occur
       *    without arguments in special places like an editor1.palette_row
       * "type"     : function or symbol
       * "argcount": number of arguments for a function
       */
      initialize : function(cd,name,symbol,type,argcount) {
        this.cd = cd;
        this.name = name;
        this.type = type;

        if (argcount!==null && argcount!== undefined) {
          this.argcount = argcount;
        } else {
          this.argcount = null;
        }

        if (symbol) {
          this.symbol = {};
          if (symbol.onscreen) {
            this.symbol.onscreen = symbol.onscreen;
          }
          if (symbol.openmath) {
            this.symbol.openmath = symbol.openmath;
          }
          if (symbol.mathml) {
            this.symbol.mathml = symbol.mathml;
          }
        }
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */

      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;
        var string;
        var symbolOnscreen = this.getSymbolOnscreen(context);
	var result;

        // XXX make case distinction for U+25A1 white square 
        // to become BlockSymbol
        if (symbolOnscreen !== null && symbolOnscreen !== undefined) {
          // U+25A1 white square
          if (symbolOnscreen == '□') {
            if (context.inPalette === true && 
              (context.inMatrix === true || context.inVector === true)
            ) {
              return new presentation.Row(new presentation.BlockSymbol(','));
            } else {
              return new presentation.Row(new presentation.BlockSymbol());
            }
          } else if (symbolOnscreen === '') {
            if (context.inPalette === true) {
              string=" ";
            } else {
              string=" ";
            }
          } else if (symbolOnscreen instanceof Array) {
            var arr = [];

            if (symbolOnscreen[0] != "") {
              arr.push(new presentation.Symbol(symbolOnscreen[0]));
            }
            if (symbolOnscreen[0] != "" && symbolOnscreen[2]!= "") {
              arr.push(new presentation.BlockSymbol());
            }
            if (symbolOnscreen[2] != "") {
              arr.push(new presentation.Symbol(symbolOnscreen[2]));
            }
            result = new presentation.Row();

            result.initialize.apply(result, arr);
            return result;
	  } else {
            string = symbolOnscreen.toString();
          }
        } else {
          string = (this.cd + "." + this.name).toString();
        }

        var symbols = [];

        for (var i=0; i<string.length; i++) {
          symbols[i] = new presentation.Symbol(string.charAt(i));
        }

        result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {
        var result;
        
        if (this.symbol.openmath !== null && this.symbol.openmath !== undefined) {
          result = this.symbol.openmath;
        } else {
          result = "<OMS cd='" + this.cd + "' name='" + this.name + "'/>";
        }
        return result;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {
        var result;
        
        if (this.symbol.mathml !== null) {
          result = this.symbol.mathml;
        } else if (this.symbol.onscreen !== null) {
          result = "<mi>" + this.symbol.onscreen + "</mi>";
        } else {
          result = "<mi>" + this.cd + "." + this.name + "</mi>";
        }

        return result;
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/Lambda.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/semantics/Variable.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary function application.
   */
  org.mathdox.formulaeditor.semantics.Lambda =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The expression 
       */
      expression: null,

      /**
       * The bound variables of the lambda expression
       */
      variables: [],

      /**
       * Initializes the operation using the specified arguments as operands.
       */
      initialize : function() {
        var variables;
        var expression;

        if (arguments.length === 0) {
          // no arguments 
          variables = [];
          expression = null;
        } else if (arguments.length == 1) {
          // one arguments -> only expression
          variables = [];
          expression = arguments[0];
        } else if (arguments.length == 2) {
          // two arguments -> variable [array] and expression
          if (arguments[0] instanceof Array) {
            variables = arguments[0];
          } else {
            variables = [];
            variables.push(arguments[0]);
          }
          expression = arguments[1];
        } else if (arguments.length > 2) {
          // more than two arguments -> variables and expression
          variables = argument.slice(0, arguments.length -2);
          expression = arguments[arguments.length - 1];
        }

        this.variables = variables;
        this.expression = expression;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // WITH Operator symbols
        var array = [];
        var pres;
        var i; // counter

        // U+03BB greek small letter lamda
        array.push(new presentation.Symbol("λ"));
        if (this.variables.length == 1) {
          array.push(this.variables[0].getPresentation(context));
        } else {
          array.push(new presentation.Symbol("("));
          for (i=0; i<this.variables.length; i++) {
            if (i>0) {
              array.push(new presentation.Symbol(","));
            }
            array.push(this.variables[i].getPresentation(context));
          }
          array.push(new presentation.Symbol(")"));
        }

        array.push(new presentation.Symbol("."));
        array.push(new presentation.Symbol("("));
        array.push(this.expression.getPresentation(context));
        array.push(new presentation.Symbol(")"));

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);

        return result;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {

        var result = [];
        var i; // counter
        
        result.push("<OMBIND>");
        result.push("<OMS cd='fns1' name='lambda'/>");
        
        // bound variables
        result.push("<OMBVAR>");

        for (i=0; i<this.variables.length; i++) {
          result.push(this.variables[i].getOpenMath());
        }

        result.push("</OMBVAR>");

        // expression
        result.push(this.expression.getOpenMath());

        result.push("</OMBIND>");

        return result.join("");
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {
        var result = [];
        result.push("<mrow>");
        // U+03BB greek small letter lamda
        result.push("<mo>λ</mo>");

        if (this.variables.length == 1) {
          result.push(this.variables[0].getMathML());
        } else {
          result.push("<mo>(</mo>");
          for (i=0; i<this.variables.length; i++) {
            if (i>0) {
              result.push("<mo>,</mo>");
            }
            result.push(this.variables[i].getMathML());
          }
          result.push("<mo>)</mo>");
        }
        result.push("</mrow>");

        return result.join("");

      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/MultaryListOperation.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/semantics/MultaryOperation.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary infix operation.
   */
  org.mathdox.formulaeditor.semantics.MultaryListOperation =
    $extend(org.mathdox.formulaeditor.semantics.MultaryOperation, {
      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var array = [];
        var i;
        if (this.style != "invisible" && this.symbol.onscreen instanceof Array) {
          if (this.symbol.onscreen[0]!=="") {
            array.push(new presentation.Row(this.symbol.onscreen[0]));
          }
        }
        for (i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
          if (i>0 && this.style != "invisible" ) {
            if (this.symbol.onscreen instanceof Array) {
              // NOTE: use listSeparator
              array.push(new presentation.Row(context.listSeparator));
            }
            else {
              array.push(new presentation.Row(this.symbol.onscreen));
            }
          }
          if (operand.getPrecedence && operand.getPrecedence(context) != 0 && operand.getPrecedence(context) < this.getPrecedence(context)) {
            array.push(new presentation.Symbol("("));
            array.push(operand.getPresentation(context));
            array.push(new presentation.Symbol(")"));
          }
          else {
            array.push(operand.getPresentation(context));
          }
        }
        if (this.style != "invisible" && this.symbol.onscreen instanceof Array) {
          if (this.symbol.onscreen[2]!=="") {
            array.push(new presentation.Row(this.symbol.onscreen[2]));
          }
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);
        return result;

      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/MultaryOperation.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");

$main(function(){

  /**
   * Representation of an n-ary infix operation.
   */
  org.mathdox.formulaeditor.semantics.MultaryOperation =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The operands of the operation.
       */
      operands: null,

      /**
       * Information about the symbol that is used to represent this operation.
       */
      symbol : {

        /**
         * The symbol that is used for rendering the operation to the screen.
         */
        onscreen         : null,

        /**
         * The OpenMath symbol that is associated with this operation.
         */
        openmath         : null,

        /**
         * The MathML representation of this operation.
         */
        mathml           : null,

        /**
         * The MathML invisible representation of this operation (if any)
         */
        mathml_invisible : null

      },

      getSymbolMathML : function(context) {
        return this.symbol.mathml;
      },

      getSymbolOnscreen : function(context) {
        return this.symbol.onscreen;
      },

      getSymbolOpenMath : function(context) {
        return this.symbol.openmath;
      },

      /**
       * The precedence level of the operator.
       */
      precedence : 0,

      getPrecedence : function(context) {
	return this.precedence;
      },
      getInnerPrecedence : function(context) {
	return this.getPrecedence(context);
      },
 
      /**
       * Is the operator associative
       *
       * if false: put brackets around the second argument also if it has an
       * operator with the same precedence. Example: a-(b-c)
       */
      associative : true,

      /**
       * style if any (like "invisible")
       */ 
      style:null,

      /**
       * Initializes the operation using the specified arguments as operands.
       */
      initialize : function() {
        this.operands = arguments;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation(context)
       */
      getPresentation : function(context) {

        var presentation = org.mathdox.formulaeditor.presentation;

        // construct an array of the presentation of operand nodes interleaved
        // with operator symbols
        var array = [];
        var i;
        var symbolOnscreen = this.getSymbolOnscreen(context);
        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[0]!=="") {
            array.push(new presentation.Row(symbolOnscreen[0]));
          }
        }
        for (i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
          if (i>0 && this.style != "invisible" ) {
            if (symbolOnscreen instanceof Array) {
              if (symbolOnscreen[1]!=="") {
                array.push(new presentation.Row(symbolOnscreen[1]));
              }
            }
            else {
              array.push(new presentation.Row(symbolOnscreen));
            }
          }
          //if (operand.precedence && ((operand.precedence < this.precedence) || ((this.associative==false) && i>0 && operand.precedence <= this.precedence))) {
          if (operand.getPrecedence && operand.getPrecedence(context) != 0 && ((operand.getPrecedence(context) < this.getInnerPrecedence(context)) || 
	     (operand.getPrecedence(context) == this.getInnerPrecedence(context) && 
	       (i>0 || (this.associative==true && this.symbol.openmath == operand.symbol.openmath) ||
		(this.operands.length == 1)
		)) 
	     )) {
            array.push(new presentation.Symbol("("));
            array.push(operand.getPresentation(context));
            array.push(new presentation.Symbol(")"));
          }
          else {
            array.push(operand.getPresentation(context));
          }
        }
        if (this.style != "invisible" && symbolOnscreen instanceof Array) {
          if (symbolOnscreen[2]!=="") {
            array.push(new presentation.Row(symbolOnscreen[2]));
          }
        }

        // create and return new presentation row using the constructed array
        var result = new presentation.Row();
        result.initialize.apply(result, array);
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath()
       */
      getOpenMath : function() {
        var semantics = org.mathdox.formulaeditor.semantics;
	var result;

        var argtest = this.checkArguments(this.operands);

        if (typeof argtest === "string") {
          result = "<OME><OMS cd='moreerrors' name='encodingError'/>";
          result += "<OMSTR>invalid expression entered: "+ argtest+"</OMSTR>";
          result += "</OME>";
          return result;
        }

        var result = "<OMA";

        // add style (like invisible) if present
        if (this.style) {
          result = result + " style='" + this.style + "'";
        }

        result = result + ">" + this.getSymbolOpenMath();
        for (var i=0; i<this.operands.length; i++) {
          result = result + this.operands[i].getOpenMath();
        }
        result = result + "</OMA>";
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML()
       */
      getMathML : function() {

        var result = "<mrow>";
        var symbol_mathml = this.getSymbolMathML();

	if (this.style == "invisible" && (this.symbol.mathml_invisible !== undefined && this.symbol.mathml_invisible !== null)) {
          symbol_mathml = this.symbol.mathml_invisible;
	}

        if (symbol_mathml instanceof Array) {
          result = result + symbol_mathml[0];
        }

        for (var i=0; i<this.operands.length; i++) {
          var operand = this.operands[i];
          if (i>0) {
            if (symbol_mathml instanceof Array) {
              result = result + symbol_mathml[1];
            } else {
              result = result + symbol_mathml;
            }
          }
          if (operand.precedence && ((operand.precedence < this.precedence) || ((this.associative==false) && i>0 && operand.precedence <= this.precedence))) {
            result = result + "<mfenced>";
            result = result + this.operands[i].getMathML();
            result = result + "</mfenced>";
          }
          else {
            result = result + this.operands[i].getMathML();
          }
        }

        if (symbol_mathml instanceof Array) {
          result = result + symbol_mathml[2];
        }

        result = result + "</mrow>";
        return result;

      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$require("org/mathdox/formulaeditor/presentation/Bracket.js");
$require("org/mathdox/formulaeditor/presentation/Bracketed.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$identify("org/mathdox/formulaeditor/semantics/Node.js");


$main(function(){

  /**
   * Representation of a node in the semantic tree.
   */
  org.mathdox.formulaeditor.semantics.Node = $extend(Object, {

      /**
       * expected number of arguments
       * "null" means no information
       */
      argcount : null,

      /**
       * checkArguments: check the number of arguments, returns true or an error string
       */
      checkArguments : function(operands) {
        var argcount;
        
        if (operands === null || operands === undefined) {
          argcount = 0;
        } else {
          argcount = operands.length;
        }

        if (this.argcount === null) {
          return true;
        } else if (this.argcount == argcount) {
          return true;
        } else {
          return "expecting "+this.argcount+" argument(s), but found "+argcount+" argument(s) instead";
        }
      },

    /**
     * Returns the presentation tree node that is used to draw this semantic
     * tree node on a canvas. This is an abstract method, so it is expected that
     * subclasses will override this method.
     *
     * context: object that can contain information that might influence the
     * presentation of child objects. context cascades; it is either the same,
     * or copied and then extended or modified.
     */
    getPresentation : function(context) {
      throw new Error("abstract method called");
    },

    /**
     * Returns the OpenMath representation of the node. This is an abstract
     * method, so it is expected that subclasses will override this method.
     */
    getOpenMath : function() {
      throw new Error("abstract method called");
    },

    /**
     * Returns the MathML presentation of the node. This is an abstract method,
     * so it is expected that subclasses will override this method.
     */
    getMathML : function() {
      throw new Error("abstract method called");
    },

    /**
     * get the value as a string, useful when multiple internal representations are possible
     */
    getValueAsString : function() {
      return this.value.toString();
    },

    /**
     * Utility method to add a bracket to presentation array
     *
     * Note: pres structure should be:
     * pres.array: presentation items
     * pres.old: old presentation structure containing array and possibly leftBracket
     * pres.leftBracket: left Bracket
     * rightBracket: closing Bracket
     */
    addPresentationBracketOpen : function(context, pres, bracket) {
      var presentation = org.mathdox.formulaeditor.presentation;

      if (context.optionResizeBrackets === true) {
	var tmp = {
	  array: pres.array,
	  leftBracket: pres.leftBracket,
	  old: pres.old
	};
	pres.old = tmp;

        pres.leftBracket = new presentation.Bracket(bracket);
        pres.array = [];
      } else {
	pres.array.push(new presentation.Bracket(bracket));
      }
    },
    addPresentationBracketClose : function(context, pres, bracket) {
      var presentation = org.mathdox.formulaeditor.presentation;

      if (context.optionResizeBrackets === true) {
        var rightBracket = new presentation.Bracket(bracket);

	var row = new presentation.Row();
	row.initialize.apply(row, pres.array);

        var bracketed = new presentation.Bracketed(pres.leftBracket, row, rightBracket);

        pres.array = pres.old.array;
        pres.leftBracket = pres.old.leftBracket;
        pres.old = pres.old.old;

        pres.array.push(bracketed);
      } else {
        pres.array.push(new presentation.Bracket(bracket));
      }
    }
  });

});

  $package("org/mathdox/formulaeditor/semantics");

$identify("org/mathdox/formulaeditor/semantics/SemanticFloat.js");

$require("org/mathdox/formulaeditor/semantics/Node.js");
$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/presentation/Row.js");

$main(function(){

  /**
  * Representation of a float in the semantic tree.
  * it is named SemanticFloat because float is a reserved keyword
  */
  org.mathdox.formulaeditor.semantics.SemanticFloat =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The float value.
       */
      value : null,

      /**
       * Initializes a semantic tree node to represent an float with the
       * specified value.
       */
      initialize : function(value) {
        this.value = value;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var string = this.getValueAsString(context); // getValueAsString returns a string with corrected decimal mark
        var symbols = [];

        for (var i=0; i<string.length; i++) {
          symbols[i] = new presentation.Symbol(string.charAt(i));
        }

        var result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;

      },

      /**
       * return the value with the correct decimal mark
       */
      getValueAsString : function(context) {
        var string = this.value.toString();

	if (context === null || context === undefined || context.decimalMark == '.') {
          return string;
	}

	// use context to change the decimalMark

        var result=[];

        for (var i=0; i<string.length; i++) {
          if (string.charAt(i) != '.') {
            result.push(string.charAt(i));
          } else {
            result.push(context.decimalMark);
          }
        }

        return result.join("");
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMF dec='" + this.value + "'/>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        var string = this.value.toString();
        var result=[];

	result.push("<mn>");

        for (var i=0; i<string.length; i++) {
          if (string.charAt(i)!='.') {
            result.push(string.charAt(i));
          } else {
            result.push((new org.mathdox.formulaeditor.Options).getDecimalMark());
          }
        }
	result.push("</mn>");

        return result.join("");
      },

      toString : function() {
        return this.value.toString();
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/String.js");

$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/Node.js");

$main(function(){

  /**
   * Representation of a variable in the semantic tree.
   */
  org.mathdox.formulaeditor.semantics.SString =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The variable name.
       */
      name : null,

      /**
       * Initializes a semantic tree node to represent the variable with the
       * specified name.
       */
      initialize : function(name) {
        this.name = name;
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var str = this.name; // the string that is presented
        var symbols = []; // array for the symbols
	
	// opening "
	symbols.push(new presentation.Symbol("\""));

	// the actual string
        for (var i=0; i<str.length; i++) {
          symbols.push(new presentation.Symbol(str.charAt(i)));
        }

	// closing "
	symbols.push(new presentation.Symbol("\""));

	// now create a row and initialize it with the list of symbols
        var result = new presentation.Row();
        result.initialize.apply(result, symbols);

        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMSTR>" + this.name + "</OMSTR>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        return "<mtext>" + this.name + "</mtext>";
      }

    });

});

  $package("org.mathdox.formulaeditor.semantics");

$identify("org/mathdox/formulaeditor/semantics/Variable.js");

$require("org/mathdox/formulaeditor/presentation/Symbol.js");
$require("org/mathdox/formulaeditor/semantics/Node.js");

$main(function(){

  /**
   * Representation of a variable in the semantic tree.
   */
  org.mathdox.formulaeditor.semantics.Variable =
    $extend(org.mathdox.formulaeditor.semantics.Node, {

      /**
       * The variable name.
       */
      name : null,

     /**
       * Information about the variable that is used to represent it.
       */
      symbol : {

        /**
         * The symbol(s) that is/are used for rendering the variable to the
         * screen.
         */
        onscreen : null,

        /**
         * The MathML representation of this variable.
         */
        mathml   : null

      },


      /**
       * Initializes a semantic tree node to represent the variable with the
       * specified name.
       */
      initialize : function(name, symbol) {
        this.name = name;

        if (symbol) {
          this.symbol = {};
          if (symbol.onscreen) {
            this.symbol.onscreen = symbol.onscreen;
          }
          if (symbol.mathml) {
            this.symbol.mathml = symbol.mathml;
          }
        }
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getPresentation
       */
      getPresentation : function(context) {
        var presentation = org.mathdox.formulaeditor.presentation;

        var str;
        if (this.symbol.onscreen !== null) {
          str = this.symbol.onscreen.toString();
        } else { 
          str = this.name.toString();
        }
        var symbols = [];

        for (var i=0; i<str.length; i++) {
          symbols[i] = new presentation.Symbol(str.charAt(i), "math");
        }

        var result = new presentation.Row();
        result.initialize.apply(result, symbols);
        return result;

      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getOpenMath
       */
      getOpenMath : function() {
        return "<OMV name='" + this.name + "'/>";
      },

      /**
       * See org.mathdox.formulaeditor.semantics.Node.getMathML
       */
      getMathML : function() {
        if (this.symbol.mathml !== null) {
          return this.symbol.mathml.toString();
        } else {
          return "<mi>" + this.name + "</mi>";
        }
      }

    });

});

  $package("org.mathdox.formulaeditor");

$identify("org/mathdox/formulaeditor/version.js");

$main(function(){
  /**
  * Version object (static)
  */

  org.mathdox.formulaeditor.version = {
    /**
     * Show an "About" popup with version info
     */
    showAboutPopup: function() {
      alert("MathDox Formulaeditor\n"+
	    "version: "+this.toString()+"\n"+
	    "http://mathdox.org/formulaeditor/\n"+
	    "info@mathdox.org");
    },
    /**
     * Return the version as a string
     */
    toString : function() {
      return this.versionInfo;
    },
    /**
     * variable containing the version information
     */
    versionInfo: "1.1.31f"
  };
});

  $package("org.mathdox.parsing");

$identify("org/mathdox/parsing/Parser.js");

$main(function(){

  org.mathdox.parsing.Parser = $extend(Object, {

    start : null,

    parse : function(string, index, backward, start) {

      if (index === null || index === undefined) {
        index = 0;
      }
      if (backward === null || backward === undefined) {
        backward = false;
      }
      if (start === null || start === undefined) {
        start = "start";
      }

      var context = {
        input    : string,
        backward : backward,
        parser   : this,
        cache    : {}
      };

      var endIndex  = null;
      var endResult = null;

      var continuation = function(newIndex, newResult) {
        if (context.backward) {
          if (endIndex === null || newIndex < endIndex) {
            endIndex  = newIndex;
            endResult = newResult;
          }
        }
        else {
          if (endIndex === null || newIndex > endIndex) {
            endIndex  = newIndex;
            endResult = newResult;
          }
        }
      };

      this[start](context, index, [], continuation);

      if (endResult !== null && endResult.length == 1) {
        endResult = endResult[0];
      }

      return { index: endIndex, value : endResult };

    }

  });

});

  $package("org.mathdox.parsing");

$identify("org/mathdox/parsing/ParserGenerator.js");

$main(function(){

  /**
   * A recursive descent parser in continuation passing style. This parser allows
   * both forward (left-to-right) and backward (right-to-left) parsing.
   */
  org.mathdox.parsing.ParserGenerator = $extend(Object, {

    alternation : function() {

      var alternatives = arguments;

      return function(context, index, result, continuation) {
        for (var i=0; i<alternatives.length; i++) {
          alternatives[i](context, index, result, continuation);
        }
      };

    },

    begin : function(context, index, result, continuation) {

      if (index == 0) {
        this.empty(context, index, result, continuation);
      }

    },

    concatenation : function() {

      var elements = Array.prototype.slice.call(arguments);
      var generator = this;

      if (elements.length > 0) {

        var concatenation = arguments.callee;

        return function(context, index, result, continuation) {

          var tail = elements.slice();
          var head = context.backward ? tail.pop() : tail.shift();

          head(
            context,
            index,
            result,
            function(newindex, newresult) {
              var tailparser = concatenation.apply(generator, tail);
              tailparser(context, newindex, newresult, continuation);
            }
          );

        };

      }
      else {

        return generator.empty;

      }

    },

    empty : function(context, index, result, continuation) {

      continuation(index, result);

    },

    end : function(context, index, result, continuation) {

      if (index == context.input.length) {
        this.empty(context, index, result, continuation);
      }

    },

    literal : function(string) {

      return function(context, index, result, continuation) {

        var start = context.backward ? index - string.length : index;
        var end   = context.backward ? index : index + string.length;

        if (context.input.substring(start, end) == string) {
          if (context.backward) {
            continuation(start, [string].concat(result));
          }
          else {
            continuation(end, result.concat([string]));
          }
        }

      };

    },

    never : function(context, index, result, continuation) {

      //skip

    },

    range : function(lower, upper) {

      return function(context, index, result, continuation) {

        var character = context.input.charAt(context.backward ? index-1 : index);

        if (lower <= character && character <= upper) {
          if (context.backward) {
            continuation(index - 1, [character].concat(result));
          }
          else {
            continuation(index + 1, result.concat([character]));
          }
        }

      };

    },

    repetition : function(operand) {
      var pG = this;

      return pG.alternation(
        pG.empty,
        pG.repetitionplus(operand)
      );

    },

    repetitionplus : function(operand) {

      var pG = this;

      return function(context, index, result, continuation) {
	// note: repetition is the same forwards and backwards
	// alternative 1: only 1 
        operand(context, index, result, continuation); 

	/* alternative 2: 1 followed by repetitionplus */
        operand(
          context,
          index,
          result,
          function(newindex, newresult) {
            pG.repetitionplus(operand)(context, newindex, newresult, continuation);
          }
        );
      };
    },

    rule : function(name) {

      return function(context, index, result, continuation) {

        context.parser[name](context, index, result, continuation);

      };

    },

    transform : function(operand, transform) {

      return function(context, index, result, continuation) {

        operand(
          context,
          index,
          result,
          function(newindex, newresult) {
	    var sliced;
            if (context.backward) {
              sliced = newresult.slice(0, newresult.length - result.length);
              continuation(newindex,[transform(sliced)].concat(result));
            }
            else {
              sliced = newresult.slice(result.length);
              continuation(newindex, result.concat([transform(sliced)]));
            }
          }
        );

      };

    }
  });


  /**
   * Add string representation to the generated parser parts. This is needed for
   * the memoization algorithm below.
   */
  org.mathdox.parsing.ParserGenerator =
    $extend(org.mathdox.parsing.ParserGenerator, {

      initialize : function() {

        this.begin.asString = "^" ;
        this.empty.asString = "()";
        this.end.asString   = "$" ;
        this.never.asString = "0" ;

      },

      alternation : function() {

        var parent = arguments.callee.parent;
        var result = parent.alternation.apply(this, arguments);

        result.asString = "(";

        for (var i=0; i<arguments.length; i++) {

          if (i>0) {
            result.asString += "|";
          }

          result.asString += arguments[i].asString;

        }

        result.asString += ")";

        return result;

      },

      parentAlternation: function(newrule, oldrule, obj) {
        alert(obj);
        alert(obj[oldrule]);
        var result = function() {
          this.alternation(newrule, obj[oldrule]).apply(this, arguments);
        }
        result.asString = "(" + obj[oldrule].asString + "|" + 
	  newrule.asString + ")";

        return result;
      },

      concatenation : function() {

        var parent = arguments.callee.parent;
        var result = parent.concatenation.apply(this, arguments);

        result.asString = "(";

        for (var i=0; i<arguments.length; i++) {

          if (i>0) {
            result.asString += " ";
          }

          result.asString += arguments[i].asString;

        }

        result.asString += ")";

        return result;

      },

      literal : function(string) {

        var parent = arguments.callee.parent;
        var result = parent.literal.apply(this, arguments);
        result.asString = "\"" + string + "\"";
        return result;

      },

      range : function(lower, upper) {

        var parent = arguments.callee.parent;
        var result = parent.range.apply(this, arguments);
        result.asString = "[" + lower + ".." + upper + "]";
        return result;

      },

      repetition : function(operand) {

        var parent = arguments.callee.parent;
        var result = parent.repetition.apply(this, arguments);
        result.asString = operand.asString + "*";
        return result;

      },

      repetitionplus : function(operand) {

        var parent = arguments.callee.parent;
        var result = parent.repetitionplus.apply(this, arguments);
        result.asString = operand.asString + "+";
        return result;

      },

      rule : function(name) {

        var parent = arguments.callee.parent;
        var result = parent.rule.apply(this, arguments);
        result.asString = name;
        return result;

      },

      transform : function(operand, transform) {

        var parent = arguments.callee.parent;
        var result = parent.transform.apply(this, arguments);
        result.asString = "{" + operand.asString + "}";
        return result;

      }

  });


  /**
   * Add memoization to support left-recursion (and right recursion when parsing
   * backwards), and improve the time complexity from exponential to polynomial.
   */
  org.mathdox.parsing.ParserGenerator =
    $extend(org.mathdox.parsing.ParserGenerator, {

      memoize : function(f) {

        var result = function(context, index, result, continuation) {

          var key = f.asString + "," + index;

          var entry = context.cache[key];
          if (!entry) {

            entry = context.cache[key] = { results : [], continuations : [] };
            entry.continuations.push(continuation);
            f(context, index, result, function(index, result) {
              entry.results.push({index : index, value : result});
              for (var i=0; i<entry.continuations.length; i++) {
                entry.continuations[i](index, result);
              }
            });

          }
          else {

            entry.continuations.push(continuation);
            for (var i=0; i<entry.results.length; i++) {
              var result = entry.results[i];
              continuation(result.index, result.value);
            }

          }

        };

        result.asString = f.asString;

        return result;

      },

      rule : function(name) {

        var parent = arguments.callee.parent;
        return this.memoize(parent.rule.apply(this, arguments));

      },

      repetitionplus : function(name) {

        var parent = arguments.callee.parent;
        return this.memoize(parent.repetitionplus.apply(this,arguments));

      }

    });

});

